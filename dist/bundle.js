/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@3d-dice/dice-box-threejs/dist/dice-box-threejs.es.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@3d-dice/dice-box-threejs/dist/dice-box-threejs.es.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Cp)
/* harmony export */ });
var zo = Object.defineProperty;
var Bo = (h, e, t) => e in h ? zo(h, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : h[e] = t;
var Ys = (h, e, t) => (Bo(h, typeof e != "symbol" ? e + "" : e, t), t);
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Os = "143";
const Jt = "srgb", yn = "srgb-linear";
const Zs = "300 es";
class $n {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let s = 0, o = i.length; s < o; s++)
        i[s].call(this, e);
      e.target = null;
    }
  }
}
const nt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], Qi = Math.PI / 180, zs = 180 / Math.PI;
function hi() {
  const h = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (nt[h & 255] + nt[h >> 8 & 255] + nt[h >> 16 & 255] + nt[h >> 24 & 255] + "-" + nt[e & 255] + nt[e >> 8 & 255] + "-" + nt[e >> 16 & 15 | 64] + nt[e >> 24 & 255] + "-" + nt[t & 63 | 128] + nt[t >> 8 & 255] + "-" + nt[t >> 16 & 255] + nt[t >> 24 & 255] + nt[n & 255] + nt[n >> 8 & 255] + nt[n >> 16 & 255] + nt[n >> 24 & 255]).toLowerCase();
}
function mt(h, e, t) {
  return Math.max(e, Math.min(t, h));
}
function No(h, e) {
  return (h % e + e) % e;
}
function es(h, e, t) {
  return (1 - t) * h + t * e;
}
function $s(h) {
  return (h & h - 1) === 0 && h !== 0;
}
function Bs(h) {
  return Math.pow(2, Math.floor(Math.log(h) / Math.LN2));
}
class Ce {
  constructor(e = 0, t = 0) {
    Ce.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * n - o * i + e.x, this.y = s * i + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Mt {
  constructor() {
    Mt.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, n, i, s, o, r, l, a) {
    const c = this.elements;
    return c[0] = e, c[1] = i, c[2] = r, c[3] = t, c[4] = s, c[5] = l, c[6] = n, c[7] = o, c[8] = a, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, s = this.elements, o = n[0], r = n[3], l = n[6], a = n[1], c = n[4], d = n[7], u = n[2], m = n[5], g = n[8], p = i[0], f = i[3], v = i[6], _ = i[1], w = i[4], x = i[7], M = i[2], E = i[5], R = i[8];
    return s[0] = o * p + r * _ + l * M, s[3] = o * f + r * w + l * E, s[6] = o * v + r * x + l * R, s[1] = a * p + c * _ + d * M, s[4] = a * f + c * w + d * E, s[7] = a * v + c * x + d * R, s[2] = u * p + m * _ + g * M, s[5] = u * f + m * w + g * E, s[8] = u * v + m * x + g * R, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], r = e[5], l = e[6], a = e[7], c = e[8];
    return t * o * c - t * r * a - n * s * c + n * r * l + i * s * a - i * o * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], r = e[5], l = e[6], a = e[7], c = e[8], d = c * o - r * a, u = r * l - c * s, m = a * s - o * l, g = t * d + n * u + i * m;
    if (g === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const p = 1 / g;
    return e[0] = d * p, e[1] = (i * a - c * n) * p, e[2] = (r * n - i * o) * p, e[3] = u * p, e[4] = (c * t - i * l) * p, e[5] = (i * s - r * t) * p, e[6] = m * p, e[7] = (n * l - a * t) * p, e[8] = (o * t - n * s) * p, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, i, s, o, r) {
    const l = Math.cos(s), a = Math.sin(s);
    return this.set(
      n * l,
      n * a,
      -n * (l * o + a * r) + o + e,
      -i * a,
      i * l,
      -i * (-a * o + l * r) + r + t,
      0,
      0,
      1
    ), this;
  }
  scale(e, t) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this;
  }
  rotate(e) {
    const t = Math.cos(e), n = Math.sin(e), i = this.elements, s = i[0], o = i[3], r = i[6], l = i[1], a = i[4], c = i[7];
    return i[0] = t * s + n * l, i[3] = t * o + n * a, i[6] = t * r + n * c, i[1] = -n * s + t * l, i[4] = -n * o + t * a, i[7] = -n * r + t * c, this;
  }
  translate(e, t) {
    const n = this.elements;
    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function to(h) {
  for (let e = h.length - 1; e >= 0; --e)
    if (h[e] > 65535)
      return !0;
  return !1;
}
function qi(h) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", h);
}
function bn(h) {
  return h < 0.04045 ? h * 0.0773993808 : Math.pow(h * 0.9478672986 + 0.0521327014, 2.4);
}
function Wi(h) {
  return h < 31308e-7 ? h * 12.92 : 1.055 * Math.pow(h, 0.41666) - 0.055;
}
const ts = {
  [Jt]: { [yn]: bn },
  [yn]: { [Jt]: Wi }
}, St = {
  legacyMode: !0,
  get workingColorSpace() {
    return yn;
  },
  set workingColorSpace(h) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(h, e, t) {
    if (this.legacyMode || e === t || !e || !t)
      return h;
    if (ts[e] && ts[e][t] !== void 0) {
      const n = ts[e][t];
      return h.r = n(h.r), h.g = n(h.g), h.b = n(h.b), h;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(h, e) {
    return this.convert(h, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(h, e) {
    return this.convert(h, e, this.workingColorSpace);
  }
}, no = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ye = { r: 0, g: 0, b: 0 }, Et = { h: 0, s: 0, l: 0 }, gi = { h: 0, s: 0, l: 0 };
function ns(h, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? h + (e - h) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? h + (e - h) * 6 * (2 / 3 - t) : h;
}
function _i(h, e) {
  return e.r = h.r, e.g = h.g, e.b = h.b, e;
}
class Ae {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Jt) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, St.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, i = yn) {
    return this.r = e, this.g = t, this.b = n, St.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = yn) {
    if (e = No(e, 1), t = mt(t, 0, 1), n = mt(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t, o = 2 * n - s;
      this.r = ns(o, s, e + 1 / 3), this.g = ns(o, s, e), this.b = ns(o, s, e - 1 / 3);
    }
    return St.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Jt) {
    function n(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let s;
      const o = i[1], r = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, St.toWorkingColorSpace(this, t), n(s[4]), this;
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, St.toWorkingColorSpace(this, t), n(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
            const l = parseFloat(s[1]) / 360, a = parseInt(s[2], 10) / 100, c = parseInt(s[3], 10) / 100;
            return n(s[4]), this.setHSL(l, a, c, t);
          }
          break;
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = i[1], o = s.length;
      if (o === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, St.toWorkingColorSpace(this, t), this;
      if (o === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, St.toWorkingColorSpace(this, t), this;
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = Jt) {
    const n = no[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = bn(e.r), this.g = bn(e.g), this.b = bn(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Wi(e.r), this.g = Wi(e.g), this.b = Wi(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Jt) {
    return St.fromWorkingColorSpace(_i(this, Ye), e), mt(Ye.r * 255, 0, 255) << 16 ^ mt(Ye.g * 255, 0, 255) << 8 ^ mt(Ye.b * 255, 0, 255) << 0;
  }
  getHexString(e = Jt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = yn) {
    St.fromWorkingColorSpace(_i(this, Ye), t);
    const n = Ye.r, i = Ye.g, s = Ye.b, o = Math.max(n, i, s), r = Math.min(n, i, s);
    let l, a;
    const c = (r + o) / 2;
    if (r === o)
      l = 0, a = 0;
    else {
      const d = o - r;
      switch (a = c <= 0.5 ? d / (o + r) : d / (2 - o - r), o) {
        case n:
          l = (i - s) / d + (i < s ? 6 : 0);
          break;
        case i:
          l = (s - n) / d + 2;
          break;
        case s:
          l = (n - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = a, e.l = c, e;
  }
  getRGB(e, t = yn) {
    return St.fromWorkingColorSpace(_i(this, Ye), t), e.r = Ye.r, e.g = Ye.g, e.b = Ye.b, e;
  }
  getStyle(e = Jt) {
    return St.fromWorkingColorSpace(_i(this, Ye), e), e !== Jt ? `color(${e} ${Ye.r} ${Ye.g} ${Ye.b})` : `rgb(${Ye.r * 255 | 0},${Ye.g * 255 | 0},${Ye.b * 255 | 0})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(Et), Et.h += e, Et.s += t, Et.l += n, this.setHSL(Et.h, Et.s, Et.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(Et), e.getHSL(gi);
    const n = es(Et.h, gi.h, t), i = es(Et.s, gi.s, t), s = es(Et.l, gi.l, t);
    return this.setHSL(n, i, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
Ae.NAMES = no;
let Fn;
class io {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Fn === void 0 && (Fn = qi("canvas")), Fn.width = e.width, Fn.height = e.height;
      const n = Fn.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Fn;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = qi("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), s = i.data;
      for (let o = 0; o < s.length; o++)
        s[o] = bn(s[o] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(bn(t[n] / 255) * 255) : t[n] = bn(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
class so {
  constructor(e = null) {
    this.isSource = !0, this.uuid = hi(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let o = 0, r = i.length; o < r; o++)
          i[o].isDataTexture ? s.push(is(i[o].image)) : s.push(is(i[o]));
      } else
        s = is(i);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function is(h) {
  return typeof HTMLImageElement < "u" && h instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && h instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && h instanceof ImageBitmap ? io.getDataURL(h) : h.data ? {
    data: Array.from(h.data),
    width: h.width,
    height: h.height,
    type: h.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Oo = 0;
class _t extends $n {
  constructor(e = _t.DEFAULT_IMAGE, t = _t.DEFAULT_MAPPING, n = 1001, i = 1001, s = 1006, o = 1008, r = 1023, l = 1009, a = 1, c = 3e3) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Oo++ }), this.uuid = hi(), this.name = "", this.source = new so(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = o, this.anisotropy = a, this.format = r, this.internalFormat = null, this.type = l, this.offset = new Ce(0, 0), this.repeat = new Ce(1, 1), this.center = new Ce(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Mt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== 300)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case 1e3:
          e.x = e.x - Math.floor(e.x);
          break;
        case 1001:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case 1e3:
          e.y = e.y - Math.floor(e.y);
          break;
        case 1001:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
_t.DEFAULT_IMAGE = null;
_t.DEFAULT_MAPPING = 300;
class $e {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    $e.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, s = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, s;
    const l = e.elements, a = l[0], c = l[4], d = l[8], u = l[1], m = l[5], g = l[9], p = l[2], f = l[6], v = l[10];
    if (Math.abs(c - u) < 0.01 && Math.abs(d - p) < 0.01 && Math.abs(g - f) < 0.01) {
      if (Math.abs(c + u) < 0.1 && Math.abs(d + p) < 0.1 && Math.abs(g + f) < 0.1 && Math.abs(a + m + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const w = (a + 1) / 2, x = (m + 1) / 2, M = (v + 1) / 2, E = (c + u) / 4, R = (d + p) / 4, y = (g + f) / 4;
      return w > x && w > M ? w < 0.01 ? (n = 0, i = 0.707106781, s = 0.707106781) : (n = Math.sqrt(w), i = E / n, s = R / n) : x > M ? x < 0.01 ? (n = 0.707106781, i = 0, s = 0.707106781) : (i = Math.sqrt(x), n = E / i, s = y / i) : M < 0.01 ? (n = 0.707106781, i = 0.707106781, s = 0) : (s = Math.sqrt(M), n = R / s, i = y / s), this.set(n, i, s, t), this;
    }
    let _ = Math.sqrt((f - g) * (f - g) + (d - p) * (d - p) + (u - c) * (u - c));
    return Math.abs(_) < 1e-3 && (_ = 1), this.x = (f - g) / _, this.y = (d - p) / _, this.z = (u - c) / _, this.w = Math.acos((a + m + v - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class En extends $n {
  constructor(e, t, n = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new $e(0, 0, e, t), this.scissorTest = !1, this.viewport = new $e(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    this.texture = new _t(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : 1006, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0;
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new so(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ro extends _t {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Uo extends _t {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class ui {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  static slerpFlat(e, t, n, i, s, o, r) {
    let l = n[i + 0], a = n[i + 1], c = n[i + 2], d = n[i + 3];
    const u = s[o + 0], m = s[o + 1], g = s[o + 2], p = s[o + 3];
    if (r === 0) {
      e[t + 0] = l, e[t + 1] = a, e[t + 2] = c, e[t + 3] = d;
      return;
    }
    if (r === 1) {
      e[t + 0] = u, e[t + 1] = m, e[t + 2] = g, e[t + 3] = p;
      return;
    }
    if (d !== p || l !== u || a !== m || c !== g) {
      let f = 1 - r;
      const v = l * u + a * m + c * g + d * p, _ = v >= 0 ? 1 : -1, w = 1 - v * v;
      if (w > Number.EPSILON) {
        const M = Math.sqrt(w), E = Math.atan2(M, v * _);
        f = Math.sin(f * E) / M, r = Math.sin(r * E) / M;
      }
      const x = r * _;
      if (l = l * f + u * x, a = a * f + m * x, c = c * f + g * x, d = d * f + p * x, f === 1 - r) {
        const M = 1 / Math.sqrt(l * l + a * a + c * c + d * d);
        l *= M, a *= M, c *= M, d *= M;
      }
    }
    e[t] = l, e[t + 1] = a, e[t + 2] = c, e[t + 3] = d;
  }
  static multiplyQuaternionsFlat(e, t, n, i, s, o) {
    const r = n[i], l = n[i + 1], a = n[i + 2], c = n[i + 3], d = s[o], u = s[o + 1], m = s[o + 2], g = s[o + 3];
    return e[t] = r * g + c * d + l * m - a * u, e[t + 1] = l * g + c * u + a * d - r * m, e[t + 2] = a * g + c * m + r * u - l * d, e[t + 3] = c * g - r * d - l * u - a * m, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const n = e._x, i = e._y, s = e._z, o = e._order, r = Math.cos, l = Math.sin, a = r(n / 2), c = r(i / 2), d = r(s / 2), u = l(n / 2), m = l(i / 2), g = l(s / 2);
    switch (o) {
      case "XYZ":
        this._x = u * c * d + a * m * g, this._y = a * m * d - u * c * g, this._z = a * c * g + u * m * d, this._w = a * c * d - u * m * g;
        break;
      case "YXZ":
        this._x = u * c * d + a * m * g, this._y = a * m * d - u * c * g, this._z = a * c * g - u * m * d, this._w = a * c * d + u * m * g;
        break;
      case "ZXY":
        this._x = u * c * d - a * m * g, this._y = a * m * d + u * c * g, this._z = a * c * g + u * m * d, this._w = a * c * d - u * m * g;
        break;
      case "ZYX":
        this._x = u * c * d - a * m * g, this._y = a * m * d + u * c * g, this._z = a * c * g - u * m * d, this._w = a * c * d + u * m * g;
        break;
      case "YZX":
        this._x = u * c * d + a * m * g, this._y = a * m * d + u * c * g, this._z = a * c * g - u * m * d, this._w = a * c * d - u * m * g;
        break;
      case "XZY":
        this._x = u * c * d - a * m * g, this._y = a * m * d - u * c * g, this._z = a * c * g + u * m * d, this._w = a * c * d + u * m * g;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], s = t[8], o = t[1], r = t[5], l = t[9], a = t[2], c = t[6], d = t[10], u = n + r + d;
    if (u > 0) {
      const m = 0.5 / Math.sqrt(u + 1);
      this._w = 0.25 / m, this._x = (c - l) * m, this._y = (s - a) * m, this._z = (o - i) * m;
    } else if (n > r && n > d) {
      const m = 2 * Math.sqrt(1 + n - r - d);
      this._w = (c - l) / m, this._x = 0.25 * m, this._y = (i + o) / m, this._z = (s + a) / m;
    } else if (r > d) {
      const m = 2 * Math.sqrt(1 + r - n - d);
      this._w = (s - a) / m, this._x = (i + o) / m, this._y = 0.25 * m, this._z = (l + c) / m;
    } else {
      const m = 2 * Math.sqrt(1 + d - n - r);
      this._w = (o - i) / m, this._x = (s + a) / m, this._y = (l + c) / m, this._z = 0.25 * m;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(mt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0)
      return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, s = e._z, o = e._w, r = t._x, l = t._y, a = t._z, c = t._w;
    return this._x = n * c + o * r + i * a - s * l, this._y = i * c + o * l + s * r - n * a, this._z = s * c + o * a + n * l - i * r, this._w = o * c - n * r - i * l - s * a, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const n = this._x, i = this._y, s = this._z, o = this._w;
    let r = o * e._w + n * e._x + i * e._y + s * e._z;
    if (r < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, r = -r) : this.copy(e), r >= 1)
      return this._w = o, this._x = n, this._y = i, this._z = s, this;
    const l = 1 - r * r;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return this._w = m * o + t * this._w, this._x = m * n + t * this._x, this._y = m * i + t * this._y, this._z = m * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const a = Math.sqrt(l), c = Math.atan2(a, r), d = Math.sin((1 - t) * c) / a, u = Math.sin(t * c) / a;
    return this._w = o * d + this._w * u, this._x = n * d + this._x * u, this._y = i * d + this._y * u, this._z = s * d + this._z * u, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), i = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(s),
      n * Math.cos(s),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class O {
  constructor(e = 0, t = 0, n = 0) {
    O.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Ks.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Ks.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6] * i, this.y = s[1] * t + s[4] * n + s[7] * i, this.z = s[2] * t + s[5] * n + s[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
    return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o, this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o, this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, s = e.x, o = e.y, r = e.z, l = e.w, a = l * t + o * i - r * n, c = l * n + r * t - s * i, d = l * i + s * n - o * t, u = -s * t - o * n - r * i;
    return this.x = a * l + u * -s + c * -r - d * -o, this.y = c * l + u * -o + d * -s - a * -r, this.z = d * l + u * -r + a * -o - c * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * n + s[8] * i, this.y = s[1] * t + s[5] * n + s[9] * i, this.z = s[2] * t + s[6] * n + s[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, i = e.y, s = e.z, o = t.x, r = t.y, l = t.z;
    return this.x = i * l - s * r, this.y = s * o - n * l, this.z = n * r - i * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return ss.copy(this).projectOnVector(e), this.sub(ss);
  }
  reflect(e) {
    return this.sub(ss.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(mt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const ss = /* @__PURE__ */ new O(), Ks = /* @__PURE__ */ new ui();
class di {
  constructor(e = new O(1 / 0, 1 / 0, 1 / 0), t = new O(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, n = 1 / 0, i = 1 / 0, s = -1 / 0, o = -1 / 0, r = -1 / 0;
    for (let l = 0, a = e.length; l < a; l += 3) {
      const c = e[l], d = e[l + 1], u = e[l + 2];
      c < t && (t = c), d < n && (n = d), u < i && (i = u), c > s && (s = c), d > o && (o = d), u > r && (r = u);
    }
    return this.min.set(t, n, i), this.max.set(s, o, r), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, n = 1 / 0, i = 1 / 0, s = -1 / 0, o = -1 / 0, r = -1 / 0;
    for (let l = 0, a = e.count; l < a; l++) {
      const c = e.getX(l), d = e.getY(l), u = e.getZ(l);
      c < t && (t = c), d < n && (n = d), u < i && (i = u), c > s && (s = c), d > o && (o = d), u > r && (r = u);
    }
    return this.min.set(t, n, i), this.max.set(s, o, r), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = dn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0)
      if (t && n.attributes != null && n.attributes.position !== void 0) {
        const s = n.attributes.position;
        for (let o = 0, r = s.count; o < r; o++)
          dn.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(dn);
      } else
        n.boundingBox === null && n.computeBoundingBox(), rs.copy(n.boundingBox), rs.applyMatrix4(e.matrixWorld), this.union(rs);
    const i = e.children;
    for (let s = 0, o = i.length; s < o; s++)
      this.expandByObject(i[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, dn), dn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ei), vi.subVectors(this.max, ei), Dn.subVectors(e.a, ei), Pn.subVectors(e.b, ei), In.subVectors(e.c, ei), nn.subVectors(Pn, Dn), sn.subVectors(In, Pn), fn.subVectors(Dn, In);
    let t = [
      0,
      -nn.z,
      nn.y,
      0,
      -sn.z,
      sn.y,
      0,
      -fn.z,
      fn.y,
      nn.z,
      0,
      -nn.x,
      sn.z,
      0,
      -sn.x,
      fn.z,
      0,
      -fn.x,
      -nn.y,
      nn.x,
      0,
      -sn.y,
      sn.x,
      0,
      -fn.y,
      fn.x,
      0
    ];
    return !os(t, Dn, Pn, In, vi) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !os(t, Dn, Pn, In, vi)) ? !1 : (xi.crossVectors(nn, sn), t = [xi.x, xi.y, xi.z], os(t, Dn, Pn, In, vi));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return dn.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(dn).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Wt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Wt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Wt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Wt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Wt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Wt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Wt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Wt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Wt), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Wt = [
  /* @__PURE__ */ new O(),
  /* @__PURE__ */ new O(),
  /* @__PURE__ */ new O(),
  /* @__PURE__ */ new O(),
  /* @__PURE__ */ new O(),
  /* @__PURE__ */ new O(),
  /* @__PURE__ */ new O(),
  /* @__PURE__ */ new O()
], dn = /* @__PURE__ */ new O(), rs = /* @__PURE__ */ new di(), Dn = /* @__PURE__ */ new O(), Pn = /* @__PURE__ */ new O(), In = /* @__PURE__ */ new O(), nn = /* @__PURE__ */ new O(), sn = /* @__PURE__ */ new O(), fn = /* @__PURE__ */ new O(), ei = /* @__PURE__ */ new O(), vi = /* @__PURE__ */ new O(), xi = /* @__PURE__ */ new O(), pn = /* @__PURE__ */ new O();
function os(h, e, t, n, i) {
  for (let s = 0, o = h.length - 3; s <= o; s += 3) {
    pn.fromArray(h, s);
    const r = i.x * Math.abs(pn.x) + i.y * Math.abs(pn.y) + i.z * Math.abs(pn.z), l = e.dot(pn), a = t.dot(pn), c = n.dot(pn);
    if (Math.max(-Math.max(l, a, c), Math.min(l, a, c)) > r)
      return !1;
  }
  return !0;
}
const Go = /* @__PURE__ */ new di(), Js = /* @__PURE__ */ new O(), yi = /* @__PURE__ */ new O(), as = /* @__PURE__ */ new O();
class ci {
  constructor(e = new O(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : Go.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let s = 0, o = e.length; s < o; s++)
      i = Math.max(i, n.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    as.subVectors(e, this.center);
    const t = as.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.add(as.multiplyScalar(i / n)), this.radius += i;
    }
    return this;
  }
  union(e) {
    return this.center.equals(e.center) === !0 ? yi.set(0, 0, 1).multiplyScalar(e.radius) : yi.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Js.copy(e.center).add(yi)), this.expandByPoint(Js.copy(e.center).sub(yi)), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Vt = /* @__PURE__ */ new O(), ls = /* @__PURE__ */ new O(), bi = /* @__PURE__ */ new O(), rn = /* @__PURE__ */ new O(), cs = /* @__PURE__ */ new O(), wi = /* @__PURE__ */ new O(), hs = /* @__PURE__ */ new O();
class ko {
  constructor(e = new O(), t = new O(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Vt)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Vt.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Vt.copy(this.direction).multiplyScalar(t).add(this.origin), Vt.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    ls.copy(e).add(t).multiplyScalar(0.5), bi.copy(t).sub(e).normalize(), rn.copy(this.origin).sub(ls);
    const s = e.distanceTo(t) * 0.5, o = -this.direction.dot(bi), r = rn.dot(this.direction), l = -rn.dot(bi), a = rn.lengthSq(), c = Math.abs(1 - o * o);
    let d, u, m, g;
    if (c > 0)
      if (d = o * l - r, u = o * r - l, g = s * c, d >= 0)
        if (u >= -g)
          if (u <= g) {
            const p = 1 / c;
            d *= p, u *= p, m = d * (d + o * u + 2 * r) + u * (o * d + u + 2 * l) + a;
          } else
            u = s, d = Math.max(0, -(o * u + r)), m = -d * d + u * (u + 2 * l) + a;
        else
          u = -s, d = Math.max(0, -(o * u + r)), m = -d * d + u * (u + 2 * l) + a;
      else
        u <= -g ? (d = Math.max(0, -(-o * s + r)), u = d > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -d * d + u * (u + 2 * l) + a) : u <= g ? (d = 0, u = Math.min(Math.max(-s, -l), s), m = u * (u + 2 * l) + a) : (d = Math.max(0, -(o * s + r)), u = d > 0 ? s : Math.min(Math.max(-s, -l), s), m = -d * d + u * (u + 2 * l) + a);
    else
      u = o > 0 ? -s : s, d = Math.max(0, -(o * u + r)), m = -d * d + u * (u + 2 * l) + a;
    return n && n.copy(this.direction).multiplyScalar(d).add(this.origin), i && i.copy(bi).multiplyScalar(u).add(ls), m;
  }
  intersectSphere(e, t) {
    Vt.subVectors(e.center, this.origin);
    const n = Vt.dot(this.direction), i = Vt.dot(Vt) - n * n, s = e.radius * e.radius;
    if (i > s)
      return null;
    const o = Math.sqrt(s - i), r = n - o, l = n + o;
    return r < 0 && l < 0 ? null : r < 0 ? this.at(l, t) : this.at(r, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, s, o, r, l;
    const a = 1 / this.direction.x, c = 1 / this.direction.y, d = 1 / this.direction.z, u = this.origin;
    return a >= 0 ? (n = (e.min.x - u.x) * a, i = (e.max.x - u.x) * a) : (n = (e.max.x - u.x) * a, i = (e.min.x - u.x) * a), c >= 0 ? (s = (e.min.y - u.y) * c, o = (e.max.y - u.y) * c) : (s = (e.max.y - u.y) * c, o = (e.min.y - u.y) * c), n > o || s > i || ((s > n || n !== n) && (n = s), (o < i || i !== i) && (i = o), d >= 0 ? (r = (e.min.z - u.z) * d, l = (e.max.z - u.z) * d) : (r = (e.max.z - u.z) * d, l = (e.min.z - u.z) * d), n > l || r > i) || ((r > n || n !== n) && (n = r), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Vt) !== null;
  }
  intersectTriangle(e, t, n, i, s) {
    cs.subVectors(t, e), wi.subVectors(n, e), hs.crossVectors(cs, wi);
    let o = this.direction.dot(hs), r;
    if (o > 0) {
      if (i)
        return null;
      r = 1;
    } else if (o < 0)
      r = -1, o = -o;
    else
      return null;
    rn.subVectors(this.origin, e);
    const l = r * this.direction.dot(wi.crossVectors(rn, wi));
    if (l < 0)
      return null;
    const a = r * this.direction.dot(cs.cross(rn));
    if (a < 0 || l + a > o)
      return null;
    const c = -r * rn.dot(hs);
    return c < 0 ? null : this.at(c / o, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ke {
  constructor() {
    Ke.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, n, i, s, o, r, l, a, c, d, u, m, g, p, f) {
    const v = this.elements;
    return v[0] = e, v[4] = t, v[8] = n, v[12] = i, v[1] = s, v[5] = o, v[9] = r, v[13] = l, v[2] = a, v[6] = c, v[10] = d, v[14] = u, v[3] = m, v[7] = g, v[11] = p, v[15] = f, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Ke().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / zn.setFromMatrixColumn(e, 0).length(), s = 1 / zn.setFromMatrixColumn(e, 1).length(), o = 1 / zn.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, s = e.z, o = Math.cos(n), r = Math.sin(n), l = Math.cos(i), a = Math.sin(i), c = Math.cos(s), d = Math.sin(s);
    if (e.order === "XYZ") {
      const u = o * c, m = o * d, g = r * c, p = r * d;
      t[0] = l * c, t[4] = -l * d, t[8] = a, t[1] = m + g * a, t[5] = u - p * a, t[9] = -r * l, t[2] = p - u * a, t[6] = g + m * a, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const u = l * c, m = l * d, g = a * c, p = a * d;
      t[0] = u + p * r, t[4] = g * r - m, t[8] = o * a, t[1] = o * d, t[5] = o * c, t[9] = -r, t[2] = m * r - g, t[6] = p + u * r, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const u = l * c, m = l * d, g = a * c, p = a * d;
      t[0] = u - p * r, t[4] = -o * d, t[8] = g + m * r, t[1] = m + g * r, t[5] = o * c, t[9] = p - u * r, t[2] = -o * a, t[6] = r, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const u = o * c, m = o * d, g = r * c, p = r * d;
      t[0] = l * c, t[4] = g * a - m, t[8] = u * a + p, t[1] = l * d, t[5] = p * a + u, t[9] = m * a - g, t[2] = -a, t[6] = r * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const u = o * l, m = o * a, g = r * l, p = r * a;
      t[0] = l * c, t[4] = p - u * d, t[8] = g * d + m, t[1] = d, t[5] = o * c, t[9] = -r * c, t[2] = -a * c, t[6] = m * d + g, t[10] = u - p * d;
    } else if (e.order === "XZY") {
      const u = o * l, m = o * a, g = r * l, p = r * a;
      t[0] = l * c, t[4] = -d, t[8] = a * c, t[1] = u * d + p, t[5] = o * c, t[9] = m * d - g, t[2] = g * d - m, t[6] = r * c, t[10] = p * d + u;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Wo, e, Vo);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return ft.subVectors(e, t), ft.lengthSq() === 0 && (ft.z = 1), ft.normalize(), on.crossVectors(n, ft), on.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ft.x += 1e-4 : ft.z += 1e-4, ft.normalize(), on.crossVectors(n, ft)), on.normalize(), Mi.crossVectors(ft, on), i[0] = on.x, i[4] = Mi.x, i[8] = ft.x, i[1] = on.y, i[5] = Mi.y, i[9] = ft.y, i[2] = on.z, i[6] = Mi.z, i[10] = ft.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, s = this.elements, o = n[0], r = n[4], l = n[8], a = n[12], c = n[1], d = n[5], u = n[9], m = n[13], g = n[2], p = n[6], f = n[10], v = n[14], _ = n[3], w = n[7], x = n[11], M = n[15], E = i[0], R = i[4], y = i[8], A = i[12], F = i[1], P = i[5], G = i[9], z = i[13], L = i[2], I = i[6], D = i[10], q = i[14], k = i[3], N = i[7], H = i[11], J = i[15];
    return s[0] = o * E + r * F + l * L + a * k, s[4] = o * R + r * P + l * I + a * N, s[8] = o * y + r * G + l * D + a * H, s[12] = o * A + r * z + l * q + a * J, s[1] = c * E + d * F + u * L + m * k, s[5] = c * R + d * P + u * I + m * N, s[9] = c * y + d * G + u * D + m * H, s[13] = c * A + d * z + u * q + m * J, s[2] = g * E + p * F + f * L + v * k, s[6] = g * R + p * P + f * I + v * N, s[10] = g * y + p * G + f * D + v * H, s[14] = g * A + p * z + f * q + v * J, s[3] = _ * E + w * F + x * L + M * k, s[7] = _ * R + w * P + x * I + M * N, s[11] = _ * y + w * G + x * D + M * H, s[15] = _ * A + w * z + x * q + M * J, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], s = e[12], o = e[1], r = e[5], l = e[9], a = e[13], c = e[2], d = e[6], u = e[10], m = e[14], g = e[3], p = e[7], f = e[11], v = e[15];
    return g * (+s * l * d - i * a * d - s * r * u + n * a * u + i * r * m - n * l * m) + p * (+t * l * m - t * a * u + s * o * u - i * o * m + i * a * c - s * l * c) + f * (+t * a * d - t * r * m - s * o * d + n * o * m + s * r * c - n * a * c) + v * (-i * r * c - t * l * d + t * r * u + i * o * d - n * o * u + n * l * c);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], r = e[5], l = e[6], a = e[7], c = e[8], d = e[9], u = e[10], m = e[11], g = e[12], p = e[13], f = e[14], v = e[15], _ = d * f * a - p * u * a + p * l * m - r * f * m - d * l * v + r * u * v, w = g * u * a - c * f * a - g * l * m + o * f * m + c * l * v - o * u * v, x = c * p * a - g * d * a + g * r * m - o * p * m - c * r * v + o * d * v, M = g * d * l - c * p * l - g * r * u + o * p * u + c * r * f - o * d * f, E = t * _ + n * w + i * x + s * M;
    if (E === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const R = 1 / E;
    return e[0] = _ * R, e[1] = (p * u * s - d * f * s - p * i * m + n * f * m + d * i * v - n * u * v) * R, e[2] = (r * f * s - p * l * s + p * i * a - n * f * a - r * i * v + n * l * v) * R, e[3] = (d * l * s - r * u * s - d * i * a + n * u * a + r * i * m - n * l * m) * R, e[4] = w * R, e[5] = (c * f * s - g * u * s + g * i * m - t * f * m - c * i * v + t * u * v) * R, e[6] = (g * l * s - o * f * s - g * i * a + t * f * a + o * i * v - t * l * v) * R, e[7] = (o * u * s - c * l * s + c * i * a - t * u * a - o * i * m + t * l * m) * R, e[8] = x * R, e[9] = (g * d * s - c * p * s - g * n * m + t * p * m + c * n * v - t * d * v) * R, e[10] = (o * p * s - g * r * s + g * n * a - t * p * a - o * n * v + t * r * v) * R, e[11] = (c * r * s - o * d * s - c * n * a + t * d * a + o * n * m - t * r * m) * R, e[12] = M * R, e[13] = (c * p * i - g * d * i + g * n * u - t * p * u - c * n * f + t * d * f) * R, e[14] = (g * r * i - o * p * i - g * n * l + t * p * l + o * n * f - t * r * f) * R, e[15] = (o * d * i - c * r * i + c * n * l - t * d * l - o * n * u + t * r * u) * R, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, s = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= s, t[1] *= n, t[5] *= i, t[9] *= s, t[2] *= n, t[6] *= i, t[10] *= s, t[3] *= n, t[7] *= i, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), s = 1 - n, o = e.x, r = e.y, l = e.z, a = s * o, c = s * r;
    return this.set(
      a * o + n,
      a * r - i * l,
      a * l + i * r,
      0,
      a * r + i * l,
      c * r + n,
      c * l - i * o,
      0,
      a * l - i * r,
      c * l + i * o,
      s * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, i, s, o) {
    return this.set(
      1,
      n,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const i = this.elements, s = t._x, o = t._y, r = t._z, l = t._w, a = s + s, c = o + o, d = r + r, u = s * a, m = s * c, g = s * d, p = o * c, f = o * d, v = r * d, _ = l * a, w = l * c, x = l * d, M = n.x, E = n.y, R = n.z;
    return i[0] = (1 - (p + v)) * M, i[1] = (m + x) * M, i[2] = (g - w) * M, i[3] = 0, i[4] = (m - x) * E, i[5] = (1 - (u + v)) * E, i[6] = (f + _) * E, i[7] = 0, i[8] = (g + w) * R, i[9] = (f - _) * R, i[10] = (1 - (u + p)) * R, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, n) {
    const i = this.elements;
    let s = zn.set(i[0], i[1], i[2]).length();
    const o = zn.set(i[4], i[5], i[6]).length(), r = zn.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], Tt.copy(this);
    const a = 1 / s, c = 1 / o, d = 1 / r;
    return Tt.elements[0] *= a, Tt.elements[1] *= a, Tt.elements[2] *= a, Tt.elements[4] *= c, Tt.elements[5] *= c, Tt.elements[6] *= c, Tt.elements[8] *= d, Tt.elements[9] *= d, Tt.elements[10] *= d, t.setFromRotationMatrix(Tt), n.x = s, n.y = o, n.z = r, this;
  }
  makePerspective(e, t, n, i, s, o) {
    const r = this.elements, l = 2 * s / (t - e), a = 2 * s / (n - i), c = (t + e) / (t - e), d = (n + i) / (n - i), u = -(o + s) / (o - s), m = -2 * o * s / (o - s);
    return r[0] = l, r[4] = 0, r[8] = c, r[12] = 0, r[1] = 0, r[5] = a, r[9] = d, r[13] = 0, r[2] = 0, r[6] = 0, r[10] = u, r[14] = m, r[3] = 0, r[7] = 0, r[11] = -1, r[15] = 0, this;
  }
  makeOrthographic(e, t, n, i, s, o) {
    const r = this.elements, l = 1 / (t - e), a = 1 / (n - i), c = 1 / (o - s), d = (t + e) * l, u = (n + i) * a, m = (o + s) * c;
    return r[0] = 2 * l, r[4] = 0, r[8] = 0, r[12] = -d, r[1] = 0, r[5] = 2 * a, r[9] = 0, r[13] = -u, r[2] = 0, r[6] = 0, r[10] = -2 * c, r[14] = -m, r[3] = 0, r[7] = 0, r[11] = 0, r[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const zn = /* @__PURE__ */ new O(), Tt = /* @__PURE__ */ new Ke(), Wo = /* @__PURE__ */ new O(0, 0, 0), Vo = /* @__PURE__ */ new O(1, 1, 1), on = /* @__PURE__ */ new O(), Mi = /* @__PURE__ */ new O(), ft = /* @__PURE__ */ new O(), Qs = /* @__PURE__ */ new Ke(), er = /* @__PURE__ */ new ui();
class fi {
  constructor(e = 0, t = 0, n = 0, i = fi.DefaultOrder) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, s = i[0], o = i[4], r = i[8], l = i[1], a = i[5], c = i[9], d = i[2], u = i[6], m = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(mt(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(-c, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(u, a), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-mt(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(r, m), this._z = Math.atan2(l, a)) : (this._y = Math.atan2(-d, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(mt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-d, m), this._z = Math.atan2(-o, a)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-mt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(u, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, a));
        break;
      case "YZX":
        this._z = Math.asin(mt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-c, a), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(r, m));
        break;
      case "XZY":
        this._z = Math.asin(-mt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(u, a), this._y = Math.atan2(r, s)) : (this._x = Math.atan2(-c, m), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return Qs.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Qs, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return er.setFromEuler(this), this.setFromQuaternion(er, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
fi.DefaultOrder = "XYZ";
fi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class oo {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let Ho = 0;
const tr = /* @__PURE__ */ new O(), Bn = /* @__PURE__ */ new ui(), Ht = /* @__PURE__ */ new Ke(), Si = /* @__PURE__ */ new O(), ti = /* @__PURE__ */ new O(), qo = /* @__PURE__ */ new O(), Xo = /* @__PURE__ */ new ui(), nr = /* @__PURE__ */ new O(1, 0, 0), ir = /* @__PURE__ */ new O(0, 1, 0), sr = /* @__PURE__ */ new O(0, 0, 1), jo = { type: "added" }, rr = { type: "removed" };
class at extends $n {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Ho++ }), this.uuid = hi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = at.DefaultUp.clone();
    const e = new O(), t = new fi(), n = new ui(), i = new O(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new Ke()
      },
      normalMatrix: {
        value: new Mt()
      }
    }), this.matrix = new Ke(), this.matrixWorld = new Ke(), this.matrixAutoUpdate = at.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new oo(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Bn.setFromAxisAngle(e, t), this.quaternion.multiply(Bn), this;
  }
  rotateOnWorldAxis(e, t) {
    return Bn.setFromAxisAngle(e, t), this.quaternion.premultiply(Bn), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(nr, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(ir, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(sr, e);
  }
  translateOnAxis(e, t) {
    return tr.copy(e).applyQuaternion(this.quaternion), this.position.add(tr.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(nr, e);
  }
  translateY(e) {
    return this.translateOnAxis(ir, e);
  }
  translateZ(e) {
    return this.translateOnAxis(sr, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(Ht.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Si.copy(e) : Si.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), ti.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ht.lookAt(ti, Si, this.up) : Ht.lookAt(Si, ti, this.up), this.quaternion.setFromRotationMatrix(Ht), i && (Ht.extractRotation(i.matrixWorld), Bn.setFromRotationMatrix(Ht), this.quaternion.premultiply(Bn.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(jo)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(rr)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(rr);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Ht.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ht.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ht), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ti, e, qo), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ti, Xo, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let s = 0, o = i.length; s < o; s++)
        i[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
    function s(r, l) {
      return r[l.uuid] === void 0 && (r[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const r = this.geometry.parameters;
      if (r !== void 0 && r.shapes !== void 0) {
        const l = r.shapes;
        if (Array.isArray(l))
          for (let a = 0, c = l.length; a < c; a++) {
            const d = l[a];
            s(e.shapes, d);
          }
        else
          s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const r = [];
        for (let l = 0, a = this.material.length; l < a; l++)
          r.push(s(e.materials, this.material[l]));
        i.material = r;
      } else
        i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let r = 0; r < this.children.length; r++)
        i.children.push(this.children[r].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let r = 0; r < this.animations.length; r++) {
        const l = this.animations[r];
        i.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const r = o(e.geometries), l = o(e.materials), a = o(e.textures), c = o(e.images), d = o(e.shapes), u = o(e.skeletons), m = o(e.animations), g = o(e.nodes);
      r.length > 0 && (n.geometries = r), l.length > 0 && (n.materials = l), a.length > 0 && (n.textures = a), c.length > 0 && (n.images = c), d.length > 0 && (n.shapes = d), u.length > 0 && (n.skeletons = u), m.length > 0 && (n.animations = m), g.length > 0 && (n.nodes = g);
    }
    return n.object = i, n;
    function o(r) {
      const l = [];
      for (const a in r) {
        const c = r[a];
        delete c.metadata, l.push(c);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
at.DefaultUp = /* @__PURE__ */ new O(0, 1, 0);
at.DefaultMatrixAutoUpdate = !0;
const At = /* @__PURE__ */ new O(), qt = /* @__PURE__ */ new O(), us = /* @__PURE__ */ new O(), Xt = /* @__PURE__ */ new O(), Nn = /* @__PURE__ */ new O(), On = /* @__PURE__ */ new O(), or = /* @__PURE__ */ new O(), ds = /* @__PURE__ */ new O(), fs = /* @__PURE__ */ new O(), ps = /* @__PURE__ */ new O();
class Qt {
  constructor(e = new O(), t = new O(), n = new O()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), At.subVectors(e, t), i.cross(At);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, s) {
    At.subVectors(i, t), qt.subVectors(n, t), us.subVectors(e, t);
    const o = At.dot(At), r = At.dot(qt), l = At.dot(us), a = qt.dot(qt), c = qt.dot(us), d = o * a - r * r;
    if (d === 0)
      return s.set(-2, -1, -1);
    const u = 1 / d, m = (a * l - r * c) * u, g = (o * c - r * l) * u;
    return s.set(1 - m - g, g, m);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, Xt), Xt.x >= 0 && Xt.y >= 0 && Xt.x + Xt.y <= 1;
  }
  static getUV(e, t, n, i, s, o, r, l) {
    return this.getBarycoord(e, t, n, i, Xt), l.set(0, 0), l.addScaledVector(s, Xt.x), l.addScaledVector(o, Xt.y), l.addScaledVector(r, Xt.z), l;
  }
  static isFrontFacing(e, t, n, i) {
    return At.subVectors(n, t), qt.subVectors(e, t), At.cross(qt).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return At.subVectors(this.c, this.b), qt.subVectors(this.a, this.b), At.cross(qt).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Qt.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Qt.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, s) {
    return Qt.getUV(e, this.a, this.b, this.c, t, n, i, s);
  }
  containsPoint(e) {
    return Qt.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Qt.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, s = this.c;
    let o, r;
    Nn.subVectors(i, n), On.subVectors(s, n), ds.subVectors(e, n);
    const l = Nn.dot(ds), a = On.dot(ds);
    if (l <= 0 && a <= 0)
      return t.copy(n);
    fs.subVectors(e, i);
    const c = Nn.dot(fs), d = On.dot(fs);
    if (c >= 0 && d <= c)
      return t.copy(i);
    const u = l * d - c * a;
    if (u <= 0 && l >= 0 && c <= 0)
      return o = l / (l - c), t.copy(n).addScaledVector(Nn, o);
    ps.subVectors(e, s);
    const m = Nn.dot(ps), g = On.dot(ps);
    if (g >= 0 && m <= g)
      return t.copy(s);
    const p = m * a - l * g;
    if (p <= 0 && a >= 0 && g <= 0)
      return r = a / (a - g), t.copy(n).addScaledVector(On, r);
    const f = c * g - m * d;
    if (f <= 0 && d - c >= 0 && m - g >= 0)
      return or.subVectors(s, i), r = (d - c) / (d - c + (m - g)), t.copy(i).addScaledVector(or, r);
    const v = 1 / (f + p + u);
    return o = p * v, r = u * v, t.copy(n).addScaledVector(Nn, o).addScaledVector(On, r);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Yo = 0;
class An extends $n {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Yo++ }), this.uuid = hi(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === 1;
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.side !== 0 && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function i(s) {
      const o = [];
      for (const r in s) {
        const l = s[r];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = i(e.textures), o = i(e.images);
      s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let s = 0; s !== i; ++s)
        n[s] = t[s].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class ao extends An {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ae(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const qe = /* @__PURE__ */ new O(), Ei = /* @__PURE__ */ new Ce();
class Ot {
  constructor(e, t, n) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n === !0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let o = e[i];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), o = new Ae()), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b;
    }
    return this;
  }
  copyVector2sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let o = e[i];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), o = new Ce()), t[n++] = o.x, t[n++] = o.y;
    }
    return this;
  }
  copyVector3sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let o = e[i];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), o = new O()), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z;
    }
    return this;
  }
  copyVector4sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let o = e[i];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new $e()), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w;
    }
    return this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Ei.fromBufferAttribute(this, t), Ei.applyMatrix3(e), this.setXY(t, Ei.x, Ei.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        qe.fromBufferAttribute(this, t), qe.applyMatrix3(e), this.setXYZ(t, qe.x, qe.y, qe.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qe.fromBufferAttribute(this, t), qe.applyMatrix4(e), this.setXYZ(t, qe.x, qe.y, qe.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qe.fromBufferAttribute(this, t), qe.applyNormalMatrix(e), this.setXYZ(t, qe.x, qe.y, qe.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qe.fromBufferAttribute(this, t), qe.transformDirection(e), this.setXYZ(t, qe.x, qe.y, qe.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, t) {
    return this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, t) {
    return this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, t) {
    return this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, t) {
    return this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, s) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== 35044 && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class lo extends Ot {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class co extends Ot {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class st extends Ot {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let Zo = 0;
const bt = /* @__PURE__ */ new Ke(), ms = /* @__PURE__ */ new at(), Un = /* @__PURE__ */ new O(), pt = /* @__PURE__ */ new di(), ni = /* @__PURE__ */ new di(), Qe = /* @__PURE__ */ new O();
class Ut extends $n {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Zo++ }), this.uuid = hi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (to(e) ? co : lo)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new Mt().getNormalMatrix(e);
      n.applyNormalMatrix(s), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return bt.makeRotationFromQuaternion(e), this.applyMatrix4(bt), this;
  }
  rotateX(e) {
    return bt.makeRotationX(e), this.applyMatrix4(bt), this;
  }
  rotateY(e) {
    return bt.makeRotationY(e), this.applyMatrix4(bt), this;
  }
  rotateZ(e) {
    return bt.makeRotationZ(e), this.applyMatrix4(bt), this;
  }
  translate(e, t, n) {
    return bt.makeTranslation(e, t, n), this.applyMatrix4(bt), this;
  }
  scale(e, t, n) {
    return bt.makeScale(e, t, n), this.applyMatrix4(bt), this;
  }
  lookAt(e) {
    return ms.lookAt(e), ms.updateMatrix(), this.applyMatrix4(ms.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Un).negate(), this.translate(Un.x, Un.y, Un.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new st(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new di());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new O(-1 / 0, -1 / 0, -1 / 0),
        new O(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const s = t[n];
          pt.setFromBufferAttribute(s), this.morphTargetsRelative ? (Qe.addVectors(this.boundingBox.min, pt.min), this.boundingBox.expandByPoint(Qe), Qe.addVectors(this.boundingBox.max, pt.max), this.boundingBox.expandByPoint(Qe)) : (this.boundingBox.expandByPoint(pt.min), this.boundingBox.expandByPoint(pt.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ci());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new O(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (pt.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const r = t[s];
          ni.setFromBufferAttribute(r), this.morphTargetsRelative ? (Qe.addVectors(pt.min, ni.min), pt.expandByPoint(Qe), Qe.addVectors(pt.max, ni.max), pt.expandByPoint(Qe)) : (pt.expandByPoint(ni.min), pt.expandByPoint(ni.max));
        }
      pt.getCenter(n);
      let i = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Qe.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(Qe));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const r = t[s], l = this.morphTargetsRelative;
          for (let a = 0, c = r.count; a < c; a++)
            Qe.fromBufferAttribute(r, a), l && (Un.fromBufferAttribute(e, a), Qe.add(Un)), i = Math.max(i, n.distanceToSquared(Qe));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.array, i = t.position.array, s = t.normal.array, o = t.uv.array, r = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ot(new Float32Array(4 * r), 4));
    const l = this.getAttribute("tangent").array, a = [], c = [];
    for (let F = 0; F < r; F++)
      a[F] = new O(), c[F] = new O();
    const d = new O(), u = new O(), m = new O(), g = new Ce(), p = new Ce(), f = new Ce(), v = new O(), _ = new O();
    function w(F, P, G) {
      d.fromArray(i, F * 3), u.fromArray(i, P * 3), m.fromArray(i, G * 3), g.fromArray(o, F * 2), p.fromArray(o, P * 2), f.fromArray(o, G * 2), u.sub(d), m.sub(d), p.sub(g), f.sub(g);
      const z = 1 / (p.x * f.y - f.x * p.y);
      !isFinite(z) || (v.copy(u).multiplyScalar(f.y).addScaledVector(m, -p.y).multiplyScalar(z), _.copy(m).multiplyScalar(p.x).addScaledVector(u, -f.x).multiplyScalar(z), a[F].add(v), a[P].add(v), a[G].add(v), c[F].add(_), c[P].add(_), c[G].add(_));
    }
    let x = this.groups;
    x.length === 0 && (x = [{
      start: 0,
      count: n.length
    }]);
    for (let F = 0, P = x.length; F < P; ++F) {
      const G = x[F], z = G.start, L = G.count;
      for (let I = z, D = z + L; I < D; I += 3)
        w(
          n[I + 0],
          n[I + 1],
          n[I + 2]
        );
    }
    const M = new O(), E = new O(), R = new O(), y = new O();
    function A(F) {
      R.fromArray(s, F * 3), y.copy(R);
      const P = a[F];
      M.copy(P), M.sub(R.multiplyScalar(R.dot(P))).normalize(), E.crossVectors(y, P);
      const z = E.dot(c[F]) < 0 ? -1 : 1;
      l[F * 4] = M.x, l[F * 4 + 1] = M.y, l[F * 4 + 2] = M.z, l[F * 4 + 3] = z;
    }
    for (let F = 0, P = x.length; F < P; ++F) {
      const G = x[F], z = G.start, L = G.count;
      for (let I = z, D = z + L; I < D; I += 3)
        A(n[I + 0]), A(n[I + 1]), A(n[I + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Ot(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let u = 0, m = n.count; u < m; u++)
          n.setXYZ(u, 0, 0, 0);
      const i = new O(), s = new O(), o = new O(), r = new O(), l = new O(), a = new O(), c = new O(), d = new O();
      if (e)
        for (let u = 0, m = e.count; u < m; u += 3) {
          const g = e.getX(u + 0), p = e.getX(u + 1), f = e.getX(u + 2);
          i.fromBufferAttribute(t, g), s.fromBufferAttribute(t, p), o.fromBufferAttribute(t, f), c.subVectors(o, s), d.subVectors(i, s), c.cross(d), r.fromBufferAttribute(n, g), l.fromBufferAttribute(n, p), a.fromBufferAttribute(n, f), r.add(c), l.add(c), a.add(c), n.setXYZ(g, r.x, r.y, r.z), n.setXYZ(p, l.x, l.y, l.z), n.setXYZ(f, a.x, a.y, a.z);
        }
      else
        for (let u = 0, m = t.count; u < m; u += 3)
          i.fromBufferAttribute(t, u + 0), s.fromBufferAttribute(t, u + 1), o.fromBufferAttribute(t, u + 2), c.subVectors(o, s), d.subVectors(i, s), c.cross(d), n.setXYZ(u + 0, c.x, c.y, c.z), n.setXYZ(u + 1, c.x, c.y, c.z), n.setXYZ(u + 2, c.x, c.y, c.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  merge(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    t === void 0 && (t = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const n = this.attributes;
    for (const i in n) {
      if (e.attributes[i] === void 0)
        continue;
      const o = n[i].array, r = e.attributes[i], l = r.array, a = r.itemSize * t, c = Math.min(l.length, o.length - a);
      for (let d = 0, u = a; d < c; d++, u++)
        o[u] = l[d];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Qe.fromBufferAttribute(e, t), Qe.normalize(), e.setXYZ(t, Qe.x, Qe.y, Qe.z);
  }
  toNonIndexed() {
    function e(r, l) {
      const a = r.array, c = r.itemSize, d = r.normalized, u = new a.constructor(l.length * c);
      let m = 0, g = 0;
      for (let p = 0, f = l.length; p < f; p++) {
        r.isInterleavedBufferAttribute ? m = l[p] * r.data.stride + r.offset : m = l[p] * c;
        for (let v = 0; v < c; v++)
          u[g++] = a[m++];
      }
      return new Ot(u, c, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Ut(), n = this.index.array, i = this.attributes;
    for (const r in i) {
      const l = i[r], a = e(l, n);
      t.setAttribute(r, a);
    }
    const s = this.morphAttributes;
    for (const r in s) {
      const l = [], a = s[r];
      for (let c = 0, d = a.length; c < d; c++) {
        const u = a[c], m = e(u, n);
        l.push(m);
      }
      t.morphAttributes[r] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let r = 0, l = o.length; r < l; r++) {
      const a = o[r];
      t.addGroup(a.start, a.count, a.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const a in l)
        l[a] !== void 0 && (e[a] = l[a]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const a = n[l];
      e.data.attributes[l] = a.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const a = this.morphAttributes[l], c = [];
      for (let d = 0, u = a.length; d < u; d++) {
        const m = a[d];
        c.push(m.toJSON(e.data));
      }
      c.length > 0 && (i[l] = c, s = !0);
    }
    s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const r = this.boundingSphere;
    return r !== null && (e.data.boundingSphere = {
      center: r.center.toArray(),
      radius: r.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const a in i) {
      const c = i[a];
      this.setAttribute(a, c.clone(t));
    }
    const s = e.morphAttributes;
    for (const a in s) {
      const c = [], d = s[a];
      for (let u = 0, m = d.length; u < m; u++)
        c.push(d[u].clone(t));
      this.morphAttributes[a] = c;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let a = 0, c = o.length; a < c; a++) {
      const d = o[a];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const r = e.boundingBox;
    r !== null && (this.boundingBox = r.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const ar = /* @__PURE__ */ new Ke(), Gn = /* @__PURE__ */ new ko(), gs = /* @__PURE__ */ new ci(), an = /* @__PURE__ */ new O(), ln = /* @__PURE__ */ new O(), cn = /* @__PURE__ */ new O(), _s = /* @__PURE__ */ new O(), vs = /* @__PURE__ */ new O(), xs = /* @__PURE__ */ new O(), Ti = /* @__PURE__ */ new O(), Ai = /* @__PURE__ */ new O(), Ci = /* @__PURE__ */ new O(), Li = /* @__PURE__ */ new Ce(), Ri = /* @__PURE__ */ new Ce(), Fi = /* @__PURE__ */ new Ce(), ys = /* @__PURE__ */ new O(), Di = /* @__PURE__ */ new O();
class Nt extends at {
  constructor(e = new Ut(), t = new ao()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = i.length; s < o; s++) {
          const r = i[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = s;
        }
      }
    }
  }
  raycast(e, t) {
    const n = this.geometry, i = this.material, s = this.matrixWorld;
    if (i === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), gs.copy(n.boundingSphere), gs.applyMatrix4(s), e.ray.intersectsSphere(gs) === !1) || (ar.copy(s).invert(), Gn.copy(e.ray).applyMatrix4(ar), n.boundingBox !== null && Gn.intersectsBox(n.boundingBox) === !1))
      return;
    let o;
    const r = n.index, l = n.attributes.position, a = n.morphAttributes.position, c = n.morphTargetsRelative, d = n.attributes.uv, u = n.attributes.uv2, m = n.groups, g = n.drawRange;
    if (r !== null)
      if (Array.isArray(i))
        for (let p = 0, f = m.length; p < f; p++) {
          const v = m[p], _ = i[v.materialIndex], w = Math.max(v.start, g.start), x = Math.min(r.count, Math.min(v.start + v.count, g.start + g.count));
          for (let M = w, E = x; M < E; M += 3) {
            const R = r.getX(M), y = r.getX(M + 1), A = r.getX(M + 2);
            o = Pi(this, _, e, Gn, l, a, c, d, u, R, y, A), o && (o.faceIndex = Math.floor(M / 3), o.face.materialIndex = v.materialIndex, t.push(o));
          }
        }
      else {
        const p = Math.max(0, g.start), f = Math.min(r.count, g.start + g.count);
        for (let v = p, _ = f; v < _; v += 3) {
          const w = r.getX(v), x = r.getX(v + 1), M = r.getX(v + 2);
          o = Pi(this, i, e, Gn, l, a, c, d, u, w, x, M), o && (o.faceIndex = Math.floor(v / 3), t.push(o));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(i))
        for (let p = 0, f = m.length; p < f; p++) {
          const v = m[p], _ = i[v.materialIndex], w = Math.max(v.start, g.start), x = Math.min(l.count, Math.min(v.start + v.count, g.start + g.count));
          for (let M = w, E = x; M < E; M += 3) {
            const R = M, y = M + 1, A = M + 2;
            o = Pi(this, _, e, Gn, l, a, c, d, u, R, y, A), o && (o.faceIndex = Math.floor(M / 3), o.face.materialIndex = v.materialIndex, t.push(o));
          }
        }
      else {
        const p = Math.max(0, g.start), f = Math.min(l.count, g.start + g.count);
        for (let v = p, _ = f; v < _; v += 3) {
          const w = v, x = v + 1, M = v + 2;
          o = Pi(this, i, e, Gn, l, a, c, d, u, w, x, M), o && (o.faceIndex = Math.floor(v / 3), t.push(o));
        }
      }
  }
}
function $o(h, e, t, n, i, s, o, r) {
  let l;
  if (e.side === 1 ? l = n.intersectTriangle(o, s, i, !0, r) : l = n.intersectTriangle(i, s, o, e.side !== 2, r), l === null)
    return null;
  Di.copy(r), Di.applyMatrix4(h.matrixWorld);
  const a = t.ray.origin.distanceTo(Di);
  return a < t.near || a > t.far ? null : {
    distance: a,
    point: Di.clone(),
    object: h
  };
}
function Pi(h, e, t, n, i, s, o, r, l, a, c, d) {
  an.fromBufferAttribute(i, a), ln.fromBufferAttribute(i, c), cn.fromBufferAttribute(i, d);
  const u = h.morphTargetInfluences;
  if (s && u) {
    Ti.set(0, 0, 0), Ai.set(0, 0, 0), Ci.set(0, 0, 0);
    for (let g = 0, p = s.length; g < p; g++) {
      const f = u[g], v = s[g];
      f !== 0 && (_s.fromBufferAttribute(v, a), vs.fromBufferAttribute(v, c), xs.fromBufferAttribute(v, d), o ? (Ti.addScaledVector(_s, f), Ai.addScaledVector(vs, f), Ci.addScaledVector(xs, f)) : (Ti.addScaledVector(_s.sub(an), f), Ai.addScaledVector(vs.sub(ln), f), Ci.addScaledVector(xs.sub(cn), f)));
    }
    an.add(Ti), ln.add(Ai), cn.add(Ci);
  }
  h.isSkinnedMesh && (h.boneTransform(a, an), h.boneTransform(c, ln), h.boneTransform(d, cn));
  const m = $o(h, e, t, n, an, ln, cn, ys);
  if (m) {
    r && (Li.fromBufferAttribute(r, a), Ri.fromBufferAttribute(r, c), Fi.fromBufferAttribute(r, d), m.uv = Qt.getUV(ys, an, ln, cn, Li, Ri, Fi, new Ce())), l && (Li.fromBufferAttribute(l, a), Ri.fromBufferAttribute(l, c), Fi.fromBufferAttribute(l, d), m.uv2 = Qt.getUV(ys, an, ln, cn, Li, Ri, Fi, new Ce()));
    const g = {
      a,
      b: c,
      c: d,
      normal: new O(),
      materialIndex: 0
    };
    Qt.getNormal(an, ln, cn, g.normal), m.face = g;
  }
  return m;
}
class pi extends Ut {
  constructor(e = 1, t = 1, n = 1, i = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: s,
      depthSegments: o
    };
    const r = this;
    i = Math.floor(i), s = Math.floor(s), o = Math.floor(o);
    const l = [], a = [], c = [], d = [];
    let u = 0, m = 0;
    g("z", "y", "x", -1, -1, n, t, e, o, s, 0), g("z", "y", "x", 1, -1, n, t, -e, o, s, 1), g("x", "z", "y", 1, 1, e, n, t, i, o, 2), g("x", "z", "y", 1, -1, e, n, -t, i, o, 3), g("x", "y", "z", 1, -1, e, t, n, i, s, 4), g("x", "y", "z", -1, -1, e, t, -n, i, s, 5), this.setIndex(l), this.setAttribute("position", new st(a, 3)), this.setAttribute("normal", new st(c, 3)), this.setAttribute("uv", new st(d, 2));
    function g(p, f, v, _, w, x, M, E, R, y, A) {
      const F = x / R, P = M / y, G = x / 2, z = M / 2, L = E / 2, I = R + 1, D = y + 1;
      let q = 0, k = 0;
      const N = new O();
      for (let H = 0; H < D; H++) {
        const J = H * P - z;
        for (let V = 0; V < I; V++) {
          const ee = V * F - G;
          N[p] = ee * _, N[f] = J * w, N[v] = L, a.push(N.x, N.y, N.z), N[p] = 0, N[f] = 0, N[v] = E > 0 ? 1 : -1, c.push(N.x, N.y, N.z), d.push(V / R), d.push(1 - H / y), q += 1;
        }
      }
      for (let H = 0; H < y; H++)
        for (let J = 0; J < R; J++) {
          const V = u + J + I * H, ee = u + J + I * (H + 1), ce = u + (J + 1) + I * (H + 1), ge = u + (J + 1) + I * H;
          l.push(V, ee, ge), l.push(ee, ce, ge), k += 6;
        }
      r.addGroup(m, k, A), m += k, u += q;
    }
  }
  static fromJSON(e) {
    return new pi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Zn(h) {
  const e = {};
  for (const t in h) {
    e[t] = {};
    for (const n in h[t]) {
      const i = h[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function it(h) {
  const e = {};
  for (let t = 0; t < h.length; t++) {
    const n = Zn(h[t]);
    for (const i in n)
      e[i] = n[i];
  }
  return e;
}
function Ko(h) {
  const e = [];
  for (let t = 0; t < h.length; t++)
    e.push(h[t].clone());
  return e;
}
const Jo = { clone: Zn, merge: it };
var Qo = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, ea = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Tn extends An {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Qo, this.fragmentShader = ea, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Zn(e.uniforms), this.uniformsGroups = Ko(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture ? t.uniforms[i] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[i] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[i] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class ho extends at {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ke(), this.projectionMatrix = new Ke(), this.projectionMatrixInverse = new Ke();
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class gt extends ho {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = zs * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Qi * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return zs * 2 * Math.atan(
      Math.tan(Qi * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, i, s, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Qi * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, s = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, a = o.fullHeight;
      s += o.offsetX * i / l, t -= o.offsetY * n / a, i *= o.width / l, n *= o.height / a;
    }
    const r = this.filmOffset;
    r !== 0 && (s += e * r / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const kn = 90, Wn = 1;
class ta extends at {
  constructor(e, t, n) {
    if (super(), this.type = "CubeCamera", n.isWebGLCubeRenderTarget !== !0) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = n;
    const i = new gt(kn, Wn, e, t);
    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new O(1, 0, 0)), this.add(i);
    const s = new gt(kn, Wn, e, t);
    s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new O(-1, 0, 0)), this.add(s);
    const o = new gt(kn, Wn, e, t);
    o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new O(0, 1, 0)), this.add(o);
    const r = new gt(kn, Wn, e, t);
    r.layers = this.layers, r.up.set(0, 0, -1), r.lookAt(new O(0, -1, 0)), this.add(r);
    const l = new gt(kn, Wn, e, t);
    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new O(0, 0, 1)), this.add(l);
    const a = new gt(kn, Wn, e, t);
    a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new O(0, 0, -1)), this.add(a);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget, [i, s, o, r, l, a] = this.children, c = e.getRenderTarget(), d = e.toneMapping, u = e.xr.enabled;
    e.toneMapping = 0, e.xr.enabled = !1;
    const m = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, o), e.setRenderTarget(n, 3), e.render(t, r), e.setRenderTarget(n, 4), e.render(t, l), n.texture.generateMipmaps = m, e.setRenderTarget(n, 5), e.render(t, a), e.setRenderTarget(c), e.toneMapping = d, e.xr.enabled = u, n.texture.needsPMREMUpdate = !0;
  }
}
class uo extends _t {
  constructor(e, t, n, i, s, o, r, l, a, c) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : 301, super(e, t, n, i, s, o, r, l, a, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class na extends En {
  constructor(e, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    this.texture = new uo(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : 1006;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    }, i = new pi(5, 5, 5), s = new Tn({
      name: "CubemapFromEquirect",
      uniforms: Zn(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: 1,
      blending: 0
    });
    s.uniforms.tEquirect.value = t;
    const o = new Nt(i, s), r = t.minFilter;
    return t.minFilter === 1008 && (t.minFilter = 1006), new ta(1, 10, this).update(e, o), t.minFilter = r, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, n, i) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, n, i);
    e.setRenderTarget(s);
  }
}
const bs = /* @__PURE__ */ new O(), ia = /* @__PURE__ */ new O(), sa = /* @__PURE__ */ new Mt();
class gn {
  constructor(e = new O(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = bs.subVectors(n, t).cross(ia.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const n = e.delta(bs), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(n).multiplyScalar(s).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || sa.getNormalMatrix(e), i = this.coplanarPoint(bs).applyMatrix4(e), s = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Vn = /* @__PURE__ */ new ci(), Ii = /* @__PURE__ */ new O();
class Us {
  constructor(e = new gn(), t = new gn(), n = new gn(), i = new gn(), s = new gn(), o = new gn()) {
    this.planes = [e, t, n, i, s, o];
  }
  set(e, t, n, i, s, o) {
    const r = this.planes;
    return r[0].copy(e), r[1].copy(t), r[2].copy(n), r[3].copy(i), r[4].copy(s), r[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, n = e.elements, i = n[0], s = n[1], o = n[2], r = n[3], l = n[4], a = n[5], c = n[6], d = n[7], u = n[8], m = n[9], g = n[10], p = n[11], f = n[12], v = n[13], _ = n[14], w = n[15];
    return t[0].setComponents(r - i, d - l, p - u, w - f).normalize(), t[1].setComponents(r + i, d + l, p + u, w + f).normalize(), t[2].setComponents(r + s, d + a, p + m, w + v).normalize(), t[3].setComponents(r - s, d - a, p - m, w - v).normalize(), t[4].setComponents(r - o, d - c, p - g, w - _).normalize(), t[5].setComponents(r + o, d + c, p + g, w + _).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), Vn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Vn);
  }
  intersectsSprite(e) {
    return Vn.center.set(0, 0, 0), Vn.radius = 0.7071067811865476, Vn.applyMatrix4(e.matrixWorld), this.intersectsSphere(Vn);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (Ii.x = i.normal.x > 0 ? e.max.x : e.min.x, Ii.y = i.normal.y > 0 ? e.max.y : e.min.y, Ii.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Ii) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function fo() {
  let h = null, e = !1, t = null, n = null;
  function i(s, o) {
    t(s, o), n = h.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = h.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      h.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      h = s;
    }
  };
}
function ra(h, e) {
  const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function i(a, c) {
    const d = a.array, u = a.usage, m = h.createBuffer();
    h.bindBuffer(c, m), h.bufferData(c, d, u), a.onUploadCallback();
    let g;
    if (d instanceof Float32Array)
      g = 5126;
    else if (d instanceof Uint16Array)
      if (a.isFloat16BufferAttribute)
        if (t)
          g = 5131;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        g = 5123;
    else if (d instanceof Int16Array)
      g = 5122;
    else if (d instanceof Uint32Array)
      g = 5125;
    else if (d instanceof Int32Array)
      g = 5124;
    else if (d instanceof Int8Array)
      g = 5120;
    else if (d instanceof Uint8Array)
      g = 5121;
    else if (d instanceof Uint8ClampedArray)
      g = 5121;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
    return {
      buffer: m,
      type: g,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: a.version
    };
  }
  function s(a, c, d) {
    const u = c.array, m = c.updateRange;
    h.bindBuffer(d, a), m.count === -1 ? h.bufferSubData(d, 0, u) : (t ? h.bufferSubData(
      d,
      m.offset * u.BYTES_PER_ELEMENT,
      u,
      m.offset,
      m.count
    ) : h.bufferSubData(
      d,
      m.offset * u.BYTES_PER_ELEMENT,
      u.subarray(m.offset, m.offset + m.count)
    ), m.count = -1);
  }
  function o(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), n.get(a);
  }
  function r(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const c = n.get(a);
    c && (h.deleteBuffer(c.buffer), n.delete(a));
  }
  function l(a, c) {
    if (a.isGLBufferAttribute) {
      const u = n.get(a);
      (!u || u.version < a.version) && n.set(a, {
        buffer: a.buffer,
        type: a.type,
        bytesPerElement: a.elementSize,
        version: a.version
      });
      return;
    }
    a.isInterleavedBufferAttribute && (a = a.data);
    const d = n.get(a);
    d === void 0 ? n.set(a, i(a, c)) : d.version < a.version && (s(d.buffer, a, c), d.version = a.version);
  }
  return {
    get: o,
    remove: r,
    update: l
  };
}
class ji extends Ut {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const s = e / 2, o = t / 2, r = Math.floor(n), l = Math.floor(i), a = r + 1, c = l + 1, d = e / r, u = t / l, m = [], g = [], p = [], f = [];
    for (let v = 0; v < c; v++) {
      const _ = v * u - o;
      for (let w = 0; w < a; w++) {
        const x = w * d - s;
        g.push(x, -_, 0), p.push(0, 0, 1), f.push(w / r), f.push(1 - v / l);
      }
    }
    for (let v = 0; v < l; v++)
      for (let _ = 0; _ < r; _++) {
        const w = _ + a * v, x = _ + a * (v + 1), M = _ + 1 + a * (v + 1), E = _ + 1 + a * v;
        m.push(w, x, E), m.push(x, M, E);
      }
    this.setIndex(m), this.setAttribute("position", new st(g, 3)), this.setAttribute("normal", new st(p, 3)), this.setAttribute("uv", new st(f, 2));
  }
  static fromJSON(e) {
    return new ji(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var oa = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, aa = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, la = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, ca = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, ha = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, ua = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, da = "vec3 transformed = vec3( position );", fa = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, pa = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, ma = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, ga = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, _a = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, va = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, xa = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, ya = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, ba = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, wa = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Ma = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, Sa = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Ea = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, Ta = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Aa = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Ca = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, La = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, Ra = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Fa = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Da = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Pa = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Ia = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, za = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Ba = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Na = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Oa = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Ua = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Ga = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, ka = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Wa = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Va = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, Ha = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, qa = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Xa = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`, ja = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Ya = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, Za = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, $a = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, Ka = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Ja = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, Qa = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, el = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, tl = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, nl = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, il = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, sl = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, rl = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, ol = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, al = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, ll = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, cl = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, hl = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, ul = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, dl = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, fl = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, pl = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, ml = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, gl = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, _l = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, vl = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, xl = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, yl = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, bl = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, wl = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Ml = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, Sl = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, El = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, Tl = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, Al = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Cl = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Ll = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, Rl = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Fl = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Dl = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Pl = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Il = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, zl = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Bl = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, Nl = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Ol = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, Ul = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Gl = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, kl = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, Wl = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Vl = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Hl = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, ql = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Xl = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, jl = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Yl = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`, Zl = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, $l = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, Kl = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, Jl = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, Ql = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, ec = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, tc = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, nc = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const ic = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, sc = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, rc = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, oc = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, ac = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, lc = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, cc = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, hc = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, uc = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, dc = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, fc = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, pc = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, mc = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, gc = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _c = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, vc = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xc = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, yc = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, bc = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, wc = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Mc = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Sc = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ec = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Tc = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ac = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Cc = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Lc = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Rc = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Fc = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Dc = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Pc = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Ic = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Te = {
  alphamap_fragment: oa,
  alphamap_pars_fragment: aa,
  alphatest_fragment: la,
  alphatest_pars_fragment: ca,
  aomap_fragment: ha,
  aomap_pars_fragment: ua,
  begin_vertex: da,
  beginnormal_vertex: fa,
  bsdfs: pa,
  iridescence_fragment: ma,
  bumpmap_pars_fragment: ga,
  clipping_planes_fragment: _a,
  clipping_planes_pars_fragment: va,
  clipping_planes_pars_vertex: xa,
  clipping_planes_vertex: ya,
  color_fragment: ba,
  color_pars_fragment: wa,
  color_pars_vertex: Ma,
  color_vertex: Sa,
  common: Ea,
  cube_uv_reflection_fragment: Ta,
  defaultnormal_vertex: Aa,
  displacementmap_pars_vertex: Ca,
  displacementmap_vertex: La,
  emissivemap_fragment: Ra,
  emissivemap_pars_fragment: Fa,
  encodings_fragment: Da,
  encodings_pars_fragment: Pa,
  envmap_fragment: Ia,
  envmap_common_pars_fragment: za,
  envmap_pars_fragment: Ba,
  envmap_pars_vertex: Na,
  envmap_physical_pars_fragment: Ya,
  envmap_vertex: Oa,
  fog_vertex: Ua,
  fog_pars_vertex: Ga,
  fog_fragment: ka,
  fog_pars_fragment: Wa,
  gradientmap_pars_fragment: Va,
  lightmap_fragment: Ha,
  lightmap_pars_fragment: qa,
  lights_lambert_vertex: Xa,
  lights_pars_begin: ja,
  lights_toon_fragment: Za,
  lights_toon_pars_fragment: $a,
  lights_phong_fragment: Ka,
  lights_phong_pars_fragment: Ja,
  lights_physical_fragment: Qa,
  lights_physical_pars_fragment: el,
  lights_fragment_begin: tl,
  lights_fragment_maps: nl,
  lights_fragment_end: il,
  logdepthbuf_fragment: sl,
  logdepthbuf_pars_fragment: rl,
  logdepthbuf_pars_vertex: ol,
  logdepthbuf_vertex: al,
  map_fragment: ll,
  map_pars_fragment: cl,
  map_particle_fragment: hl,
  map_particle_pars_fragment: ul,
  metalnessmap_fragment: dl,
  metalnessmap_pars_fragment: fl,
  morphcolor_vertex: pl,
  morphnormal_vertex: ml,
  morphtarget_pars_vertex: gl,
  morphtarget_vertex: _l,
  normal_fragment_begin: vl,
  normal_fragment_maps: xl,
  normal_pars_fragment: yl,
  normal_pars_vertex: bl,
  normal_vertex: wl,
  normalmap_pars_fragment: Ml,
  clearcoat_normal_fragment_begin: Sl,
  clearcoat_normal_fragment_maps: El,
  clearcoat_pars_fragment: Tl,
  iridescence_pars_fragment: Al,
  output_fragment: Cl,
  packing: Ll,
  premultiplied_alpha_fragment: Rl,
  project_vertex: Fl,
  dithering_fragment: Dl,
  dithering_pars_fragment: Pl,
  roughnessmap_fragment: Il,
  roughnessmap_pars_fragment: zl,
  shadowmap_pars_fragment: Bl,
  shadowmap_pars_vertex: Nl,
  shadowmap_vertex: Ol,
  shadowmask_pars_fragment: Ul,
  skinbase_vertex: Gl,
  skinning_pars_vertex: kl,
  skinning_vertex: Wl,
  skinnormal_vertex: Vl,
  specularmap_fragment: Hl,
  specularmap_pars_fragment: ql,
  tonemapping_fragment: Xl,
  tonemapping_pars_fragment: jl,
  transmission_fragment: Yl,
  transmission_pars_fragment: Zl,
  uv_pars_fragment: $l,
  uv_pars_vertex: Kl,
  uv_vertex: Jl,
  uv2_pars_fragment: Ql,
  uv2_pars_vertex: ec,
  uv2_vertex: tc,
  worldpos_vertex: nc,
  background_vert: ic,
  background_frag: sc,
  cube_vert: rc,
  cube_frag: oc,
  depth_vert: ac,
  depth_frag: lc,
  distanceRGBA_vert: cc,
  distanceRGBA_frag: hc,
  equirect_vert: uc,
  equirect_frag: dc,
  linedashed_vert: fc,
  linedashed_frag: pc,
  meshbasic_vert: mc,
  meshbasic_frag: gc,
  meshlambert_vert: _c,
  meshlambert_frag: vc,
  meshmatcap_vert: xc,
  meshmatcap_frag: yc,
  meshnormal_vert: bc,
  meshnormal_frag: wc,
  meshphong_vert: Mc,
  meshphong_frag: Sc,
  meshphysical_vert: Ec,
  meshphysical_frag: Tc,
  meshtoon_vert: Ac,
  meshtoon_frag: Cc,
  points_vert: Lc,
  points_frag: Rc,
  shadow_vert: Fc,
  shadow_frag: Dc,
  sprite_vert: Pc,
  sprite_frag: Ic
}, ne = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Ae(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new Mt() },
    uv2Transform: { value: /* @__PURE__ */ new Mt() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new Ce(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Ae(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Ae(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Mt() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Ae(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ce(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Mt() }
  }
}, Bt = {
  basic: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.specularmap,
      ne.envmap,
      ne.aomap,
      ne.lightmap,
      ne.fog
    ]),
    vertexShader: Te.meshbasic_vert,
    fragmentShader: Te.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.specularmap,
      ne.envmap,
      ne.aomap,
      ne.lightmap,
      ne.emissivemap,
      ne.fog,
      ne.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ae(0) }
      }
    ]),
    vertexShader: Te.meshlambert_vert,
    fragmentShader: Te.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.specularmap,
      ne.envmap,
      ne.aomap,
      ne.lightmap,
      ne.emissivemap,
      ne.bumpmap,
      ne.normalmap,
      ne.displacementmap,
      ne.fog,
      ne.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ae(0) },
        specular: { value: /* @__PURE__ */ new Ae(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Te.meshphong_vert,
    fragmentShader: Te.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.envmap,
      ne.aomap,
      ne.lightmap,
      ne.emissivemap,
      ne.bumpmap,
      ne.normalmap,
      ne.displacementmap,
      ne.roughnessmap,
      ne.metalnessmap,
      ne.fog,
      ne.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ae(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Te.meshphysical_vert,
    fragmentShader: Te.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.aomap,
      ne.lightmap,
      ne.emissivemap,
      ne.bumpmap,
      ne.normalmap,
      ne.displacementmap,
      ne.gradientmap,
      ne.fog,
      ne.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ae(0) }
      }
    ]),
    vertexShader: Te.meshtoon_vert,
    fragmentShader: Te.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.bumpmap,
      ne.normalmap,
      ne.displacementmap,
      ne.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Te.meshmatcap_vert,
    fragmentShader: Te.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ it([
      ne.points,
      ne.fog
    ]),
    vertexShader: Te.points_vert,
    fragmentShader: Te.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Te.linedashed_vert,
    fragmentShader: Te.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.displacementmap
    ]),
    vertexShader: Te.depth_vert,
    fragmentShader: Te.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.bumpmap,
      ne.normalmap,
      ne.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Te.meshnormal_vert,
    fragmentShader: Te.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ it([
      ne.sprite,
      ne.fog
    ]),
    vertexShader: Te.sprite_vert,
    fragmentShader: Te.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Mt() },
      t2D: { value: null }
    },
    vertexShader: Te.background_vert,
    fragmentShader: Te.background_frag
  },
  cube: {
    uniforms: /* @__PURE__ */ it([
      ne.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Te.cube_vert,
    fragmentShader: Te.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Te.equirect_vert,
    fragmentShader: Te.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ it([
      ne.common,
      ne.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new O() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Te.distanceRGBA_vert,
    fragmentShader: Te.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ it([
      ne.lights,
      ne.fog,
      {
        color: { value: /* @__PURE__ */ new Ae(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Te.shadow_vert,
    fragmentShader: Te.shadow_frag
  }
};
Bt.physical = {
  uniforms: /* @__PURE__ */ it([
    Bt.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ce(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Ae(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ce() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Ae(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new Ae(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: Te.meshphysical_vert,
  fragmentShader: Te.meshphysical_frag
};
function zc(h, e, t, n, i, s) {
  const o = new Ae(0);
  let r = i === !0 ? 0 : 1, l, a, c = null, d = 0, u = null;
  function m(p, f) {
    let v = !1, _ = f.isScene === !0 ? f.background : null;
    _ && _.isTexture && (_ = e.get(_));
    const w = h.xr, x = w.getSession && w.getSession();
    x && x.environmentBlendMode === "additive" && (_ = null), _ === null ? g(o, r) : _ && _.isColor && (g(_, 1), v = !0), (h.autoClear || v) && h.clear(h.autoClearColor, h.autoClearDepth, h.autoClearStencil), _ && (_.isCubeTexture || _.mapping === 306) ? (a === void 0 && (a = new Nt(
      new pi(1, 1, 1),
      new Tn({
        name: "BackgroundCubeMaterial",
        uniforms: Zn(Bt.cube.uniforms),
        vertexShader: Bt.cube.vertexShader,
        fragmentShader: Bt.cube.fragmentShader,
        side: 1,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(M, E, R) {
      this.matrixWorld.copyPosition(R.matrixWorld);
    }, Object.defineProperty(a.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), n.update(a)), a.material.uniforms.envMap.value = _, a.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, (c !== _ || d !== _.version || u !== h.toneMapping) && (a.material.needsUpdate = !0, c = _, d = _.version, u = h.toneMapping), a.layers.enableAll(), p.unshift(a, a.geometry, a.material, 0, 0, null)) : _ && _.isTexture && (l === void 0 && (l = new Nt(
      new ji(2, 2),
      new Tn({
        name: "BackgroundMaterial",
        uniforms: Zn(Bt.background.uniforms),
        vertexShader: Bt.background.vertexShader,
        fragmentShader: Bt.background.fragmentShader,
        side: 0,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), n.update(l)), l.material.uniforms.t2D.value = _, _.matrixAutoUpdate === !0 && _.updateMatrix(), l.material.uniforms.uvTransform.value.copy(_.matrix), (c !== _ || d !== _.version || u !== h.toneMapping) && (l.material.needsUpdate = !0, c = _, d = _.version, u = h.toneMapping), l.layers.enableAll(), p.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function g(p, f) {
    t.buffers.color.setClear(p.r, p.g, p.b, f, s);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(p, f = 1) {
      o.set(p), r = f, g(o, r);
    },
    getClearAlpha: function() {
      return r;
    },
    setClearAlpha: function(p) {
      r = p, g(o, r);
    },
    render: m
  };
}
function Bc(h, e, t, n) {
  const i = h.getParameter(34921), s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = n.isWebGL2 || s !== null, r = {}, l = f(null);
  let a = l, c = !1;
  function d(L, I, D, q, k) {
    let N = !1;
    if (o) {
      const H = p(q, D, I);
      a !== H && (a = H, m(a.object)), N = v(L, q, D, k), N && _(L, q, D, k);
    } else {
      const H = I.wireframe === !0;
      (a.geometry !== q.id || a.program !== D.id || a.wireframe !== H) && (a.geometry = q.id, a.program = D.id, a.wireframe = H, N = !0);
    }
    k !== null && t.update(k, 34963), (N || c) && (c = !1, y(L, I, D, q), k !== null && h.bindBuffer(34963, t.get(k).buffer));
  }
  function u() {
    return n.isWebGL2 ? h.createVertexArray() : s.createVertexArrayOES();
  }
  function m(L) {
    return n.isWebGL2 ? h.bindVertexArray(L) : s.bindVertexArrayOES(L);
  }
  function g(L) {
    return n.isWebGL2 ? h.deleteVertexArray(L) : s.deleteVertexArrayOES(L);
  }
  function p(L, I, D) {
    const q = D.wireframe === !0;
    let k = r[L.id];
    k === void 0 && (k = {}, r[L.id] = k);
    let N = k[I.id];
    N === void 0 && (N = {}, k[I.id] = N);
    let H = N[q];
    return H === void 0 && (H = f(u()), N[q] = H), H;
  }
  function f(L) {
    const I = [], D = [], q = [];
    for (let k = 0; k < i; k++)
      I[k] = 0, D[k] = 0, q[k] = 0;
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: I,
      enabledAttributes: D,
      attributeDivisors: q,
      object: L,
      attributes: {},
      index: null
    };
  }
  function v(L, I, D, q) {
    const k = a.attributes, N = I.attributes;
    let H = 0;
    const J = D.getAttributes();
    for (const V in J)
      if (J[V].location >= 0) {
        const ce = k[V];
        let ge = N[V];
        if (ge === void 0 && (V === "instanceMatrix" && L.instanceMatrix && (ge = L.instanceMatrix), V === "instanceColor" && L.instanceColor && (ge = L.instanceColor)), ce === void 0 || ce.attribute !== ge || ge && ce.data !== ge.data)
          return !0;
        H++;
      }
    return a.attributesNum !== H || a.index !== q;
  }
  function _(L, I, D, q) {
    const k = {}, N = I.attributes;
    let H = 0;
    const J = D.getAttributes();
    for (const V in J)
      if (J[V].location >= 0) {
        let ce = N[V];
        ce === void 0 && (V === "instanceMatrix" && L.instanceMatrix && (ce = L.instanceMatrix), V === "instanceColor" && L.instanceColor && (ce = L.instanceColor));
        const ge = {};
        ge.attribute = ce, ce && ce.data && (ge.data = ce.data), k[V] = ge, H++;
      }
    a.attributes = k, a.attributesNum = H, a.index = q;
  }
  function w() {
    const L = a.newAttributes;
    for (let I = 0, D = L.length; I < D; I++)
      L[I] = 0;
  }
  function x(L) {
    M(L, 0);
  }
  function M(L, I) {
    const D = a.newAttributes, q = a.enabledAttributes, k = a.attributeDivisors;
    D[L] = 1, q[L] === 0 && (h.enableVertexAttribArray(L), q[L] = 1), k[L] !== I && ((n.isWebGL2 ? h : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](L, I), k[L] = I);
  }
  function E() {
    const L = a.newAttributes, I = a.enabledAttributes;
    for (let D = 0, q = I.length; D < q; D++)
      I[D] !== L[D] && (h.disableVertexAttribArray(D), I[D] = 0);
  }
  function R(L, I, D, q, k, N) {
    n.isWebGL2 === !0 && (D === 5124 || D === 5125) ? h.vertexAttribIPointer(L, I, D, k, N) : h.vertexAttribPointer(L, I, D, q, k, N);
  }
  function y(L, I, D, q) {
    if (n.isWebGL2 === !1 && (L.isInstancedMesh || q.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    w();
    const k = q.attributes, N = D.getAttributes(), H = I.defaultAttributeValues;
    for (const J in N) {
      const V = N[J];
      if (V.location >= 0) {
        let ee = k[J];
        if (ee === void 0 && (J === "instanceMatrix" && L.instanceMatrix && (ee = L.instanceMatrix), J === "instanceColor" && L.instanceColor && (ee = L.instanceColor)), ee !== void 0) {
          const ce = ee.normalized, ge = ee.itemSize, $ = t.get(ee);
          if ($ === void 0)
            continue;
          const De = $.buffer, ve = $.type, xe = $.bytesPerElement;
          if (ee.isInterleavedBufferAttribute) {
            const ue = ee.data, Oe = ue.stride, Ee = ee.offset;
            if (ue.isInstancedInterleavedBuffer) {
              for (let me = 0; me < V.locationSize; me++)
                M(V.location + me, ue.meshPerAttribute);
              L.isInstancedMesh !== !0 && q._maxInstanceCount === void 0 && (q._maxInstanceCount = ue.meshPerAttribute * ue.count);
            } else
              for (let me = 0; me < V.locationSize; me++)
                x(V.location + me);
            h.bindBuffer(34962, De);
            for (let me = 0; me < V.locationSize; me++)
              R(
                V.location + me,
                ge / V.locationSize,
                ve,
                ce,
                Oe * xe,
                (Ee + ge / V.locationSize * me) * xe
              );
          } else {
            if (ee.isInstancedBufferAttribute) {
              for (let ue = 0; ue < V.locationSize; ue++)
                M(V.location + ue, ee.meshPerAttribute);
              L.isInstancedMesh !== !0 && q._maxInstanceCount === void 0 && (q._maxInstanceCount = ee.meshPerAttribute * ee.count);
            } else
              for (let ue = 0; ue < V.locationSize; ue++)
                x(V.location + ue);
            h.bindBuffer(34962, De);
            for (let ue = 0; ue < V.locationSize; ue++)
              R(
                V.location + ue,
                ge / V.locationSize,
                ve,
                ce,
                ge * xe,
                ge / V.locationSize * ue * xe
              );
          }
        } else if (H !== void 0) {
          const ce = H[J];
          if (ce !== void 0)
            switch (ce.length) {
              case 2:
                h.vertexAttrib2fv(V.location, ce);
                break;
              case 3:
                h.vertexAttrib3fv(V.location, ce);
                break;
              case 4:
                h.vertexAttrib4fv(V.location, ce);
                break;
              default:
                h.vertexAttrib1fv(V.location, ce);
            }
        }
      }
    }
    E();
  }
  function A() {
    G();
    for (const L in r) {
      const I = r[L];
      for (const D in I) {
        const q = I[D];
        for (const k in q)
          g(q[k].object), delete q[k];
        delete I[D];
      }
      delete r[L];
    }
  }
  function F(L) {
    if (r[L.id] === void 0)
      return;
    const I = r[L.id];
    for (const D in I) {
      const q = I[D];
      for (const k in q)
        g(q[k].object), delete q[k];
      delete I[D];
    }
    delete r[L.id];
  }
  function P(L) {
    for (const I in r) {
      const D = r[I];
      if (D[L.id] === void 0)
        continue;
      const q = D[L.id];
      for (const k in q)
        g(q[k].object), delete q[k];
      delete D[L.id];
    }
  }
  function G() {
    z(), c = !0, a !== l && (a = l, m(a.object));
  }
  function z() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: d,
    reset: G,
    resetDefaultState: z,
    dispose: A,
    releaseStatesOfGeometry: F,
    releaseStatesOfProgram: P,
    initAttributes: w,
    enableAttribute: x,
    disableUnusedAttributes: E
  };
}
function Nc(h, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function o(a) {
    s = a;
  }
  function r(a, c) {
    h.drawArrays(s, a, c), t.update(c, s, 1);
  }
  function l(a, c, d) {
    if (d === 0)
      return;
    let u, m;
    if (i)
      u = h, m = "drawArraysInstanced";
    else if (u = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", u === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    u[m](s, a, c, d), t.update(c, s, d);
  }
  this.setMode = o, this.render = r, this.renderInstances = l;
}
function Oc(h, e, t) {
  let n;
  function i() {
    if (n !== void 0)
      return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const R = e.get("EXT_texture_filter_anisotropic");
      n = h.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function s(R) {
    if (R === "highp") {
      if (h.getShaderPrecisionFormat(35633, 36338).precision > 0 && h.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      R = "mediump";
    }
    return R === "mediump" && h.getShaderPrecisionFormat(35633, 36337).precision > 0 && h.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && h instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && h instanceof WebGL2ComputeRenderingContext;
  let r = t.precision !== void 0 ? t.precision : "highp";
  const l = s(r);
  l !== r && (console.warn("THREE.WebGLRenderer:", r, "not supported, using", l, "instead."), r = l);
  const a = o || e.has("WEBGL_draw_buffers"), c = t.logarithmicDepthBuffer === !0, d = h.getParameter(34930), u = h.getParameter(35660), m = h.getParameter(3379), g = h.getParameter(34076), p = h.getParameter(34921), f = h.getParameter(36347), v = h.getParameter(36348), _ = h.getParameter(36349), w = u > 0, x = o || e.has("OES_texture_float"), M = w && x, E = o ? h.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    drawBuffers: a,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: r,
    logarithmicDepthBuffer: c,
    maxTextures: d,
    maxVertexTextures: u,
    maxTextureSize: m,
    maxCubemapSize: g,
    maxAttributes: p,
    maxVertexUniforms: f,
    maxVaryings: v,
    maxFragmentUniforms: _,
    vertexTextures: w,
    floatFragmentTextures: x,
    floatVertexTextures: M,
    maxSamples: E
  };
}
function Uc(h) {
  const e = this;
  let t = null, n = 0, i = !1, s = !1;
  const o = new gn(), r = new Mt(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, u, m) {
    const g = d.length !== 0 || u || n !== 0 || i;
    return i = u, t = c(d, m, 0), n = d.length, g;
  }, this.beginShadows = function() {
    s = !0, c(null);
  }, this.endShadows = function() {
    s = !1, a();
  }, this.setState = function(d, u, m) {
    const g = d.clippingPlanes, p = d.clipIntersection, f = d.clipShadows, v = h.get(d);
    if (!i || g === null || g.length === 0 || s && !f)
      s ? c(null) : a();
    else {
      const _ = s ? 0 : n, w = _ * 4;
      let x = v.clippingState || null;
      l.value = x, x = c(g, u, w, m);
      for (let M = 0; M !== w; ++M)
        x[M] = t[M];
      v.clippingState = x, this.numIntersection = p ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
  function a() {
    l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function c(d, u, m, g) {
    const p = d !== null ? d.length : 0;
    let f = null;
    if (p !== 0) {
      if (f = l.value, g !== !0 || f === null) {
        const v = m + p * 4, _ = u.matrixWorldInverse;
        r.getNormalMatrix(_), (f === null || f.length < v) && (f = new Float32Array(v));
        for (let w = 0, x = m; w !== p; ++w, x += 4)
          o.copy(d[w]).applyMatrix4(_, r), o.normal.toArray(f, x), f[x + 3] = o.constant;
      }
      l.value = f, l.needsUpdate = !0;
    }
    return e.numPlanes = p, e.numIntersection = 0, f;
  }
}
function Gc(h) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, r) {
    return r === 303 ? o.mapping = 301 : r === 304 && (o.mapping = 302), o;
  }
  function n(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const r = o.mapping;
      if (r === 303 || r === 304)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const a = new na(l.height / 2);
            return a.fromEquirectangularTexture(h, o), e.set(o, a), o.addEventListener("dispose", i), t(a.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function i(o) {
    const r = o.target;
    r.removeEventListener("dispose", i);
    const l = e.get(r);
    l !== void 0 && (e.delete(r), l.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: s
  };
}
class kc extends ho {
  constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = s, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, i, s, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let s = n - e, o = n + e, r = i + t, l = i - t;
    if (this.view !== null && this.view.enabled) {
      const a = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += a * this.view.offsetX, o = s + a * this.view.width, r -= c * this.view.offsetY, l = r - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, r, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const jn = 4, lr = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], vn = 20, ws = /* @__PURE__ */ new kc(), cr = /* @__PURE__ */ new Ae();
let Ms = null;
const _n = (1 + Math.sqrt(5)) / 2, Hn = 1 / _n, hr = [
  /* @__PURE__ */ new O(1, 1, 1),
  /* @__PURE__ */ new O(-1, 1, 1),
  /* @__PURE__ */ new O(1, 1, -1),
  /* @__PURE__ */ new O(-1, 1, -1),
  /* @__PURE__ */ new O(0, _n, Hn),
  /* @__PURE__ */ new O(0, _n, -Hn),
  /* @__PURE__ */ new O(Hn, 0, _n),
  /* @__PURE__ */ new O(-Hn, 0, _n),
  /* @__PURE__ */ new O(_n, Hn, 0),
  /* @__PURE__ */ new O(-_n, Hn, 0)
];
class ur {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    Ms = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, n, i, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = pr(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = fr(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Ms), e.scissorTest = !1, zi(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === 301 || e.mapping === 302 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Ms = this._renderer.getRenderTarget();
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: 1006,
      minFilter: 1006,
      generateMipmaps: !1,
      type: 1016,
      format: 1023,
      encoding: 3e3,
      depthBuffer: !1
    }, i = dr(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = dr(e, t, n);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Wc(s)), this._blurMaterial = Vc(s, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Nt(this._lodPlanes[0], e);
    this._renderer.compile(t, ws);
  }
  _sceneToCubeUV(e, t, n, i) {
    const r = new gt(90, 1, t, n), l = [1, -1, 1, 1, 1, 1], a = [1, 1, 1, -1, -1, -1], c = this._renderer, d = c.autoClear, u = c.toneMapping;
    c.getClearColor(cr), c.toneMapping = 0, c.autoClear = !1;
    const m = new ao({
      name: "PMREM.Background",
      side: 1,
      depthWrite: !1,
      depthTest: !1
    }), g = new Nt(new pi(), m);
    let p = !1;
    const f = e.background;
    f ? f.isColor && (m.color.copy(f), e.background = null, p = !0) : (m.color.copy(cr), p = !0);
    for (let v = 0; v < 6; v++) {
      const _ = v % 3;
      _ === 0 ? (r.up.set(0, l[v], 0), r.lookAt(a[v], 0, 0)) : _ === 1 ? (r.up.set(0, 0, l[v]), r.lookAt(0, a[v], 0)) : (r.up.set(0, l[v], 0), r.lookAt(0, 0, a[v]));
      const w = this._cubeSize;
      zi(i, _ * w, v > 2 ? w : 0, w, w), c.setRenderTarget(i), p && c.render(g, r), c.render(e, r);
    }
    g.geometry.dispose(), g.material.dispose(), c.toneMapping = u, c.autoClear = d, e.background = f;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === 301 || e.mapping === 302;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = pr()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = fr());
    const s = i ? this._cubemapMaterial : this._equirectMaterial, o = new Nt(this._lodPlanes[0], s), r = s.uniforms;
    r.envMap.value = e;
    const l = this._cubeSize;
    zi(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, ws);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), o = hr[(i - 1) % hr.length];
      this._blur(e, i - 1, i, s, o);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      n,
      i,
      "latitudinal",
      s
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      i,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, n, i, s, o, r) {
    const l = this._renderer, a = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, d = new Nt(this._lodPlanes[i], a), u = a.uniforms, m = this._sizeLods[n] - 1, g = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * vn - 1), p = s / g, f = isFinite(s) ? 1 + Math.floor(c * p) : vn;
    f > vn && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${vn}`);
    const v = [];
    let _ = 0;
    for (let R = 0; R < vn; ++R) {
      const y = R / p, A = Math.exp(-y * y / 2);
      v.push(A), R === 0 ? _ += A : R < f && (_ += 2 * A);
    }
    for (let R = 0; R < v.length; R++)
      v[R] = v[R] / _;
    u.envMap.value = e.texture, u.samples.value = f, u.weights.value = v, u.latitudinal.value = o === "latitudinal", r && (u.poleAxis.value = r);
    const { _lodMax: w } = this;
    u.dTheta.value = g, u.mipInt.value = w - n;
    const x = this._sizeLods[i], M = 3 * x * (i > w - jn ? i - w + jn : 0), E = 4 * (this._cubeSize - x);
    zi(t, M, E, 3 * x, 2 * x), l.setRenderTarget(t), l.render(d, ws);
  }
}
function Wc(h) {
  const e = [], t = [], n = [];
  let i = h;
  const s = h - jn + 1 + lr.length;
  for (let o = 0; o < s; o++) {
    const r = Math.pow(2, i);
    t.push(r);
    let l = 1 / r;
    o > h - jn ? l = lr[o - h + jn - 1] : o === 0 && (l = 0), n.push(l);
    const a = 1 / (r - 2), c = -a, d = 1 + a, u = [c, c, d, c, d, d, c, c, d, d, c, d], m = 6, g = 6, p = 3, f = 2, v = 1, _ = new Float32Array(p * g * m), w = new Float32Array(f * g * m), x = new Float32Array(v * g * m);
    for (let E = 0; E < m; E++) {
      const R = E % 3 * 2 / 3 - 1, y = E > 2 ? 0 : -1, A = [
        R,
        y,
        0,
        R + 2 / 3,
        y,
        0,
        R + 2 / 3,
        y + 1,
        0,
        R,
        y,
        0,
        R + 2 / 3,
        y + 1,
        0,
        R,
        y + 1,
        0
      ];
      _.set(A, p * g * E), w.set(u, f * g * E);
      const F = [E, E, E, E, E, E];
      x.set(F, v * g * E);
    }
    const M = new Ut();
    M.setAttribute("position", new Ot(_, p)), M.setAttribute("uv", new Ot(w, f)), M.setAttribute("faceIndex", new Ot(x, v)), e.push(M), i > jn && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function dr(h, e, t) {
  const n = new En(h, e, t);
  return n.texture.mapping = 306, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function zi(h, e, t, n, i) {
  h.viewport.set(e, t, n, i), h.scissor.set(e, t, n, i);
}
function Vc(h, e, t) {
  const n = new Float32Array(vn), i = new O(0, 1, 0);
  return new Tn({
    name: "SphericalGaussianBlur",
    defines: {
      n: vn,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${h}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: Gs(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function fr() {
  return new Tn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Gs(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function pr() {
  return new Tn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Gs(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function Gs() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Hc(h) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(r) {
    if (r && r.isTexture) {
      const l = r.mapping, a = l === 303 || l === 304, c = l === 301 || l === 302;
      if (a || c)
        if (r.isRenderTargetTexture && r.needsPMREMUpdate === !0) {
          r.needsPMREMUpdate = !1;
          let d = e.get(r);
          return t === null && (t = new ur(h)), d = a ? t.fromEquirectangular(r, d) : t.fromCubemap(r, d), e.set(r, d), d.texture;
        } else {
          if (e.has(r))
            return e.get(r).texture;
          {
            const d = r.image;
            if (a && d && d.height > 0 || c && d && i(d)) {
              t === null && (t = new ur(h));
              const u = a ? t.fromEquirectangular(r) : t.fromCubemap(r);
              return e.set(r, u), r.addEventListener("dispose", s), u.texture;
            } else
              return null;
          }
        }
    }
    return r;
  }
  function i(r) {
    let l = 0;
    const a = 6;
    for (let c = 0; c < a; c++)
      r[c] !== void 0 && l++;
    return l === a;
  }
  function s(r) {
    const l = r.target;
    l.removeEventListener("dispose", s);
    const a = e.get(l);
    a !== void 0 && (e.delete(l), a.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function qc(h) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = h.getExtension("WEBGL_depth_texture") || h.getExtension("MOZ_WEBGL_depth_texture") || h.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = h.getExtension("EXT_texture_filter_anisotropic") || h.getExtension("MOZ_EXT_texture_filter_anisotropic") || h.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = h.getExtension("WEBGL_compressed_texture_s3tc") || h.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || h.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = h.getExtension("WEBGL_compressed_texture_pvrtc") || h.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = h.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function(n) {
      n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(n) {
      const i = t(n);
      return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function Xc(h, e, t, n) {
  const i = {}, s = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const u = d.target;
    u.index !== null && e.remove(u.index);
    for (const g in u.attributes)
      e.remove(u.attributes[g]);
    u.removeEventListener("dispose", o), delete i[u.id];
    const m = s.get(u);
    m && (e.remove(m), s.delete(u)), n.releaseStatesOfGeometry(u), u.isInstancedBufferGeometry === !0 && delete u._maxInstanceCount, t.memory.geometries--;
  }
  function r(d, u) {
    return i[u.id] === !0 || (u.addEventListener("dispose", o), i[u.id] = !0, t.memory.geometries++), u;
  }
  function l(d) {
    const u = d.attributes;
    for (const g in u)
      e.update(u[g], 34962);
    const m = d.morphAttributes;
    for (const g in m) {
      const p = m[g];
      for (let f = 0, v = p.length; f < v; f++)
        e.update(p[f], 34962);
    }
  }
  function a(d) {
    const u = [], m = d.index, g = d.attributes.position;
    let p = 0;
    if (m !== null) {
      const _ = m.array;
      p = m.version;
      for (let w = 0, x = _.length; w < x; w += 3) {
        const M = _[w + 0], E = _[w + 1], R = _[w + 2];
        u.push(M, E, E, R, R, M);
      }
    } else {
      const _ = g.array;
      p = g.version;
      for (let w = 0, x = _.length / 3 - 1; w < x; w += 3) {
        const M = w + 0, E = w + 1, R = w + 2;
        u.push(M, E, E, R, R, M);
      }
    }
    const f = new (to(u) ? co : lo)(u, 1);
    f.version = p;
    const v = s.get(d);
    v && e.remove(v), s.set(d, f);
  }
  function c(d) {
    const u = s.get(d);
    if (u) {
      const m = d.index;
      m !== null && u.version < m.version && a(d);
    } else
      a(d);
    return s.get(d);
  }
  return {
    get: r,
    update: l,
    getWireframeAttribute: c
  };
}
function jc(h, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function o(u) {
    s = u;
  }
  let r, l;
  function a(u) {
    r = u.type, l = u.bytesPerElement;
  }
  function c(u, m) {
    h.drawElements(s, m, r, u * l), t.update(m, s, 1);
  }
  function d(u, m, g) {
    if (g === 0)
      return;
    let p, f;
    if (i)
      p = h, f = "drawElementsInstanced";
    else if (p = e.get("ANGLE_instanced_arrays"), f = "drawElementsInstancedANGLE", p === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    p[f](s, m, r, u * l, g), t.update(m, s, g);
  }
  this.setMode = o, this.setIndex = a, this.render = c, this.renderInstances = d;
}
function Yc(h) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(s, o, r) {
    switch (t.calls++, o) {
      case 4:
        t.triangles += r * (s / 3);
        break;
      case 1:
        t.lines += r * (s / 2);
        break;
      case 3:
        t.lines += r * (s - 1);
        break;
      case 2:
        t.lines += r * s;
        break;
      case 0:
        t.points += r * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function Zc(h, e) {
  return h[0] - e[0];
}
function $c(h, e) {
  return Math.abs(e[1]) - Math.abs(h[1]);
}
function Ss(h, e) {
  let t = 1;
  const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
  n instanceof Int8Array ? t = 127 : n instanceof Uint8Array ? t = 255 : n instanceof Uint16Array ? t = 65535 : n instanceof Int16Array ? t = 32767 : n instanceof Int32Array ? t = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n), h.divideScalar(t);
}
function Kc(h, e, t) {
  const n = {}, i = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), o = new $e(), r = [];
  for (let a = 0; a < 8; a++)
    r[a] = [a, 0];
  function l(a, c, d, u) {
    const m = a.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const g = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, p = g !== void 0 ? g.length : 0;
      let f = s.get(c);
      if (f === void 0 || f.count !== p) {
        let I = function() {
          z.dispose(), s.delete(c), c.removeEventListener("dispose", I);
        };
        f !== void 0 && f.texture.dispose();
        const w = c.morphAttributes.position !== void 0, x = c.morphAttributes.normal !== void 0, M = c.morphAttributes.color !== void 0, E = c.morphAttributes.position || [], R = c.morphAttributes.normal || [], y = c.morphAttributes.color || [];
        let A = 0;
        w === !0 && (A = 1), x === !0 && (A = 2), M === !0 && (A = 3);
        let F = c.attributes.position.count * A, P = 1;
        F > e.maxTextureSize && (P = Math.ceil(F / e.maxTextureSize), F = e.maxTextureSize);
        const G = new Float32Array(F * P * 4 * p), z = new ro(G, F, P, p);
        z.type = 1015, z.needsUpdate = !0;
        const L = A * 4;
        for (let D = 0; D < p; D++) {
          const q = E[D], k = R[D], N = y[D], H = F * P * 4 * D;
          for (let J = 0; J < q.count; J++) {
            const V = J * L;
            w === !0 && (o.fromBufferAttribute(q, J), q.normalized === !0 && Ss(o, q), G[H + V + 0] = o.x, G[H + V + 1] = o.y, G[H + V + 2] = o.z, G[H + V + 3] = 0), x === !0 && (o.fromBufferAttribute(k, J), k.normalized === !0 && Ss(o, k), G[H + V + 4] = o.x, G[H + V + 5] = o.y, G[H + V + 6] = o.z, G[H + V + 7] = 0), M === !0 && (o.fromBufferAttribute(N, J), N.normalized === !0 && Ss(o, N), G[H + V + 8] = o.x, G[H + V + 9] = o.y, G[H + V + 10] = o.z, G[H + V + 11] = N.itemSize === 4 ? o.w : 1);
          }
        }
        f = {
          count: p,
          texture: z,
          size: new Ce(F, P)
        }, s.set(c, f), c.addEventListener("dispose", I);
      }
      let v = 0;
      for (let w = 0; w < m.length; w++)
        v += m[w];
      const _ = c.morphTargetsRelative ? 1 : 1 - v;
      u.getUniforms().setValue(h, "morphTargetBaseInfluence", _), u.getUniforms().setValue(h, "morphTargetInfluences", m), u.getUniforms().setValue(h, "morphTargetsTexture", f.texture, t), u.getUniforms().setValue(h, "morphTargetsTextureSize", f.size);
    } else {
      const g = m === void 0 ? 0 : m.length;
      let p = n[c.id];
      if (p === void 0 || p.length !== g) {
        p = [];
        for (let x = 0; x < g; x++)
          p[x] = [x, 0];
        n[c.id] = p;
      }
      for (let x = 0; x < g; x++) {
        const M = p[x];
        M[0] = x, M[1] = m[x];
      }
      p.sort($c);
      for (let x = 0; x < 8; x++)
        x < g && p[x][1] ? (r[x][0] = p[x][0], r[x][1] = p[x][1]) : (r[x][0] = Number.MAX_SAFE_INTEGER, r[x][1] = 0);
      r.sort(Zc);
      const f = c.morphAttributes.position, v = c.morphAttributes.normal;
      let _ = 0;
      for (let x = 0; x < 8; x++) {
        const M = r[x], E = M[0], R = M[1];
        E !== Number.MAX_SAFE_INTEGER && R ? (f && c.getAttribute("morphTarget" + x) !== f[E] && c.setAttribute("morphTarget" + x, f[E]), v && c.getAttribute("morphNormal" + x) !== v[E] && c.setAttribute("morphNormal" + x, v[E]), i[x] = R, _ += R) : (f && c.hasAttribute("morphTarget" + x) === !0 && c.deleteAttribute("morphTarget" + x), v && c.hasAttribute("morphNormal" + x) === !0 && c.deleteAttribute("morphNormal" + x), i[x] = 0);
      }
      const w = c.morphTargetsRelative ? 1 : 1 - _;
      u.getUniforms().setValue(h, "morphTargetBaseInfluence", w), u.getUniforms().setValue(h, "morphTargetInfluences", i);
    }
  }
  return {
    update: l
  };
}
function Jc(h, e, t, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function s(l) {
    const a = n.render.frame, c = l.geometry, d = e.get(l, c);
    return i.get(d) !== a && (e.update(d), i.set(d, a)), l.isInstancedMesh && (l.hasEventListener("dispose", r) === !1 && l.addEventListener("dispose", r), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), d;
  }
  function o() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function r(l) {
    const a = l.target;
    a.removeEventListener("dispose", r), t.remove(a.instanceMatrix), a.instanceColor !== null && t.remove(a.instanceColor);
  }
  return {
    update: s,
    dispose: o
  };
}
const po = /* @__PURE__ */ new _t(), mo = /* @__PURE__ */ new ro(), go = /* @__PURE__ */ new Uo(), _o = /* @__PURE__ */ new uo(), mr = [], gr = [], _r = new Float32Array(16), vr = new Float32Array(9), xr = new Float32Array(4);
function Kn(h, e, t) {
  const n = h[0];
  if (n <= 0 || n > 0)
    return h;
  const i = e * t;
  let s = mr[i];
  if (s === void 0 && (s = new Float32Array(i), mr[i] = s), e !== 0) {
    n.toArray(s, 0);
    for (let o = 1, r = 0; o !== e; ++o)
      r += t, h[o].toArray(s, r);
  }
  return s;
}
function lt(h, e) {
  if (h.length !== e.length)
    return !1;
  for (let t = 0, n = h.length; t < n; t++)
    if (h[t] !== e[t])
      return !1;
  return !0;
}
function ct(h, e) {
  for (let t = 0, n = e.length; t < n; t++)
    h[t] = e[t];
}
function Yi(h, e) {
  let t = gr[e];
  t === void 0 && (t = new Int32Array(e), gr[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = h.allocateTextureUnit();
  return t;
}
function Qc(h, e) {
  const t = this.cache;
  t[0] !== e && (h.uniform1f(this.addr, e), t[0] = e);
}
function eh(h, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (h.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (lt(t, e))
      return;
    h.uniform2fv(this.addr, e), ct(t, e);
  }
}
function th(h, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (h.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (h.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (lt(t, e))
      return;
    h.uniform3fv(this.addr, e), ct(t, e);
  }
}
function nh(h, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (h.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (lt(t, e))
      return;
    h.uniform4fv(this.addr, e), ct(t, e);
  }
}
function ih(h, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (lt(t, e))
      return;
    h.uniformMatrix2fv(this.addr, !1, e), ct(t, e);
  } else {
    if (lt(t, n))
      return;
    xr.set(n), h.uniformMatrix2fv(this.addr, !1, xr), ct(t, n);
  }
}
function sh(h, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (lt(t, e))
      return;
    h.uniformMatrix3fv(this.addr, !1, e), ct(t, e);
  } else {
    if (lt(t, n))
      return;
    vr.set(n), h.uniformMatrix3fv(this.addr, !1, vr), ct(t, n);
  }
}
function rh(h, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (lt(t, e))
      return;
    h.uniformMatrix4fv(this.addr, !1, e), ct(t, e);
  } else {
    if (lt(t, n))
      return;
    _r.set(n), h.uniformMatrix4fv(this.addr, !1, _r), ct(t, n);
  }
}
function oh(h, e) {
  const t = this.cache;
  t[0] !== e && (h.uniform1i(this.addr, e), t[0] = e);
}
function ah(h, e) {
  const t = this.cache;
  lt(t, e) || (h.uniform2iv(this.addr, e), ct(t, e));
}
function lh(h, e) {
  const t = this.cache;
  lt(t, e) || (h.uniform3iv(this.addr, e), ct(t, e));
}
function ch(h, e) {
  const t = this.cache;
  lt(t, e) || (h.uniform4iv(this.addr, e), ct(t, e));
}
function hh(h, e) {
  const t = this.cache;
  t[0] !== e && (h.uniform1ui(this.addr, e), t[0] = e);
}
function uh(h, e) {
  const t = this.cache;
  lt(t, e) || (h.uniform2uiv(this.addr, e), ct(t, e));
}
function dh(h, e) {
  const t = this.cache;
  lt(t, e) || (h.uniform3uiv(this.addr, e), ct(t, e));
}
function fh(h, e) {
  const t = this.cache;
  lt(t, e) || (h.uniform4uiv(this.addr, e), ct(t, e));
}
function ph(h, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (h.uniform1i(this.addr, i), n[0] = i), t.setTexture2D(e || po, i);
}
function mh(h, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (h.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || go, i);
}
function gh(h, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (h.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || _o, i);
}
function _h(h, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (h.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || mo, i);
}
function vh(h) {
  switch (h) {
    case 5126:
      return Qc;
    case 35664:
      return eh;
    case 35665:
      return th;
    case 35666:
      return nh;
    case 35674:
      return ih;
    case 35675:
      return sh;
    case 35676:
      return rh;
    case 5124:
    case 35670:
      return oh;
    case 35667:
    case 35671:
      return ah;
    case 35668:
    case 35672:
      return lh;
    case 35669:
    case 35673:
      return ch;
    case 5125:
      return hh;
    case 36294:
      return uh;
    case 36295:
      return dh;
    case 36296:
      return fh;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return ph;
    case 35679:
    case 36299:
    case 36307:
      return mh;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return gh;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return _h;
  }
}
function xh(h, e) {
  h.uniform1fv(this.addr, e);
}
function yh(h, e) {
  const t = Kn(e, this.size, 2);
  h.uniform2fv(this.addr, t);
}
function bh(h, e) {
  const t = Kn(e, this.size, 3);
  h.uniform3fv(this.addr, t);
}
function wh(h, e) {
  const t = Kn(e, this.size, 4);
  h.uniform4fv(this.addr, t);
}
function Mh(h, e) {
  const t = Kn(e, this.size, 4);
  h.uniformMatrix2fv(this.addr, !1, t);
}
function Sh(h, e) {
  const t = Kn(e, this.size, 9);
  h.uniformMatrix3fv(this.addr, !1, t);
}
function Eh(h, e) {
  const t = Kn(e, this.size, 16);
  h.uniformMatrix4fv(this.addr, !1, t);
}
function Th(h, e) {
  h.uniform1iv(this.addr, e);
}
function Ah(h, e) {
  h.uniform2iv(this.addr, e);
}
function Ch(h, e) {
  h.uniform3iv(this.addr, e);
}
function Lh(h, e) {
  h.uniform4iv(this.addr, e);
}
function Rh(h, e) {
  h.uniform1uiv(this.addr, e);
}
function Fh(h, e) {
  h.uniform2uiv(this.addr, e);
}
function Dh(h, e) {
  h.uniform3uiv(this.addr, e);
}
function Ph(h, e) {
  h.uniform4uiv(this.addr, e);
}
function Ih(h, e, t) {
  const n = e.length, i = Yi(t, n);
  h.uniform1iv(this.addr, i);
  for (let s = 0; s !== n; ++s)
    t.setTexture2D(e[s] || po, i[s]);
}
function zh(h, e, t) {
  const n = e.length, i = Yi(t, n);
  h.uniform1iv(this.addr, i);
  for (let s = 0; s !== n; ++s)
    t.setTexture3D(e[s] || go, i[s]);
}
function Bh(h, e, t) {
  const n = e.length, i = Yi(t, n);
  h.uniform1iv(this.addr, i);
  for (let s = 0; s !== n; ++s)
    t.setTextureCube(e[s] || _o, i[s]);
}
function Nh(h, e, t) {
  const n = e.length, i = Yi(t, n);
  h.uniform1iv(this.addr, i);
  for (let s = 0; s !== n; ++s)
    t.setTexture2DArray(e[s] || mo, i[s]);
}
function Oh(h) {
  switch (h) {
    case 5126:
      return xh;
    case 35664:
      return yh;
    case 35665:
      return bh;
    case 35666:
      return wh;
    case 35674:
      return Mh;
    case 35675:
      return Sh;
    case 35676:
      return Eh;
    case 5124:
    case 35670:
      return Th;
    case 35667:
    case 35671:
      return Ah;
    case 35668:
    case 35672:
      return Ch;
    case 35669:
    case 35673:
      return Lh;
    case 5125:
      return Rh;
    case 36294:
      return Fh;
    case 36295:
      return Dh;
    case 36296:
      return Ph;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Ih;
    case 35679:
    case 36299:
    case 36307:
      return zh;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Bh;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Nh;
  }
}
class Uh {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.setValue = vh(t.type);
  }
}
class Gh {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = Oh(t.type);
  }
}
class kh {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let s = 0, o = i.length; s !== o; ++s) {
      const r = i[s];
      r.setValue(e, t[r.id], n);
    }
  }
}
const Es = /(\w+)(\])?(\[|\.)?/g;
function yr(h, e) {
  h.seq.push(e), h.map[e.id] = e;
}
function Wh(h, e, t) {
  const n = h.name, i = n.length;
  for (Es.lastIndex = 0; ; ) {
    const s = Es.exec(n), o = Es.lastIndex;
    let r = s[1];
    const l = s[2] === "]", a = s[3];
    if (l && (r = r | 0), a === void 0 || a === "[" && o + 2 === i) {
      yr(t, a === void 0 ? new Uh(r, h, e) : new Gh(r, h, e));
      break;
    } else {
      let d = t.map[r];
      d === void 0 && (d = new kh(r), yr(t, d)), t = d;
    }
  }
}
class Vi {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, 35718);
    for (let i = 0; i < n; ++i) {
      const s = e.getActiveUniform(t, i), o = e.getUniformLocation(t, s.name);
      Wh(s, o, this);
    }
  }
  setValue(e, t, n, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const r = t[s], l = n[r.id];
      l.needsUpdate !== !1 && r.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const o = e[i];
      o.id in t && n.push(o);
    }
    return n;
  }
}
function br(h, e, t) {
  const n = h.createShader(e);
  return h.shaderSource(n, t), h.compileShader(n), n;
}
let Vh = 0;
function Hh(h, e) {
  const t = h.split(`
`), n = [], i = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let o = i; o < s; o++) {
    const r = o + 1;
    n.push(`${r === e ? ">" : " "} ${r}: ${t[o]}`);
  }
  return n.join(`
`);
}
function qh(h) {
  switch (h) {
    case 3e3:
      return ["Linear", "( value )"];
    case 3001:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", h), ["Linear", "( value )"];
  }
}
function wr(h, e, t) {
  const n = h.getShaderParameter(e, 35713), i = h.getShaderInfoLog(e).trim();
  if (n && i === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const o = parseInt(s[1]);
    return t.toUpperCase() + `

` + i + `

` + Hh(h.getShaderSource(e), o);
  } else
    return i;
}
function Xh(h, e) {
  const t = qh(e);
  return "vec4 " + h + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function jh(h, e) {
  let t;
  switch (e) {
    case 1:
      t = "Linear";
      break;
    case 2:
      t = "Reinhard";
      break;
    case 3:
      t = "OptimizedCineon";
      break;
    case 4:
      t = "ACESFilmic";
      break;
    case 5:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + h + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function Yh(h) {
  return [
    h.extensionDerivatives || !!h.envMapCubeUVHeight || h.bumpMap || h.tangentSpaceNormalMap || h.clearcoatNormalMap || h.flatShading || h.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (h.extensionFragDepth || h.logarithmicDepthBuffer) && h.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    h.extensionDrawBuffers && h.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (h.extensionShaderTextureLOD || h.envMap || h.transmission) && h.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(li).join(`
`);
}
function Zh(h) {
  const e = [];
  for (const t in h) {
    const n = h[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function $h(h, e) {
  const t = {}, n = h.getProgramParameter(e, 35721);
  for (let i = 0; i < n; i++) {
    const s = h.getActiveAttrib(e, i), o = s.name;
    let r = 1;
    s.type === 35674 && (r = 2), s.type === 35675 && (r = 3), s.type === 35676 && (r = 4), t[o] = {
      type: s.type,
      location: h.getAttribLocation(e, o),
      locationSize: r
    };
  }
  return t;
}
function li(h) {
  return h !== "";
}
function Mr(h, e) {
  return h.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Sr(h, e) {
  return h.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Kh = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ns(h) {
  return h.replace(Kh, Jh);
}
function Jh(h, e) {
  const t = Te[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return Ns(t);
}
const Qh = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, eu = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Er(h) {
  return h.replace(eu, vo).replace(Qh, tu);
}
function tu(h, e, t, n) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), vo(h, e, t, n);
}
function vo(h, e, t, n) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function Tr(h) {
  let e = "precision " + h.precision + ` float;
precision ` + h.precision + " int;";
  return h.precision === "highp" ? e += `
#define HIGH_PRECISION` : h.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : h.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function nu(h) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return h.shadowMapType === 1 ? e = "SHADOWMAP_TYPE_PCF" : h.shadowMapType === 2 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : h.shadowMapType === 3 && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function iu(h) {
  let e = "ENVMAP_TYPE_CUBE";
  if (h.envMap)
    switch (h.envMapMode) {
      case 301:
      case 302:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case 306:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function su(h) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (h.envMap)
    switch (h.envMapMode) {
      case 302:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function ru(h) {
  let e = "ENVMAP_BLENDING_NONE";
  if (h.envMap)
    switch (h.combine) {
      case 0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case 1:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case 2:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function ou(h) {
  const e = h.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function au(h, e, t, n) {
  const i = h.getContext(), s = t.defines;
  let o = t.vertexShader, r = t.fragmentShader;
  const l = nu(t), a = iu(t), c = su(t), d = ru(t), u = ou(t), m = t.isWebGL2 ? "" : Yh(t), g = Zh(s), p = i.createProgram();
  let f, v, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (f = [
    g
  ].filter(li).join(`
`), f.length > 0 && (f += `
`), v = [
    m,
    g
  ].filter(li).join(`
`), v.length > 0 && (v += `
`)) : (f = [
    Tr(t),
    "#define SHADER_NAME " + t.shaderName,
    g,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(li).join(`
`), v = [
    m,
    Tr(t),
    "#define SHADER_NAME " + t.shaderName,
    g,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + a : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + d : "",
    u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "",
    u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "",
    u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== 0 ? "#define TONE_MAPPING" : "",
    t.toneMapping !== 0 ? Te.tonemapping_pars_fragment : "",
    t.toneMapping !== 0 ? jh("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Te.encodings_pars_fragment,
    Xh("linearToOutputTexel", t.outputEncoding),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(li).join(`
`)), o = Ns(o), o = Mr(o, t), o = Sr(o, t), r = Ns(r), r = Mr(r, t), r = Sr(r, t), o = Er(o), r = Er(r), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, f = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + f, v = [
    "#define varying in",
    t.glslVersion === Zs ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Zs ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + v);
  const w = _ + f + o, x = _ + v + r, M = br(i, 35633, w), E = br(i, 35632, x);
  if (i.attachShader(p, M), i.attachShader(p, E), t.index0AttributeName !== void 0 ? i.bindAttribLocation(p, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(p, 0, "position"), i.linkProgram(p), h.debug.checkShaderErrors) {
    const A = i.getProgramInfoLog(p).trim(), F = i.getShaderInfoLog(M).trim(), P = i.getShaderInfoLog(E).trim();
    let G = !0, z = !0;
    if (i.getProgramParameter(p, 35714) === !1) {
      G = !1;
      const L = wr(i, M, "vertex"), I = wr(i, E, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(p, 35715) + `

Program Info Log: ` + A + `
` + L + `
` + I
      );
    } else
      A !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", A) : (F === "" || P === "") && (z = !1);
    z && (this.diagnostics = {
      runnable: G,
      programLog: A,
      vertexShader: {
        log: F,
        prefix: f
      },
      fragmentShader: {
        log: P,
        prefix: v
      }
    });
  }
  i.deleteShader(M), i.deleteShader(E);
  let R;
  this.getUniforms = function() {
    return R === void 0 && (R = new Vi(i, p)), R;
  };
  let y;
  return this.getAttributes = function() {
    return y === void 0 && (y = $h(i, p)), y;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(p), this.program = void 0;
  }, this.name = t.shaderName, this.id = Vh++, this.cacheKey = e, this.usedTimes = 1, this.program = p, this.vertexShader = M, this.fragmentShader = E, this;
}
let lu = 0;
class cu {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), s = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    return t.has(e) === !1 && t.set(e, /* @__PURE__ */ new Set()), t.get(e);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    if (t.has(e) === !1) {
      const n = new hu(e);
      t.set(e, n);
    }
    return t.get(e);
  }
}
class hu {
  constructor(e) {
    this.id = lu++, this.code = e, this.usedTimes = 0;
  }
}
function uu(h, e, t, n, i, s, o) {
  const r = new oo(), l = new cu(), a = [], c = i.isWebGL2, d = i.logarithmicDepthBuffer, u = i.vertexTextures;
  let m = i.precision;
  const g = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function p(y, A, F, P, G) {
    const z = P.fog, L = G.geometry, I = y.isMeshStandardMaterial ? P.environment : null, D = (y.isMeshStandardMaterial ? t : e).get(y.envMap || I), q = !!D && D.mapping === 306 ? D.image.height : null, k = g[y.type];
    y.precision !== null && (m = i.getMaxPrecision(y.precision), m !== y.precision && console.warn("THREE.WebGLProgram.getParameters:", y.precision, "not supported, using", m, "instead."));
    const N = L.morphAttributes.position || L.morphAttributes.normal || L.morphAttributes.color, H = N !== void 0 ? N.length : 0;
    let J = 0;
    L.morphAttributes.position !== void 0 && (J = 1), L.morphAttributes.normal !== void 0 && (J = 2), L.morphAttributes.color !== void 0 && (J = 3);
    let V, ee, ce, ge;
    if (k) {
      const Oe = Bt[k];
      V = Oe.vertexShader, ee = Oe.fragmentShader;
    } else
      V = y.vertexShader, ee = y.fragmentShader, l.update(y), ce = l.getVertexShaderID(y), ge = l.getFragmentShaderID(y);
    const $ = h.getRenderTarget(), De = y.alphaTest > 0, ve = y.clearcoat > 0, xe = y.iridescence > 0;
    return {
      isWebGL2: c,
      shaderID: k,
      shaderName: y.type,
      vertexShader: V,
      fragmentShader: ee,
      defines: y.defines,
      customVertexShaderID: ce,
      customFragmentShaderID: ge,
      isRawShaderMaterial: y.isRawShaderMaterial === !0,
      glslVersion: y.glslVersion,
      precision: m,
      instancing: G.isInstancedMesh === !0,
      instancingColor: G.isInstancedMesh === !0 && G.instanceColor !== null,
      supportsVertexTextures: u,
      outputEncoding: $ === null ? h.outputEncoding : $.isXRRenderTarget === !0 ? $.texture.encoding : 3e3,
      map: !!y.map,
      matcap: !!y.matcap,
      envMap: !!D,
      envMapMode: D && D.mapping,
      envMapCubeUVHeight: q,
      lightMap: !!y.lightMap,
      aoMap: !!y.aoMap,
      emissiveMap: !!y.emissiveMap,
      bumpMap: !!y.bumpMap,
      normalMap: !!y.normalMap,
      objectSpaceNormalMap: y.normalMapType === 1,
      tangentSpaceNormalMap: y.normalMapType === 0,
      decodeVideoTexture: !!y.map && y.map.isVideoTexture === !0 && y.map.encoding === 3001,
      clearcoat: ve,
      clearcoatMap: ve && !!y.clearcoatMap,
      clearcoatRoughnessMap: ve && !!y.clearcoatRoughnessMap,
      clearcoatNormalMap: ve && !!y.clearcoatNormalMap,
      iridescence: xe,
      iridescenceMap: xe && !!y.iridescenceMap,
      iridescenceThicknessMap: xe && !!y.iridescenceThicknessMap,
      displacementMap: !!y.displacementMap,
      roughnessMap: !!y.roughnessMap,
      metalnessMap: !!y.metalnessMap,
      specularMap: !!y.specularMap,
      specularIntensityMap: !!y.specularIntensityMap,
      specularColorMap: !!y.specularColorMap,
      opaque: y.transparent === !1 && y.blending === 1,
      alphaMap: !!y.alphaMap,
      alphaTest: De,
      gradientMap: !!y.gradientMap,
      sheen: y.sheen > 0,
      sheenColorMap: !!y.sheenColorMap,
      sheenRoughnessMap: !!y.sheenRoughnessMap,
      transmission: y.transmission > 0,
      transmissionMap: !!y.transmissionMap,
      thicknessMap: !!y.thicknessMap,
      combine: y.combine,
      vertexTangents: !!y.normalMap && !!L.attributes.tangent,
      vertexColors: y.vertexColors,
      vertexAlphas: y.vertexColors === !0 && !!L.attributes.color && L.attributes.color.itemSize === 4,
      vertexUvs: !!y.map || !!y.bumpMap || !!y.normalMap || !!y.specularMap || !!y.alphaMap || !!y.emissiveMap || !!y.roughnessMap || !!y.metalnessMap || !!y.clearcoatMap || !!y.clearcoatRoughnessMap || !!y.clearcoatNormalMap || !!y.iridescenceMap || !!y.iridescenceThicknessMap || !!y.displacementMap || !!y.transmissionMap || !!y.thicknessMap || !!y.specularIntensityMap || !!y.specularColorMap || !!y.sheenColorMap || !!y.sheenRoughnessMap,
      uvsVertexOnly: !(!!y.map || !!y.bumpMap || !!y.normalMap || !!y.specularMap || !!y.alphaMap || !!y.emissiveMap || !!y.roughnessMap || !!y.metalnessMap || !!y.clearcoatNormalMap || !!y.iridescenceMap || !!y.iridescenceThicknessMap || y.transmission > 0 || !!y.transmissionMap || !!y.thicknessMap || !!y.specularIntensityMap || !!y.specularColorMap || y.sheen > 0 || !!y.sheenColorMap || !!y.sheenRoughnessMap) && !!y.displacementMap,
      fog: !!z,
      useFog: y.fog === !0,
      fogExp2: z && z.isFogExp2,
      flatShading: !!y.flatShading,
      sizeAttenuation: y.sizeAttenuation,
      logarithmicDepthBuffer: d,
      skinning: G.isSkinnedMesh === !0,
      morphTargets: L.morphAttributes.position !== void 0,
      morphNormals: L.morphAttributes.normal !== void 0,
      morphColors: L.morphAttributes.color !== void 0,
      morphTargetsCount: H,
      morphTextureStride: J,
      numDirLights: A.directional.length,
      numPointLights: A.point.length,
      numSpotLights: A.spot.length,
      numRectAreaLights: A.rectArea.length,
      numHemiLights: A.hemi.length,
      numDirLightShadows: A.directionalShadowMap.length,
      numPointLightShadows: A.pointShadowMap.length,
      numSpotLightShadows: A.spotShadowMap.length,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: y.dithering,
      shadowMapEnabled: h.shadowMap.enabled && F.length > 0,
      shadowMapType: h.shadowMap.type,
      toneMapping: y.toneMapped ? h.toneMapping : 0,
      physicallyCorrectLights: h.physicallyCorrectLights,
      premultipliedAlpha: y.premultipliedAlpha,
      doubleSided: y.side === 2,
      flipSided: y.side === 1,
      useDepthPacking: !!y.depthPacking,
      depthPacking: y.depthPacking || 0,
      index0AttributeName: y.index0AttributeName,
      extensionDerivatives: y.extensions && y.extensions.derivatives,
      extensionFragDepth: y.extensions && y.extensions.fragDepth,
      extensionDrawBuffers: y.extensions && y.extensions.drawBuffers,
      extensionShaderTextureLOD: y.extensions && y.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: c || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: c || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: c || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: y.customProgramCacheKey()
    };
  }
  function f(y) {
    const A = [];
    if (y.shaderID ? A.push(y.shaderID) : (A.push(y.customVertexShaderID), A.push(y.customFragmentShaderID)), y.defines !== void 0)
      for (const F in y.defines)
        A.push(F), A.push(y.defines[F]);
    return y.isRawShaderMaterial === !1 && (v(A, y), _(A, y), A.push(h.outputEncoding)), A.push(y.customProgramCacheKey), A.join();
  }
  function v(y, A) {
    y.push(A.precision), y.push(A.outputEncoding), y.push(A.envMapMode), y.push(A.envMapCubeUVHeight), y.push(A.combine), y.push(A.vertexUvs), y.push(A.fogExp2), y.push(A.sizeAttenuation), y.push(A.morphTargetsCount), y.push(A.morphAttributeCount), y.push(A.numDirLights), y.push(A.numPointLights), y.push(A.numSpotLights), y.push(A.numHemiLights), y.push(A.numRectAreaLights), y.push(A.numDirLightShadows), y.push(A.numPointLightShadows), y.push(A.numSpotLightShadows), y.push(A.shadowMapType), y.push(A.toneMapping), y.push(A.numClippingPlanes), y.push(A.numClipIntersection), y.push(A.depthPacking);
  }
  function _(y, A) {
    r.disableAll(), A.isWebGL2 && r.enable(0), A.supportsVertexTextures && r.enable(1), A.instancing && r.enable(2), A.instancingColor && r.enable(3), A.map && r.enable(4), A.matcap && r.enable(5), A.envMap && r.enable(6), A.lightMap && r.enable(7), A.aoMap && r.enable(8), A.emissiveMap && r.enable(9), A.bumpMap && r.enable(10), A.normalMap && r.enable(11), A.objectSpaceNormalMap && r.enable(12), A.tangentSpaceNormalMap && r.enable(13), A.clearcoat && r.enable(14), A.clearcoatMap && r.enable(15), A.clearcoatRoughnessMap && r.enable(16), A.clearcoatNormalMap && r.enable(17), A.iridescence && r.enable(18), A.iridescenceMap && r.enable(19), A.iridescenceThicknessMap && r.enable(20), A.displacementMap && r.enable(21), A.specularMap && r.enable(22), A.roughnessMap && r.enable(23), A.metalnessMap && r.enable(24), A.gradientMap && r.enable(25), A.alphaMap && r.enable(26), A.alphaTest && r.enable(27), A.vertexColors && r.enable(28), A.vertexAlphas && r.enable(29), A.vertexUvs && r.enable(30), A.vertexTangents && r.enable(31), A.uvsVertexOnly && r.enable(32), A.fog && r.enable(33), y.push(r.mask), r.disableAll(), A.useFog && r.enable(0), A.flatShading && r.enable(1), A.logarithmicDepthBuffer && r.enable(2), A.skinning && r.enable(3), A.morphTargets && r.enable(4), A.morphNormals && r.enable(5), A.morphColors && r.enable(6), A.premultipliedAlpha && r.enable(7), A.shadowMapEnabled && r.enable(8), A.physicallyCorrectLights && r.enable(9), A.doubleSided && r.enable(10), A.flipSided && r.enable(11), A.useDepthPacking && r.enable(12), A.dithering && r.enable(13), A.specularIntensityMap && r.enable(14), A.specularColorMap && r.enable(15), A.transmission && r.enable(16), A.transmissionMap && r.enable(17), A.thicknessMap && r.enable(18), A.sheen && r.enable(19), A.sheenColorMap && r.enable(20), A.sheenRoughnessMap && r.enable(21), A.decodeVideoTexture && r.enable(22), A.opaque && r.enable(23), y.push(r.mask);
  }
  function w(y) {
    const A = g[y.type];
    let F;
    if (A) {
      const P = Bt[A];
      F = Jo.clone(P.uniforms);
    } else
      F = y.uniforms;
    return F;
  }
  function x(y, A) {
    let F;
    for (let P = 0, G = a.length; P < G; P++) {
      const z = a[P];
      if (z.cacheKey === A) {
        F = z, ++F.usedTimes;
        break;
      }
    }
    return F === void 0 && (F = new au(h, A, y, s), a.push(F)), F;
  }
  function M(y) {
    if (--y.usedTimes === 0) {
      const A = a.indexOf(y);
      a[A] = a[a.length - 1], a.pop(), y.destroy();
    }
  }
  function E(y) {
    l.remove(y);
  }
  function R() {
    l.dispose();
  }
  return {
    getParameters: p,
    getProgramCacheKey: f,
    getUniforms: w,
    acquireProgram: x,
    releaseProgram: M,
    releaseShaderCache: E,
    programs: a,
    dispose: R
  };
}
function du() {
  let h = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let o = h.get(s);
    return o === void 0 && (o = {}, h.set(s, o)), o;
  }
  function t(s) {
    h.delete(s);
  }
  function n(s, o, r) {
    h.get(s)[o] = r;
  }
  function i() {
    h = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: i
  };
}
function fu(h, e) {
  return h.groupOrder !== e.groupOrder ? h.groupOrder - e.groupOrder : h.renderOrder !== e.renderOrder ? h.renderOrder - e.renderOrder : h.material.id !== e.material.id ? h.material.id - e.material.id : h.z !== e.z ? h.z - e.z : h.id - e.id;
}
function Ar(h, e) {
  return h.groupOrder !== e.groupOrder ? h.groupOrder - e.groupOrder : h.renderOrder !== e.renderOrder ? h.renderOrder - e.renderOrder : h.z !== e.z ? e.z - h.z : h.id - e.id;
}
function Cr() {
  const h = [];
  let e = 0;
  const t = [], n = [], i = [];
  function s() {
    e = 0, t.length = 0, n.length = 0, i.length = 0;
  }
  function o(d, u, m, g, p, f) {
    let v = h[e];
    return v === void 0 ? (v = {
      id: d.id,
      object: d,
      geometry: u,
      material: m,
      groupOrder: g,
      renderOrder: d.renderOrder,
      z: p,
      group: f
    }, h[e] = v) : (v.id = d.id, v.object = d, v.geometry = u, v.material = m, v.groupOrder = g, v.renderOrder = d.renderOrder, v.z = p, v.group = f), e++, v;
  }
  function r(d, u, m, g, p, f) {
    const v = o(d, u, m, g, p, f);
    m.transmission > 0 ? n.push(v) : m.transparent === !0 ? i.push(v) : t.push(v);
  }
  function l(d, u, m, g, p, f) {
    const v = o(d, u, m, g, p, f);
    m.transmission > 0 ? n.unshift(v) : m.transparent === !0 ? i.unshift(v) : t.unshift(v);
  }
  function a(d, u) {
    t.length > 1 && t.sort(d || fu), n.length > 1 && n.sort(u || Ar), i.length > 1 && i.sort(u || Ar);
  }
  function c() {
    for (let d = e, u = h.length; d < u; d++) {
      const m = h[d];
      if (m.id === null)
        break;
      m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: s,
    push: r,
    unshift: l,
    finish: c,
    sort: a
  };
}
function pu() {
  let h = /* @__PURE__ */ new WeakMap();
  function e(n, i) {
    let s;
    return h.has(n) === !1 ? (s = new Cr(), h.set(n, [s])) : i >= h.get(n).length ? (s = new Cr(), h.get(n).push(s)) : s = h.get(n)[i], s;
  }
  function t() {
    h = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function mu() {
  const h = {};
  return {
    get: function(e) {
      if (h[e.id] !== void 0)
        return h[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new O(),
            color: new Ae()
          };
          break;
        case "SpotLight":
          t = {
            position: new O(),
            direction: new O(),
            color: new Ae(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new O(),
            color: new Ae(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new O(),
            skyColor: new Ae(),
            groundColor: new Ae()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Ae(),
            position: new O(),
            halfWidth: new O(),
            halfHeight: new O()
          };
          break;
      }
      return h[e.id] = t, t;
    }
  };
}
function gu() {
  const h = {};
  return {
    get: function(e) {
      if (h[e.id] !== void 0)
        return h[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return h[e.id] = t, t;
    }
  };
}
let _u = 0;
function vu(h, e) {
  return (e.castShadow ? 1 : 0) - (h.castShadow ? 1 : 0);
}
function xu(h, e) {
  const t = new mu(), n = gu(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let c = 0; c < 9; c++)
    i.probe.push(new O());
  const s = new O(), o = new Ke(), r = new Ke();
  function l(c, d) {
    let u = 0, m = 0, g = 0;
    for (let A = 0; A < 9; A++)
      i.probe[A].set(0, 0, 0);
    let p = 0, f = 0, v = 0, _ = 0, w = 0, x = 0, M = 0, E = 0;
    c.sort(vu);
    const R = d !== !0 ? Math.PI : 1;
    for (let A = 0, F = c.length; A < F; A++) {
      const P = c[A], G = P.color, z = P.intensity, L = P.distance, I = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
      if (P.isAmbientLight)
        u += G.r * z * R, m += G.g * z * R, g += G.b * z * R;
      else if (P.isLightProbe)
        for (let D = 0; D < 9; D++)
          i.probe[D].addScaledVector(P.sh.coefficients[D], z);
      else if (P.isDirectionalLight) {
        const D = t.get(P);
        if (D.color.copy(P.color).multiplyScalar(P.intensity * R), P.castShadow) {
          const q = P.shadow, k = n.get(P);
          k.shadowBias = q.bias, k.shadowNormalBias = q.normalBias, k.shadowRadius = q.radius, k.shadowMapSize = q.mapSize, i.directionalShadow[p] = k, i.directionalShadowMap[p] = I, i.directionalShadowMatrix[p] = P.shadow.matrix, x++;
        }
        i.directional[p] = D, p++;
      } else if (P.isSpotLight) {
        const D = t.get(P);
        if (D.position.setFromMatrixPosition(P.matrixWorld), D.color.copy(G).multiplyScalar(z * R), D.distance = L, D.coneCos = Math.cos(P.angle), D.penumbraCos = Math.cos(P.angle * (1 - P.penumbra)), D.decay = P.decay, P.castShadow) {
          const q = P.shadow, k = n.get(P);
          k.shadowBias = q.bias, k.shadowNormalBias = q.normalBias, k.shadowRadius = q.radius, k.shadowMapSize = q.mapSize, i.spotShadow[v] = k, i.spotShadowMap[v] = I, i.spotShadowMatrix[v] = P.shadow.matrix, E++;
        }
        i.spot[v] = D, v++;
      } else if (P.isRectAreaLight) {
        const D = t.get(P);
        D.color.copy(G).multiplyScalar(z), D.halfWidth.set(P.width * 0.5, 0, 0), D.halfHeight.set(0, P.height * 0.5, 0), i.rectArea[_] = D, _++;
      } else if (P.isPointLight) {
        const D = t.get(P);
        if (D.color.copy(P.color).multiplyScalar(P.intensity * R), D.distance = P.distance, D.decay = P.decay, P.castShadow) {
          const q = P.shadow, k = n.get(P);
          k.shadowBias = q.bias, k.shadowNormalBias = q.normalBias, k.shadowRadius = q.radius, k.shadowMapSize = q.mapSize, k.shadowCameraNear = q.camera.near, k.shadowCameraFar = q.camera.far, i.pointShadow[f] = k, i.pointShadowMap[f] = I, i.pointShadowMatrix[f] = P.shadow.matrix, M++;
        }
        i.point[f] = D, f++;
      } else if (P.isHemisphereLight) {
        const D = t.get(P);
        D.skyColor.copy(P.color).multiplyScalar(z * R), D.groundColor.copy(P.groundColor).multiplyScalar(z * R), i.hemi[w] = D, w++;
      }
    }
    _ > 0 && (e.isWebGL2 || h.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = ne.LTC_FLOAT_1, i.rectAreaLTC2 = ne.LTC_FLOAT_2) : h.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = ne.LTC_HALF_1, i.rectAreaLTC2 = ne.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = u, i.ambient[1] = m, i.ambient[2] = g;
    const y = i.hash;
    (y.directionalLength !== p || y.pointLength !== f || y.spotLength !== v || y.rectAreaLength !== _ || y.hemiLength !== w || y.numDirectionalShadows !== x || y.numPointShadows !== M || y.numSpotShadows !== E) && (i.directional.length = p, i.spot.length = v, i.rectArea.length = _, i.point.length = f, i.hemi.length = w, i.directionalShadow.length = x, i.directionalShadowMap.length = x, i.pointShadow.length = M, i.pointShadowMap.length = M, i.spotShadow.length = E, i.spotShadowMap.length = E, i.directionalShadowMatrix.length = x, i.pointShadowMatrix.length = M, i.spotShadowMatrix.length = E, y.directionalLength = p, y.pointLength = f, y.spotLength = v, y.rectAreaLength = _, y.hemiLength = w, y.numDirectionalShadows = x, y.numPointShadows = M, y.numSpotShadows = E, i.version = _u++);
  }
  function a(c, d) {
    let u = 0, m = 0, g = 0, p = 0, f = 0;
    const v = d.matrixWorldInverse;
    for (let _ = 0, w = c.length; _ < w; _++) {
      const x = c[_];
      if (x.isDirectionalLight) {
        const M = i.directional[u];
        M.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(v), u++;
      } else if (x.isSpotLight) {
        const M = i.spot[g];
        M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(v), M.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(v), g++;
      } else if (x.isRectAreaLight) {
        const M = i.rectArea[p];
        M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(v), r.identity(), o.copy(x.matrixWorld), o.premultiply(v), r.extractRotation(o), M.halfWidth.set(x.width * 0.5, 0, 0), M.halfHeight.set(0, x.height * 0.5, 0), M.halfWidth.applyMatrix4(r), M.halfHeight.applyMatrix4(r), p++;
      } else if (x.isPointLight) {
        const M = i.point[m];
        M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(v), m++;
      } else if (x.isHemisphereLight) {
        const M = i.hemi[f];
        M.direction.setFromMatrixPosition(x.matrixWorld), M.direction.transformDirection(v), f++;
      }
    }
  }
  return {
    setup: l,
    setupView: a,
    state: i
  };
}
function Lr(h, e) {
  const t = new xu(h, e), n = [], i = [];
  function s() {
    n.length = 0, i.length = 0;
  }
  function o(d) {
    n.push(d);
  }
  function r(d) {
    i.push(d);
  }
  function l(d) {
    t.setup(n, d);
  }
  function a(d) {
    t.setupView(n, d);
  }
  return {
    init: s,
    state: {
      lightsArray: n,
      shadowsArray: i,
      lights: t
    },
    setupLights: l,
    setupLightsView: a,
    pushLight: o,
    pushShadow: r
  };
}
function yu(h, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(s, o = 0) {
    let r;
    return t.has(s) === !1 ? (r = new Lr(h, e), t.set(s, [r])) : o >= t.get(s).length ? (r = new Lr(h, e), t.get(s).push(r)) : r = t.get(s)[o], r;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class bu extends An {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class wu extends An {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new O(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const Mu = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Su = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Eu(h, e, t) {
  let n = new Us();
  const i = new Ce(), s = new Ce(), o = new $e(), r = new bu({ depthPacking: 3201 }), l = new wu(), a = {}, c = t.maxTextureSize, d = { 0: 1, 1: 0, 2: 2 }, u = new Tn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ce() },
      radius: { value: 4 }
    },
    vertexShader: Mu,
    fragmentShader: Su
  }), m = u.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const g = new Ut();
  g.setAttribute(
    "position",
    new Ot(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const p = new Nt(g, u), f = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(x, M, E) {
    if (f.enabled === !1 || f.autoUpdate === !1 && f.needsUpdate === !1 || x.length === 0)
      return;
    const R = h.getRenderTarget(), y = h.getActiveCubeFace(), A = h.getActiveMipmapLevel(), F = h.state;
    F.setBlending(0), F.buffers.color.setClear(1, 1, 1, 1), F.buffers.depth.setTest(!0), F.setScissorTest(!1);
    for (let P = 0, G = x.length; P < G; P++) {
      const z = x[P], L = z.shadow;
      if (L === void 0) {
        console.warn("THREE.WebGLShadowMap:", z, "has no shadow.");
        continue;
      }
      if (L.autoUpdate === !1 && L.needsUpdate === !1)
        continue;
      i.copy(L.mapSize);
      const I = L.getFrameExtents();
      if (i.multiply(I), s.copy(L.mapSize), (i.x > c || i.y > c) && (i.x > c && (s.x = Math.floor(c / I.x), i.x = s.x * I.x, L.mapSize.x = s.x), i.y > c && (s.y = Math.floor(c / I.y), i.y = s.y * I.y, L.mapSize.y = s.y)), L.map === null) {
        const q = this.type !== 3 ? { minFilter: 1003, magFilter: 1003 } : {};
        L.map = new En(i.x, i.y, q), L.map.texture.name = z.name + ".shadowMap", L.camera.updateProjectionMatrix();
      }
      h.setRenderTarget(L.map), h.clear();
      const D = L.getViewportCount();
      for (let q = 0; q < D; q++) {
        const k = L.getViewport(q);
        o.set(
          s.x * k.x,
          s.y * k.y,
          s.x * k.z,
          s.y * k.w
        ), F.viewport(o), L.updateMatrices(z, q), n = L.getFrustum(), w(M, E, L.camera, z, this.type);
      }
      L.isPointLightShadow !== !0 && this.type === 3 && v(L, E), L.needsUpdate = !1;
    }
    f.needsUpdate = !1, h.setRenderTarget(R, y, A);
  };
  function v(x, M) {
    const E = e.update(p);
    u.defines.VSM_SAMPLES !== x.blurSamples && (u.defines.VSM_SAMPLES = x.blurSamples, m.defines.VSM_SAMPLES = x.blurSamples, u.needsUpdate = !0, m.needsUpdate = !0), x.mapPass === null && (x.mapPass = new En(i.x, i.y)), u.uniforms.shadow_pass.value = x.map.texture, u.uniforms.resolution.value = x.mapSize, u.uniforms.radius.value = x.radius, h.setRenderTarget(x.mapPass), h.clear(), h.renderBufferDirect(M, null, E, u, p, null), m.uniforms.shadow_pass.value = x.mapPass.texture, m.uniforms.resolution.value = x.mapSize, m.uniforms.radius.value = x.radius, h.setRenderTarget(x.map), h.clear(), h.renderBufferDirect(M, null, E, m, p, null);
  }
  function _(x, M, E, R, y, A) {
    let F = null;
    const P = E.isPointLight === !0 ? x.customDistanceMaterial : x.customDepthMaterial;
    if (P !== void 0 ? F = P : F = E.isPointLight === !0 ? l : r, h.localClippingEnabled && M.clipShadows === !0 && Array.isArray(M.clippingPlanes) && M.clippingPlanes.length !== 0 || M.displacementMap && M.displacementScale !== 0 || M.alphaMap && M.alphaTest > 0) {
      const G = F.uuid, z = M.uuid;
      let L = a[G];
      L === void 0 && (L = {}, a[G] = L);
      let I = L[z];
      I === void 0 && (I = F.clone(), L[z] = I), F = I;
    }
    return F.visible = M.visible, F.wireframe = M.wireframe, A === 3 ? F.side = M.shadowSide !== null ? M.shadowSide : M.side : F.side = M.shadowSide !== null ? M.shadowSide : d[M.side], F.alphaMap = M.alphaMap, F.alphaTest = M.alphaTest, F.clipShadows = M.clipShadows, F.clippingPlanes = M.clippingPlanes, F.clipIntersection = M.clipIntersection, F.displacementMap = M.displacementMap, F.displacementScale = M.displacementScale, F.displacementBias = M.displacementBias, F.wireframeLinewidth = M.wireframeLinewidth, F.linewidth = M.linewidth, E.isPointLight === !0 && F.isMeshDistanceMaterial === !0 && (F.referencePosition.setFromMatrixPosition(E.matrixWorld), F.nearDistance = R, F.farDistance = y), F;
  }
  function w(x, M, E, R, y) {
    if (x.visible === !1)
      return;
    if (x.layers.test(M.layers) && (x.isMesh || x.isLine || x.isPoints) && (x.castShadow || x.receiveShadow && y === 3) && (!x.frustumCulled || n.intersectsObject(x))) {
      x.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, x.matrixWorld);
      const P = e.update(x), G = x.material;
      if (Array.isArray(G)) {
        const z = P.groups;
        for (let L = 0, I = z.length; L < I; L++) {
          const D = z[L], q = G[D.materialIndex];
          if (q && q.visible) {
            const k = _(x, q, R, E.near, E.far, y);
            h.renderBufferDirect(E, null, P, k, x, D);
          }
        }
      } else if (G.visible) {
        const z = _(x, G, R, E.near, E.far, y);
        h.renderBufferDirect(E, null, P, z, x, null);
      }
    }
    const F = x.children;
    for (let P = 0, G = F.length; P < G; P++)
      w(F[P], M, E, R, y);
  }
}
function Tu(h, e, t) {
  const n = t.isWebGL2;
  function i() {
    let B = !1;
    const ae = new $e();
    let Y = null;
    const oe = new $e(0, 0, 0, 0);
    return {
      setMask: function(se) {
        Y !== se && !B && (h.colorMask(se, se, se, se), Y = se);
      },
      setLocked: function(se) {
        B = se;
      },
      setClear: function(se, Re, Je, Ve, en) {
        en === !0 && (se *= Ve, Re *= Ve, Je *= Ve), ae.set(se, Re, Je, Ve), oe.equals(ae) === !1 && (h.clearColor(se, Re, Je, Ve), oe.copy(ae));
      },
      reset: function() {
        B = !1, Y = null, oe.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let B = !1, ae = null, Y = null, oe = null;
    return {
      setTest: function(se) {
        se ? De(2929) : ve(2929);
      },
      setMask: function(se) {
        ae !== se && !B && (h.depthMask(se), ae = se);
      },
      setFunc: function(se) {
        if (Y !== se) {
          if (se)
            switch (se) {
              case 0:
                h.depthFunc(512);
                break;
              case 1:
                h.depthFunc(519);
                break;
              case 2:
                h.depthFunc(513);
                break;
              case 3:
                h.depthFunc(515);
                break;
              case 4:
                h.depthFunc(514);
                break;
              case 5:
                h.depthFunc(518);
                break;
              case 6:
                h.depthFunc(516);
                break;
              case 7:
                h.depthFunc(517);
                break;
              default:
                h.depthFunc(515);
            }
          else
            h.depthFunc(515);
          Y = se;
        }
      },
      setLocked: function(se) {
        B = se;
      },
      setClear: function(se) {
        oe !== se && (h.clearDepth(se), oe = se);
      },
      reset: function() {
        B = !1, ae = null, Y = null, oe = null;
      }
    };
  }
  function o() {
    let B = !1, ae = null, Y = null, oe = null, se = null, Re = null, Je = null, Ve = null, en = null;
    return {
      setTest: function(Ge) {
        B || (Ge ? De(2960) : ve(2960));
      },
      setMask: function(Ge) {
        ae !== Ge && !B && (h.stencilMask(Ge), ae = Ge);
      },
      setFunc: function(Ge, kt, xt) {
        (Y !== Ge || oe !== kt || se !== xt) && (h.stencilFunc(Ge, kt, xt), Y = Ge, oe = kt, se = xt);
      },
      setOp: function(Ge, kt, xt) {
        (Re !== Ge || Je !== kt || Ve !== xt) && (h.stencilOp(Ge, kt, xt), Re = Ge, Je = kt, Ve = xt);
      },
      setLocked: function(Ge) {
        B = Ge;
      },
      setClear: function(Ge) {
        en !== Ge && (h.clearStencil(Ge), en = Ge);
      },
      reset: function() {
        B = !1, ae = null, Y = null, oe = null, se = null, Re = null, Je = null, Ve = null, en = null;
      }
    };
  }
  const r = new i(), l = new s(), a = new o(), c = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap();
  let u = {}, m = {}, g = /* @__PURE__ */ new WeakMap(), p = [], f = null, v = !1, _ = null, w = null, x = null, M = null, E = null, R = null, y = null, A = !1, F = null, P = null, G = null, z = null, L = null;
  const I = h.getParameter(35661);
  let D = !1, q = 0;
  const k = h.getParameter(7938);
  k.indexOf("WebGL") !== -1 ? (q = parseFloat(/^WebGL (\d)/.exec(k)[1]), D = q >= 1) : k.indexOf("OpenGL ES") !== -1 && (q = parseFloat(/^OpenGL ES (\d)/.exec(k)[1]), D = q >= 2);
  let N = null, H = {};
  const J = h.getParameter(3088), V = h.getParameter(2978), ee = new $e().fromArray(J), ce = new $e().fromArray(V);
  function ge(B, ae, Y) {
    const oe = new Uint8Array(4), se = h.createTexture();
    h.bindTexture(B, se), h.texParameteri(B, 10241, 9728), h.texParameteri(B, 10240, 9728);
    for (let Re = 0; Re < Y; Re++)
      h.texImage2D(ae + Re, 0, 6408, 1, 1, 0, 6408, 5121, oe);
    return se;
  }
  const $ = {};
  $[3553] = ge(3553, 3553, 1), $[34067] = ge(34067, 34069, 6), r.setClear(0, 0, 0, 1), l.setClear(1), a.setClear(0), De(2929), l.setFunc(3), rt(!1), Rt(1), De(2884), et(0);
  function De(B) {
    u[B] !== !0 && (h.enable(B), u[B] = !0);
  }
  function ve(B) {
    u[B] !== !1 && (h.disable(B), u[B] = !1);
  }
  function xe(B, ae) {
    return m[B] !== ae ? (h.bindFramebuffer(B, ae), m[B] = ae, n && (B === 36009 && (m[36160] = ae), B === 36160 && (m[36009] = ae)), !0) : !1;
  }
  function ue(B, ae) {
    let Y = p, oe = !1;
    if (B)
      if (Y = g.get(ae), Y === void 0 && (Y = [], g.set(ae, Y)), B.isWebGLMultipleRenderTargets) {
        const se = B.texture;
        if (Y.length !== se.length || Y[0] !== 36064) {
          for (let Re = 0, Je = se.length; Re < Je; Re++)
            Y[Re] = 36064 + Re;
          Y.length = se.length, oe = !0;
        }
      } else
        Y[0] !== 36064 && (Y[0] = 36064, oe = !0);
    else
      Y[0] !== 1029 && (Y[0] = 1029, oe = !0);
    oe && (t.isWebGL2 ? h.drawBuffers(Y) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Y));
  }
  function Oe(B) {
    return f !== B ? (h.useProgram(B), f = B, !0) : !1;
  }
  const Ee = {
    [100]: 32774,
    [101]: 32778,
    [102]: 32779
  };
  if (n)
    Ee[103] = 32775, Ee[104] = 32776;
  else {
    const B = e.get("EXT_blend_minmax");
    B !== null && (Ee[103] = B.MIN_EXT, Ee[104] = B.MAX_EXT);
  }
  const me = {
    [200]: 0,
    [201]: 1,
    [202]: 768,
    [204]: 770,
    [210]: 776,
    [208]: 774,
    [206]: 772,
    [203]: 769,
    [205]: 771,
    [209]: 775,
    [207]: 773
  };
  function et(B, ae, Y, oe, se, Re, Je, Ve) {
    if (B === 0) {
      v === !0 && (ve(3042), v = !1);
      return;
    }
    if (v === !1 && (De(3042), v = !0), B !== 5) {
      if (B !== _ || Ve !== A) {
        if ((w !== 100 || E !== 100) && (h.blendEquation(32774), w = 100, E = 100), Ve)
          switch (B) {
            case 1:
              h.blendFuncSeparate(1, 771, 1, 771);
              break;
            case 2:
              h.blendFunc(1, 1);
              break;
            case 3:
              h.blendFuncSeparate(0, 769, 0, 1);
              break;
            case 4:
              h.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }
        else
          switch (B) {
            case 1:
              h.blendFuncSeparate(770, 771, 1, 771);
              break;
            case 2:
              h.blendFunc(770, 1);
              break;
            case 3:
              h.blendFuncSeparate(0, 769, 0, 1);
              break;
            case 4:
              h.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }
        x = null, M = null, R = null, y = null, _ = B, A = Ve;
      }
      return;
    }
    se = se || ae, Re = Re || Y, Je = Je || oe, (ae !== w || se !== E) && (h.blendEquationSeparate(Ee[ae], Ee[se]), w = ae, E = se), (Y !== x || oe !== M || Re !== R || Je !== y) && (h.blendFuncSeparate(me[Y], me[oe], me[Re], me[Je]), x = Y, M = oe, R = Re, y = Je), _ = B, A = null;
  }
  function ut(B, ae) {
    B.side === 2 ? ve(2884) : De(2884);
    let Y = B.side === 1;
    ae && (Y = !Y), rt(Y), B.blending === 1 && B.transparent === !1 ? et(0) : et(B.blending, B.blendEquation, B.blendSrc, B.blendDst, B.blendEquationAlpha, B.blendSrcAlpha, B.blendDstAlpha, B.premultipliedAlpha), l.setFunc(B.depthFunc), l.setTest(B.depthTest), l.setMask(B.depthWrite), r.setMask(B.colorWrite);
    const oe = B.stencilWrite;
    a.setTest(oe), oe && (a.setMask(B.stencilWriteMask), a.setFunc(B.stencilFunc, B.stencilRef, B.stencilFuncMask), a.setOp(B.stencilFail, B.stencilZFail, B.stencilZPass)), Ne(B.polygonOffset, B.polygonOffsetFactor, B.polygonOffsetUnits), B.alphaToCoverage === !0 ? De(32926) : ve(32926);
  }
  function rt(B) {
    F !== B && (B ? h.frontFace(2304) : h.frontFace(2305), F = B);
  }
  function Rt(B) {
    B !== 0 ? (De(2884), B !== P && (B === 1 ? h.cullFace(1029) : B === 2 ? h.cullFace(1028) : h.cullFace(1032))) : ve(2884), P = B;
  }
  function tt(B) {
    B !== G && (D && h.lineWidth(B), G = B);
  }
  function Ne(B, ae, Y) {
    B ? (De(32823), (z !== ae || L !== Y) && (h.polygonOffset(ae, Y), z = ae, L = Y)) : ve(32823);
  }
  function Gt(B) {
    B ? De(3089) : ve(3089);
  }
  function Ft(B) {
    B === void 0 && (B = 33984 + I - 1), N !== B && (h.activeTexture(B), N = B);
  }
  function C(B, ae) {
    N === null && Ft();
    let Y = H[N];
    Y === void 0 && (Y = { type: void 0, texture: void 0 }, H[N] = Y), (Y.type !== B || Y.texture !== ae) && (h.bindTexture(B, ae || $[B]), Y.type = B, Y.texture = ae);
  }
  function S() {
    const B = H[N];
    B !== void 0 && B.type !== void 0 && (h.bindTexture(B.type, null), B.type = void 0, B.texture = void 0);
  }
  function Z() {
    try {
      h.compressedTexImage2D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function Q() {
    try {
      h.texSubImage2D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function te() {
    try {
      h.texSubImage3D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function re() {
    try {
      h.compressedTexSubImage2D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ye() {
    try {
      h.texStorage2D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function j() {
    try {
      h.texStorage3D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function pe() {
    try {
      h.texImage2D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function he() {
    try {
      h.texImage3D.apply(h, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function fe(B) {
    ee.equals(B) === !1 && (h.scissor(B.x, B.y, B.z, B.w), ee.copy(B));
  }
  function de(B) {
    ce.equals(B) === !1 && (h.viewport(B.x, B.y, B.z, B.w), ce.copy(B));
  }
  function we(B, ae) {
    let Y = d.get(ae);
    Y === void 0 && (Y = /* @__PURE__ */ new WeakMap(), d.set(ae, Y));
    let oe = Y.get(B);
    oe === void 0 && (oe = h.getUniformBlockIndex(ae, B.name), Y.set(B, oe));
  }
  function Ie(B, ae) {
    const oe = d.get(ae).get(B);
    c.get(B) !== oe && (h.uniformBlockBinding(ae, oe, B.__bindingPointIndex), c.set(B, oe));
  }
  function We() {
    h.disable(3042), h.disable(2884), h.disable(2929), h.disable(32823), h.disable(3089), h.disable(2960), h.disable(32926), h.blendEquation(32774), h.blendFunc(1, 0), h.blendFuncSeparate(1, 0, 1, 0), h.colorMask(!0, !0, !0, !0), h.clearColor(0, 0, 0, 0), h.depthMask(!0), h.depthFunc(513), h.clearDepth(1), h.stencilMask(4294967295), h.stencilFunc(519, 0, 4294967295), h.stencilOp(7680, 7680, 7680), h.clearStencil(0), h.cullFace(1029), h.frontFace(2305), h.polygonOffset(0, 0), h.activeTexture(33984), h.bindFramebuffer(36160, null), n === !0 && (h.bindFramebuffer(36009, null), h.bindFramebuffer(36008, null)), h.useProgram(null), h.lineWidth(1), h.scissor(0, 0, h.canvas.width, h.canvas.height), h.viewport(0, 0, h.canvas.width, h.canvas.height), u = {}, N = null, H = {}, m = {}, g = /* @__PURE__ */ new WeakMap(), p = [], f = null, v = !1, _ = null, w = null, x = null, M = null, E = null, R = null, y = null, A = !1, F = null, P = null, G = null, z = null, L = null, ee.set(0, 0, h.canvas.width, h.canvas.height), ce.set(0, 0, h.canvas.width, h.canvas.height), r.reset(), l.reset(), a.reset();
  }
  return {
    buffers: {
      color: r,
      depth: l,
      stencil: a
    },
    enable: De,
    disable: ve,
    bindFramebuffer: xe,
    drawBuffers: ue,
    useProgram: Oe,
    setBlending: et,
    setMaterial: ut,
    setFlipSided: rt,
    setCullFace: Rt,
    setLineWidth: tt,
    setPolygonOffset: Ne,
    setScissorTest: Gt,
    activeTexture: Ft,
    bindTexture: C,
    unbindTexture: S,
    compressedTexImage2D: Z,
    texImage2D: pe,
    texImage3D: he,
    updateUBOMapping: we,
    uniformBlockBinding: Ie,
    texStorage2D: ye,
    texStorage3D: j,
    texSubImage2D: Q,
    texSubImage3D: te,
    compressedTexSubImage2D: re,
    scissor: fe,
    viewport: de,
    reset: We
  };
}
function Au(h, e, t, n, i, s, o) {
  const r = i.isWebGL2, l = i.maxTextures, a = i.maxCubemapSize, c = i.maxTextureSize, d = i.maxSamples, u = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = /OculusBrowser/g.test(navigator.userAgent), g = /* @__PURE__ */ new WeakMap();
  let p;
  const f = /* @__PURE__ */ new WeakMap();
  let v = !1;
  try {
    v = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function _(C, S) {
    return v ? new OffscreenCanvas(C, S) : qi("canvas");
  }
  function w(C, S, Z, Q) {
    let te = 1;
    if ((C.width > Q || C.height > Q) && (te = Q / Math.max(C.width, C.height)), te < 1 || S === !0)
      if (typeof HTMLImageElement < "u" && C instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && C instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && C instanceof ImageBitmap) {
        const re = S ? Bs : Math.floor, ye = re(te * C.width), j = re(te * C.height);
        p === void 0 && (p = _(ye, j));
        const pe = Z ? _(ye, j) : p;
        return pe.width = ye, pe.height = j, pe.getContext("2d").drawImage(C, 0, 0, ye, j), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + C.width + "x" + C.height + ") to (" + ye + "x" + j + ")."), pe;
      } else
        return "data" in C && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + C.width + "x" + C.height + ")."), C;
    return C;
  }
  function x(C) {
    return $s(C.width) && $s(C.height);
  }
  function M(C) {
    return r ? !1 : C.wrapS !== 1001 || C.wrapT !== 1001 || C.minFilter !== 1003 && C.minFilter !== 1006;
  }
  function E(C, S) {
    return C.generateMipmaps && S && C.minFilter !== 1003 && C.minFilter !== 1006;
  }
  function R(C) {
    h.generateMipmap(C);
  }
  function y(C, S, Z, Q, te = !1) {
    if (r === !1)
      return S;
    if (C !== null) {
      if (h[C] !== void 0)
        return h[C];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + C + "'");
    }
    let re = S;
    return S === 6403 && (Z === 5126 && (re = 33326), Z === 5131 && (re = 33325), Z === 5121 && (re = 33321)), S === 33319 && (Z === 5126 && (re = 33328), Z === 5131 && (re = 33327), Z === 5121 && (re = 33323)), S === 6408 && (Z === 5126 && (re = 34836), Z === 5131 && (re = 34842), Z === 5121 && (re = Q === 3001 && te === !1 ? 35907 : 32856), Z === 32819 && (re = 32854), Z === 32820 && (re = 32855)), (re === 33325 || re === 33326 || re === 33327 || re === 33328 || re === 34842 || re === 34836) && e.get("EXT_color_buffer_float"), re;
  }
  function A(C, S, Z) {
    return E(C, Z) === !0 || C.isFramebufferTexture && C.minFilter !== 1003 && C.minFilter !== 1006 ? Math.log2(Math.max(S.width, S.height)) + 1 : C.mipmaps !== void 0 && C.mipmaps.length > 0 ? C.mipmaps.length : C.isCompressedTexture && Array.isArray(C.image) ? S.mipmaps.length : 1;
  }
  function F(C) {
    return C === 1003 || C === 1004 || C === 1005 ? 9728 : 9729;
  }
  function P(C) {
    const S = C.target;
    S.removeEventListener("dispose", P), z(S), S.isVideoTexture && g.delete(S);
  }
  function G(C) {
    const S = C.target;
    S.removeEventListener("dispose", G), I(S);
  }
  function z(C) {
    const S = n.get(C);
    if (S.__webglInit === void 0)
      return;
    const Z = C.source, Q = f.get(Z);
    if (Q) {
      const te = Q[S.__cacheKey];
      te.usedTimes--, te.usedTimes === 0 && L(C), Object.keys(Q).length === 0 && f.delete(Z);
    }
    n.remove(C);
  }
  function L(C) {
    const S = n.get(C);
    h.deleteTexture(S.__webglTexture);
    const Z = C.source, Q = f.get(Z);
    delete Q[S.__cacheKey], o.memory.textures--;
  }
  function I(C) {
    const S = C.texture, Z = n.get(C), Q = n.get(S);
    if (Q.__webglTexture !== void 0 && (h.deleteTexture(Q.__webglTexture), o.memory.textures--), C.depthTexture && C.depthTexture.dispose(), C.isWebGLCubeRenderTarget)
      for (let te = 0; te < 6; te++)
        h.deleteFramebuffer(Z.__webglFramebuffer[te]), Z.__webglDepthbuffer && h.deleteRenderbuffer(Z.__webglDepthbuffer[te]);
    else {
      if (h.deleteFramebuffer(Z.__webglFramebuffer), Z.__webglDepthbuffer && h.deleteRenderbuffer(Z.__webglDepthbuffer), Z.__webglMultisampledFramebuffer && h.deleteFramebuffer(Z.__webglMultisampledFramebuffer), Z.__webglColorRenderbuffer)
        for (let te = 0; te < Z.__webglColorRenderbuffer.length; te++)
          Z.__webglColorRenderbuffer[te] && h.deleteRenderbuffer(Z.__webglColorRenderbuffer[te]);
      Z.__webglDepthRenderbuffer && h.deleteRenderbuffer(Z.__webglDepthRenderbuffer);
    }
    if (C.isWebGLMultipleRenderTargets)
      for (let te = 0, re = S.length; te < re; te++) {
        const ye = n.get(S[te]);
        ye.__webglTexture && (h.deleteTexture(ye.__webglTexture), o.memory.textures--), n.remove(S[te]);
      }
    n.remove(S), n.remove(C);
  }
  let D = 0;
  function q() {
    D = 0;
  }
  function k() {
    const C = D;
    return C >= l && console.warn("THREE.WebGLTextures: Trying to use " + C + " texture units while this GPU supports only " + l), D += 1, C;
  }
  function N(C) {
    const S = [];
    return S.push(C.wrapS), S.push(C.wrapT), S.push(C.magFilter), S.push(C.minFilter), S.push(C.anisotropy), S.push(C.internalFormat), S.push(C.format), S.push(C.type), S.push(C.generateMipmaps), S.push(C.premultiplyAlpha), S.push(C.flipY), S.push(C.unpackAlignment), S.push(C.encoding), S.join();
  }
  function H(C, S) {
    const Z = n.get(C);
    if (C.isVideoTexture && Gt(C), C.isRenderTargetTexture === !1 && C.version > 0 && Z.__version !== C.version) {
      const Q = C.image;
      if (Q === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Q.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ve(Z, C, S);
        return;
      }
    }
    t.activeTexture(33984 + S), t.bindTexture(3553, Z.__webglTexture);
  }
  function J(C, S) {
    const Z = n.get(C);
    if (C.version > 0 && Z.__version !== C.version) {
      ve(Z, C, S);
      return;
    }
    t.activeTexture(33984 + S), t.bindTexture(35866, Z.__webglTexture);
  }
  function V(C, S) {
    const Z = n.get(C);
    if (C.version > 0 && Z.__version !== C.version) {
      ve(Z, C, S);
      return;
    }
    t.activeTexture(33984 + S), t.bindTexture(32879, Z.__webglTexture);
  }
  function ee(C, S) {
    const Z = n.get(C);
    if (C.version > 0 && Z.__version !== C.version) {
      xe(Z, C, S);
      return;
    }
    t.activeTexture(33984 + S), t.bindTexture(34067, Z.__webglTexture);
  }
  const ce = {
    [1e3]: 10497,
    [1001]: 33071,
    [1002]: 33648
  }, ge = {
    [1003]: 9728,
    [1004]: 9984,
    [1005]: 9986,
    [1006]: 9729,
    [1007]: 9985,
    [1008]: 9987
  };
  function $(C, S, Z) {
    if (Z ? (h.texParameteri(C, 10242, ce[S.wrapS]), h.texParameteri(C, 10243, ce[S.wrapT]), (C === 32879 || C === 35866) && h.texParameteri(C, 32882, ce[S.wrapR]), h.texParameteri(C, 10240, ge[S.magFilter]), h.texParameteri(C, 10241, ge[S.minFilter])) : (h.texParameteri(C, 10242, 33071), h.texParameteri(C, 10243, 33071), (C === 32879 || C === 35866) && h.texParameteri(C, 32882, 33071), (S.wrapS !== 1001 || S.wrapT !== 1001) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), h.texParameteri(C, 10240, F(S.magFilter)), h.texParameteri(C, 10241, F(S.minFilter)), S.minFilter !== 1003 && S.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const Q = e.get("EXT_texture_filter_anisotropic");
      if (S.type === 1015 && e.has("OES_texture_float_linear") === !1 || r === !1 && S.type === 1016 && e.has("OES_texture_half_float_linear") === !1)
        return;
      (S.anisotropy > 1 || n.get(S).__currentAnisotropy) && (h.texParameterf(C, Q.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(S.anisotropy, i.getMaxAnisotropy())), n.get(S).__currentAnisotropy = S.anisotropy);
    }
  }
  function De(C, S) {
    let Z = !1;
    C.__webglInit === void 0 && (C.__webglInit = !0, S.addEventListener("dispose", P));
    const Q = S.source;
    let te = f.get(Q);
    te === void 0 && (te = {}, f.set(Q, te));
    const re = N(S);
    if (re !== C.__cacheKey) {
      te[re] === void 0 && (te[re] = {
        texture: h.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, Z = !0), te[re].usedTimes++;
      const ye = te[C.__cacheKey];
      ye !== void 0 && (te[C.__cacheKey].usedTimes--, ye.usedTimes === 0 && L(S)), C.__cacheKey = re, C.__webglTexture = te[re].texture;
    }
    return Z;
  }
  function ve(C, S, Z) {
    let Q = 3553;
    S.isDataArrayTexture && (Q = 35866), S.isData3DTexture && (Q = 32879);
    const te = De(C, S), re = S.source;
    if (t.activeTexture(33984 + Z), t.bindTexture(Q, C.__webglTexture), re.version !== re.__currentVersion || te === !0) {
      h.pixelStorei(37440, S.flipY), h.pixelStorei(37441, S.premultiplyAlpha), h.pixelStorei(3317, S.unpackAlignment), h.pixelStorei(37443, 0);
      const ye = M(S) && x(S.image) === !1;
      let j = w(S.image, ye, !1, c);
      j = Ft(S, j);
      const pe = x(j) || r, he = s.convert(S.format, S.encoding);
      let fe = s.convert(S.type), de = y(S.internalFormat, he, fe, S.encoding, S.isVideoTexture);
      $(Q, S, pe);
      let we;
      const Ie = S.mipmaps, We = r && S.isVideoTexture !== !0, B = re.__currentVersion === void 0 || te === !0, ae = A(S, j, pe);
      if (S.isDepthTexture)
        de = 6402, r ? S.type === 1015 ? de = 36012 : S.type === 1014 ? de = 33190 : S.type === 1020 ? de = 35056 : de = 33189 : S.type === 1015 && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), S.format === 1026 && de === 6402 && S.type !== 1012 && S.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), S.type = 1014, fe = s.convert(S.type)), S.format === 1027 && de === 6402 && (de = 34041, S.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), S.type = 1020, fe = s.convert(S.type))), B && (We ? t.texStorage2D(3553, 1, de, j.width, j.height) : t.texImage2D(3553, 0, de, j.width, j.height, 0, he, fe, null));
      else if (S.isDataTexture)
        if (Ie.length > 0 && pe) {
          We && B && t.texStorage2D(3553, ae, de, Ie[0].width, Ie[0].height);
          for (let Y = 0, oe = Ie.length; Y < oe; Y++)
            we = Ie[Y], We ? t.texSubImage2D(3553, Y, 0, 0, we.width, we.height, he, fe, we.data) : t.texImage2D(3553, Y, de, we.width, we.height, 0, he, fe, we.data);
          S.generateMipmaps = !1;
        } else
          We ? (B && t.texStorage2D(3553, ae, de, j.width, j.height), t.texSubImage2D(3553, 0, 0, 0, j.width, j.height, he, fe, j.data)) : t.texImage2D(3553, 0, de, j.width, j.height, 0, he, fe, j.data);
      else if (S.isCompressedTexture) {
        We && B && t.texStorage2D(3553, ae, de, Ie[0].width, Ie[0].height);
        for (let Y = 0, oe = Ie.length; Y < oe; Y++)
          we = Ie[Y], S.format !== 1023 ? he !== null ? We ? t.compressedTexSubImage2D(3553, Y, 0, 0, we.width, we.height, he, we.data) : t.compressedTexImage2D(3553, Y, de, we.width, we.height, 0, we.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : We ? t.texSubImage2D(3553, Y, 0, 0, we.width, we.height, he, fe, we.data) : t.texImage2D(3553, Y, de, we.width, we.height, 0, he, fe, we.data);
      } else if (S.isDataArrayTexture)
        We ? (B && t.texStorage3D(35866, ae, de, j.width, j.height, j.depth), t.texSubImage3D(35866, 0, 0, 0, 0, j.width, j.height, j.depth, he, fe, j.data)) : t.texImage3D(35866, 0, de, j.width, j.height, j.depth, 0, he, fe, j.data);
      else if (S.isData3DTexture)
        We ? (B && t.texStorage3D(32879, ae, de, j.width, j.height, j.depth), t.texSubImage3D(32879, 0, 0, 0, 0, j.width, j.height, j.depth, he, fe, j.data)) : t.texImage3D(32879, 0, de, j.width, j.height, j.depth, 0, he, fe, j.data);
      else if (S.isFramebufferTexture) {
        if (B)
          if (We)
            t.texStorage2D(3553, ae, de, j.width, j.height);
          else {
            let Y = j.width, oe = j.height;
            for (let se = 0; se < ae; se++)
              t.texImage2D(3553, se, de, Y, oe, 0, he, fe, null), Y >>= 1, oe >>= 1;
          }
      } else if (Ie.length > 0 && pe) {
        We && B && t.texStorage2D(3553, ae, de, Ie[0].width, Ie[0].height);
        for (let Y = 0, oe = Ie.length; Y < oe; Y++)
          we = Ie[Y], We ? t.texSubImage2D(3553, Y, 0, 0, he, fe, we) : t.texImage2D(3553, Y, de, he, fe, we);
        S.generateMipmaps = !1;
      } else
        We ? (B && t.texStorage2D(3553, ae, de, j.width, j.height), t.texSubImage2D(3553, 0, 0, 0, he, fe, j)) : t.texImage2D(3553, 0, de, he, fe, j);
      E(S, pe) && R(Q), re.__currentVersion = re.version, S.onUpdate && S.onUpdate(S);
    }
    C.__version = S.version;
  }
  function xe(C, S, Z) {
    if (S.image.length !== 6)
      return;
    const Q = De(C, S), te = S.source;
    if (t.activeTexture(33984 + Z), t.bindTexture(34067, C.__webglTexture), te.version !== te.__currentVersion || Q === !0) {
      h.pixelStorei(37440, S.flipY), h.pixelStorei(37441, S.premultiplyAlpha), h.pixelStorei(3317, S.unpackAlignment), h.pixelStorei(37443, 0);
      const re = S.isCompressedTexture || S.image[0].isCompressedTexture, ye = S.image[0] && S.image[0].isDataTexture, j = [];
      for (let Y = 0; Y < 6; Y++)
        !re && !ye ? j[Y] = w(S.image[Y], !1, !0, a) : j[Y] = ye ? S.image[Y].image : S.image[Y], j[Y] = Ft(S, j[Y]);
      const pe = j[0], he = x(pe) || r, fe = s.convert(S.format, S.encoding), de = s.convert(S.type), we = y(S.internalFormat, fe, de, S.encoding), Ie = r && S.isVideoTexture !== !0, We = te.__currentVersion === void 0 || Q === !0;
      let B = A(S, pe, he);
      $(34067, S, he);
      let ae;
      if (re) {
        Ie && We && t.texStorage2D(34067, B, we, pe.width, pe.height);
        for (let Y = 0; Y < 6; Y++) {
          ae = j[Y].mipmaps;
          for (let oe = 0; oe < ae.length; oe++) {
            const se = ae[oe];
            S.format !== 1023 ? fe !== null ? Ie ? t.compressedTexSubImage2D(34069 + Y, oe, 0, 0, se.width, se.height, fe, se.data) : t.compressedTexImage2D(34069 + Y, oe, we, se.width, se.height, 0, se.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ie ? t.texSubImage2D(34069 + Y, oe, 0, 0, se.width, se.height, fe, de, se.data) : t.texImage2D(34069 + Y, oe, we, se.width, se.height, 0, fe, de, se.data);
          }
        }
      } else {
        ae = S.mipmaps, Ie && We && (ae.length > 0 && B++, t.texStorage2D(34067, B, we, j[0].width, j[0].height));
        for (let Y = 0; Y < 6; Y++)
          if (ye) {
            Ie ? t.texSubImage2D(34069 + Y, 0, 0, 0, j[Y].width, j[Y].height, fe, de, j[Y].data) : t.texImage2D(34069 + Y, 0, we, j[Y].width, j[Y].height, 0, fe, de, j[Y].data);
            for (let oe = 0; oe < ae.length; oe++) {
              const Re = ae[oe].image[Y].image;
              Ie ? t.texSubImage2D(34069 + Y, oe + 1, 0, 0, Re.width, Re.height, fe, de, Re.data) : t.texImage2D(34069 + Y, oe + 1, we, Re.width, Re.height, 0, fe, de, Re.data);
            }
          } else {
            Ie ? t.texSubImage2D(34069 + Y, 0, 0, 0, fe, de, j[Y]) : t.texImage2D(34069 + Y, 0, we, fe, de, j[Y]);
            for (let oe = 0; oe < ae.length; oe++) {
              const se = ae[oe];
              Ie ? t.texSubImage2D(34069 + Y, oe + 1, 0, 0, fe, de, se.image[Y]) : t.texImage2D(34069 + Y, oe + 1, we, fe, de, se.image[Y]);
            }
          }
      }
      E(S, he) && R(34067), te.__currentVersion = te.version, S.onUpdate && S.onUpdate(S);
    }
    C.__version = S.version;
  }
  function ue(C, S, Z, Q, te) {
    const re = s.convert(Z.format, Z.encoding), ye = s.convert(Z.type), j = y(Z.internalFormat, re, ye, Z.encoding);
    n.get(S).__hasExternalTextures || (te === 32879 || te === 35866 ? t.texImage3D(te, 0, j, S.width, S.height, S.depth, 0, re, ye, null) : t.texImage2D(te, 0, j, S.width, S.height, 0, re, ye, null)), t.bindFramebuffer(36160, C), Ne(S) ? u.framebufferTexture2DMultisampleEXT(36160, Q, te, n.get(Z).__webglTexture, 0, tt(S)) : h.framebufferTexture2D(36160, Q, te, n.get(Z).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function Oe(C, S, Z) {
    if (h.bindRenderbuffer(36161, C), S.depthBuffer && !S.stencilBuffer) {
      let Q = 33189;
      if (Z || Ne(S)) {
        const te = S.depthTexture;
        te && te.isDepthTexture && (te.type === 1015 ? Q = 36012 : te.type === 1014 && (Q = 33190));
        const re = tt(S);
        Ne(S) ? u.renderbufferStorageMultisampleEXT(36161, re, Q, S.width, S.height) : h.renderbufferStorageMultisample(36161, re, Q, S.width, S.height);
      } else
        h.renderbufferStorage(36161, Q, S.width, S.height);
      h.framebufferRenderbuffer(36160, 36096, 36161, C);
    } else if (S.depthBuffer && S.stencilBuffer) {
      const Q = tt(S);
      Z && Ne(S) === !1 ? h.renderbufferStorageMultisample(36161, Q, 35056, S.width, S.height) : Ne(S) ? u.renderbufferStorageMultisampleEXT(36161, Q, 35056, S.width, S.height) : h.renderbufferStorage(36161, 34041, S.width, S.height), h.framebufferRenderbuffer(36160, 33306, 36161, C);
    } else {
      const Q = S.isWebGLMultipleRenderTargets === !0 ? S.texture : [S.texture];
      for (let te = 0; te < Q.length; te++) {
        const re = Q[te], ye = s.convert(re.format, re.encoding), j = s.convert(re.type), pe = y(re.internalFormat, ye, j, re.encoding), he = tt(S);
        Z && Ne(S) === !1 ? h.renderbufferStorageMultisample(36161, he, pe, S.width, S.height) : Ne(S) ? u.renderbufferStorageMultisampleEXT(36161, he, pe, S.width, S.height) : h.renderbufferStorage(36161, pe, S.width, S.height);
      }
    }
    h.bindRenderbuffer(36161, null);
  }
  function Ee(C, S) {
    if (S && S.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, C), !(S.depthTexture && S.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(S.depthTexture).__webglTexture || S.depthTexture.image.width !== S.width || S.depthTexture.image.height !== S.height) && (S.depthTexture.image.width = S.width, S.depthTexture.image.height = S.height, S.depthTexture.needsUpdate = !0), H(S.depthTexture, 0);
    const Q = n.get(S.depthTexture).__webglTexture, te = tt(S);
    if (S.depthTexture.format === 1026)
      Ne(S) ? u.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Q, 0, te) : h.framebufferTexture2D(36160, 36096, 3553, Q, 0);
    else if (S.depthTexture.format === 1027)
      Ne(S) ? u.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Q, 0, te) : h.framebufferTexture2D(36160, 33306, 3553, Q, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function me(C) {
    const S = n.get(C), Z = C.isWebGLCubeRenderTarget === !0;
    if (C.depthTexture && !S.__autoAllocateDepthBuffer) {
      if (Z)
        throw new Error("target.depthTexture not supported in Cube render targets");
      Ee(S.__webglFramebuffer, C);
    } else if (Z) {
      S.__webglDepthbuffer = [];
      for (let Q = 0; Q < 6; Q++)
        t.bindFramebuffer(36160, S.__webglFramebuffer[Q]), S.__webglDepthbuffer[Q] = h.createRenderbuffer(), Oe(S.__webglDepthbuffer[Q], C, !1);
    } else
      t.bindFramebuffer(36160, S.__webglFramebuffer), S.__webglDepthbuffer = h.createRenderbuffer(), Oe(S.__webglDepthbuffer, C, !1);
    t.bindFramebuffer(36160, null);
  }
  function et(C, S, Z) {
    const Q = n.get(C);
    S !== void 0 && ue(Q.__webglFramebuffer, C, C.texture, 36064, 3553), Z !== void 0 && me(C);
  }
  function ut(C) {
    const S = C.texture, Z = n.get(C), Q = n.get(S);
    C.addEventListener("dispose", G), C.isWebGLMultipleRenderTargets !== !0 && (Q.__webglTexture === void 0 && (Q.__webglTexture = h.createTexture()), Q.__version = S.version, o.memory.textures++);
    const te = C.isWebGLCubeRenderTarget === !0, re = C.isWebGLMultipleRenderTargets === !0, ye = x(C) || r;
    if (te) {
      Z.__webglFramebuffer = [];
      for (let j = 0; j < 6; j++)
        Z.__webglFramebuffer[j] = h.createFramebuffer();
    } else {
      if (Z.__webglFramebuffer = h.createFramebuffer(), re)
        if (i.drawBuffers) {
          const j = C.texture;
          for (let pe = 0, he = j.length; pe < he; pe++) {
            const fe = n.get(j[pe]);
            fe.__webglTexture === void 0 && (fe.__webglTexture = h.createTexture(), o.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (r && C.samples > 0 && Ne(C) === !1) {
        const j = re ? S : [S];
        Z.__webglMultisampledFramebuffer = h.createFramebuffer(), Z.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, Z.__webglMultisampledFramebuffer);
        for (let pe = 0; pe < j.length; pe++) {
          const he = j[pe];
          Z.__webglColorRenderbuffer[pe] = h.createRenderbuffer(), h.bindRenderbuffer(36161, Z.__webglColorRenderbuffer[pe]);
          const fe = s.convert(he.format, he.encoding), de = s.convert(he.type), we = y(he.internalFormat, fe, de, he.encoding), Ie = tt(C);
          h.renderbufferStorageMultisample(36161, Ie, we, C.width, C.height), h.framebufferRenderbuffer(36160, 36064 + pe, 36161, Z.__webglColorRenderbuffer[pe]);
        }
        h.bindRenderbuffer(36161, null), C.depthBuffer && (Z.__webglDepthRenderbuffer = h.createRenderbuffer(), Oe(Z.__webglDepthRenderbuffer, C, !0)), t.bindFramebuffer(36160, null);
      }
    }
    if (te) {
      t.bindTexture(34067, Q.__webglTexture), $(34067, S, ye);
      for (let j = 0; j < 6; j++)
        ue(Z.__webglFramebuffer[j], C, S, 36064, 34069 + j);
      E(S, ye) && R(34067), t.unbindTexture();
    } else if (re) {
      const j = C.texture;
      for (let pe = 0, he = j.length; pe < he; pe++) {
        const fe = j[pe], de = n.get(fe);
        t.bindTexture(3553, de.__webglTexture), $(3553, fe, ye), ue(Z.__webglFramebuffer, C, fe, 36064 + pe, 3553), E(fe, ye) && R(3553);
      }
      t.unbindTexture();
    } else {
      let j = 3553;
      (C.isWebGL3DRenderTarget || C.isWebGLArrayRenderTarget) && (r ? j = C.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(j, Q.__webglTexture), $(j, S, ye), ue(Z.__webglFramebuffer, C, S, 36064, j), E(S, ye) && R(j), t.unbindTexture();
    }
    C.depthBuffer && me(C);
  }
  function rt(C) {
    const S = x(C) || r, Z = C.isWebGLMultipleRenderTargets === !0 ? C.texture : [C.texture];
    for (let Q = 0, te = Z.length; Q < te; Q++) {
      const re = Z[Q];
      if (E(re, S)) {
        const ye = C.isWebGLCubeRenderTarget ? 34067 : 3553, j = n.get(re).__webglTexture;
        t.bindTexture(ye, j), R(ye), t.unbindTexture();
      }
    }
  }
  function Rt(C) {
    if (r && C.samples > 0 && Ne(C) === !1) {
      const S = C.isWebGLMultipleRenderTargets ? C.texture : [C.texture], Z = C.width, Q = C.height;
      let te = 16384;
      const re = [], ye = C.stencilBuffer ? 33306 : 36096, j = n.get(C), pe = C.isWebGLMultipleRenderTargets === !0;
      if (pe)
        for (let he = 0; he < S.length; he++)
          t.bindFramebuffer(36160, j.__webglMultisampledFramebuffer), h.framebufferRenderbuffer(36160, 36064 + he, 36161, null), t.bindFramebuffer(36160, j.__webglFramebuffer), h.framebufferTexture2D(36009, 36064 + he, 3553, null, 0);
      t.bindFramebuffer(36008, j.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, j.__webglFramebuffer);
      for (let he = 0; he < S.length; he++) {
        re.push(36064 + he), C.depthBuffer && re.push(ye);
        const fe = j.__ignoreDepthValues !== void 0 ? j.__ignoreDepthValues : !1;
        if (fe === !1 && (C.depthBuffer && (te |= 256), C.stencilBuffer && (te |= 1024)), pe && h.framebufferRenderbuffer(36008, 36064, 36161, j.__webglColorRenderbuffer[he]), fe === !0 && (h.invalidateFramebuffer(36008, [ye]), h.invalidateFramebuffer(36009, [ye])), pe) {
          const de = n.get(S[he]).__webglTexture;
          h.framebufferTexture2D(36009, 36064, 3553, de, 0);
        }
        h.blitFramebuffer(0, 0, Z, Q, 0, 0, Z, Q, te, 9728), m && h.invalidateFramebuffer(36008, re);
      }
      if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), pe)
        for (let he = 0; he < S.length; he++) {
          t.bindFramebuffer(36160, j.__webglMultisampledFramebuffer), h.framebufferRenderbuffer(36160, 36064 + he, 36161, j.__webglColorRenderbuffer[he]);
          const fe = n.get(S[he]).__webglTexture;
          t.bindFramebuffer(36160, j.__webglFramebuffer), h.framebufferTexture2D(36009, 36064 + he, 3553, fe, 0);
        }
      t.bindFramebuffer(36009, j.__webglMultisampledFramebuffer);
    }
  }
  function tt(C) {
    return Math.min(d, C.samples);
  }
  function Ne(C) {
    const S = n.get(C);
    return r && C.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && S.__useRenderToTexture !== !1;
  }
  function Gt(C) {
    const S = o.render.frame;
    g.get(C) !== S && (g.set(C, S), C.update());
  }
  function Ft(C, S) {
    const Z = C.encoding, Q = C.format, te = C.type;
    return C.isCompressedTexture === !0 || C.isVideoTexture === !0 || C.format === 1035 || Z !== 3e3 && (Z === 3001 ? r === !1 ? e.has("EXT_sRGB") === !0 && Q === 1023 ? (C.format = 1035, C.minFilter = 1006, C.generateMipmaps = !1) : S = io.sRGBToLinear(S) : (Q !== 1023 || te !== 1009) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", Z)), S;
  }
  this.allocateTextureUnit = k, this.resetTextureUnits = q, this.setTexture2D = H, this.setTexture2DArray = J, this.setTexture3D = V, this.setTextureCube = ee, this.rebindTextures = et, this.setupRenderTarget = ut, this.updateRenderTargetMipmap = rt, this.updateMultisampleRenderTarget = Rt, this.setupDepthRenderbuffer = me, this.setupFrameBufferTexture = ue, this.useMultisampledRTT = Ne;
}
function Cu(h, e, t) {
  const n = t.isWebGL2;
  function i(s, o = null) {
    let r;
    if (s === 1009)
      return 5121;
    if (s === 1017)
      return 32819;
    if (s === 1018)
      return 32820;
    if (s === 1010)
      return 5120;
    if (s === 1011)
      return 5122;
    if (s === 1012)
      return 5123;
    if (s === 1013)
      return 5124;
    if (s === 1014)
      return 5125;
    if (s === 1015)
      return 5126;
    if (s === 1016)
      return n ? 5131 : (r = e.get("OES_texture_half_float"), r !== null ? r.HALF_FLOAT_OES : null);
    if (s === 1021)
      return 6406;
    if (s === 1023)
      return 6408;
    if (s === 1024)
      return 6409;
    if (s === 1025)
      return 6410;
    if (s === 1026)
      return 6402;
    if (s === 1027)
      return 34041;
    if (s === 1028)
      return 6403;
    if (s === 1022)
      return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (s === 1035)
      return r = e.get("EXT_sRGB"), r !== null ? r.SRGB_ALPHA_EXT : null;
    if (s === 1029)
      return 36244;
    if (s === 1030)
      return 33319;
    if (s === 1031)
      return 33320;
    if (s === 1033)
      return 36249;
    if (s === 33776 || s === 33777 || s === 33778 || s === 33779)
      if (o === 3001)
        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
          if (s === 33776)
            return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === 33777)
            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === 33778)
            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === 33779)
            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
        if (s === 33776)
          return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === 33777)
          return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === 33778)
          return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === 33779)
          return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === 35840 || s === 35841 || s === 35842 || s === 35843)
      if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
        if (s === 35840)
          return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === 35841)
          return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === 35842)
          return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === 35843)
          return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === 36196)
      return r = e.get("WEBGL_compressed_texture_etc1"), r !== null ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === 37492 || s === 37496)
      if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
        if (s === 37492)
          return o === 3001 ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (s === 37496)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === 37808 || s === 37809 || s === 37810 || s === 37811 || s === 37812 || s === 37813 || s === 37814 || s === 37815 || s === 37816 || s === 37817 || s === 37818 || s === 37819 || s === 37820 || s === 37821)
      if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
        if (s === 37808)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === 37809)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === 37810)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === 37811)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === 37812)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === 37813)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === 37814)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === 37815)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === 37816)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === 37817)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === 37818)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === 37819)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === 37820)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === 37821)
          return o === 3001 ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === 36492)
      if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
        if (s === 36492)
          return o === 3001 ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    return s === 1020 ? n ? 34042 : (r = e.get("WEBGL_depth_texture"), r !== null ? r.UNSIGNED_INT_24_8_WEBGL : null) : h[s] !== void 0 ? h[s] : null;
  }
  return { convert: i };
}
class Lu extends gt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Bi extends at {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const Ru = { type: "move" };
class Ts {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Bi(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Bi(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new O(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new O()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Bi(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new O(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new O()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let i = null, s = null, o = null;
    const r = this._targetRay, l = this._grip, a = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (a && e.hand) {
        o = !0;
        for (const p of e.hand.values()) {
          const f = t.getJointPose(p, n);
          if (a.joints[p.jointName] === void 0) {
            const _ = new Bi();
            _.matrixAutoUpdate = !1, _.visible = !1, a.joints[p.jointName] = _, a.add(_);
          }
          const v = a.joints[p.jointName];
          f !== null && (v.matrix.fromArray(f.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.jointRadius = f.radius), v.visible = f !== null;
        }
        const c = a.joints["index-finger-tip"], d = a.joints["thumb-tip"], u = c.position.distanceTo(d.position), m = 0.02, g = 5e-3;
        a.inputState.pinching && u > m + g ? (a.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !a.inputState.pinching && u <= m - g && (a.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
      r !== null && (i = t.getPose(e.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (r.matrix.fromArray(i.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), i.linearVelocity ? (r.hasLinearVelocity = !0, r.linearVelocity.copy(i.linearVelocity)) : r.hasLinearVelocity = !1, i.angularVelocity ? (r.hasAngularVelocity = !0, r.angularVelocity.copy(i.angularVelocity)) : r.hasAngularVelocity = !1, this.dispatchEvent(Ru)));
    }
    return r !== null && (r.visible = i !== null), l !== null && (l.visible = s !== null), a !== null && (a.visible = o !== null), this;
  }
}
class Fu extends _t {
  constructor(e, t, n, i, s, o, r, l, a, c) {
    if (c = c !== void 0 ? c : 1026, c !== 1026 && c !== 1027)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && c === 1026 && (n = 1014), n === void 0 && c === 1027 && (n = 1020), super(null, i, s, o, r, l, c, n, a), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = r !== void 0 ? r : 1003, this.minFilter = l !== void 0 ? l : 1003, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Du extends $n {
  constructor(e, t) {
    super();
    const n = this;
    let i = null, s = 1, o = null, r = "local-floor", l = null, a = null, c = null, d = null, u = null, m = null;
    const g = t.getContextAttributes();
    let p = null, f = null;
    const v = [], _ = [], w = new gt();
    w.layers.enable(1), w.viewport = new $e();
    const x = new gt();
    x.layers.enable(2), x.viewport = new $e();
    const M = [w, x], E = new Lu();
    E.layers.enable(1), E.layers.enable(2);
    let R = null, y = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(N) {
      let H = v[N];
      return H === void 0 && (H = new Ts(), v[N] = H), H.getTargetRaySpace();
    }, this.getControllerGrip = function(N) {
      let H = v[N];
      return H === void 0 && (H = new Ts(), v[N] = H), H.getGripSpace();
    }, this.getHand = function(N) {
      let H = v[N];
      return H === void 0 && (H = new Ts(), v[N] = H), H.getHandSpace();
    };
    function A(N) {
      const H = _.indexOf(N.inputSource);
      if (H === -1)
        return;
      const J = v[H];
      J !== void 0 && J.dispatchEvent({ type: N.type, data: N.inputSource });
    }
    function F() {
      i.removeEventListener("select", A), i.removeEventListener("selectstart", A), i.removeEventListener("selectend", A), i.removeEventListener("squeeze", A), i.removeEventListener("squeezestart", A), i.removeEventListener("squeezeend", A), i.removeEventListener("end", F), i.removeEventListener("inputsourceschange", P);
      for (let N = 0; N < v.length; N++) {
        const H = _[N];
        H !== null && (_[N] = null, v[N].disconnect(H));
      }
      R = null, y = null, e.setRenderTarget(p), u = null, d = null, c = null, i = null, f = null, k.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(N) {
      s = N, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(N) {
      r = N, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return l || o;
    }, this.setReferenceSpace = function(N) {
      l = N;
    }, this.getBaseLayer = function() {
      return d !== null ? d : u;
    }, this.getBinding = function() {
      return c;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(N) {
      if (i = N, i !== null) {
        if (p = e.getRenderTarget(), i.addEventListener("select", A), i.addEventListener("selectstart", A), i.addEventListener("selectend", A), i.addEventListener("squeeze", A), i.addEventListener("squeezestart", A), i.addEventListener("squeezeend", A), i.addEventListener("end", F), i.addEventListener("inputsourceschange", P), g.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const H = {
            antialias: i.renderState.layers === void 0 ? g.antialias : !0,
            alpha: g.alpha,
            depth: g.depth,
            stencil: g.stencil,
            framebufferScaleFactor: s
          };
          u = new XRWebGLLayer(i, t, H), i.updateRenderState({ baseLayer: u }), f = new En(
            u.framebufferWidth,
            u.framebufferHeight,
            {
              format: 1023,
              type: 1009,
              encoding: e.outputEncoding
            }
          );
        } else {
          let H = null, J = null, V = null;
          g.depth && (V = g.stencil ? 35056 : 33190, H = g.stencil ? 1027 : 1026, J = g.stencil ? 1020 : 1014);
          const ee = {
            colorFormat: 32856,
            depthFormat: V,
            scaleFactor: s
          };
          c = new XRWebGLBinding(i, t), d = c.createProjectionLayer(ee), i.updateRenderState({ layers: [d] }), f = new En(
            d.textureWidth,
            d.textureHeight,
            {
              format: 1023,
              type: 1009,
              depthTexture: new Fu(d.textureWidth, d.textureHeight, J, void 0, void 0, void 0, void 0, void 0, void 0, H),
              stencilBuffer: g.stencil,
              encoding: e.outputEncoding,
              samples: g.antialias ? 4 : 0
            }
          );
          const ce = e.properties.get(f);
          ce.__ignoreDepthValues = d.ignoreDepthValues;
        }
        f.isXRRenderTarget = !0, this.setFoveation(1), l = null, o = await i.requestReferenceSpace(r), k.setContext(i), k.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    };
    function P(N) {
      for (let H = 0; H < N.removed.length; H++) {
        const J = N.removed[H], V = _.indexOf(J);
        V >= 0 && (_[V] = null, v[V].dispatchEvent({ type: "disconnected", data: J }));
      }
      for (let H = 0; H < N.added.length; H++) {
        const J = N.added[H];
        let V = _.indexOf(J);
        if (V === -1) {
          for (let ce = 0; ce < v.length; ce++)
            if (ce >= _.length) {
              _.push(J), V = ce;
              break;
            } else if (_[ce] === null) {
              _[ce] = J, V = ce;
              break;
            }
          if (V === -1)
            break;
        }
        const ee = v[V];
        ee && ee.dispatchEvent({ type: "connected", data: J });
      }
    }
    const G = new O(), z = new O();
    function L(N, H, J) {
      G.setFromMatrixPosition(H.matrixWorld), z.setFromMatrixPosition(J.matrixWorld);
      const V = G.distanceTo(z), ee = H.projectionMatrix.elements, ce = J.projectionMatrix.elements, ge = ee[14] / (ee[10] - 1), $ = ee[14] / (ee[10] + 1), De = (ee[9] + 1) / ee[5], ve = (ee[9] - 1) / ee[5], xe = (ee[8] - 1) / ee[0], ue = (ce[8] + 1) / ce[0], Oe = ge * xe, Ee = ge * ue, me = V / (-xe + ue), et = me * -xe;
      H.matrixWorld.decompose(N.position, N.quaternion, N.scale), N.translateX(et), N.translateZ(me), N.matrixWorld.compose(N.position, N.quaternion, N.scale), N.matrixWorldInverse.copy(N.matrixWorld).invert();
      const ut = ge + me, rt = $ + me, Rt = Oe - et, tt = Ee + (V - et), Ne = De * $ / rt * ut, Gt = ve * $ / rt * ut;
      N.projectionMatrix.makePerspective(Rt, tt, Ne, Gt, ut, rt);
    }
    function I(N, H) {
      H === null ? N.matrixWorld.copy(N.matrix) : N.matrixWorld.multiplyMatrices(H.matrixWorld, N.matrix), N.matrixWorldInverse.copy(N.matrixWorld).invert();
    }
    this.updateCamera = function(N) {
      if (i === null)
        return;
      E.near = x.near = w.near = N.near, E.far = x.far = w.far = N.far, (R !== E.near || y !== E.far) && (i.updateRenderState({
        depthNear: E.near,
        depthFar: E.far
      }), R = E.near, y = E.far);
      const H = N.parent, J = E.cameras;
      I(E, H);
      for (let ee = 0; ee < J.length; ee++)
        I(J[ee], H);
      E.matrixWorld.decompose(E.position, E.quaternion, E.scale), N.position.copy(E.position), N.quaternion.copy(E.quaternion), N.scale.copy(E.scale), N.matrix.copy(E.matrix), N.matrixWorld.copy(E.matrixWorld);
      const V = N.children;
      for (let ee = 0, ce = V.length; ee < ce; ee++)
        V[ee].updateMatrixWorld(!0);
      J.length === 2 ? L(E, w, x) : E.projectionMatrix.copy(w.projectionMatrix);
    }, this.getCamera = function() {
      return E;
    }, this.getFoveation = function() {
      if (d !== null)
        return d.fixedFoveation;
      if (u !== null)
        return u.fixedFoveation;
    }, this.setFoveation = function(N) {
      d !== null && (d.fixedFoveation = N), u !== null && u.fixedFoveation !== void 0 && (u.fixedFoveation = N);
    };
    let D = null;
    function q(N, H) {
      if (a = H.getViewerPose(l || o), m = H, a !== null) {
        const J = a.views;
        u !== null && (e.setRenderTargetFramebuffer(f, u.framebuffer), e.setRenderTarget(f));
        let V = !1;
        J.length !== E.cameras.length && (E.cameras.length = 0, V = !0);
        for (let ee = 0; ee < J.length; ee++) {
          const ce = J[ee];
          let ge = null;
          if (u !== null)
            ge = u.getViewport(ce);
          else {
            const De = c.getViewSubImage(d, ce);
            ge = De.viewport, ee === 0 && (e.setRenderTargetTextures(
              f,
              De.colorTexture,
              d.ignoreDepthValues ? void 0 : De.depthStencilTexture
            ), e.setRenderTarget(f));
          }
          let $ = M[ee];
          $ === void 0 && ($ = new gt(), $.layers.enable(ee), $.viewport = new $e(), M[ee] = $), $.matrix.fromArray(ce.transform.matrix), $.projectionMatrix.fromArray(ce.projectionMatrix), $.viewport.set(ge.x, ge.y, ge.width, ge.height), ee === 0 && E.matrix.copy($.matrix), V === !0 && E.cameras.push($);
        }
      }
      for (let J = 0; J < v.length; J++) {
        const V = _[J], ee = v[J];
        V !== null && ee !== void 0 && ee.update(V, H, l || o);
      }
      D && D(N, H), m = null;
    }
    const k = new fo();
    k.setAnimationLoop(q), this.setAnimationLoop = function(N) {
      D = N;
    }, this.dispose = function() {
    };
  }
}
function Pu(h, e) {
  function t(p, f) {
    p.fogColor.value.copy(f.color), f.isFog ? (p.fogNear.value = f.near, p.fogFar.value = f.far) : f.isFogExp2 && (p.fogDensity.value = f.density);
  }
  function n(p, f, v, _, w) {
    f.isMeshBasicMaterial || f.isMeshLambertMaterial ? i(p, f) : f.isMeshToonMaterial ? (i(p, f), c(p, f)) : f.isMeshPhongMaterial ? (i(p, f), a(p, f)) : f.isMeshStandardMaterial ? (i(p, f), d(p, f), f.isMeshPhysicalMaterial && u(p, f, w)) : f.isMeshMatcapMaterial ? (i(p, f), m(p, f)) : f.isMeshDepthMaterial ? i(p, f) : f.isMeshDistanceMaterial ? (i(p, f), g(p, f)) : f.isMeshNormalMaterial ? i(p, f) : f.isLineBasicMaterial ? (s(p, f), f.isLineDashedMaterial && o(p, f)) : f.isPointsMaterial ? r(p, f, v, _) : f.isSpriteMaterial ? l(p, f) : f.isShadowMaterial ? (p.color.value.copy(f.color), p.opacity.value = f.opacity) : f.isShaderMaterial && (f.uniformsNeedUpdate = !1);
  }
  function i(p, f) {
    p.opacity.value = f.opacity, f.color && p.diffuse.value.copy(f.color), f.emissive && p.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity), f.map && (p.map.value = f.map), f.alphaMap && (p.alphaMap.value = f.alphaMap), f.bumpMap && (p.bumpMap.value = f.bumpMap, p.bumpScale.value = f.bumpScale, f.side === 1 && (p.bumpScale.value *= -1)), f.displacementMap && (p.displacementMap.value = f.displacementMap, p.displacementScale.value = f.displacementScale, p.displacementBias.value = f.displacementBias), f.emissiveMap && (p.emissiveMap.value = f.emissiveMap), f.normalMap && (p.normalMap.value = f.normalMap, p.normalScale.value.copy(f.normalScale), f.side === 1 && p.normalScale.value.negate()), f.specularMap && (p.specularMap.value = f.specularMap), f.alphaTest > 0 && (p.alphaTest.value = f.alphaTest);
    const v = e.get(f).envMap;
    if (v && (p.envMap.value = v, p.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, p.reflectivity.value = f.reflectivity, p.ior.value = f.ior, p.refractionRatio.value = f.refractionRatio), f.lightMap) {
      p.lightMap.value = f.lightMap;
      const x = h.physicallyCorrectLights !== !0 ? Math.PI : 1;
      p.lightMapIntensity.value = f.lightMapIntensity * x;
    }
    f.aoMap && (p.aoMap.value = f.aoMap, p.aoMapIntensity.value = f.aoMapIntensity);
    let _;
    f.map ? _ = f.map : f.specularMap ? _ = f.specularMap : f.displacementMap ? _ = f.displacementMap : f.normalMap ? _ = f.normalMap : f.bumpMap ? _ = f.bumpMap : f.roughnessMap ? _ = f.roughnessMap : f.metalnessMap ? _ = f.metalnessMap : f.alphaMap ? _ = f.alphaMap : f.emissiveMap ? _ = f.emissiveMap : f.clearcoatMap ? _ = f.clearcoatMap : f.clearcoatNormalMap ? _ = f.clearcoatNormalMap : f.clearcoatRoughnessMap ? _ = f.clearcoatRoughnessMap : f.iridescenceMap ? _ = f.iridescenceMap : f.iridescenceThicknessMap ? _ = f.iridescenceThicknessMap : f.specularIntensityMap ? _ = f.specularIntensityMap : f.specularColorMap ? _ = f.specularColorMap : f.transmissionMap ? _ = f.transmissionMap : f.thicknessMap ? _ = f.thicknessMap : f.sheenColorMap ? _ = f.sheenColorMap : f.sheenRoughnessMap && (_ = f.sheenRoughnessMap), _ !== void 0 && (_.isWebGLRenderTarget && (_ = _.texture), _.matrixAutoUpdate === !0 && _.updateMatrix(), p.uvTransform.value.copy(_.matrix));
    let w;
    f.aoMap ? w = f.aoMap : f.lightMap && (w = f.lightMap), w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture), w.matrixAutoUpdate === !0 && w.updateMatrix(), p.uv2Transform.value.copy(w.matrix));
  }
  function s(p, f) {
    p.diffuse.value.copy(f.color), p.opacity.value = f.opacity;
  }
  function o(p, f) {
    p.dashSize.value = f.dashSize, p.totalSize.value = f.dashSize + f.gapSize, p.scale.value = f.scale;
  }
  function r(p, f, v, _) {
    p.diffuse.value.copy(f.color), p.opacity.value = f.opacity, p.size.value = f.size * v, p.scale.value = _ * 0.5, f.map && (p.map.value = f.map), f.alphaMap && (p.alphaMap.value = f.alphaMap), f.alphaTest > 0 && (p.alphaTest.value = f.alphaTest);
    let w;
    f.map ? w = f.map : f.alphaMap && (w = f.alphaMap), w !== void 0 && (w.matrixAutoUpdate === !0 && w.updateMatrix(), p.uvTransform.value.copy(w.matrix));
  }
  function l(p, f) {
    p.diffuse.value.copy(f.color), p.opacity.value = f.opacity, p.rotation.value = f.rotation, f.map && (p.map.value = f.map), f.alphaMap && (p.alphaMap.value = f.alphaMap), f.alphaTest > 0 && (p.alphaTest.value = f.alphaTest);
    let v;
    f.map ? v = f.map : f.alphaMap && (v = f.alphaMap), v !== void 0 && (v.matrixAutoUpdate === !0 && v.updateMatrix(), p.uvTransform.value.copy(v.matrix));
  }
  function a(p, f) {
    p.specular.value.copy(f.specular), p.shininess.value = Math.max(f.shininess, 1e-4);
  }
  function c(p, f) {
    f.gradientMap && (p.gradientMap.value = f.gradientMap);
  }
  function d(p, f) {
    p.roughness.value = f.roughness, p.metalness.value = f.metalness, f.roughnessMap && (p.roughnessMap.value = f.roughnessMap), f.metalnessMap && (p.metalnessMap.value = f.metalnessMap), e.get(f).envMap && (p.envMapIntensity.value = f.envMapIntensity);
  }
  function u(p, f, v) {
    p.ior.value = f.ior, f.sheen > 0 && (p.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen), p.sheenRoughness.value = f.sheenRoughness, f.sheenColorMap && (p.sheenColorMap.value = f.sheenColorMap), f.sheenRoughnessMap && (p.sheenRoughnessMap.value = f.sheenRoughnessMap)), f.clearcoat > 0 && (p.clearcoat.value = f.clearcoat, p.clearcoatRoughness.value = f.clearcoatRoughness, f.clearcoatMap && (p.clearcoatMap.value = f.clearcoatMap), f.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap), f.clearcoatNormalMap && (p.clearcoatNormalScale.value.copy(f.clearcoatNormalScale), p.clearcoatNormalMap.value = f.clearcoatNormalMap, f.side === 1 && p.clearcoatNormalScale.value.negate())), f.iridescence > 0 && (p.iridescence.value = f.iridescence, p.iridescenceIOR.value = f.iridescenceIOR, p.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0], p.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1], f.iridescenceMap && (p.iridescenceMap.value = f.iridescenceMap), f.iridescenceThicknessMap && (p.iridescenceThicknessMap.value = f.iridescenceThicknessMap)), f.transmission > 0 && (p.transmission.value = f.transmission, p.transmissionSamplerMap.value = v.texture, p.transmissionSamplerSize.value.set(v.width, v.height), f.transmissionMap && (p.transmissionMap.value = f.transmissionMap), p.thickness.value = f.thickness, f.thicknessMap && (p.thicknessMap.value = f.thicknessMap), p.attenuationDistance.value = f.attenuationDistance, p.attenuationColor.value.copy(f.attenuationColor)), p.specularIntensity.value = f.specularIntensity, p.specularColor.value.copy(f.specularColor), f.specularIntensityMap && (p.specularIntensityMap.value = f.specularIntensityMap), f.specularColorMap && (p.specularColorMap.value = f.specularColorMap);
  }
  function m(p, f) {
    f.matcap && (p.matcap.value = f.matcap);
  }
  function g(p, f) {
    p.referencePosition.value.copy(f.referencePosition), p.nearDistance.value = f.nearDistance, p.farDistance.value = f.farDistance;
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: n
  };
}
function Iu(h, e, t, n) {
  let i = {}, s = {}, o = [];
  const r = t.isWebGL2 ? h.getParameter(35375) : 0;
  function l(_, w) {
    const x = w.program;
    n.uniformBlockBinding(_, x);
  }
  function a(_, w) {
    let x = i[_.id];
    x === void 0 && (g(_), x = c(_), i[_.id] = x, _.addEventListener("dispose", f));
    const M = w.program;
    n.updateUBOMapping(_, M);
    const E = e.render.frame;
    s[_.id] !== E && (u(_), s[_.id] = E);
  }
  function c(_) {
    const w = d();
    _.__bindingPointIndex = w;
    const x = h.createBuffer(), M = _.__size, E = _.usage;
    return h.bindBuffer(35345, x), h.bufferData(35345, M, E), h.bindBuffer(35345, null), h.bindBufferBase(35345, w, x), x;
  }
  function d() {
    for (let _ = 0; _ < r; _++)
      if (o.indexOf(_) === -1)
        return o.push(_), _;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function u(_) {
    const w = i[_.id], x = _.uniforms, M = _.__cache;
    h.bindBuffer(35345, w);
    for (let E = 0, R = x.length; E < R; E++) {
      const y = x[E];
      if (m(y, E, M) === !0) {
        const A = y.value, F = y.__offset;
        typeof A == "number" ? (y.__data[0] = A, h.bufferSubData(35345, F, y.__data)) : (y.value.isMatrix3 ? (y.__data[0] = y.value.elements[0], y.__data[1] = y.value.elements[1], y.__data[2] = y.value.elements[2], y.__data[3] = y.value.elements[0], y.__data[4] = y.value.elements[3], y.__data[5] = y.value.elements[4], y.__data[6] = y.value.elements[5], y.__data[7] = y.value.elements[0], y.__data[8] = y.value.elements[6], y.__data[9] = y.value.elements[7], y.__data[10] = y.value.elements[8], y.__data[11] = y.value.elements[0]) : A.toArray(y.__data), h.bufferSubData(35345, F, y.__data));
      }
    }
    h.bindBuffer(35345, null);
  }
  function m(_, w, x) {
    const M = _.value;
    if (x[w] === void 0)
      return typeof M == "number" ? x[w] = M : x[w] = M.clone(), !0;
    if (typeof M == "number") {
      if (x[w] !== M)
        return x[w] = M, !0;
    } else {
      const E = x[w];
      if (E.equals(M) === !1)
        return E.copy(M), !0;
    }
    return !1;
  }
  function g(_) {
    const w = _.uniforms;
    let x = 0;
    const M = 16;
    let E = 0;
    for (let R = 0, y = w.length; R < y; R++) {
      const A = w[R], F = p(A);
      if (A.__data = new Float32Array(F.storage / Float32Array.BYTES_PER_ELEMENT), A.__offset = x, R > 0) {
        E = x % M;
        const P = M - E;
        E !== 0 && P - F.boundary < 0 && (x += M - E, A.__offset = x);
      }
      x += F.storage;
    }
    return E = x % M, E > 0 && (x += M - E), _.__size = x, _.__cache = {}, this;
  }
  function p(_) {
    const w = _.value, x = {
      boundary: 0,
      storage: 0
    };
    return typeof w == "number" ? (x.boundary = 4, x.storage = 4) : w.isVector2 ? (x.boundary = 8, x.storage = 8) : w.isVector3 || w.isColor ? (x.boundary = 16, x.storage = 12) : w.isVector4 ? (x.boundary = 16, x.storage = 16) : w.isMatrix3 ? (x.boundary = 48, x.storage = 48) : w.isMatrix4 ? (x.boundary = 64, x.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w), x;
  }
  function f(_) {
    const w = _.target;
    w.removeEventListener("dispose", f);
    const x = o.indexOf(w.__bindingPointIndex);
    o.splice(x, 1), h.deleteBuffer(i[w.id]), delete i[w.id], delete s[w.id];
  }
  function v() {
    for (const _ in i)
      h.deleteBuffer(i[_]);
    o = [], i = {}, s = {};
  }
  return {
    bind: l,
    update: a,
    dispose: v
  };
}
function zu() {
  const h = qi("canvas");
  return h.style.display = "block", h;
}
function xo(h = {}) {
  this.isWebGLRenderer = !0;
  const e = h.canvas !== void 0 ? h.canvas : zu(), t = h.context !== void 0 ? h.context : null, n = h.depth !== void 0 ? h.depth : !0, i = h.stencil !== void 0 ? h.stencil : !0, s = h.antialias !== void 0 ? h.antialias : !1, o = h.premultipliedAlpha !== void 0 ? h.premultipliedAlpha : !0, r = h.preserveDrawingBuffer !== void 0 ? h.preserveDrawingBuffer : !1, l = h.powerPreference !== void 0 ? h.powerPreference : "default", a = h.failIfMajorPerformanceCaveat !== void 0 ? h.failIfMajorPerformanceCaveat : !1;
  let c;
  t !== null ? c = t.getContextAttributes().alpha : c = h.alpha !== void 0 ? h.alpha : !1;
  let d = null, u = null;
  const m = [], g = [];
  this.domElement = e, this.debug = {
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, Object.defineProperties(this, {
    gammaFactor: {
      get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      }
    }
  });
  const p = this;
  let f = !1, v = 0, _ = 0, w = null, x = -1, M = null;
  const E = new $e(), R = new $e();
  let y = null, A = e.width, F = e.height, P = 1, G = null, z = null;
  const L = new $e(0, 0, A, F), I = new $e(0, 0, A, F);
  let D = !1;
  const q = new Us();
  let k = !1, N = !1, H = null;
  const J = new Ke(), V = new Ce(), ee = new O(), ce = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function ge() {
    return w === null ? P : 1;
  }
  let $ = t;
  function De(T, U) {
    for (let X = 0; X < T.length; X++) {
      const W = T[X], K = e.getContext(W, U);
      if (K !== null)
        return K;
    }
    return null;
  }
  try {
    const T = {
      alpha: !0,
      depth: n,
      stencil: i,
      antialias: s,
      premultipliedAlpha: o,
      preserveDrawingBuffer: r,
      powerPreference: l,
      failIfMajorPerformanceCaveat: a
    };
    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Os}`), e.addEventListener("webglcontextlost", we, !1), e.addEventListener("webglcontextrestored", Ie, !1), e.addEventListener("webglcontextcreationerror", We, !1), $ === null) {
      const U = ["webgl2", "webgl", "experimental-webgl"];
      if (p.isWebGL1Renderer === !0 && U.shift(), $ = De(U, T), $ === null)
        throw De(U) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    $.getShaderPrecisionFormat === void 0 && ($.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (T) {
    throw console.error("THREE.WebGLRenderer: " + T.message), T;
  }
  let ve, xe, ue, Oe, Ee, me, et, ut, rt, Rt, tt, Ne, Gt, Ft, C, S, Z, Q, te, re, ye, j, pe, he;
  function fe() {
    ve = new qc($), xe = new Oc($, ve, h), ve.init(xe), j = new Cu($, ve, xe), ue = new Tu($, ve, xe), Oe = new Yc(), Ee = new du(), me = new Au($, ve, ue, Ee, xe, j, Oe), et = new Gc(p), ut = new Hc(p), rt = new ra($, xe), pe = new Bc($, ve, rt, xe), Rt = new Xc($, rt, Oe, pe), tt = new Jc($, Rt, rt, Oe), te = new Kc($, xe, me), S = new Uc(Ee), Ne = new uu(p, et, ut, ve, xe, pe, S), Gt = new Pu(p, Ee), Ft = new pu(), C = new yu(ve, xe), Q = new zc(p, et, ue, tt, c, o), Z = new Eu(p, tt, xe), he = new Iu($, Oe, xe, ue), re = new Nc($, ve, Oe, xe), ye = new jc($, ve, Oe, xe), Oe.programs = Ne.programs, p.capabilities = xe, p.extensions = ve, p.properties = Ee, p.renderLists = Ft, p.shadowMap = Z, p.state = ue, p.info = Oe;
  }
  fe();
  const de = new Du(p, $);
  this.xr = de, this.getContext = function() {
    return $;
  }, this.getContextAttributes = function() {
    return $.getContextAttributes();
  }, this.forceContextLoss = function() {
    const T = ve.get("WEBGL_lose_context");
    T && T.loseContext();
  }, this.forceContextRestore = function() {
    const T = ve.get("WEBGL_lose_context");
    T && T.restoreContext();
  }, this.getPixelRatio = function() {
    return P;
  }, this.setPixelRatio = function(T) {
    T !== void 0 && (P = T, this.setSize(A, F, !1));
  }, this.getSize = function(T) {
    return T.set(A, F);
  }, this.setSize = function(T, U, X) {
    if (de.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    A = T, F = U, e.width = Math.floor(T * P), e.height = Math.floor(U * P), X !== !1 && (e.style.width = T + "px", e.style.height = U + "px"), this.setViewport(0, 0, T, U);
  }, this.getDrawingBufferSize = function(T) {
    return T.set(A * P, F * P).floor();
  }, this.setDrawingBufferSize = function(T, U, X) {
    A = T, F = U, P = X, e.width = Math.floor(T * X), e.height = Math.floor(U * X), this.setViewport(0, 0, T, U);
  }, this.getCurrentViewport = function(T) {
    return T.copy(E);
  }, this.getViewport = function(T) {
    return T.copy(L);
  }, this.setViewport = function(T, U, X, W) {
    T.isVector4 ? L.set(T.x, T.y, T.z, T.w) : L.set(T, U, X, W), ue.viewport(E.copy(L).multiplyScalar(P).floor());
  }, this.getScissor = function(T) {
    return T.copy(I);
  }, this.setScissor = function(T, U, X, W) {
    T.isVector4 ? I.set(T.x, T.y, T.z, T.w) : I.set(T, U, X, W), ue.scissor(R.copy(I).multiplyScalar(P).floor());
  }, this.getScissorTest = function() {
    return D;
  }, this.setScissorTest = function(T) {
    ue.setScissorTest(D = T);
  }, this.setOpaqueSort = function(T) {
    G = T;
  }, this.setTransparentSort = function(T) {
    z = T;
  }, this.getClearColor = function(T) {
    return T.copy(Q.getClearColor());
  }, this.setClearColor = function() {
    Q.setClearColor.apply(Q, arguments);
  }, this.getClearAlpha = function() {
    return Q.getClearAlpha();
  }, this.setClearAlpha = function() {
    Q.setClearAlpha.apply(Q, arguments);
  }, this.clear = function(T = !0, U = !0, X = !0) {
    let W = 0;
    T && (W |= 16384), U && (W |= 256), X && (W |= 1024), $.clear(W);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", we, !1), e.removeEventListener("webglcontextrestored", Ie, !1), e.removeEventListener("webglcontextcreationerror", We, !1), Ft.dispose(), C.dispose(), Ee.dispose(), et.dispose(), ut.dispose(), tt.dispose(), pe.dispose(), he.dispose(), Ne.dispose(), de.dispose(), de.removeEventListener("sessionstart", Re), de.removeEventListener("sessionend", Je), H && (H.dispose(), H = null), Ve.stop();
  };
  function we(T) {
    T.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), f = !0;
  }
  function Ie() {
    console.log("THREE.WebGLRenderer: Context Restored."), f = !1;
    const T = Oe.autoReset, U = Z.enabled, X = Z.autoUpdate, W = Z.needsUpdate, K = Z.type;
    fe(), Oe.autoReset = T, Z.enabled = U, Z.autoUpdate = X, Z.needsUpdate = W, Z.type = K;
  }
  function We(T) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", T.statusMessage);
  }
  function B(T) {
    const U = T.target;
    U.removeEventListener("dispose", B), ae(U);
  }
  function ae(T) {
    Y(T), Ee.remove(T);
  }
  function Y(T) {
    const U = Ee.get(T).programs;
    U !== void 0 && (U.forEach(function(X) {
      Ne.releaseProgram(X);
    }), T.isShaderMaterial && Ne.releaseShaderCache(T));
  }
  this.renderBufferDirect = function(T, U, X, W, K, _e) {
    U === null && (U = ce);
    const be = K.isMesh && K.matrixWorld.determinant() < 0, Se = Fo(T, U, X, W, K);
    ue.setMaterial(W, be);
    let Me = X.index;
    const Be = X.attributes.position;
    if (Me === null) {
      if (Be === void 0 || Be.count === 0)
        return;
    } else if (Me.count === 0)
      return;
    let Le = 1;
    W.wireframe === !0 && (Me = Rt.getWireframeAttribute(X), Le = 2), pe.setup(K, W, Se, X, Me);
    let Fe, ke = re;
    Me !== null && (Fe = rt.get(Me), ke = ye, ke.setIndex(Fe));
    const un = Me !== null ? Me.count : Be.count, Cn = X.drawRange.start * Le, Ln = X.drawRange.count * Le, Dt = _e !== null ? _e.start * Le : 0, ze = _e !== null ? _e.count * Le : 1 / 0, Rn = Math.max(Cn, Dt), He = Math.min(un, Cn + Ln, Dt + ze) - 1, yt = Math.max(0, He - Rn + 1);
    if (yt !== 0) {
      if (K.isMesh)
        W.wireframe === !0 ? (ue.setLineWidth(W.wireframeLinewidth * ge()), ke.setMode(1)) : ke.setMode(4);
      else if (K.isLine) {
        let tn = W.linewidth;
        tn === void 0 && (tn = 1), ue.setLineWidth(tn * ge()), K.isLineSegments ? ke.setMode(1) : K.isLineLoop ? ke.setMode(2) : ke.setMode(3);
      } else
        K.isPoints ? ke.setMode(0) : K.isSprite && ke.setMode(4);
      if (K.isInstancedMesh)
        ke.renderInstances(Rn, yt, K.count);
      else if (X.isInstancedBufferGeometry) {
        const tn = Math.min(X.instanceCount, X._maxInstanceCount);
        ke.renderInstances(Rn, yt, tn);
      } else
        ke.render(Rn, yt);
    }
  }, this.compile = function(T, U) {
    u = C.get(T), u.init(), g.push(u), T.traverseVisible(function(X) {
      X.isLight && X.layers.test(U.layers) && (u.pushLight(X), X.castShadow && u.pushShadow(X));
    }), u.setupLights(p.physicallyCorrectLights), T.traverse(function(X) {
      const W = X.material;
      if (W)
        if (Array.isArray(W))
          for (let K = 0; K < W.length; K++) {
            const _e = W[K];
            Zi(_e, T, X);
          }
        else
          Zi(W, T, X);
    }), g.pop(), u = null;
  };
  let oe = null;
  function se(T) {
    oe && oe(T);
  }
  function Re() {
    Ve.stop();
  }
  function Je() {
    Ve.start();
  }
  const Ve = new fo();
  Ve.setAnimationLoop(se), typeof self < "u" && Ve.setContext(self), this.setAnimationLoop = function(T) {
    oe = T, de.setAnimationLoop(T), T === null ? Ve.stop() : Ve.start();
  }, de.addEventListener("sessionstart", Re), de.addEventListener("sessionend", Je), this.render = function(T, U) {
    if (U !== void 0 && U.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (f === !0)
      return;
    T.autoUpdate === !0 && T.updateMatrixWorld(), U.parent === null && U.updateMatrixWorld(), de.enabled === !0 && de.isPresenting === !0 && (de.cameraAutoUpdate === !0 && de.updateCamera(U), U = de.getCamera()), T.isScene === !0 && T.onBeforeRender(p, T, U, w), u = C.get(T, g.length), u.init(), g.push(u), J.multiplyMatrices(U.projectionMatrix, U.matrixWorldInverse), q.setFromProjectionMatrix(J), N = this.localClippingEnabled, k = S.init(this.clippingPlanes, N, U), d = Ft.get(T, m.length), d.init(), m.push(d), en(T, U, 0, p.sortObjects), d.finish(), p.sortObjects === !0 && d.sort(G, z), k === !0 && S.beginShadows();
    const X = u.state.shadowsArray;
    if (Z.render(X, T, U), k === !0 && S.endShadows(), this.info.autoReset === !0 && this.info.reset(), Q.render(d, T), u.setupLights(p.physicallyCorrectLights), U.isArrayCamera) {
      const W = U.cameras;
      for (let K = 0, _e = W.length; K < _e; K++) {
        const be = W[K];
        Ge(d, T, be, be.viewport);
      }
    } else
      Ge(d, T, U);
    w !== null && (me.updateMultisampleRenderTarget(w), me.updateRenderTargetMipmap(w)), T.isScene === !0 && T.onAfterRender(p, T, U), pe.resetDefaultState(), x = -1, M = null, g.pop(), g.length > 0 ? u = g[g.length - 1] : u = null, m.pop(), m.length > 0 ? d = m[m.length - 1] : d = null;
  };
  function en(T, U, X, W) {
    if (T.visible === !1)
      return;
    if (T.layers.test(U.layers)) {
      if (T.isGroup)
        X = T.renderOrder;
      else if (T.isLOD)
        T.autoUpdate === !0 && T.update(U);
      else if (T.isLight)
        u.pushLight(T), T.castShadow && u.pushShadow(T);
      else if (T.isSprite) {
        if (!T.frustumCulled || q.intersectsSprite(T)) {
          W && ee.setFromMatrixPosition(T.matrixWorld).applyMatrix4(J);
          const be = tt.update(T), Se = T.material;
          Se.visible && d.push(T, be, Se, X, ee.z, null);
        }
      } else if ((T.isMesh || T.isLine || T.isPoints) && (T.isSkinnedMesh && T.skeleton.frame !== Oe.render.frame && (T.skeleton.update(), T.skeleton.frame = Oe.render.frame), !T.frustumCulled || q.intersectsObject(T))) {
        W && ee.setFromMatrixPosition(T.matrixWorld).applyMatrix4(J);
        const be = tt.update(T), Se = T.material;
        if (Array.isArray(Se)) {
          const Me = be.groups;
          for (let Be = 0, Le = Me.length; Be < Le; Be++) {
            const Fe = Me[Be], ke = Se[Fe.materialIndex];
            ke && ke.visible && d.push(T, be, ke, X, ee.z, Fe);
          }
        } else
          Se.visible && d.push(T, be, Se, X, ee.z, null);
      }
    }
    const _e = T.children;
    for (let be = 0, Se = _e.length; be < Se; be++)
      en(_e[be], U, X, W);
  }
  function Ge(T, U, X, W) {
    const K = T.opaque, _e = T.transmissive, be = T.transparent;
    u.setupLightsView(X), _e.length > 0 && kt(K, U, X), W && ue.viewport(E.copy(W)), K.length > 0 && xt(K, U, X), _e.length > 0 && xt(_e, U, X), be.length > 0 && xt(be, U, X), ue.buffers.depth.setTest(!0), ue.buffers.depth.setMask(!0), ue.buffers.color.setMask(!0), ue.setPolygonOffset(!1);
  }
  function kt(T, U, X) {
    const W = xe.isWebGL2;
    H === null && (H = new En(1, 1, {
      generateMipmaps: !0,
      type: ve.has("EXT_color_buffer_half_float") ? 1016 : 1009,
      minFilter: 1008,
      samples: W && s === !0 ? 4 : 0
    })), p.getDrawingBufferSize(V), W ? H.setSize(V.x, V.y) : H.setSize(Bs(V.x), Bs(V.y));
    const K = p.getRenderTarget();
    p.setRenderTarget(H), p.clear();
    const _e = p.toneMapping;
    p.toneMapping = 0, xt(T, U, X), p.toneMapping = _e, me.updateMultisampleRenderTarget(H), me.updateRenderTargetMipmap(H), p.setRenderTarget(K);
  }
  function xt(T, U, X) {
    const W = U.isScene === !0 ? U.overrideMaterial : null;
    for (let K = 0, _e = T.length; K < _e; K++) {
      const be = T[K], Se = be.object, Me = be.geometry, Be = W === null ? be.material : W, Le = be.group;
      Se.layers.test(X.layers) && Ro(Se, U, X, Me, Be, Le);
    }
  }
  function Ro(T, U, X, W, K, _e) {
    T.onBeforeRender(p, U, X, W, K, _e), T.modelViewMatrix.multiplyMatrices(X.matrixWorldInverse, T.matrixWorld), T.normalMatrix.getNormalMatrix(T.modelViewMatrix), K.onBeforeRender(p, U, X, W, T, _e), K.transparent === !0 && K.side === 2 ? (K.side = 1, K.needsUpdate = !0, p.renderBufferDirect(X, U, W, K, T, _e), K.side = 0, K.needsUpdate = !0, p.renderBufferDirect(X, U, W, K, T, _e), K.side = 2) : p.renderBufferDirect(X, U, W, K, T, _e), T.onAfterRender(p, U, X, W, K, _e);
  }
  function Zi(T, U, X) {
    U.isScene !== !0 && (U = ce);
    const W = Ee.get(T), K = u.state.lights, _e = u.state.shadowsArray, be = K.state.version, Se = Ne.getParameters(T, K.state, _e, U, X), Me = Ne.getProgramCacheKey(Se);
    let Be = W.programs;
    W.environment = T.isMeshStandardMaterial ? U.environment : null, W.fog = U.fog, W.envMap = (T.isMeshStandardMaterial ? ut : et).get(T.envMap || W.environment), Be === void 0 && (T.addEventListener("dispose", B), Be = /* @__PURE__ */ new Map(), W.programs = Be);
    let Le = Be.get(Me);
    if (Le !== void 0) {
      if (W.currentProgram === Le && W.lightsStateVersion === be)
        return Xs(T, Se), Le;
    } else
      Se.uniforms = Ne.getUniforms(T), T.onBuild(X, Se, p), T.onBeforeCompile(Se, p), Le = Ne.acquireProgram(Se, Me), Be.set(Me, Le), W.uniforms = Se.uniforms;
    const Fe = W.uniforms;
    (!T.isShaderMaterial && !T.isRawShaderMaterial || T.clipping === !0) && (Fe.clippingPlanes = S.uniform), Xs(T, Se), W.needsLights = Po(T), W.lightsStateVersion = be, W.needsLights && (Fe.ambientLightColor.value = K.state.ambient, Fe.lightProbe.value = K.state.probe, Fe.directionalLights.value = K.state.directional, Fe.directionalLightShadows.value = K.state.directionalShadow, Fe.spotLights.value = K.state.spot, Fe.spotLightShadows.value = K.state.spotShadow, Fe.rectAreaLights.value = K.state.rectArea, Fe.ltc_1.value = K.state.rectAreaLTC1, Fe.ltc_2.value = K.state.rectAreaLTC2, Fe.pointLights.value = K.state.point, Fe.pointLightShadows.value = K.state.pointShadow, Fe.hemisphereLights.value = K.state.hemi, Fe.directionalShadowMap.value = K.state.directionalShadowMap, Fe.directionalShadowMatrix.value = K.state.directionalShadowMatrix, Fe.spotShadowMap.value = K.state.spotShadowMap, Fe.spotShadowMatrix.value = K.state.spotShadowMatrix, Fe.pointShadowMap.value = K.state.pointShadowMap, Fe.pointShadowMatrix.value = K.state.pointShadowMatrix);
    const ke = Le.getUniforms(), un = Vi.seqWithValue(ke.seq, Fe);
    return W.currentProgram = Le, W.uniformsList = un, Le;
  }
  function Xs(T, U) {
    const X = Ee.get(T);
    X.outputEncoding = U.outputEncoding, X.instancing = U.instancing, X.skinning = U.skinning, X.morphTargets = U.morphTargets, X.morphNormals = U.morphNormals, X.morphColors = U.morphColors, X.morphTargetsCount = U.morphTargetsCount, X.numClippingPlanes = U.numClippingPlanes, X.numIntersection = U.numClipIntersection, X.vertexAlphas = U.vertexAlphas, X.vertexTangents = U.vertexTangents, X.toneMapping = U.toneMapping;
  }
  function Fo(T, U, X, W, K) {
    U.isScene !== !0 && (U = ce), me.resetTextureUnits();
    const _e = U.fog, be = W.isMeshStandardMaterial ? U.environment : null, Se = w === null ? p.outputEncoding : w.isXRRenderTarget === !0 ? w.texture.encoding : 3e3, Me = (W.isMeshStandardMaterial ? ut : et).get(W.envMap || be), Be = W.vertexColors === !0 && !!X.attributes.color && X.attributes.color.itemSize === 4, Le = !!W.normalMap && !!X.attributes.tangent, Fe = !!X.morphAttributes.position, ke = !!X.morphAttributes.normal, un = !!X.morphAttributes.color, Cn = W.toneMapped ? p.toneMapping : 0, Ln = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color, Dt = Ln !== void 0 ? Ln.length : 0, ze = Ee.get(W), Rn = u.state.lights;
    if (k === !0 && (N === !0 || T !== M)) {
      const dt = T === M && W.id === x;
      S.setState(W, T, dt);
    }
    let He = !1;
    W.version === ze.__version ? (ze.needsLights && ze.lightsStateVersion !== Rn.state.version || ze.outputEncoding !== Se || K.isInstancedMesh && ze.instancing === !1 || !K.isInstancedMesh && ze.instancing === !0 || K.isSkinnedMesh && ze.skinning === !1 || !K.isSkinnedMesh && ze.skinning === !0 || ze.envMap !== Me || W.fog === !0 && ze.fog !== _e || ze.numClippingPlanes !== void 0 && (ze.numClippingPlanes !== S.numPlanes || ze.numIntersection !== S.numIntersection) || ze.vertexAlphas !== Be || ze.vertexTangents !== Le || ze.morphTargets !== Fe || ze.morphNormals !== ke || ze.morphColors !== un || ze.toneMapping !== Cn || xe.isWebGL2 === !0 && ze.morphTargetsCount !== Dt) && (He = !0) : (He = !0, ze.__version = W.version);
    let yt = ze.currentProgram;
    He === !0 && (yt = Zi(W, U, K));
    let tn = !1, Jn = !1, $i = !1;
    const ot = yt.getUniforms(), Qn = ze.uniforms;
    if (ue.useProgram(yt.program) && (tn = !0, Jn = !0, $i = !0), W.id !== x && (x = W.id, Jn = !0), tn || M !== T) {
      if (ot.setValue($, "projectionMatrix", T.projectionMatrix), xe.logarithmicDepthBuffer && ot.setValue(
        $,
        "logDepthBufFC",
        2 / (Math.log(T.far + 1) / Math.LN2)
      ), M !== T && (M = T, Jn = !0, $i = !0), W.isShaderMaterial || W.isMeshPhongMaterial || W.isMeshToonMaterial || W.isMeshStandardMaterial || W.envMap) {
        const dt = ot.map.cameraPosition;
        dt !== void 0 && dt.setValue(
          $,
          ee.setFromMatrixPosition(T.matrixWorld)
        );
      }
      (W.isMeshPhongMaterial || W.isMeshToonMaterial || W.isMeshLambertMaterial || W.isMeshBasicMaterial || W.isMeshStandardMaterial || W.isShaderMaterial) && ot.setValue($, "isOrthographic", T.isOrthographicCamera === !0), (W.isMeshPhongMaterial || W.isMeshToonMaterial || W.isMeshLambertMaterial || W.isMeshBasicMaterial || W.isMeshStandardMaterial || W.isShaderMaterial || W.isShadowMaterial || K.isSkinnedMesh) && ot.setValue($, "viewMatrix", T.matrixWorldInverse);
    }
    if (K.isSkinnedMesh) {
      ot.setOptional($, K, "bindMatrix"), ot.setOptional($, K, "bindMatrixInverse");
      const dt = K.skeleton;
      dt && (xe.floatVertexTextures ? (dt.boneTexture === null && dt.computeBoneTexture(), ot.setValue($, "boneTexture", dt.boneTexture, me), ot.setValue($, "boneTextureSize", dt.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
    }
    const Ki = X.morphAttributes;
    if ((Ki.position !== void 0 || Ki.normal !== void 0 || Ki.color !== void 0 && xe.isWebGL2 === !0) && te.update(K, X, W, yt), (Jn || ze.receiveShadow !== K.receiveShadow) && (ze.receiveShadow = K.receiveShadow, ot.setValue($, "receiveShadow", K.receiveShadow)), Jn && (ot.setValue($, "toneMappingExposure", p.toneMappingExposure), ze.needsLights && Do(Qn, $i), _e && W.fog === !0 && Gt.refreshFogUniforms(Qn, _e), Gt.refreshMaterialUniforms(Qn, W, P, F, H), Vi.upload($, ze.uniformsList, Qn, me)), W.isShaderMaterial && W.uniformsNeedUpdate === !0 && (Vi.upload($, ze.uniformsList, Qn, me), W.uniformsNeedUpdate = !1), W.isSpriteMaterial && ot.setValue($, "center", K.center), ot.setValue($, "modelViewMatrix", K.modelViewMatrix), ot.setValue($, "normalMatrix", K.normalMatrix), ot.setValue($, "modelMatrix", K.matrixWorld), W.isShaderMaterial || W.isRawShaderMaterial) {
      const dt = W.uniformsGroups;
      for (let Ji = 0, Io = dt.length; Ji < Io; Ji++)
        if (xe.isWebGL2) {
          const js = dt[Ji];
          he.update(js, yt), he.bind(js, yt);
        } else
          console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
    }
    return yt;
  }
  function Do(T, U) {
    T.ambientLightColor.needsUpdate = U, T.lightProbe.needsUpdate = U, T.directionalLights.needsUpdate = U, T.directionalLightShadows.needsUpdate = U, T.pointLights.needsUpdate = U, T.pointLightShadows.needsUpdate = U, T.spotLights.needsUpdate = U, T.spotLightShadows.needsUpdate = U, T.rectAreaLights.needsUpdate = U, T.hemisphereLights.needsUpdate = U;
  }
  function Po(T) {
    return T.isMeshLambertMaterial || T.isMeshToonMaterial || T.isMeshPhongMaterial || T.isMeshStandardMaterial || T.isShadowMaterial || T.isShaderMaterial && T.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return v;
  }, this.getActiveMipmapLevel = function() {
    return _;
  }, this.getRenderTarget = function() {
    return w;
  }, this.setRenderTargetTextures = function(T, U, X) {
    Ee.get(T.texture).__webglTexture = U, Ee.get(T.depthTexture).__webglTexture = X;
    const W = Ee.get(T);
    W.__hasExternalTextures = !0, W.__hasExternalTextures && (W.__autoAllocateDepthBuffer = X === void 0, W.__autoAllocateDepthBuffer || ve.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), W.__useRenderToTexture = !1));
  }, this.setRenderTargetFramebuffer = function(T, U) {
    const X = Ee.get(T);
    X.__webglFramebuffer = U, X.__useDefaultFramebuffer = U === void 0;
  }, this.setRenderTarget = function(T, U = 0, X = 0) {
    w = T, v = U, _ = X;
    let W = !0;
    if (T) {
      const Me = Ee.get(T);
      Me.__useDefaultFramebuffer !== void 0 ? (ue.bindFramebuffer(36160, null), W = !1) : Me.__webglFramebuffer === void 0 ? me.setupRenderTarget(T) : Me.__hasExternalTextures && me.rebindTextures(T, Ee.get(T.texture).__webglTexture, Ee.get(T.depthTexture).__webglTexture);
    }
    let K = null, _e = !1, be = !1;
    if (T) {
      const Me = T.texture;
      (Me.isData3DTexture || Me.isDataArrayTexture) && (be = !0);
      const Be = Ee.get(T).__webglFramebuffer;
      T.isWebGLCubeRenderTarget ? (K = Be[U], _e = !0) : xe.isWebGL2 && T.samples > 0 && me.useMultisampledRTT(T) === !1 ? K = Ee.get(T).__webglMultisampledFramebuffer : K = Be, E.copy(T.viewport), R.copy(T.scissor), y = T.scissorTest;
    } else
      E.copy(L).multiplyScalar(P).floor(), R.copy(I).multiplyScalar(P).floor(), y = D;
    if (ue.bindFramebuffer(36160, K) && xe.drawBuffers && W && ue.drawBuffers(T, K), ue.viewport(E), ue.scissor(R), ue.setScissorTest(y), _e) {
      const Me = Ee.get(T.texture);
      $.framebufferTexture2D(36160, 36064, 34069 + U, Me.__webglTexture, X);
    } else if (be) {
      const Me = Ee.get(T.texture), Be = U || 0;
      $.framebufferTextureLayer(36160, 36064, Me.__webglTexture, X || 0, Be);
    }
    x = -1;
  }, this.readRenderTargetPixels = function(T, U, X, W, K, _e, be) {
    if (!(T && T.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Se = Ee.get(T).__webglFramebuffer;
    if (T.isWebGLCubeRenderTarget && be !== void 0 && (Se = Se[be]), Se) {
      ue.bindFramebuffer(36160, Se);
      try {
        const Me = T.texture, Be = Me.format, Le = Me.type;
        if (Be !== 1023 && j.convert(Be) !== $.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const Fe = Le === 1016 && (ve.has("EXT_color_buffer_half_float") || xe.isWebGL2 && ve.has("EXT_color_buffer_float"));
        if (Le !== 1009 && j.convert(Le) !== $.getParameter(35738) && !(Le === 1015 && (xe.isWebGL2 || ve.has("OES_texture_float") || ve.has("WEBGL_color_buffer_float"))) && !Fe) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        U >= 0 && U <= T.width - W && X >= 0 && X <= T.height - K && $.readPixels(U, X, W, K, j.convert(Be), j.convert(Le), _e);
      } finally {
        const Me = w !== null ? Ee.get(w).__webglFramebuffer : null;
        ue.bindFramebuffer(36160, Me);
      }
    }
  }, this.copyFramebufferToTexture = function(T, U, X = 0) {
    const W = Math.pow(2, -X), K = Math.floor(U.image.width * W), _e = Math.floor(U.image.height * W);
    me.setTexture2D(U, 0), $.copyTexSubImage2D(3553, X, 0, 0, T.x, T.y, K, _e), ue.unbindTexture();
  }, this.copyTextureToTexture = function(T, U, X, W = 0) {
    const K = U.image.width, _e = U.image.height, be = j.convert(X.format), Se = j.convert(X.type);
    me.setTexture2D(X, 0), $.pixelStorei(37440, X.flipY), $.pixelStorei(37441, X.premultiplyAlpha), $.pixelStorei(3317, X.unpackAlignment), U.isDataTexture ? $.texSubImage2D(3553, W, T.x, T.y, K, _e, be, Se, U.image.data) : U.isCompressedTexture ? $.compressedTexSubImage2D(3553, W, T.x, T.y, U.mipmaps[0].width, U.mipmaps[0].height, be, U.mipmaps[0].data) : $.texSubImage2D(3553, W, T.x, T.y, be, Se, U.image), W === 0 && X.generateMipmaps && $.generateMipmap(3553), ue.unbindTexture();
  }, this.copyTextureToTexture3D = function(T, U, X, W, K = 0) {
    if (p.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const _e = T.max.x - T.min.x + 1, be = T.max.y - T.min.y + 1, Se = T.max.z - T.min.z + 1, Me = j.convert(W.format), Be = j.convert(W.type);
    let Le;
    if (W.isData3DTexture)
      me.setTexture3D(W, 0), Le = 32879;
    else if (W.isDataArrayTexture)
      me.setTexture2DArray(W, 0), Le = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    $.pixelStorei(37440, W.flipY), $.pixelStorei(37441, W.premultiplyAlpha), $.pixelStorei(3317, W.unpackAlignment);
    const Fe = $.getParameter(3314), ke = $.getParameter(32878), un = $.getParameter(3316), Cn = $.getParameter(3315), Ln = $.getParameter(32877), Dt = X.isCompressedTexture ? X.mipmaps[0] : X.image;
    $.pixelStorei(3314, Dt.width), $.pixelStorei(32878, Dt.height), $.pixelStorei(3316, T.min.x), $.pixelStorei(3315, T.min.y), $.pixelStorei(32877, T.min.z), X.isDataTexture || X.isData3DTexture ? $.texSubImage3D(Le, K, U.x, U.y, U.z, _e, be, Se, Me, Be, Dt.data) : X.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), $.compressedTexSubImage3D(Le, K, U.x, U.y, U.z, _e, be, Se, Me, Dt.data)) : $.texSubImage3D(Le, K, U.x, U.y, U.z, _e, be, Se, Me, Be, Dt), $.pixelStorei(3314, Fe), $.pixelStorei(32878, ke), $.pixelStorei(3316, un), $.pixelStorei(3315, Cn), $.pixelStorei(32877, Ln), K === 0 && W.generateMipmaps && $.generateMipmap(Le), ue.unbindTexture();
  }, this.initTexture = function(T) {
    T.isCubeTexture ? me.setTextureCube(T, 0) : T.isData3DTexture ? me.setTexture3D(T, 0) : T.isDataArrayTexture ? me.setTexture2DArray(T, 0) : me.setTexture2D(T, 0), ue.unbindTexture();
  }, this.resetState = function() {
    v = 0, _ = 0, w = null, ue.reset(), pe.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class Bu extends xo {
}
Bu.prototype.isWebGL1Renderer = !0;
class Nu extends at {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
}
class Rr extends _t {
  constructor(e, t, n, i, s, o, r, l, a) {
    super(e, t, n, i, s, o, r, l, a), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class ks extends Ut {
  constructor(e = 1, t = 1, n = 1, i = 8, s = 1, o = !1, r = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: s,
      openEnded: o,
      thetaStart: r,
      thetaLength: l
    };
    const a = this;
    i = Math.floor(i), s = Math.floor(s);
    const c = [], d = [], u = [], m = [];
    let g = 0;
    const p = [], f = n / 2;
    let v = 0;
    _(), o === !1 && (e > 0 && w(!0), t > 0 && w(!1)), this.setIndex(c), this.setAttribute("position", new st(d, 3)), this.setAttribute("normal", new st(u, 3)), this.setAttribute("uv", new st(m, 2));
    function _() {
      const x = new O(), M = new O();
      let E = 0;
      const R = (t - e) / n;
      for (let y = 0; y <= s; y++) {
        const A = [], F = y / s, P = F * (t - e) + e;
        for (let G = 0; G <= i; G++) {
          const z = G / i, L = z * l + r, I = Math.sin(L), D = Math.cos(L);
          M.x = P * I, M.y = -F * n + f, M.z = P * D, d.push(M.x, M.y, M.z), x.set(I, R, D).normalize(), u.push(x.x, x.y, x.z), m.push(z, 1 - F), A.push(g++);
        }
        p.push(A);
      }
      for (let y = 0; y < i; y++)
        for (let A = 0; A < s; A++) {
          const F = p[A][y], P = p[A + 1][y], G = p[A + 1][y + 1], z = p[A][y + 1];
          c.push(F, P, z), c.push(P, G, z), E += 6;
        }
      a.addGroup(v, E, 0), v += E;
    }
    function w(x) {
      const M = g, E = new Ce(), R = new O();
      let y = 0;
      const A = x === !0 ? e : t, F = x === !0 ? 1 : -1;
      for (let G = 1; G <= i; G++)
        d.push(0, f * F, 0), u.push(0, F, 0), m.push(0.5, 0.5), g++;
      const P = g;
      for (let G = 0; G <= i; G++) {
        const L = G / i * l + r, I = Math.cos(L), D = Math.sin(L);
        R.x = A * D, R.y = f * F, R.z = A * I, d.push(R.x, R.y, R.z), u.push(0, F, 0), E.x = I * 0.5 + 0.5, E.y = D * 0.5 * F + 0.5, m.push(E.x, E.y), g++;
      }
      for (let G = 0; G < i; G++) {
        const z = M + G, L = P + G;
        x === !0 ? c.push(L, L + 1, z) : c.push(L + 1, L, z), y += 3;
      }
      a.addGroup(v, y, x === !0 ? 1 : 2), v += y;
    }
  }
  static fromJSON(e) {
    return new ks(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Ou extends An {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Ae(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class Uu extends An {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ae(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ae(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Gu extends An {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Ae(16777215), this.specular = new Ae(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ae(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class yo extends at {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Ae(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class ku extends yo {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(at.DefaultUp), this.updateMatrix(), this.groundColor = new Ae(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Fr = /* @__PURE__ */ new Ke(), Dr = /* @__PURE__ */ new O(), Pr = /* @__PURE__ */ new O();
class Wu {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ce(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ke(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Us(), this._frameExtents = new Ce(1, 1), this._viewportCount = 1, this._viewports = [
      new $e(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    Dr.setFromMatrixPosition(e.matrixWorld), t.position.copy(Dr), Pr.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Pr), t.updateMatrixWorld(), Fr.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Fr), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class Vu extends Wu {
  constructor() {
    super(new gt(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = zs * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Hu extends yo {
  constructor(e, t, n = 0, i = Math.PI / 3, s = 0, o = 1) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(at.DefaultUp), this.updateMatrix(), this.target = new at(), this.distance = n, this.angle = i, this.penumbra = s, this.decay = o, this.shadow = new Vu();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Os
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Os);
class Lt {
  constructor(e) {
    e === void 0 && (e = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = e;
  }
  identity() {
    const e = this.elements;
    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1;
  }
  setZero() {
    const e = this.elements;
    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0;
  }
  setTrace(e) {
    const t = this.elements;
    t[0] = e.x, t[4] = e.y, t[8] = e.z;
  }
  getTrace(e) {
    e === void 0 && (e = new b());
    const t = this.elements;
    return e.x = t[0], e.y = t[4], e.z = t[8], e;
  }
  vmult(e, t) {
    t === void 0 && (t = new b());
    const n = this.elements, i = e.x, s = e.y, o = e.z;
    return t.x = n[0] * i + n[1] * s + n[2] * o, t.y = n[3] * i + n[4] * s + n[5] * o, t.z = n[6] * i + n[7] * s + n[8] * o, t;
  }
  smult(e) {
    for (let t = 0; t < this.elements.length; t++)
      this.elements[t] *= e;
  }
  mmult(e, t) {
    t === void 0 && (t = new Lt());
    const n = this.elements, i = e.elements, s = t.elements, o = n[0], r = n[1], l = n[2], a = n[3], c = n[4], d = n[5], u = n[6], m = n[7], g = n[8], p = i[0], f = i[1], v = i[2], _ = i[3], w = i[4], x = i[5], M = i[6], E = i[7], R = i[8];
    return s[0] = o * p + r * _ + l * M, s[1] = o * f + r * w + l * E, s[2] = o * v + r * x + l * R, s[3] = a * p + c * _ + d * M, s[4] = a * f + c * w + d * E, s[5] = a * v + c * x + d * R, s[6] = u * p + m * _ + g * M, s[7] = u * f + m * w + g * E, s[8] = u * v + m * x + g * R, t;
  }
  scale(e, t) {
    t === void 0 && (t = new Lt());
    const n = this.elements, i = t.elements;
    for (let s = 0; s !== 3; s++)
      i[3 * s + 0] = e.x * n[3 * s + 0], i[3 * s + 1] = e.y * n[3 * s + 1], i[3 * s + 2] = e.z * n[3 * s + 2];
    return t;
  }
  solve(e, t) {
    t === void 0 && (t = new b());
    const n = 3, i = 4, s = [];
    let o, r;
    for (o = 0; o < n * i; o++)
      s.push(0);
    for (o = 0; o < 3; o++)
      for (r = 0; r < 3; r++)
        s[o + i * r] = this.elements[o + 3 * r];
    s[3 + 4 * 0] = e.x, s[3 + 4 * 1] = e.y, s[3 + 4 * 2] = e.z;
    let l = 3;
    const a = l;
    let c;
    const d = 4;
    let u;
    do {
      if (o = a - l, s[o + i * o] === 0) {
        for (r = o + 1; r < a; r++)
          if (s[o + i * r] !== 0) {
            c = d;
            do
              u = d - c, s[u + i * o] += s[u + i * r];
            while (--c);
            break;
          }
      }
      if (s[o + i * o] !== 0)
        for (r = o + 1; r < a; r++) {
          const m = s[o + i * r] / s[o + i * o];
          c = d;
          do
            u = d - c, s[u + i * r] = u <= o ? 0 : s[u + i * r] - s[u + i * o] * m;
          while (--c);
        }
    } while (--l);
    if (t.z = s[2 * i + 3] / s[2 * i + 2], t.y = (s[1 * i + 3] - s[1 * i + 2] * t.z) / s[1 * i + 1], t.x = (s[0 * i + 3] - s[0 * i + 2] * t.z - s[0 * i + 1] * t.y) / s[0 * i + 0], isNaN(t.x) || isNaN(t.y) || isNaN(t.z) || t.x === 1 / 0 || t.y === 1 / 0 || t.z === 1 / 0)
      throw `Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;
    return t;
  }
  e(e, t, n) {
    if (n === void 0)
      return this.elements[t + 3 * e];
    this.elements[t + 3 * e] = n;
  }
  copy(e) {
    for (let t = 0; t < e.elements.length; t++)
      this.elements[t] = e.elements[t];
    return this;
  }
  toString() {
    let e = "";
    const t = ",";
    for (let n = 0; n < 9; n++)
      e += this.elements[n] + t;
    return e;
  }
  reverse(e) {
    e === void 0 && (e = new Lt());
    const t = 3, n = 6, i = qu;
    let s, o;
    for (s = 0; s < 3; s++)
      for (o = 0; o < 3; o++)
        i[s + n * o] = this.elements[s + 3 * o];
    i[3 + 6 * 0] = 1, i[3 + 6 * 1] = 0, i[3 + 6 * 2] = 0, i[4 + 6 * 0] = 0, i[4 + 6 * 1] = 1, i[4 + 6 * 2] = 0, i[5 + 6 * 0] = 0, i[5 + 6 * 1] = 0, i[5 + 6 * 2] = 1;
    let r = 3;
    const l = r;
    let a;
    const c = n;
    let d;
    do {
      if (s = l - r, i[s + n * s] === 0) {
        for (o = s + 1; o < l; o++)
          if (i[s + n * o] !== 0) {
            a = c;
            do
              d = c - a, i[d + n * s] += i[d + n * o];
            while (--a);
            break;
          }
      }
      if (i[s + n * s] !== 0)
        for (o = s + 1; o < l; o++) {
          const u = i[s + n * o] / i[s + n * s];
          a = c;
          do
            d = c - a, i[d + n * o] = d <= s ? 0 : i[d + n * o] - i[d + n * s] * u;
          while (--a);
        }
    } while (--r);
    s = 2;
    do {
      o = s - 1;
      do {
        const u = i[s + n * o] / i[s + n * s];
        a = n;
        do
          d = n - a, i[d + n * o] = i[d + n * o] - i[d + n * s] * u;
        while (--a);
      } while (o--);
    } while (--s);
    s = 2;
    do {
      const u = 1 / i[s + n * s];
      a = n;
      do
        d = n - a, i[d + n * s] = i[d + n * s] * u;
      while (--a);
    } while (s--);
    s = 2;
    do {
      o = 2;
      do {
        if (d = i[t + o + n * s], isNaN(d) || d === 1 / 0)
          throw `Could not reverse! A=[${this.toString()}]`;
        e.e(s, o, d);
      } while (o--);
    } while (s--);
    return e;
  }
  setRotationFromQuaternion(e) {
    const t = e.x, n = e.y, i = e.z, s = e.w, o = t + t, r = n + n, l = i + i, a = t * o, c = t * r, d = t * l, u = n * r, m = n * l, g = i * l, p = s * o, f = s * r, v = s * l, _ = this.elements;
    return _[3 * 0 + 0] = 1 - (u + g), _[3 * 0 + 1] = c - v, _[3 * 0 + 2] = d + f, _[3 * 1 + 0] = c + v, _[3 * 1 + 1] = 1 - (a + g), _[3 * 1 + 2] = m - p, _[3 * 2 + 0] = d - f, _[3 * 2 + 1] = m + p, _[3 * 2 + 2] = 1 - (a + u), this;
  }
  transpose(e) {
    e === void 0 && (e = new Lt());
    const t = this.elements, n = e.elements;
    let i;
    return n[0] = t[0], n[4] = t[4], n[8] = t[8], i = t[1], n[1] = t[3], n[3] = i, i = t[2], n[2] = t[6], n[6] = i, i = t[5], n[5] = t[7], n[7] = i, e;
  }
}
const qu = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
class b {
  constructor(e, t, n) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), this.x = e, this.y = t, this.z = n;
  }
  cross(e, t) {
    t === void 0 && (t = new b());
    const n = e.x, i = e.y, s = e.z, o = this.x, r = this.y, l = this.z;
    return t.x = r * s - l * i, t.y = l * n - o * s, t.z = o * i - r * n, t;
  }
  set(e, t, n) {
    return this.x = e, this.y = t, this.z = n, this;
  }
  setZero() {
    this.x = this.y = this.z = 0;
  }
  vadd(e, t) {
    if (t)
      t.x = e.x + this.x, t.y = e.y + this.y, t.z = e.z + this.z;
    else
      return new b(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  vsub(e, t) {
    if (t)
      t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z;
    else
      return new b(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  crossmat() {
    return new Lt([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  normalize() {
    const e = this.x, t = this.y, n = this.z, i = Math.sqrt(e * e + t * t + n * n);
    if (i > 0) {
      const s = 1 / i;
      this.x *= s, this.y *= s, this.z *= s;
    } else
      this.x = 0, this.y = 0, this.z = 0;
    return i;
  }
  unit(e) {
    e === void 0 && (e = new b());
    const t = this.x, n = this.y, i = this.z;
    let s = Math.sqrt(t * t + n * n + i * i);
    return s > 0 ? (s = 1 / s, e.x = t * s, e.y = n * s, e.z = i * s) : (e.x = 1, e.y = 0, e.z = 0), e;
  }
  length() {
    const e = this.x, t = this.y, n = this.z;
    return Math.sqrt(e * e + t * t + n * n);
  }
  lengthSquared() {
    return this.dot(this);
  }
  distanceTo(e) {
    const t = this.x, n = this.y, i = this.z, s = e.x, o = e.y, r = e.z;
    return Math.sqrt((s - t) * (s - t) + (o - n) * (o - n) + (r - i) * (r - i));
  }
  distanceSquared(e) {
    const t = this.x, n = this.y, i = this.z, s = e.x, o = e.y, r = e.z;
    return (s - t) * (s - t) + (o - n) * (o - n) + (r - i) * (r - i);
  }
  scale(e, t) {
    t === void 0 && (t = new b());
    const n = this.x, i = this.y, s = this.z;
    return t.x = e * n, t.y = e * i, t.z = e * s, t;
  }
  vmul(e, t) {
    return t === void 0 && (t = new b()), t.x = e.x * this.x, t.y = e.y * this.y, t.z = e.z * this.z, t;
  }
  addScaledVector(e, t, n) {
    return n === void 0 && (n = new b()), n.x = this.x + e * t.x, n.y = this.y + e * t.y, n.z = this.z + e * t.z, n;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  negate(e) {
    return e === void 0 && (e = new b()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e;
  }
  tangents(e, t) {
    const n = this.length();
    if (n > 0) {
      const i = Xu, s = 1 / n;
      i.set(this.x * s, this.y * s, this.z * s);
      const o = ju;
      Math.abs(i.x) < 0.9 ? (o.set(1, 0, 0), i.cross(o, e)) : (o.set(0, 1, 0), i.cross(o, e)), i.cross(e, t);
    } else
      e.set(1, 0, 0), t.set(0, 1, 0);
  }
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  lerp(e, t, n) {
    const i = this.x, s = this.y, o = this.z;
    n.x = i + (e.x - i) * t, n.y = s + (e.y - s) * t, n.z = o + (e.z - o) * t;
  }
  almostEquals(e, t) {
    return t === void 0 && (t = 1e-6), !(Math.abs(this.x - e.x) > t || Math.abs(this.y - e.y) > t || Math.abs(this.z - e.z) > t);
  }
  almostZero(e) {
    return e === void 0 && (e = 1e-6), !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e);
  }
  isAntiparallelTo(e, t) {
    return this.negate(Ir), Ir.almostEquals(e, t);
  }
  clone() {
    return new b(this.x, this.y, this.z);
  }
}
b.ZERO = new b(0, 0, 0);
b.UNIT_X = new b(1, 0, 0);
b.UNIT_Y = new b(0, 1, 0);
b.UNIT_Z = new b(0, 0, 1);
const Xu = new b(), ju = new b(), Ir = new b();
class vt {
  constructor(e) {
    e === void 0 && (e = {}), this.lowerBound = new b(), this.upperBound = new b(), e.lowerBound && this.lowerBound.copy(e.lowerBound), e.upperBound && this.upperBound.copy(e.upperBound);
  }
  setFromPoints(e, t, n, i) {
    const s = this.lowerBound, o = this.upperBound, r = n;
    s.copy(e[0]), r && r.vmult(s, s), o.copy(s);
    for (let l = 1; l < e.length; l++) {
      let a = e[l];
      r && (r.vmult(a, zr), a = zr), a.x > o.x && (o.x = a.x), a.x < s.x && (s.x = a.x), a.y > o.y && (o.y = a.y), a.y < s.y && (s.y = a.y), a.z > o.z && (o.z = a.z), a.z < s.z && (s.z = a.z);
    }
    return t && (t.vadd(s, s), t.vadd(o, o)), i && (s.x -= i, s.y -= i, s.z -= i, o.x += i, o.y += i, o.z += i), this;
  }
  copy(e) {
    return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this;
  }
  clone() {
    return new vt().copy(this);
  }
  extend(e) {
    this.lowerBound.x = Math.min(this.lowerBound.x, e.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e.upperBound.z);
  }
  overlaps(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, s = e.upperBound, o = i.x <= n.x && n.x <= s.x || t.x <= s.x && s.x <= n.x, r = i.y <= n.y && n.y <= s.y || t.y <= s.y && s.y <= n.y, l = i.z <= n.z && n.z <= s.z || t.z <= s.z && s.z <= n.z;
    return o && r && l;
  }
  volume() {
    const e = this.lowerBound, t = this.upperBound;
    return (t.x - e.x) * (t.y - e.y) * (t.z - e.z);
  }
  contains(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, s = e.upperBound;
    return t.x <= i.x && n.x >= s.x && t.y <= i.y && n.y >= s.y && t.z <= i.z && n.z >= s.z;
  }
  getCorners(e, t, n, i, s, o, r, l) {
    const a = this.lowerBound, c = this.upperBound;
    e.copy(a), t.set(c.x, a.y, a.z), n.set(c.x, c.y, a.z), i.set(a.x, c.y, c.z), s.set(c.x, a.y, c.z), o.set(a.x, c.y, a.z), r.set(a.x, a.y, c.z), l.copy(c);
  }
  toLocalFrame(e, t) {
    const n = Br, i = n[0], s = n[1], o = n[2], r = n[3], l = n[4], a = n[5], c = n[6], d = n[7];
    this.getCorners(i, s, o, r, l, a, c, d);
    for (let u = 0; u !== 8; u++) {
      const m = n[u];
      e.pointToLocal(m, m);
    }
    return t.setFromPoints(n);
  }
  toWorldFrame(e, t) {
    const n = Br, i = n[0], s = n[1], o = n[2], r = n[3], l = n[4], a = n[5], c = n[6], d = n[7];
    this.getCorners(i, s, o, r, l, a, c, d);
    for (let u = 0; u !== 8; u++) {
      const m = n[u];
      e.pointToWorld(m, m);
    }
    return t.setFromPoints(n);
  }
  overlapsRay(e) {
    const {
      direction: t,
      from: n
    } = e, i = 1 / t.x, s = 1 / t.y, o = 1 / t.z, r = (this.lowerBound.x - n.x) * i, l = (this.upperBound.x - n.x) * i, a = (this.lowerBound.y - n.y) * s, c = (this.upperBound.y - n.y) * s, d = (this.lowerBound.z - n.z) * o, u = (this.upperBound.z - n.z) * o, m = Math.max(Math.max(Math.min(r, l), Math.min(a, c)), Math.min(d, u)), g = Math.min(Math.min(Math.max(r, l), Math.max(a, c)), Math.max(d, u));
    return !(g < 0 || m > g);
  }
}
const zr = new b(), Br = [new b(), new b(), new b(), new b(), new b(), new b(), new b(), new b()];
class Nr {
  constructor() {
    this.matrix = [];
  }
  get(e, t) {
    let {
      index: n
    } = e, {
      index: i
    } = t;
    if (i > n) {
      const s = i;
      i = n, n = s;
    }
    return this.matrix[(n * (n + 1) >> 1) + i - 1];
  }
  set(e, t, n) {
    let {
      index: i
    } = e, {
      index: s
    } = t;
    if (s > i) {
      const o = s;
      s = i, i = o;
    }
    this.matrix[(i * (i + 1) >> 1) + s - 1] = n ? 1 : 0;
  }
  reset() {
    for (let e = 0, t = this.matrix.length; e !== t; e++)
      this.matrix[e] = 0;
  }
  setNumObjects(e) {
    this.matrix.length = e * (e - 1) >> 1;
  }
}
class bo {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    return n[e] === void 0 && (n[e] = []), n[e].includes(t) || n[e].push(t), this;
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return !!(n[e] !== void 0 && n[e].includes(t));
  }
  hasAnyEventListener(e) {
    return this._listeners === void 0 ? !1 : this._listeners[e] !== void 0;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return this;
    const n = this._listeners;
    if (n[e] === void 0)
      return this;
    const i = n[e].indexOf(t);
    return i !== -1 && n[e].splice(i, 1), this;
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return this;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      for (let i = 0, s = n.length; i < s; i++)
        n[i].call(this, e);
    }
    return this;
  }
}
class je {
  constructor(e, t, n, i) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), i === void 0 && (i = 1), this.x = e, this.y = t, this.z = n, this.w = i;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  setFromAxisAngle(e, t) {
    const n = Math.sin(t * 0.5);
    return this.x = e.x * n, this.y = e.y * n, this.z = e.z * n, this.w = Math.cos(t * 0.5), this;
  }
  toAxisAngle(e) {
    e === void 0 && (e = new b()), this.normalize();
    const t = 2 * Math.acos(this.w), n = Math.sqrt(1 - this.w * this.w);
    return n < 1e-3 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / n, e.y = this.y / n, e.z = this.z / n), [e, t];
  }
  setFromVectors(e, t) {
    if (e.isAntiparallelTo(t)) {
      const n = Yu, i = Zu;
      e.tangents(n, i), this.setFromAxisAngle(n, Math.PI);
    } else {
      const n = e.cross(t);
      this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(e.length() ** 2 * t.length() ** 2) + e.dot(t), this.normalize();
    }
    return this;
  }
  mult(e, t) {
    t === void 0 && (t = new je());
    const n = this.x, i = this.y, s = this.z, o = this.w, r = e.x, l = e.y, a = e.z, c = e.w;
    return t.x = n * c + o * r + i * a - s * l, t.y = i * c + o * l + s * r - n * a, t.z = s * c + o * a + n * l - i * r, t.w = o * c - n * r - i * l - s * a, t;
  }
  inverse(e) {
    e === void 0 && (e = new je());
    const t = this.x, n = this.y, i = this.z, s = this.w;
    this.conjugate(e);
    const o = 1 / (t * t + n * n + i * i + s * s);
    return e.x *= o, e.y *= o, e.z *= o, e.w *= o, e;
  }
  conjugate(e) {
    return e === void 0 && (e = new je()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e;
  }
  normalize() {
    let e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  normalizeFast() {
    const e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  vmult(e, t) {
    t === void 0 && (t = new b());
    const n = e.x, i = e.y, s = e.z, o = this.x, r = this.y, l = this.z, a = this.w, c = a * n + r * s - l * i, d = a * i + l * n - o * s, u = a * s + o * i - r * n, m = -o * n - r * i - l * s;
    return t.x = c * a + m * -o + d * -l - u * -r, t.y = d * a + m * -r + u * -o - c * -l, t.z = u * a + m * -l + c * -r - d * -o, t;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  toEuler(e, t) {
    t === void 0 && (t = "YZX");
    let n, i, s;
    const o = this.x, r = this.y, l = this.z, a = this.w;
    switch (t) {
      case "YZX":
        const c = o * r + l * a;
        if (c > 0.499 && (n = 2 * Math.atan2(o, a), i = Math.PI / 2, s = 0), c < -0.499 && (n = -2 * Math.atan2(o, a), i = -Math.PI / 2, s = 0), n === void 0) {
          const d = o * o, u = r * r, m = l * l;
          n = Math.atan2(2 * r * a - 2 * o * l, 1 - 2 * u - 2 * m), i = Math.asin(2 * c), s = Math.atan2(2 * o * a - 2 * r * l, 1 - 2 * d - 2 * m);
        }
        break;
      default:
        throw new Error(`Euler order ${t} not supported yet.`);
    }
    e.y = n, e.z = i, e.x = s;
  }
  setFromEuler(e, t, n, i) {
    i === void 0 && (i = "XYZ");
    const s = Math.cos(e / 2), o = Math.cos(t / 2), r = Math.cos(n / 2), l = Math.sin(e / 2), a = Math.sin(t / 2), c = Math.sin(n / 2);
    return i === "XYZ" ? (this.x = l * o * r + s * a * c, this.y = s * a * r - l * o * c, this.z = s * o * c + l * a * r, this.w = s * o * r - l * a * c) : i === "YXZ" ? (this.x = l * o * r + s * a * c, this.y = s * a * r - l * o * c, this.z = s * o * c - l * a * r, this.w = s * o * r + l * a * c) : i === "ZXY" ? (this.x = l * o * r - s * a * c, this.y = s * a * r + l * o * c, this.z = s * o * c + l * a * r, this.w = s * o * r - l * a * c) : i === "ZYX" ? (this.x = l * o * r - s * a * c, this.y = s * a * r + l * o * c, this.z = s * o * c - l * a * r, this.w = s * o * r + l * a * c) : i === "YZX" ? (this.x = l * o * r + s * a * c, this.y = s * a * r + l * o * c, this.z = s * o * c - l * a * r, this.w = s * o * r - l * a * c) : i === "XZY" && (this.x = l * o * r - s * a * c, this.y = s * a * r - l * o * c, this.z = s * o * c + l * a * r, this.w = s * o * r + l * a * c), this;
  }
  clone() {
    return new je(this.x, this.y, this.z, this.w);
  }
  slerp(e, t, n) {
    n === void 0 && (n = new je());
    const i = this.x, s = this.y, o = this.z, r = this.w;
    let l = e.x, a = e.y, c = e.z, d = e.w, u, m, g, p, f;
    return m = i * l + s * a + o * c + r * d, m < 0 && (m = -m, l = -l, a = -a, c = -c, d = -d), 1 - m > 1e-6 ? (u = Math.acos(m), g = Math.sin(u), p = Math.sin((1 - t) * u) / g, f = Math.sin(t * u) / g) : (p = 1 - t, f = t), n.x = p * i + f * l, n.y = p * s + f * a, n.z = p * o + f * c, n.w = p * r + f * d, n;
  }
  integrate(e, t, n, i) {
    i === void 0 && (i = new je());
    const s = e.x * n.x, o = e.y * n.y, r = e.z * n.z, l = this.x, a = this.y, c = this.z, d = this.w, u = t * 0.5;
    return i.x += u * (s * d + o * c - r * a), i.y += u * (o * d + r * l - s * c), i.z += u * (r * d + s * a - o * l), i.w += u * (-s * l - o * a - r * c), i;
  }
}
const Yu = new b(), Zu = new b(), $u = {
  SPHERE: 1,
  PLANE: 2,
  BOX: 4,
  COMPOUND: 8,
  CONVEXPOLYHEDRON: 16,
  HEIGHTFIELD: 32,
  PARTICLE: 64,
  CYLINDER: 128,
  TRIMESH: 256
};
class le {
  constructor(e) {
    e === void 0 && (e = {}), this.id = le.idCounter++, this.type = e.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = e.collisionResponse ? e.collisionResponse : !0, this.collisionFilterGroup = e.collisionFilterGroup !== void 0 ? e.collisionFilterGroup : 1, this.collisionFilterMask = e.collisionFilterMask !== void 0 ? e.collisionFilterMask : -1, this.material = e.material ? e.material : null, this.body = null;
  }
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  calculateLocalInertia(e, t) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  calculateWorldAABB(e, t, n, i) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
}
le.idCounter = 0;
le.types = $u;
class Pe {
  constructor(e) {
    e === void 0 && (e = {}), this.position = new b(), this.quaternion = new je(), e.position && this.position.copy(e.position), e.quaternion && this.quaternion.copy(e.quaternion);
  }
  pointToLocal(e, t) {
    return Pe.pointToLocalFrame(this.position, this.quaternion, e, t);
  }
  pointToWorld(e, t) {
    return Pe.pointToWorldFrame(this.position, this.quaternion, e, t);
  }
  vectorToWorldFrame(e, t) {
    return t === void 0 && (t = new b()), this.quaternion.vmult(e, t), t;
  }
  static pointToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new b()), n.vsub(e, i), t.conjugate(Or), Or.vmult(i, i), i;
  }
  static pointToWorldFrame(e, t, n, i) {
    return i === void 0 && (i = new b()), t.vmult(n, i), i.vadd(e, i), i;
  }
  static vectorToWorldFrame(e, t, n) {
    return n === void 0 && (n = new b()), e.vmult(t, n), n;
  }
  static vectorToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new b()), t.w *= -1, t.vmult(n, i), t.w *= -1, i;
  }
}
const Or = new je();
class wn extends le {
  constructor(e) {
    e === void 0 && (e = {});
    const {
      vertices: t = [],
      faces: n = [],
      normals: i = [],
      axes: s,
      boundingSphereRadius: o
    } = e;
    super({
      type: le.types.CONVEXPOLYHEDRON
    }), this.vertices = t, this.faces = n, this.faceNormals = i, this.faceNormals.length === 0 && this.computeNormals(), o ? this.boundingSphereRadius = o : this.updateBoundingSphereRadius(), this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, this.worldFaceNormals = [], this.worldFaceNormalsNeedsUpdate = !0, this.uniqueAxes = s ? s.slice() : null, this.uniqueEdges = [], this.computeEdges();
  }
  computeEdges() {
    const e = this.faces, t = this.vertices, n = this.uniqueEdges;
    n.length = 0;
    const i = new b();
    for (let s = 0; s !== e.length; s++) {
      const o = e[s], r = o.length;
      for (let l = 0; l !== r; l++) {
        const a = (l + 1) % r;
        t[o[l]].vsub(t[o[a]], i), i.normalize();
        let c = !1;
        for (let d = 0; d !== n.length; d++)
          if (n[d].almostEquals(i) || n[d].almostEquals(i)) {
            c = !0;
            break;
          }
        c || n.push(i.clone());
      }
    }
  }
  computeNormals() {
    this.faceNormals.length = this.faces.length;
    for (let e = 0; e < this.faces.length; e++) {
      for (let i = 0; i < this.faces[e].length; i++)
        if (!this.vertices[this.faces[e][i]])
          throw new Error(`Vertex ${this.faces[e][i]} not found!`);
      const t = this.faceNormals[e] || new b();
      this.getFaceNormal(e, t), t.negate(t), this.faceNormals[e] = t;
      const n = this.vertices[this.faces[e][0]];
      if (t.dot(n) < 0) {
        console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);
        for (let i = 0; i < this.faces[e].length; i++)
          console.warn(`.vertices[${this.faces[e][i]}] = Vec3(${this.vertices[this.faces[e][i]].toString()})`);
      }
    }
  }
  getFaceNormal(e, t) {
    const n = this.faces[e], i = this.vertices[n[0]], s = this.vertices[n[1]], o = this.vertices[n[2]];
    wn.computeNormal(i, s, o, t);
  }
  static computeNormal(e, t, n, i) {
    const s = new b(), o = new b();
    t.vsub(e, o), n.vsub(t, s), s.cross(o, i), i.isZero() || i.normalize();
  }
  clipAgainstHull(e, t, n, i, s, o, r, l, a) {
    const c = new b();
    let d = -1, u = -Number.MAX_VALUE;
    for (let g = 0; g < n.faces.length; g++) {
      c.copy(n.faceNormals[g]), s.vmult(c, c);
      const p = c.dot(o);
      p > u && (u = p, d = g);
    }
    const m = [];
    for (let g = 0; g < n.faces[d].length; g++) {
      const p = n.vertices[n.faces[d][g]], f = new b();
      f.copy(p), s.vmult(f, f), i.vadd(f, f), m.push(f);
    }
    d >= 0 && this.clipFaceAgainstHull(o, e, t, m, r, l, a);
  }
  findSeparatingAxis(e, t, n, i, s, o, r, l) {
    const a = new b(), c = new b(), d = new b(), u = new b(), m = new b(), g = new b();
    let p = Number.MAX_VALUE;
    const f = this;
    if (f.uniqueAxes)
      for (let v = 0; v !== f.uniqueAxes.length; v++) {
        n.vmult(f.uniqueAxes[v], a);
        const _ = f.testSepAxis(a, e, t, n, i, s);
        if (_ === !1)
          return !1;
        _ < p && (p = _, o.copy(a));
      }
    else {
      const v = r ? r.length : f.faces.length;
      for (let _ = 0; _ < v; _++) {
        const w = r ? r[_] : _;
        a.copy(f.faceNormals[w]), n.vmult(a, a);
        const x = f.testSepAxis(a, e, t, n, i, s);
        if (x === !1)
          return !1;
        x < p && (p = x, o.copy(a));
      }
    }
    if (e.uniqueAxes)
      for (let v = 0; v !== e.uniqueAxes.length; v++) {
        s.vmult(e.uniqueAxes[v], c);
        const _ = f.testSepAxis(c, e, t, n, i, s);
        if (_ === !1)
          return !1;
        _ < p && (p = _, o.copy(c));
      }
    else {
      const v = l ? l.length : e.faces.length;
      for (let _ = 0; _ < v; _++) {
        const w = l ? l[_] : _;
        c.copy(e.faceNormals[w]), s.vmult(c, c);
        const x = f.testSepAxis(c, e, t, n, i, s);
        if (x === !1)
          return !1;
        x < p && (p = x, o.copy(c));
      }
    }
    for (let v = 0; v !== f.uniqueEdges.length; v++) {
      n.vmult(f.uniqueEdges[v], u);
      for (let _ = 0; _ !== e.uniqueEdges.length; _++)
        if (s.vmult(e.uniqueEdges[_], m), u.cross(m, g), !g.almostZero()) {
          g.normalize();
          const w = f.testSepAxis(g, e, t, n, i, s);
          if (w === !1)
            return !1;
          w < p && (p = w, o.copy(g));
        }
    }
    return i.vsub(t, d), d.dot(o) > 0 && o.negate(o), !0;
  }
  testSepAxis(e, t, n, i, s, o) {
    const r = this;
    wn.project(r, e, n, i, As), wn.project(t, e, s, o, Cs);
    const l = As[0], a = As[1], c = Cs[0], d = Cs[1];
    if (l < d || c < a)
      return !1;
    const u = l - d, m = c - a;
    return u < m ? u : m;
  }
  calculateLocalInertia(e, t) {
    const n = new b(), i = new b();
    this.computeLocalAABB(i, n);
    const s = n.x - i.x, o = n.y - i.y, r = n.z - i.z;
    t.x = 1 / 12 * e * (2 * o * 2 * o + 2 * r * 2 * r), t.y = 1 / 12 * e * (2 * s * 2 * s + 2 * r * 2 * r), t.z = 1 / 12 * e * (2 * o * 2 * o + 2 * s * 2 * s);
  }
  getPlaneConstantOfFace(e) {
    const t = this.faces[e], n = this.faceNormals[e], i = this.vertices[t[0]];
    return -n.dot(i);
  }
  clipFaceAgainstHull(e, t, n, i, s, o, r) {
    const l = new b(), a = new b(), c = new b(), d = new b(), u = new b(), m = new b(), g = new b(), p = new b(), f = this, v = [], _ = i, w = v;
    let x = -1, M = Number.MAX_VALUE;
    for (let F = 0; F < f.faces.length; F++) {
      l.copy(f.faceNormals[F]), n.vmult(l, l);
      const P = l.dot(e);
      P < M && (M = P, x = F);
    }
    if (x < 0)
      return;
    const E = f.faces[x];
    E.connectedFaces = [];
    for (let F = 0; F < f.faces.length; F++)
      for (let P = 0; P < f.faces[F].length; P++)
        E.indexOf(f.faces[F][P]) !== -1 && F !== x && E.connectedFaces.indexOf(F) === -1 && E.connectedFaces.push(F);
    const R = E.length;
    for (let F = 0; F < R; F++) {
      const P = f.vertices[E[F]], G = f.vertices[E[(F + 1) % R]];
      P.vsub(G, a), c.copy(a), n.vmult(c, c), t.vadd(c, c), d.copy(this.faceNormals[x]), n.vmult(d, d), t.vadd(d, d), c.cross(d, u), u.negate(u), m.copy(P), n.vmult(m, m), t.vadd(m, m);
      const z = E.connectedFaces[F];
      g.copy(this.faceNormals[z]);
      const L = this.getPlaneConstantOfFace(z);
      p.copy(g), n.vmult(p, p);
      const I = L - p.dot(t);
      for (this.clipFaceAgainstPlane(_, w, p, I); _.length; )
        _.shift();
      for (; w.length; )
        _.push(w.shift());
    }
    g.copy(this.faceNormals[x]);
    const y = this.getPlaneConstantOfFace(x);
    p.copy(g), n.vmult(p, p);
    const A = y - p.dot(t);
    for (let F = 0; F < _.length; F++) {
      let P = p.dot(_[F]) + A;
      if (P <= s && (P = s), P <= o) {
        const G = _[F];
        if (P <= 1e-6) {
          const z = {
            point: G,
            normal: p,
            depth: P
          };
          r.push(z);
        }
      }
    }
  }
  clipFaceAgainstPlane(e, t, n, i) {
    let s, o;
    const r = e.length;
    if (r < 2)
      return t;
    let l = e[e.length - 1], a = e[0];
    s = n.dot(l) + i;
    for (let c = 0; c < r; c++) {
      if (a = e[c], o = n.dot(a) + i, s < 0)
        if (o < 0) {
          const d = new b();
          d.copy(a), t.push(d);
        } else {
          const d = new b();
          l.lerp(a, s / (s - o), d), t.push(d);
        }
      else if (o < 0) {
        const d = new b();
        l.lerp(a, s / (s - o), d), t.push(d), t.push(a);
      }
      l = a, s = o;
    }
    return t;
  }
  computeWorldVertices(e, t) {
    for (; this.worldVertices.length < this.vertices.length; )
      this.worldVertices.push(new b());
    const n = this.vertices, i = this.worldVertices;
    for (let s = 0; s !== this.vertices.length; s++)
      t.vmult(n[s], i[s]), e.vadd(i[s], i[s]);
    this.worldVerticesNeedsUpdate = !1;
  }
  computeLocalAABB(e, t) {
    const n = this.vertices;
    e.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), t.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i = 0; i < this.vertices.length; i++) {
      const s = n[i];
      s.x < e.x ? e.x = s.x : s.x > t.x && (t.x = s.x), s.y < e.y ? e.y = s.y : s.y > t.y && (t.y = s.y), s.z < e.z ? e.z = s.z : s.z > t.z && (t.z = s.z);
    }
  }
  computeWorldFaceNormals(e) {
    const t = this.faceNormals.length;
    for (; this.worldFaceNormals.length < t; )
      this.worldFaceNormals.push(new b());
    const n = this.faceNormals, i = this.worldFaceNormals;
    for (let s = 0; s !== t; s++)
      e.vmult(n[s], i[s]);
    this.worldFaceNormalsNeedsUpdate = !1;
  }
  updateBoundingSphereRadius() {
    let e = 0;
    const t = this.vertices;
    for (let n = 0; n !== t.length; n++) {
      const i = t[n].lengthSquared();
      i > e && (e = i);
    }
    this.boundingSphereRadius = Math.sqrt(e);
  }
  calculateWorldAABB(e, t, n, i) {
    const s = this.vertices;
    let o, r, l, a, c, d, u = new b();
    for (let m = 0; m < s.length; m++) {
      u.copy(s[m]), t.vmult(u, u), e.vadd(u, u);
      const g = u;
      (o === void 0 || g.x < o) && (o = g.x), (a === void 0 || g.x > a) && (a = g.x), (r === void 0 || g.y < r) && (r = g.y), (c === void 0 || g.y > c) && (c = g.y), (l === void 0 || g.z < l) && (l = g.z), (d === void 0 || g.z > d) && (d = g.z);
    }
    n.set(o, r, l), i.set(a, c, d);
  }
  volume() {
    return 4 * Math.PI * this.boundingSphereRadius / 3;
  }
  getAveragePointLocal(e) {
    e === void 0 && (e = new b());
    const t = this.vertices;
    for (let n = 0; n < t.length; n++)
      e.vadd(t[n], e);
    return e.scale(1 / t.length, e), e;
  }
  transformAllPoints(e, t) {
    const n = this.vertices.length, i = this.vertices;
    if (t) {
      for (let s = 0; s < n; s++) {
        const o = i[s];
        t.vmult(o, o);
      }
      for (let s = 0; s < this.faceNormals.length; s++) {
        const o = this.faceNormals[s];
        t.vmult(o, o);
      }
    }
    if (e)
      for (let s = 0; s < n; s++) {
        const o = i[s];
        o.vadd(e, o);
      }
  }
  pointIsInside(e) {
    const t = this.vertices, n = this.faces, i = this.faceNormals, s = null, o = new b();
    this.getAveragePointLocal(o);
    for (let r = 0; r < this.faces.length; r++) {
      let l = i[r];
      const a = t[n[r][0]], c = new b();
      e.vsub(a, c);
      const d = l.dot(c), u = new b();
      o.vsub(a, u);
      const m = l.dot(u);
      if (d < 0 && m > 0 || d > 0 && m < 0)
        return !1;
    }
    return s ? 1 : -1;
  }
  static project(e, t, n, i, s) {
    const o = e.vertices.length, r = Ku;
    let l = 0, a = 0;
    const c = Ju, d = e.vertices;
    c.setZero(), Pe.vectorToLocalFrame(n, i, t, r), Pe.pointToLocalFrame(n, i, c, c);
    const u = c.dot(r);
    a = l = d[0].dot(r);
    for (let m = 1; m < o; m++) {
      const g = d[m].dot(r);
      g > l && (l = g), g < a && (a = g);
    }
    if (a -= u, l -= u, a > l) {
      const m = a;
      a = l, l = m;
    }
    s[0] = l, s[1] = a;
  }
}
const As = [], Cs = [];
new b();
const Ku = new b(), Ju = new b();
class Ws extends le {
  constructor(e) {
    super({
      type: le.types.BOX
    }), this.halfExtents = e, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius();
  }
  updateConvexPolyhedronRepresentation() {
    const e = this.halfExtents.x, t = this.halfExtents.y, n = this.halfExtents.z, i = b, s = [new i(-e, -t, -n), new i(e, -t, -n), new i(e, t, -n), new i(-e, t, -n), new i(-e, -t, n), new i(e, -t, n), new i(e, t, n), new i(-e, t, n)], o = [
      [3, 2, 1, 0],
      [4, 5, 6, 7],
      [5, 4, 0, 1],
      [2, 3, 7, 6],
      [0, 4, 7, 3],
      [1, 2, 6, 5]
    ], r = [new i(0, 0, 1), new i(0, 1, 0), new i(1, 0, 0)], l = new wn({
      vertices: s,
      faces: o,
      axes: r
    });
    this.convexPolyhedronRepresentation = l, l.material = this.material;
  }
  calculateLocalInertia(e, t) {
    return t === void 0 && (t = new b()), Ws.calculateInertia(this.halfExtents, e, t), t;
  }
  static calculateInertia(e, t, n) {
    const i = e;
    n.x = 1 / 12 * t * (2 * i.y * 2 * i.y + 2 * i.z * 2 * i.z), n.y = 1 / 12 * t * (2 * i.x * 2 * i.x + 2 * i.z * 2 * i.z), n.z = 1 / 12 * t * (2 * i.y * 2 * i.y + 2 * i.x * 2 * i.x);
  }
  getSideNormals(e, t) {
    const n = e, i = this.halfExtents;
    if (n[0].set(i.x, 0, 0), n[1].set(0, i.y, 0), n[2].set(0, 0, i.z), n[3].set(-i.x, 0, 0), n[4].set(0, -i.y, 0), n[5].set(0, 0, -i.z), t !== void 0)
      for (let s = 0; s !== n.length; s++)
        t.vmult(n[s], n[s]);
    return n;
  }
  volume() {
    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }
  forEachWorldCorner(e, t, n) {
    const i = this.halfExtents, s = [[i.x, i.y, i.z], [-i.x, i.y, i.z], [-i.x, -i.y, i.z], [-i.x, -i.y, -i.z], [i.x, -i.y, -i.z], [i.x, i.y, -i.z], [-i.x, i.y, -i.z], [i.x, -i.y, i.z]];
    for (let o = 0; o < s.length; o++)
      hn.set(s[o][0], s[o][1], s[o][2]), t.vmult(hn, hn), e.vadd(hn, hn), n(hn.x, hn.y, hn.z);
  }
  calculateWorldAABB(e, t, n, i) {
    const s = this.halfExtents;
    Pt[0].set(s.x, s.y, s.z), Pt[1].set(-s.x, s.y, s.z), Pt[2].set(-s.x, -s.y, s.z), Pt[3].set(-s.x, -s.y, -s.z), Pt[4].set(s.x, -s.y, -s.z), Pt[5].set(s.x, s.y, -s.z), Pt[6].set(-s.x, s.y, -s.z), Pt[7].set(s.x, -s.y, s.z);
    const o = Pt[0];
    t.vmult(o, o), e.vadd(o, o), i.copy(o), n.copy(o);
    for (let r = 1; r < 8; r++) {
      const l = Pt[r];
      t.vmult(l, l), e.vadd(l, l);
      const a = l.x, c = l.y, d = l.z;
      a > i.x && (i.x = a), c > i.y && (i.y = c), d > i.z && (i.z = d), a < n.x && (n.x = a), c < n.y && (n.y = c), d < n.z && (n.z = d);
    }
  }
}
const hn = new b(), Pt = [new b(), new b(), new b(), new b(), new b(), new b(), new b(), new b()], Vs = {
  DYNAMIC: 1,
  STATIC: 2,
  KINEMATIC: 4
}, Hs = {
  AWAKE: 0,
  SLEEPY: 1,
  SLEEPING: 2
};
class ie extends bo {
  constructor(e) {
    e === void 0 && (e = {}), super(), this.id = ie.idCounter++, this.index = -1, this.world = null, this.vlambda = new b(), this.collisionFilterGroup = typeof e.collisionFilterGroup == "number" ? e.collisionFilterGroup : 1, this.collisionFilterMask = typeof e.collisionFilterMask == "number" ? e.collisionFilterMask : -1, this.collisionResponse = typeof e.collisionResponse == "boolean" ? e.collisionResponse : !0, this.position = new b(), this.previousPosition = new b(), this.interpolatedPosition = new b(), this.initPosition = new b(), e.position && (this.position.copy(e.position), this.previousPosition.copy(e.position), this.interpolatedPosition.copy(e.position), this.initPosition.copy(e.position)), this.velocity = new b(), e.velocity && this.velocity.copy(e.velocity), this.initVelocity = new b(), this.force = new b();
    const t = typeof e.mass == "number" ? e.mass : 0;
    this.mass = t, this.invMass = t > 0 ? 1 / t : 0, this.material = e.material || null, this.linearDamping = typeof e.linearDamping == "number" ? e.linearDamping : 0.01, this.type = t <= 0 ? ie.STATIC : ie.DYNAMIC, typeof e.type == typeof ie.STATIC && (this.type = e.type), this.allowSleep = typeof e.allowSleep < "u" ? e.allowSleep : !0, this.sleepState = ie.AWAKE, this.sleepSpeedLimit = typeof e.sleepSpeedLimit < "u" ? e.sleepSpeedLimit : 0.1, this.sleepTimeLimit = typeof e.sleepTimeLimit < "u" ? e.sleepTimeLimit : 1, this.timeLastSleepy = 0, this.wakeUpAfterNarrowphase = !1, this.torque = new b(), this.quaternion = new je(), this.initQuaternion = new je(), this.previousQuaternion = new je(), this.interpolatedQuaternion = new je(), e.quaternion && (this.quaternion.copy(e.quaternion), this.initQuaternion.copy(e.quaternion), this.previousQuaternion.copy(e.quaternion), this.interpolatedQuaternion.copy(e.quaternion)), this.angularVelocity = new b(), e.angularVelocity && this.angularVelocity.copy(e.angularVelocity), this.initAngularVelocity = new b(), this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new b(), this.invInertia = new b(), this.invInertiaWorld = new Lt(), this.invMassSolve = 0, this.invInertiaSolve = new b(), this.invInertiaWorldSolve = new Lt(), this.fixedRotation = typeof e.fixedRotation < "u" ? e.fixedRotation : !1, this.angularDamping = typeof e.angularDamping < "u" ? e.angularDamping : 0.01, this.linearFactor = new b(1, 1, 1), e.linearFactor && this.linearFactor.copy(e.linearFactor), this.angularFactor = new b(1, 1, 1), e.angularFactor && this.angularFactor.copy(e.angularFactor), this.aabb = new vt(), this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new b(), this.isTrigger = Boolean(e.isTrigger), e.shape && this.addShape(e.shape), this.updateMassProperties();
  }
  wakeUp() {
    const e = this.sleepState;
    this.sleepState = ie.AWAKE, this.wakeUpAfterNarrowphase = !1, e === ie.SLEEPING && this.dispatchEvent(ie.wakeupEvent);
  }
  sleep() {
    this.sleepState = ie.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.wakeUpAfterNarrowphase = !1;
  }
  sleepTick(e) {
    if (this.allowSleep) {
      const t = this.sleepState, n = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared(), i = this.sleepSpeedLimit ** 2;
      t === ie.AWAKE && n < i ? (this.sleepState = ie.SLEEPY, this.timeLastSleepy = e, this.dispatchEvent(ie.sleepyEvent)) : t === ie.SLEEPY && n > i ? this.wakeUp() : t === ie.SLEEPY && e - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(ie.sleepEvent));
    }
  }
  updateSolveMassProperties() {
    this.sleepState === ie.SLEEPING || this.type === ie.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
  }
  pointToLocalFrame(e, t) {
    return t === void 0 && (t = new b()), e.vsub(this.position, t), this.quaternion.conjugate().vmult(t, t), t;
  }
  vectorToLocalFrame(e, t) {
    return t === void 0 && (t = new b()), this.quaternion.conjugate().vmult(e, t), t;
  }
  pointToWorldFrame(e, t) {
    return t === void 0 && (t = new b()), this.quaternion.vmult(e, t), t.vadd(this.position, t), t;
  }
  vectorToWorldFrame(e, t) {
    return t === void 0 && (t = new b()), this.quaternion.vmult(e, t), t;
  }
  addShape(e, t, n) {
    const i = new b(), s = new je();
    return t && i.copy(t), n && s.copy(n), this.shapes.push(e), this.shapeOffsets.push(i), this.shapeOrientations.push(s), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, e.body = this, this;
  }
  removeShape(e) {
    const t = this.shapes.indexOf(e);
    return t === -1 ? (console.warn("Shape does not belong to the body"), this) : (this.shapes.splice(t, 1), this.shapeOffsets.splice(t, 1), this.shapeOrientations.splice(t, 1), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, e.body = null, this);
  }
  updateBoundingRadius() {
    const e = this.shapes, t = this.shapeOffsets, n = e.length;
    let i = 0;
    for (let s = 0; s !== n; s++) {
      const o = e[s];
      o.updateBoundingSphereRadius();
      const r = t[s].length(), l = o.boundingSphereRadius;
      r + l > i && (i = r + l);
    }
    this.boundingRadius = i;
  }
  updateAABB() {
    const e = this.shapes, t = this.shapeOffsets, n = this.shapeOrientations, i = e.length, s = Qu, o = ed, r = this.quaternion, l = this.aabb, a = td;
    for (let c = 0; c !== i; c++) {
      const d = e[c];
      r.vmult(t[c], s), s.vadd(this.position, s), r.mult(n[c], o), d.calculateWorldAABB(s, o, a.lowerBound, a.upperBound), c === 0 ? l.copy(a) : l.extend(a);
    }
    this.aabbNeedsUpdate = !1;
  }
  updateInertiaWorld(e) {
    const t = this.invInertia;
    if (!(t.x === t.y && t.y === t.z && !e)) {
      const n = nd, i = id;
      n.setRotationFromQuaternion(this.quaternion), n.transpose(i), n.scale(t, n), n.mmult(i, this.invInertiaWorld);
    }
  }
  applyForce(e, t) {
    if (t === void 0 && (t = new b()), this.type !== ie.DYNAMIC)
      return;
    this.sleepState === ie.SLEEPING && this.wakeUp();
    const n = rd;
    t.cross(e, n), this.force.vadd(e, this.force), this.torque.vadd(n, this.torque);
  }
  applyLocalForce(e, t) {
    if (t === void 0 && (t = new b()), this.type !== ie.DYNAMIC)
      return;
    const n = od, i = ad;
    this.vectorToWorldFrame(e, n), this.vectorToWorldFrame(t, i), this.applyForce(n, i);
  }
  applyTorque(e) {
    this.type === ie.DYNAMIC && (this.sleepState === ie.SLEEPING && this.wakeUp(), this.torque.vadd(e, this.torque));
  }
  applyImpulse(e, t) {
    if (t === void 0 && (t = new b()), this.type !== ie.DYNAMIC)
      return;
    this.sleepState === ie.SLEEPING && this.wakeUp();
    const n = t, i = ld;
    i.copy(e), i.scale(this.invMass, i), this.velocity.vadd(i, this.velocity);
    const s = cd;
    n.cross(e, s), this.invInertiaWorld.vmult(s, s), this.angularVelocity.vadd(s, this.angularVelocity);
  }
  applyLocalImpulse(e, t) {
    if (t === void 0 && (t = new b()), this.type !== ie.DYNAMIC)
      return;
    const n = hd, i = ud;
    this.vectorToWorldFrame(e, n), this.vectorToWorldFrame(t, i), this.applyImpulse(n, i);
  }
  updateMassProperties() {
    const e = dd;
    this.invMass = this.mass > 0 ? 1 / this.mass : 0;
    const t = this.inertia, n = this.fixedRotation;
    this.updateAABB(), e.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), Ws.calculateInertia(e, this.mass, t), this.invInertia.set(t.x > 0 && !n ? 1 / t.x : 0, t.y > 0 && !n ? 1 / t.y : 0, t.z > 0 && !n ? 1 / t.z : 0), this.updateInertiaWorld(!0);
  }
  getVelocityAtWorldPoint(e, t) {
    const n = new b();
    return e.vsub(this.position, n), this.angularVelocity.cross(n, t), this.velocity.vadd(t, t), t;
  }
  integrate(e, t, n) {
    if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), !(this.type === ie.DYNAMIC || this.type === ie.KINEMATIC) || this.sleepState === ie.SLEEPING)
      return;
    const i = this.velocity, s = this.angularVelocity, o = this.position, r = this.force, l = this.torque, a = this.quaternion, c = this.invMass, d = this.invInertiaWorld, u = this.linearFactor, m = c * e;
    i.x += r.x * m * u.x, i.y += r.y * m * u.y, i.z += r.z * m * u.z;
    const g = d.elements, p = this.angularFactor, f = l.x * p.x, v = l.y * p.y, _ = l.z * p.z;
    s.x += e * (g[0] * f + g[1] * v + g[2] * _), s.y += e * (g[3] * f + g[4] * v + g[5] * _), s.z += e * (g[6] * f + g[7] * v + g[8] * _), o.x += i.x * e, o.y += i.y * e, o.z += i.z * e, a.integrate(this.angularVelocity, e, this.angularFactor, a), t && (n ? a.normalizeFast() : a.normalize()), this.aabbNeedsUpdate = !0, this.updateInertiaWorld();
  }
}
ie.idCounter = 0;
ie.COLLIDE_EVENT_NAME = "collide";
ie.DYNAMIC = Vs.DYNAMIC;
ie.STATIC = Vs.STATIC;
ie.KINEMATIC = Vs.KINEMATIC;
ie.AWAKE = Hs.AWAKE;
ie.SLEEPY = Hs.SLEEPY;
ie.SLEEPING = Hs.SLEEPING;
ie.wakeupEvent = {
  type: "wakeup"
};
ie.sleepyEvent = {
  type: "sleepy"
};
ie.sleepEvent = {
  type: "sleep"
};
const Qu = new b(), ed = new je(), td = new vt(), nd = new Lt(), id = new Lt(), sd = new Lt(), rd = new b(), od = new b(), ad = new b(), ld = new b(), cd = new b(), hd = new b(), ud = new b(), dd = new b();
class fd {
  constructor() {
    this.world = null, this.useBoundingBoxes = !1, this.dirty = !0;
  }
  collisionPairs(e, t, n) {
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
  }
  needBroadphaseCollision(e, t) {
    return !((e.collisionFilterGroup & t.collisionFilterMask) === 0 || (t.collisionFilterGroup & e.collisionFilterMask) === 0 || ((e.type & ie.STATIC) !== 0 || e.sleepState === ie.SLEEPING) && ((t.type & ie.STATIC) !== 0 || t.sleepState === ie.SLEEPING));
  }
  intersectionTest(e, t, n, i) {
    this.useBoundingBoxes ? this.doBoundingBoxBroadphase(e, t, n, i) : this.doBoundingSphereBroadphase(e, t, n, i);
  }
  doBoundingSphereBroadphase(e, t, n, i) {
    const s = pd;
    t.position.vsub(e.position, s);
    const o = (e.boundingRadius + t.boundingRadius) ** 2;
    s.lengthSquared() < o && (n.push(e), i.push(t));
  }
  doBoundingBoxBroadphase(e, t, n, i) {
    e.aabbNeedsUpdate && e.updateAABB(), t.aabbNeedsUpdate && t.updateAABB(), e.aabb.overlaps(t.aabb) && (n.push(e), i.push(t));
  }
  makePairsUnique(e, t) {
    const n = md, i = gd, s = _d, o = e.length;
    for (let r = 0; r !== o; r++)
      i[r] = e[r], s[r] = t[r];
    e.length = 0, t.length = 0;
    for (let r = 0; r !== o; r++) {
      const l = i[r].id, a = s[r].id, c = l < a ? `${l},${a}` : `${a},${l}`;
      n[c] = r, n.keys.push(c);
    }
    for (let r = 0; r !== n.keys.length; r++) {
      const l = n.keys.pop(), a = n[l];
      e.push(i[a]), t.push(s[a]), delete n[l];
    }
  }
  setWorld(e) {
  }
  static boundingSphereCheck(e, t) {
    const n = new b();
    e.position.vsub(t.position, n);
    const i = e.shapes[0], s = t.shapes[0];
    return Math.pow(i.boundingSphereRadius + s.boundingSphereRadius, 2) > n.lengthSquared();
  }
  aabbQuery(e, t, n) {
    return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
  }
}
const pd = new b();
new b();
new je();
new b();
const md = {
  keys: []
}, gd = [], _d = [];
new b();
new b();
new b();
class wo extends fd {
  constructor() {
    super();
  }
  collisionPairs(e, t, n) {
    const i = e.bodies, s = i.length;
    let o, r;
    for (let l = 0; l !== s; l++)
      for (let a = 0; a !== l; a++)
        o = i[l], r = i[a], this.needBroadphaseCollision(o, r) && this.intersectionTest(o, r, t, n);
  }
  aabbQuery(e, t, n) {
    n === void 0 && (n = []);
    for (let i = 0; i < e.bodies.length; i++) {
      const s = e.bodies[i];
      s.aabbNeedsUpdate && s.updateAABB(), s.aabb.overlaps(t) && n.push(s);
    }
    return n;
  }
}
class Xi {
  constructor() {
    this.rayFromWorld = new b(), this.rayToWorld = new b(), this.hitNormalWorld = new b(), this.hitPointWorld = new b(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  abort() {
    this.shouldStop = !0;
  }
  set(e, t, n, i, s, o, r) {
    this.rayFromWorld.copy(e), this.rayToWorld.copy(t), this.hitNormalWorld.copy(n), this.hitPointWorld.copy(i), this.shape = s, this.body = o, this.distance = r;
  }
}
let Mo, So, Eo, To, Ao, Co, Lo;
const qs = {
  CLOSEST: 1,
  ANY: 2,
  ALL: 4
};
Mo = le.types.SPHERE;
So = le.types.PLANE;
Eo = le.types.BOX;
To = le.types.CYLINDER;
Ao = le.types.CONVEXPOLYHEDRON;
Co = le.types.HEIGHTFIELD;
Lo = le.types.TRIMESH;
class Xe {
  get [Mo]() {
    return this._intersectSphere;
  }
  get [So]() {
    return this._intersectPlane;
  }
  get [Eo]() {
    return this._intersectBox;
  }
  get [To]() {
    return this._intersectConvex;
  }
  get [Ao]() {
    return this._intersectConvex;
  }
  get [Co]() {
    return this._intersectHeightfield;
  }
  get [Lo]() {
    return this._intersectTrimesh;
  }
  constructor(e, t) {
    e === void 0 && (e = new b()), t === void 0 && (t = new b()), this.from = e.clone(), this.to = t.clone(), this.direction = new b(), this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = Xe.ANY, this.result = new Xi(), this.hasHit = !1, this.callback = (n) => {
    };
  }
  intersectWorld(e, t) {
    return this.mode = t.mode || Xe.ANY, this.result = t.result || new Xi(), this.skipBackfaces = !!t.skipBackfaces, this.collisionFilterMask = typeof t.collisionFilterMask < "u" ? t.collisionFilterMask : -1, this.collisionFilterGroup = typeof t.collisionFilterGroup < "u" ? t.collisionFilterGroup : -1, this.checkCollisionResponse = typeof t.checkCollisionResponse < "u" ? t.checkCollisionResponse : !0, t.from && this.from.copy(t.from), t.to && this.to.copy(t.to), this.callback = t.callback || (() => {
    }), this.hasHit = !1, this.result.reset(), this.updateDirection(), this.getAABB(Ur), Ls.length = 0, e.broadphase.aabbQuery(e, Ur, Ls), this.intersectBodies(Ls), this.hasHit;
  }
  intersectBody(e, t) {
    t && (this.result = t, this.updateDirection());
    const n = this.checkCollisionResponse;
    if (n && !e.collisionResponse || (this.collisionFilterGroup & e.collisionFilterMask) === 0 || (e.collisionFilterGroup & this.collisionFilterMask) === 0)
      return;
    const i = vd, s = xd;
    for (let o = 0, r = e.shapes.length; o < r; o++) {
      const l = e.shapes[o];
      if (!(n && !l.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[o], s), e.quaternion.vmult(e.shapeOffsets[o], i), i.vadd(e.position, i), this.intersectShape(l, s, i, e), this.result.shouldStop))
        break;
    }
  }
  intersectBodies(e, t) {
    t && (this.result = t, this.updateDirection());
    for (let n = 0, i = e.length; !this.result.shouldStop && n < i; n++)
      this.intersectBody(e[n]);
  }
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(e, t, n, i) {
    const s = this.from;
    if (Pd(s, this.direction, n) > e.boundingSphereRadius)
      return;
    const r = this[e.type];
    r && r.call(this, e, t, n, i, e);
  }
  _intersectBox(e, t, n, i, s) {
    return this._intersectConvex(e.convexPolyhedronRepresentation, t, n, i, s);
  }
  _intersectPlane(e, t, n, i, s) {
    const o = this.from, r = this.to, l = this.direction, a = new b(0, 0, 1);
    t.vmult(a, a);
    const c = new b();
    o.vsub(n, c);
    const d = c.dot(a);
    r.vsub(n, c);
    const u = c.dot(a);
    if (d * u > 0 || o.distanceTo(r) < d)
      return;
    const m = a.dot(l);
    if (Math.abs(m) < this.precision)
      return;
    const g = new b(), p = new b(), f = new b();
    o.vsub(n, g);
    const v = -a.dot(g) / m;
    l.scale(v, p), o.vadd(p, f), this.reportIntersection(a, f, s, i, -1);
  }
  getAABB(e) {
    const {
      lowerBound: t,
      upperBound: n
    } = e, i = this.to, s = this.from;
    t.x = Math.min(i.x, s.x), t.y = Math.min(i.y, s.y), t.z = Math.min(i.z, s.z), n.x = Math.max(i.x, s.x), n.y = Math.max(i.y, s.y), n.z = Math.max(i.z, s.z);
  }
  _intersectHeightfield(e, t, n, i, s) {
    e.data, e.elementSize;
    const o = yd;
    o.from.copy(this.from), o.to.copy(this.to), Pe.pointToLocalFrame(n, t, o.from, o.from), Pe.pointToLocalFrame(n, t, o.to, o.to), o.updateDirection();
    const r = bd;
    let l, a, c, d;
    l = a = 0, c = d = e.data.length - 1;
    const u = new vt();
    o.getAABB(u), e.getIndexOfPosition(u.lowerBound.x, u.lowerBound.y, r, !0), l = Math.max(l, r[0]), a = Math.max(a, r[1]), e.getIndexOfPosition(u.upperBound.x, u.upperBound.y, r, !0), c = Math.min(c, r[0] + 1), d = Math.min(d, r[1] + 1);
    for (let m = l; m < c; m++)
      for (let g = a; g < d; g++) {
        if (this.result.shouldStop)
          return;
        if (e.getAabbAtIndex(m, g, u), !!u.overlapsRay(o)) {
          if (e.getConvexTrianglePillar(m, g, !1), Pe.pointToWorldFrame(n, t, e.pillarOffset, Ni), this._intersectConvex(e.pillarConvex, t, Ni, i, s, Gr), this.result.shouldStop)
            return;
          e.getConvexTrianglePillar(m, g, !0), Pe.pointToWorldFrame(n, t, e.pillarOffset, Ni), this._intersectConvex(e.pillarConvex, t, Ni, i, s, Gr);
        }
      }
  }
  _intersectSphere(e, t, n, i, s) {
    const o = this.from, r = this.to, l = e.radius, a = (r.x - o.x) ** 2 + (r.y - o.y) ** 2 + (r.z - o.z) ** 2, c = 2 * ((r.x - o.x) * (o.x - n.x) + (r.y - o.y) * (o.y - n.y) + (r.z - o.z) * (o.z - n.z)), d = (o.x - n.x) ** 2 + (o.y - n.y) ** 2 + (o.z - n.z) ** 2 - l ** 2, u = c ** 2 - 4 * a * d, m = wd, g = Md;
    if (!(u < 0))
      if (u === 0)
        o.lerp(r, u, m), m.vsub(n, g), g.normalize(), this.reportIntersection(g, m, s, i, -1);
      else {
        const p = (-c - Math.sqrt(u)) / (2 * a), f = (-c + Math.sqrt(u)) / (2 * a);
        if (p >= 0 && p <= 1 && (o.lerp(r, p, m), m.vsub(n, g), g.normalize(), this.reportIntersection(g, m, s, i, -1)), this.result.shouldStop)
          return;
        f >= 0 && f <= 1 && (o.lerp(r, f, m), m.vsub(n, g), g.normalize(), this.reportIntersection(g, m, s, i, -1));
      }
  }
  _intersectConvex(e, t, n, i, s, o) {
    const r = Sd, l = kr, a = o && o.faceList || null, c = e.faces, d = e.vertices, u = e.faceNormals, m = this.direction, g = this.from, p = this.to, f = g.distanceTo(p), v = a ? a.length : c.length, _ = this.result;
    for (let w = 0; !_.shouldStop && w < v; w++) {
      const x = a ? a[w] : w, M = c[x], E = u[x], R = t, y = n;
      l.copy(d[M[0]]), R.vmult(l, l), l.vadd(y, l), l.vsub(g, l), R.vmult(E, r);
      const A = m.dot(r);
      if (Math.abs(A) < this.precision)
        continue;
      const F = r.dot(l) / A;
      if (!(F < 0)) {
        m.scale(F, ht), ht.vadd(g, ht), Ct.copy(d[M[0]]), R.vmult(Ct, Ct), y.vadd(Ct, Ct);
        for (let P = 1; !_.shouldStop && P < M.length - 1; P++) {
          It.copy(d[M[P]]), zt.copy(d[M[P + 1]]), R.vmult(It, It), R.vmult(zt, zt), y.vadd(It, It), y.vadd(zt, zt);
          const G = ht.distanceTo(g);
          !(Xe.pointInTriangle(ht, Ct, It, zt) || Xe.pointInTriangle(ht, It, Ct, zt)) || G > f || this.reportIntersection(r, ht, s, i, x);
        }
      }
    }
  }
  _intersectTrimesh(e, t, n, i, s, o) {
    const r = Ed, l = Fd, a = Dd, c = kr, d = Td, u = Ad, m = Cd, g = Rd, p = Ld, f = e.indices;
    e.vertices;
    const v = this.from, _ = this.to, w = this.direction;
    a.position.copy(n), a.quaternion.copy(t), Pe.vectorToLocalFrame(n, t, w, d), Pe.pointToLocalFrame(n, t, v, u), Pe.pointToLocalFrame(n, t, _, m), m.x *= e.scale.x, m.y *= e.scale.y, m.z *= e.scale.z, u.x *= e.scale.x, u.y *= e.scale.y, u.z *= e.scale.z, m.vsub(u, d), d.normalize();
    const x = u.distanceSquared(m);
    e.tree.rayQuery(this, a, l);
    for (let M = 0, E = l.length; !this.result.shouldStop && M !== E; M++) {
      const R = l[M];
      e.getNormal(R, r), e.getVertex(f[R * 3], Ct), Ct.vsub(u, c);
      const y = d.dot(r), A = r.dot(c) / y;
      if (A < 0)
        continue;
      d.scale(A, ht), ht.vadd(u, ht), e.getVertex(f[R * 3 + 1], It), e.getVertex(f[R * 3 + 2], zt);
      const F = ht.distanceSquared(u);
      !(Xe.pointInTriangle(ht, It, Ct, zt) || Xe.pointInTriangle(ht, Ct, It, zt)) || F > x || (Pe.vectorToWorldFrame(t, r, p), Pe.pointToWorldFrame(n, t, ht, g), this.reportIntersection(p, g, s, i, R));
    }
    l.length = 0;
  }
  reportIntersection(e, t, n, i, s) {
    const o = this.from, r = this.to, l = o.distanceTo(t), a = this.result;
    if (!(this.skipBackfaces && e.dot(this.direction) > 0))
      switch (a.hitFaceIndex = typeof s < "u" ? s : -1, this.mode) {
        case Xe.ALL:
          this.hasHit = !0, a.set(o, r, e, t, n, i, l), a.hasHit = !0, this.callback(a);
          break;
        case Xe.CLOSEST:
          (l < a.distance || !a.hasHit) && (this.hasHit = !0, a.hasHit = !0, a.set(o, r, e, t, n, i, l));
          break;
        case Xe.ANY:
          this.hasHit = !0, a.hasHit = !0, a.set(o, r, e, t, n, i, l), a.shouldStop = !0;
          break;
      }
  }
  static pointInTriangle(e, t, n, i) {
    i.vsub(t, xn), n.vsub(t, ii), e.vsub(t, Rs);
    const s = xn.dot(xn), o = xn.dot(ii), r = xn.dot(Rs), l = ii.dot(ii), a = ii.dot(Rs);
    let c, d;
    return (c = l * r - o * a) >= 0 && (d = s * a - o * r) >= 0 && c + d < s * l - o * o;
  }
}
Xe.CLOSEST = qs.CLOSEST;
Xe.ANY = qs.ANY;
Xe.ALL = qs.ALL;
const Ur = new vt(), Ls = [], ii = new b(), Rs = new b(), vd = new b(), xd = new je(), ht = new b(), Ct = new b(), It = new b(), zt = new b();
new b();
new Xi();
const Gr = {
  faceList: [0]
}, Ni = new b(), yd = new Xe(), bd = [], wd = new b(), Md = new b(), Sd = new b();
new b();
new b();
const kr = new b(), Ed = new b(), Td = new b(), Ad = new b(), Cd = new b(), Ld = new b(), Rd = new b();
new vt();
const Fd = [], Dd = new Pe(), xn = new b(), Oi = new b();
function Pd(h, e, t) {
  t.vsub(h, xn);
  const n = xn.dot(e);
  return e.scale(n, Oi), Oi.vadd(h, Oi), t.distanceTo(Oi);
}
class Id {
  static defaults(e, t) {
    e === void 0 && (e = {});
    for (let n in t)
      n in e || (e[n] = t[n]);
    return e;
  }
}
class Wr {
  constructor() {
    this.spatial = new b(), this.rotational = new b();
  }
  multiplyElement(e) {
    return e.spatial.dot(this.spatial) + e.rotational.dot(this.rotational);
  }
  multiplyVectors(e, t) {
    return e.dot(this.spatial) + t.dot(this.rotational);
  }
}
class mi {
  constructor(e, t, n, i) {
    n === void 0 && (n = -1e6), i === void 0 && (i = 1e6), this.id = mi.idCounter++, this.minForce = n, this.maxForce = i, this.bi = e, this.bj = t, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new Wr(), this.jacobianElementB = new Wr(), this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
  }
  setSpookParams(e, t, n) {
    const i = t, s = e, o = n;
    this.a = 4 / (o * (1 + 4 * i)), this.b = 4 * i / (1 + 4 * i), this.eps = 4 / (o * o * s * (1 + 4 * i));
  }
  computeB(e, t, n) {
    const i = this.computeGW(), s = this.computeGq(), o = this.computeGiMf();
    return -s * e - i * t - o * n;
  }
  computeGq() {
    const e = this.jacobianElementA, t = this.jacobianElementB, n = this.bi, i = this.bj, s = n.position, o = i.position;
    return e.spatial.dot(s) + t.spatial.dot(o);
  }
  computeGW() {
    const e = this.jacobianElementA, t = this.jacobianElementB, n = this.bi, i = this.bj, s = n.velocity, o = i.velocity, r = n.angularVelocity, l = i.angularVelocity;
    return e.multiplyVectors(s, r) + t.multiplyVectors(o, l);
  }
  computeGWlambda() {
    const e = this.jacobianElementA, t = this.jacobianElementB, n = this.bi, i = this.bj, s = n.vlambda, o = i.vlambda, r = n.wlambda, l = i.wlambda;
    return e.multiplyVectors(s, r) + t.multiplyVectors(o, l);
  }
  computeGiMf() {
    const e = this.jacobianElementA, t = this.jacobianElementB, n = this.bi, i = this.bj, s = n.force, o = n.torque, r = i.force, l = i.torque, a = n.invMassSolve, c = i.invMassSolve;
    return s.scale(a, Vr), r.scale(c, Hr), n.invInertiaWorldSolve.vmult(o, qr), i.invInertiaWorldSolve.vmult(l, Xr), e.multiplyVectors(Vr, qr) + t.multiplyVectors(Hr, Xr);
  }
  computeGiMGt() {
    const e = this.jacobianElementA, t = this.jacobianElementB, n = this.bi, i = this.bj, s = n.invMassSolve, o = i.invMassSolve, r = n.invInertiaWorldSolve, l = i.invInertiaWorldSolve;
    let a = s + o;
    return r.vmult(e.rotational, Ui), a += Ui.dot(e.rotational), l.vmult(t.rotational, Ui), a += Ui.dot(t.rotational), a;
  }
  addToWlambda(e) {
    const t = this.jacobianElementA, n = this.jacobianElementB, i = this.bi, s = this.bj, o = zd;
    i.vlambda.addScaledVector(i.invMassSolve * e, t.spatial, i.vlambda), s.vlambda.addScaledVector(s.invMassSolve * e, n.spatial, s.vlambda), i.invInertiaWorldSolve.vmult(t.rotational, o), i.wlambda.addScaledVector(e, o, i.wlambda), s.invInertiaWorldSolve.vmult(n.rotational, o), s.wlambda.addScaledVector(e, o, s.wlambda);
  }
  computeC() {
    return this.computeGiMGt() + this.eps;
  }
}
mi.idCounter = 0;
const Vr = new b(), Hr = new b(), qr = new b(), Xr = new b(), Ui = new b(), zd = new b();
class Bd extends mi {
  constructor(e, t, n) {
    n === void 0 && (n = 1e6), super(e, t, 0, n), this.restitution = 0, this.ri = new b(), this.rj = new b(), this.ni = new b();
  }
  computeB(e) {
    const t = this.a, n = this.b, i = this.bi, s = this.bj, o = this.ri, r = this.rj, l = Nd, a = Od, c = i.velocity, d = i.angularVelocity;
    i.force, i.torque;
    const u = s.velocity, m = s.angularVelocity;
    s.force, s.torque;
    const g = Ud, p = this.jacobianElementA, f = this.jacobianElementB, v = this.ni;
    o.cross(v, l), r.cross(v, a), v.negate(p.spatial), l.negate(p.rotational), f.spatial.copy(v), f.rotational.copy(a), g.copy(s.position), g.vadd(r, g), g.vsub(i.position, g), g.vsub(o, g);
    const _ = v.dot(g), w = this.restitution + 1, x = w * u.dot(v) - w * c.dot(v) + m.dot(a) - d.dot(l), M = this.computeGiMf();
    return -_ * t - x * n - e * M;
  }
  getImpactVelocityAlongNormal() {
    const e = Gd, t = kd, n = Wd, i = Vd, s = Hd;
    return this.bi.position.vadd(this.ri, n), this.bj.position.vadd(this.rj, i), this.bi.getVelocityAtWorldPoint(n, e), this.bj.getVelocityAtWorldPoint(i, t), e.vsub(t, s), this.ni.dot(s);
  }
}
const Nd = new b(), Od = new b(), Ud = new b(), Gd = new b(), kd = new b(), Wd = new b(), Vd = new b(), Hd = new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
class jr extends mi {
  constructor(e, t, n) {
    super(e, t, -n, n), this.ri = new b(), this.rj = new b(), this.t = new b();
  }
  computeB(e) {
    this.a;
    const t = this.b;
    this.bi, this.bj;
    const n = this.ri, i = this.rj, s = qd, o = Xd, r = this.t;
    n.cross(r, s), i.cross(r, o);
    const l = this.jacobianElementA, a = this.jacobianElementB;
    r.negate(l.spatial), s.negate(l.rotational), a.spatial.copy(r), a.rotational.copy(o);
    const c = this.computeGW(), d = this.computeGiMf();
    return -c * t - e * d;
  }
}
const qd = new b(), Xd = new b();
class Mn {
  constructor(e, t, n) {
    n = Id.defaults(n, {
      friction: 0.3,
      restitution: 0.3,
      contactEquationStiffness: 1e7,
      contactEquationRelaxation: 3,
      frictionEquationStiffness: 1e7,
      frictionEquationRelaxation: 3
    }), this.id = Mn.idCounter++, this.materials = [e, t], this.friction = n.friction, this.restitution = n.restitution, this.contactEquationStiffness = n.contactEquationStiffness, this.contactEquationRelaxation = n.contactEquationRelaxation, this.frictionEquationStiffness = n.frictionEquationStiffness, this.frictionEquationRelaxation = n.frictionEquationRelaxation;
  }
}
Mn.idCounter = 0;
class Sn {
  constructor(e) {
    e === void 0 && (e = {});
    let t = "";
    typeof e == "string" && (t = e, e = {}), this.name = t, this.id = Sn.idCounter++, this.friction = typeof e.friction < "u" ? e.friction : -1, this.restitution = typeof e.restitution < "u" ? e.restitution : -1;
  }
}
Sn.idCounter = 0;
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new Xe();
new b();
new b();
new b();
new b(1, 0, 0), new b(0, 1, 0), new b(0, 0, 1);
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
class jd extends wn {
  constructor(e, t, n, i) {
    if (e === void 0 && (e = 1), t === void 0 && (t = 1), n === void 0 && (n = 1), i === void 0 && (i = 8), e < 0)
      throw new Error("The cylinder radiusTop cannot be negative.");
    if (t < 0)
      throw new Error("The cylinder radiusBottom cannot be negative.");
    const s = i, o = [], r = [], l = [], a = [], c = [], d = Math.cos, u = Math.sin;
    o.push(new b(-t * u(0), -n * 0.5, t * d(0))), a.push(0), o.push(new b(-e * u(0), n * 0.5, e * d(0))), c.push(1);
    for (let g = 0; g < s; g++) {
      const p = 2 * Math.PI / s * (g + 1), f = 2 * Math.PI / s * (g + 0.5);
      g < s - 1 ? (o.push(new b(-t * u(p), -n * 0.5, t * d(p))), a.push(2 * g + 2), o.push(new b(-e * u(p), n * 0.5, e * d(p))), c.push(2 * g + 3), l.push([2 * g, 2 * g + 1, 2 * g + 3, 2 * g + 2])) : l.push([2 * g, 2 * g + 1, 1, 0]), (s % 2 === 1 || g < s / 2) && r.push(new b(-u(f), 0, d(f)));
    }
    l.push(a), r.push(new b(0, 1, 0));
    const m = [];
    for (let g = 0; g < c.length; g++)
      m.push(c[c.length - g - 1]);
    l.push(m), super({
      vertices: o,
      faces: l,
      axes: r
    }), this.type = le.types.CYLINDER, this.radiusTop = e, this.radiusBottom = t, this.height = n, this.numSegments = i;
  }
}
class si extends le {
  constructor() {
    super({
      type: le.types.PLANE
    }), this.worldNormal = new b(), this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE;
  }
  computeWorldNormal(e) {
    const t = this.worldNormal;
    t.set(0, 0, 1), e.vmult(t, t), this.worldNormalNeedsUpdate = !1;
  }
  calculateLocalInertia(e, t) {
    return t === void 0 && (t = new b()), t;
  }
  volume() {
    return Number.MAX_VALUE;
  }
  calculateWorldAABB(e, t, n, i) {
    jt.set(0, 0, 1), t.vmult(jt, jt);
    const s = Number.MAX_VALUE;
    n.set(-s, -s, -s), i.set(s, s, s), jt.x === 1 ? i.x = e.x : jt.x === -1 && (n.x = e.x), jt.y === 1 ? i.y = e.y : jt.y === -1 && (n.y = e.y), jt.z === 1 ? i.z = e.z : jt.z === -1 && (n.z = e.z);
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
}
const jt = new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new vt();
new b();
new vt();
new b();
new b();
new b();
new b();
new b();
new b();
new b();
new vt();
new b();
new Pe();
new vt();
class Yd {
  constructor() {
    this.equations = [];
  }
  solve(e, t) {
    return 0;
  }
  addEquation(e) {
    e.enabled && !e.bi.isTrigger && !e.bj.isTrigger && this.equations.push(e);
  }
  removeEquation(e) {
    const t = this.equations, n = t.indexOf(e);
    n !== -1 && t.splice(n, 1);
  }
  removeAllEquations() {
    this.equations.length = 0;
  }
}
class Zd extends Yd {
  constructor() {
    super(), this.iterations = 10, this.tolerance = 1e-7;
  }
  solve(e, t) {
    let n = 0;
    const i = this.iterations, s = this.tolerance * this.tolerance, o = this.equations, r = o.length, l = t.bodies, a = l.length, c = e;
    let d, u, m, g, p, f;
    if (r !== 0)
      for (let x = 0; x !== a; x++)
        l[x].updateSolveMassProperties();
    const v = Kd, _ = Jd, w = $d;
    v.length = r, _.length = r, w.length = r;
    for (let x = 0; x !== r; x++) {
      const M = o[x];
      w[x] = 0, _[x] = M.computeB(c), v[x] = 1 / M.computeC();
    }
    if (r !== 0) {
      for (let E = 0; E !== a; E++) {
        const R = l[E], y = R.vlambda, A = R.wlambda;
        y.set(0, 0, 0), A.set(0, 0, 0);
      }
      for (n = 0; n !== i; n++) {
        g = 0;
        for (let E = 0; E !== r; E++) {
          const R = o[E];
          d = _[E], u = v[E], f = w[E], p = R.computeGWlambda(), m = u * (d - p - R.eps * f), f + m < R.minForce ? m = R.minForce - f : f + m > R.maxForce && (m = R.maxForce - f), w[E] += m, g += m > 0 ? m : -m, R.addToWlambda(m);
        }
        if (g * g < s)
          break;
      }
      for (let E = 0; E !== a; E++) {
        const R = l[E], y = R.velocity, A = R.angularVelocity;
        R.vlambda.vmul(R.linearFactor, R.vlambda), y.vadd(R.vlambda, y), R.wlambda.vmul(R.angularFactor, R.wlambda), A.vadd(R.wlambda, A);
      }
      let x = o.length;
      const M = 1 / c;
      for (; x--; )
        o[x].multiplier = w[x] * M;
    }
    return n;
  }
}
const $d = [], Kd = [], Jd = [];
ie.STATIC;
class Qd {
  constructor() {
    this.objects = [], this.type = Object;
  }
  release() {
    const e = arguments.length;
    for (let t = 0; t !== e; t++)
      this.objects.push(t < 0 || arguments.length <= t ? void 0 : arguments[t]);
    return this;
  }
  get() {
    return this.objects.length === 0 ? this.constructObject() : this.objects.pop();
  }
  constructObject() {
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
  }
  resize(e) {
    const t = this.objects;
    for (; t.length > e; )
      t.pop();
    for (; t.length < e; )
      t.push(this.constructObject());
    return this;
  }
}
class ef extends Qd {
  constructor() {
    super(...arguments), this.type = b;
  }
  constructObject() {
    return new b();
  }
}
const Ue = {
  sphereSphere: le.types.SPHERE,
  spherePlane: le.types.SPHERE | le.types.PLANE,
  boxBox: le.types.BOX | le.types.BOX,
  sphereBox: le.types.SPHERE | le.types.BOX,
  planeBox: le.types.PLANE | le.types.BOX,
  convexConvex: le.types.CONVEXPOLYHEDRON,
  sphereConvex: le.types.SPHERE | le.types.CONVEXPOLYHEDRON,
  planeConvex: le.types.PLANE | le.types.CONVEXPOLYHEDRON,
  boxConvex: le.types.BOX | le.types.CONVEXPOLYHEDRON,
  sphereHeightfield: le.types.SPHERE | le.types.HEIGHTFIELD,
  boxHeightfield: le.types.BOX | le.types.HEIGHTFIELD,
  convexHeightfield: le.types.CONVEXPOLYHEDRON | le.types.HEIGHTFIELD,
  sphereParticle: le.types.PARTICLE | le.types.SPHERE,
  planeParticle: le.types.PLANE | le.types.PARTICLE,
  boxParticle: le.types.BOX | le.types.PARTICLE,
  convexParticle: le.types.PARTICLE | le.types.CONVEXPOLYHEDRON,
  cylinderCylinder: le.types.CYLINDER,
  sphereCylinder: le.types.SPHERE | le.types.CYLINDER,
  planeCylinder: le.types.PLANE | le.types.CYLINDER,
  boxCylinder: le.types.BOX | le.types.CYLINDER,
  convexCylinder: le.types.CONVEXPOLYHEDRON | le.types.CYLINDER,
  heightfieldCylinder: le.types.HEIGHTFIELD | le.types.CYLINDER,
  particleCylinder: le.types.PARTICLE | le.types.CYLINDER,
  sphereTrimesh: le.types.SPHERE | le.types.TRIMESH,
  planeTrimesh: le.types.PLANE | le.types.TRIMESH
};
class tf {
  get [Ue.sphereSphere]() {
    return this.sphereSphere;
  }
  get [Ue.spherePlane]() {
    return this.spherePlane;
  }
  get [Ue.boxBox]() {
    return this.boxBox;
  }
  get [Ue.sphereBox]() {
    return this.sphereBox;
  }
  get [Ue.planeBox]() {
    return this.planeBox;
  }
  get [Ue.convexConvex]() {
    return this.convexConvex;
  }
  get [Ue.sphereConvex]() {
    return this.sphereConvex;
  }
  get [Ue.planeConvex]() {
    return this.planeConvex;
  }
  get [Ue.boxConvex]() {
    return this.boxConvex;
  }
  get [Ue.sphereHeightfield]() {
    return this.sphereHeightfield;
  }
  get [Ue.boxHeightfield]() {
    return this.boxHeightfield;
  }
  get [Ue.convexHeightfield]() {
    return this.convexHeightfield;
  }
  get [Ue.sphereParticle]() {
    return this.sphereParticle;
  }
  get [Ue.planeParticle]() {
    return this.planeParticle;
  }
  get [Ue.boxParticle]() {
    return this.boxParticle;
  }
  get [Ue.convexParticle]() {
    return this.convexParticle;
  }
  get [Ue.cylinderCylinder]() {
    return this.convexConvex;
  }
  get [Ue.sphereCylinder]() {
    return this.sphereConvex;
  }
  get [Ue.planeCylinder]() {
    return this.planeConvex;
  }
  get [Ue.boxCylinder]() {
    return this.boxConvex;
  }
  get [Ue.convexCylinder]() {
    return this.convexConvex;
  }
  get [Ue.heightfieldCylinder]() {
    return this.heightfieldCylinder;
  }
  get [Ue.particleCylinder]() {
    return this.particleCylinder;
  }
  get [Ue.sphereTrimesh]() {
    return this.sphereTrimesh;
  }
  get [Ue.planeTrimesh]() {
    return this.planeTrimesh;
  }
  constructor(e) {
    this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new ef(), this.world = e, this.currentContactMaterial = e.defaultContactMaterial, this.enableFrictionReduction = !1;
  }
  createContactEquation(e, t, n, i, s, o) {
    let r;
    this.contactPointPool.length ? (r = this.contactPointPool.pop(), r.bi = e, r.bj = t) : r = new Bd(e, t), r.enabled = e.collisionResponse && t.collisionResponse && n.collisionResponse && i.collisionResponse;
    const l = this.currentContactMaterial;
    r.restitution = l.restitution, r.setSpookParams(l.contactEquationStiffness, l.contactEquationRelaxation, this.world.dt);
    const a = n.material || e.material, c = i.material || t.material;
    return a && c && a.restitution >= 0 && c.restitution >= 0 && (r.restitution = a.restitution * c.restitution), r.si = s || n, r.sj = o || i, r;
  }
  createFrictionEquationsFromContact(e, t) {
    const n = e.bi, i = e.bj, s = e.si, o = e.sj, r = this.world, l = this.currentContactMaterial;
    let a = l.friction;
    const c = s.material || n.material, d = o.material || i.material;
    if (c && d && c.friction >= 0 && d.friction >= 0 && (a = c.friction * d.friction), a > 0) {
      const u = a * (r.frictionGravity || r.gravity).length();
      let m = n.invMass + i.invMass;
      m > 0 && (m = 1 / m);
      const g = this.frictionEquationPool, p = g.length ? g.pop() : new jr(n, i, u * m), f = g.length ? g.pop() : new jr(n, i, u * m);
      return p.bi = f.bi = n, p.bj = f.bj = i, p.minForce = f.minForce = -u * m, p.maxForce = f.maxForce = u * m, p.ri.copy(e.ri), p.rj.copy(e.rj), f.ri.copy(e.ri), f.rj.copy(e.rj), e.ni.tangents(p.t, f.t), p.setSpookParams(l.frictionEquationStiffness, l.frictionEquationRelaxation, r.dt), f.setSpookParams(l.frictionEquationStiffness, l.frictionEquationRelaxation, r.dt), p.enabled = f.enabled = e.enabled, t.push(p, f), !0;
    }
    return !1;
  }
  createFrictionFromAverage(e) {
    let t = this.result[this.result.length - 1];
    if (!this.createFrictionEquationsFromContact(t, this.frictionResult) || e === 1)
      return;
    const n = this.frictionResult[this.frictionResult.length - 2], i = this.frictionResult[this.frictionResult.length - 1];
    mn.setZero(), qn.setZero(), Xn.setZero();
    const s = t.bi;
    t.bj;
    for (let r = 0; r !== e; r++)
      t = this.result[this.result.length - 1 - r], t.bi !== s ? (mn.vadd(t.ni, mn), qn.vadd(t.ri, qn), Xn.vadd(t.rj, Xn)) : (mn.vsub(t.ni, mn), qn.vadd(t.rj, qn), Xn.vadd(t.ri, Xn));
    const o = 1 / e;
    qn.scale(o, n.ri), Xn.scale(o, n.rj), i.ri.copy(n.ri), i.rj.copy(n.rj), mn.normalize(), mn.tangents(n.t, i.t);
  }
  getContacts(e, t, n, i, s, o, r) {
    this.contactPointPool = s, this.frictionEquationPool = r, this.result = i, this.frictionResult = o;
    const l = rf, a = of, c = nf, d = sf;
    for (let u = 0, m = e.length; u !== m; u++) {
      const g = e[u], p = t[u];
      let f = null;
      g.material && p.material && (f = n.getContactMaterial(g.material, p.material) || null);
      const v = g.type & ie.KINEMATIC && p.type & ie.STATIC || g.type & ie.STATIC && p.type & ie.KINEMATIC || g.type & ie.KINEMATIC && p.type & ie.KINEMATIC;
      for (let _ = 0; _ < g.shapes.length; _++) {
        g.quaternion.mult(g.shapeOrientations[_], l), g.quaternion.vmult(g.shapeOffsets[_], c), c.vadd(g.position, c);
        const w = g.shapes[_];
        for (let x = 0; x < p.shapes.length; x++) {
          p.quaternion.mult(p.shapeOrientations[x], a), p.quaternion.vmult(p.shapeOffsets[x], d), d.vadd(p.position, d);
          const M = p.shapes[x];
          if (!(w.collisionFilterMask & M.collisionFilterGroup && M.collisionFilterMask & w.collisionFilterGroup) || c.distanceTo(d) > w.boundingSphereRadius + M.boundingSphereRadius)
            continue;
          let E = null;
          w.material && M.material && (E = n.getContactMaterial(w.material, M.material) || null), this.currentContactMaterial = E || f || n.defaultContactMaterial;
          const R = w.type | M.type, y = this[R];
          if (y) {
            let A = !1;
            w.type < M.type ? A = y.call(this, w, M, c, d, l, a, g, p, w, M, v) : A = y.call(this, M, w, d, c, a, l, p, g, w, M, v), A && v && (n.shapeOverlapKeeper.set(w.id, M.id), n.bodyOverlapKeeper.set(g.id, p.id));
          }
        }
      }
    }
  }
  sphereSphere(e, t, n, i, s, o, r, l, a, c, d) {
    if (d)
      return n.distanceSquared(i) < (e.radius + t.radius) ** 2;
    const u = this.createContactEquation(r, l, e, t, a, c);
    i.vsub(n, u.ni), u.ni.normalize(), u.ri.copy(u.ni), u.rj.copy(u.ni), u.ri.scale(e.radius, u.ri), u.rj.scale(-t.radius, u.rj), u.ri.vadd(n, u.ri), u.ri.vsub(r.position, u.ri), u.rj.vadd(i, u.rj), u.rj.vsub(l.position, u.rj), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult);
  }
  spherePlane(e, t, n, i, s, o, r, l, a, c, d) {
    const u = this.createContactEquation(r, l, e, t, a, c);
    if (u.ni.set(0, 0, 1), o.vmult(u.ni, u.ni), u.ni.negate(u.ni), u.ni.normalize(), u.ni.scale(e.radius, u.ri), n.vsub(i, Gi), u.ni.scale(u.ni.dot(Gi), Yr), Gi.vsub(Yr, u.rj), -Gi.dot(u.ni) <= e.radius) {
      if (d)
        return !0;
      const m = u.ri, g = u.rj;
      m.vadd(n, m), m.vsub(r.position, m), g.vadd(i, g), g.vsub(l.position, g), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult);
    }
  }
  boxBox(e, t, n, i, s, o, r, l, a, c, d) {
    return e.convexPolyhedronRepresentation.material = e.material, t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexConvex(e.convexPolyhedronRepresentation, t.convexPolyhedronRepresentation, n, i, s, o, r, l, e, t, d);
  }
  sphereBox(e, t, n, i, s, o, r, l, a, c, d) {
    const u = this.v3pool, m = Df;
    n.vsub(i, ki), t.getSideNormals(m, o);
    const g = e.radius;
    let p = !1;
    const f = If, v = zf, _ = Bf;
    let w = null, x = 0, M = 0, E = 0, R = null;
    for (let D = 0, q = m.length; D !== q && p === !1; D++) {
      const k = Lf;
      k.copy(m[D]);
      const N = k.length();
      k.normalize();
      const H = ki.dot(k);
      if (H < N + g && H > 0) {
        const J = Rf, V = Ff;
        J.copy(m[(D + 1) % 3]), V.copy(m[(D + 2) % 3]);
        const ee = J.length(), ce = V.length();
        J.normalize(), V.normalize();
        const ge = ki.dot(J), $ = ki.dot(V);
        if (ge < ee && ge > -ee && $ < ce && $ > -ce) {
          const De = Math.abs(H - N - g);
          if ((R === null || De < R) && (R = De, M = ge, E = $, w = N, f.copy(k), v.copy(J), _.copy(V), x++, d))
            return !0;
        }
      }
    }
    if (x) {
      p = !0;
      const D = this.createContactEquation(r, l, e, t, a, c);
      f.scale(-g, D.ri), D.ni.copy(f), D.ni.negate(D.ni), f.scale(w, f), v.scale(M, v), f.vadd(v, f), _.scale(E, _), f.vadd(_, D.rj), D.ri.vadd(n, D.ri), D.ri.vsub(r.position, D.ri), D.rj.vadd(i, D.rj), D.rj.vsub(l.position, D.rj), this.result.push(D), this.createFrictionEquationsFromContact(D, this.frictionResult);
    }
    let y = u.get();
    const A = Pf;
    for (let D = 0; D !== 2 && !p; D++)
      for (let q = 0; q !== 2 && !p; q++)
        for (let k = 0; k !== 2 && !p; k++)
          if (y.set(0, 0, 0), D ? y.vadd(m[0], y) : y.vsub(m[0], y), q ? y.vadd(m[1], y) : y.vsub(m[1], y), k ? y.vadd(m[2], y) : y.vsub(m[2], y), i.vadd(y, A), A.vsub(n, A), A.lengthSquared() < g * g) {
            if (d)
              return !0;
            p = !0;
            const N = this.createContactEquation(r, l, e, t, a, c);
            N.ri.copy(A), N.ri.normalize(), N.ni.copy(N.ri), N.ri.scale(g, N.ri), N.rj.copy(y), N.ri.vadd(n, N.ri), N.ri.vsub(r.position, N.ri), N.rj.vadd(i, N.rj), N.rj.vsub(l.position, N.rj), this.result.push(N), this.createFrictionEquationsFromContact(N, this.frictionResult);
          }
    u.release(y), y = null;
    const F = u.get(), P = u.get(), G = u.get(), z = u.get(), L = u.get(), I = m.length;
    for (let D = 0; D !== I && !p; D++)
      for (let q = 0; q !== I && !p; q++)
        if (D % 3 !== q % 3) {
          m[q].cross(m[D], F), F.normalize(), m[D].vadd(m[q], P), G.copy(n), G.vsub(P, G), G.vsub(i, G);
          const k = G.dot(F);
          F.scale(k, z);
          let N = 0;
          for (; N === D % 3 || N === q % 3; )
            N++;
          L.copy(n), L.vsub(z, L), L.vsub(P, L), L.vsub(i, L);
          const H = Math.abs(k), J = L.length();
          if (H < m[N].length() && J < g) {
            if (d)
              return !0;
            p = !0;
            const V = this.createContactEquation(r, l, e, t, a, c);
            P.vadd(z, V.rj), V.rj.copy(V.rj), L.negate(V.ni), V.ni.normalize(), V.ri.copy(V.rj), V.ri.vadd(i, V.ri), V.ri.vsub(n, V.ri), V.ri.normalize(), V.ri.scale(g, V.ri), V.ri.vadd(n, V.ri), V.ri.vsub(r.position, V.ri), V.rj.vadd(i, V.rj), V.rj.vsub(l.position, V.rj), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult);
          }
        }
    u.release(F, P, G, z, L);
  }
  planeBox(e, t, n, i, s, o, r, l, a, c, d) {
    return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, t.convexPolyhedronRepresentation.id = t.id, this.planeConvex(e, t.convexPolyhedronRepresentation, n, i, s, o, r, l, e, t, d);
  }
  convexConvex(e, t, n, i, s, o, r, l, a, c, d, u, m) {
    const g = Kf;
    if (!(n.distanceTo(i) > e.boundingSphereRadius + t.boundingSphereRadius) && e.findSeparatingAxis(t, n, s, i, o, g, u, m)) {
      const p = [], f = Jf;
      e.clipAgainstHull(n, s, t, i, o, g, -100, 100, p);
      let v = 0;
      for (let _ = 0; _ !== p.length; _++) {
        if (d)
          return !0;
        const w = this.createContactEquation(r, l, e, t, a, c), x = w.ri, M = w.rj;
        g.negate(w.ni), p[_].normal.negate(f), f.scale(p[_].depth, f), p[_].point.vadd(f, x), M.copy(p[_].point), x.vsub(n, x), M.vsub(i, M), x.vadd(n, x), x.vsub(r.position, x), M.vadd(i, M), M.vsub(l.position, M), this.result.push(w), v++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(w, this.frictionResult);
      }
      this.enableFrictionReduction && v && this.createFrictionFromAverage(v);
    }
  }
  sphereConvex(e, t, n, i, s, o, r, l, a, c, d) {
    const u = this.v3pool;
    n.vsub(i, Nf);
    const m = t.faceNormals, g = t.faces, p = t.vertices, f = e.radius;
    let v = !1;
    for (let _ = 0; _ !== p.length; _++) {
      const w = p[_], x = kf;
      o.vmult(w, x), i.vadd(x, x);
      const M = Gf;
      if (x.vsub(n, M), M.lengthSquared() < f * f) {
        if (d)
          return !0;
        v = !0;
        const E = this.createContactEquation(r, l, e, t, a, c);
        E.ri.copy(M), E.ri.normalize(), E.ni.copy(E.ri), E.ri.scale(f, E.ri), x.vsub(i, E.rj), E.ri.vadd(n, E.ri), E.ri.vsub(r.position, E.ri), E.rj.vadd(i, E.rj), E.rj.vsub(l.position, E.rj), this.result.push(E), this.createFrictionEquationsFromContact(E, this.frictionResult);
        return;
      }
    }
    for (let _ = 0, w = g.length; _ !== w && v === !1; _++) {
      const x = m[_], M = g[_], E = Wf;
      o.vmult(x, E);
      const R = Vf;
      o.vmult(p[M[0]], R), R.vadd(i, R);
      const y = Hf;
      E.scale(-f, y), n.vadd(y, y);
      const A = qf;
      y.vsub(R, A);
      const F = A.dot(E), P = Xf;
      if (n.vsub(R, P), F < 0 && P.dot(E) > 0) {
        const G = [];
        for (let z = 0, L = M.length; z !== L; z++) {
          const I = u.get();
          o.vmult(p[M[z]], I), i.vadd(I, I), G.push(I);
        }
        if (Cf(G, E, n)) {
          if (d)
            return !0;
          v = !0;
          const z = this.createContactEquation(r, l, e, t, a, c);
          E.scale(-f, z.ri), E.negate(z.ni);
          const L = u.get();
          E.scale(-F, L);
          const I = u.get();
          E.scale(-f, I), n.vsub(i, z.rj), z.rj.vadd(I, z.rj), z.rj.vadd(L, z.rj), z.rj.vadd(i, z.rj), z.rj.vsub(l.position, z.rj), z.ri.vadd(n, z.ri), z.ri.vsub(r.position, z.ri), u.release(L), u.release(I), this.result.push(z), this.createFrictionEquationsFromContact(z, this.frictionResult);
          for (let D = 0, q = G.length; D !== q; D++)
            u.release(G[D]);
          return;
        } else
          for (let z = 0; z !== M.length; z++) {
            const L = u.get(), I = u.get();
            o.vmult(p[M[(z + 1) % M.length]], L), o.vmult(p[M[(z + 2) % M.length]], I), i.vadd(L, L), i.vadd(I, I);
            const D = Of;
            I.vsub(L, D);
            const q = Uf;
            D.unit(q);
            const k = u.get(), N = u.get();
            n.vsub(L, N);
            const H = N.dot(q);
            q.scale(H, k), k.vadd(L, k);
            const J = u.get();
            if (k.vsub(n, J), H > 0 && H * H < D.lengthSquared() && J.lengthSquared() < f * f) {
              if (d)
                return !0;
              const V = this.createContactEquation(r, l, e, t, a, c);
              k.vsub(i, V.rj), k.vsub(n, V.ni), V.ni.normalize(), V.ni.scale(f, V.ri), V.rj.vadd(i, V.rj), V.rj.vsub(l.position, V.rj), V.ri.vadd(n, V.ri), V.ri.vsub(r.position, V.ri), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult);
              for (let ee = 0, ce = G.length; ee !== ce; ee++)
                u.release(G[ee]);
              u.release(L), u.release(I), u.release(k), u.release(J), u.release(N);
              return;
            }
            u.release(L), u.release(I), u.release(k), u.release(J), u.release(N);
          }
        for (let z = 0, L = G.length; z !== L; z++)
          u.release(G[z]);
      }
    }
  }
  planeConvex(e, t, n, i, s, o, r, l, a, c, d) {
    const u = jf, m = Yf;
    m.set(0, 0, 1), s.vmult(m, m);
    let g = 0;
    const p = Zf;
    for (let f = 0; f !== t.vertices.length; f++)
      if (u.copy(t.vertices[f]), o.vmult(u, u), i.vadd(u, u), u.vsub(n, p), m.dot(p) <= 0) {
        if (d)
          return !0;
        const _ = this.createContactEquation(r, l, e, t, a, c), w = $f;
        m.scale(m.dot(p), w), u.vsub(w, w), w.vsub(n, _.ri), _.ni.copy(m), u.vsub(i, _.rj), _.ri.vadd(n, _.ri), _.ri.vsub(r.position, _.ri), _.rj.vadd(i, _.rj), _.rj.vsub(l.position, _.rj), this.result.push(_), g++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(_, this.frictionResult);
      }
    this.enableFrictionReduction && g && this.createFrictionFromAverage(g);
  }
  boxConvex(e, t, n, i, s, o, r, l, a, c, d) {
    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexConvex(e.convexPolyhedronRepresentation, t, n, i, s, o, r, l, e, t, d);
  }
  sphereHeightfield(e, t, n, i, s, o, r, l, a, c, d) {
    const u = t.data, m = e.radius, g = t.elementSize, p = hp, f = cp;
    Pe.pointToLocalFrame(i, o, n, f);
    let v = Math.floor((f.x - m) / g) - 1, _ = Math.ceil((f.x + m) / g) + 1, w = Math.floor((f.y - m) / g) - 1, x = Math.ceil((f.y + m) / g) + 1;
    if (_ < 0 || x < 0 || v > u.length || w > u[0].length)
      return;
    v < 0 && (v = 0), _ < 0 && (_ = 0), w < 0 && (w = 0), x < 0 && (x = 0), v >= u.length && (v = u.length - 1), _ >= u.length && (_ = u.length - 1), x >= u[0].length && (x = u[0].length - 1), w >= u[0].length && (w = u[0].length - 1);
    const M = [];
    t.getRectMinMax(v, w, _, x, M);
    const E = M[0], R = M[1];
    if (f.z - m > R || f.z + m < E)
      return;
    const y = this.result;
    for (let A = v; A < _; A++)
      for (let F = w; F < x; F++) {
        const P = y.length;
        let G = !1;
        if (t.getConvexTrianglePillar(A, F, !1), Pe.pointToWorldFrame(i, o, t.pillarOffset, p), n.distanceTo(p) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (G = this.sphereConvex(e, t.pillarConvex, n, p, s, o, r, l, e, t, d)), d && G || (t.getConvexTrianglePillar(A, F, !0), Pe.pointToWorldFrame(i, o, t.pillarOffset, p), n.distanceTo(p) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (G = this.sphereConvex(e, t.pillarConvex, n, p, s, o, r, l, e, t, d)), d && G))
          return !0;
        if (y.length - P > 2)
          return;
      }
  }
  boxHeightfield(e, t, n, i, s, o, r, l, a, c, d) {
    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexHeightfield(e.convexPolyhedronRepresentation, t, n, i, s, o, r, l, e, t, d);
  }
  convexHeightfield(e, t, n, i, s, o, r, l, a, c, d) {
    const u = t.data, m = t.elementSize, g = e.boundingSphereRadius, p = ap, f = lp, v = op;
    Pe.pointToLocalFrame(i, o, n, v);
    let _ = Math.floor((v.x - g) / m) - 1, w = Math.ceil((v.x + g) / m) + 1, x = Math.floor((v.y - g) / m) - 1, M = Math.ceil((v.y + g) / m) + 1;
    if (w < 0 || M < 0 || _ > u.length || x > u[0].length)
      return;
    _ < 0 && (_ = 0), w < 0 && (w = 0), x < 0 && (x = 0), M < 0 && (M = 0), _ >= u.length && (_ = u.length - 1), w >= u.length && (w = u.length - 1), M >= u[0].length && (M = u[0].length - 1), x >= u[0].length && (x = u[0].length - 1);
    const E = [];
    t.getRectMinMax(_, x, w, M, E);
    const R = E[0], y = E[1];
    if (!(v.z - g > y || v.z + g < R))
      for (let A = _; A < w; A++)
        for (let F = x; F < M; F++) {
          let P = !1;
          if (t.getConvexTrianglePillar(A, F, !1), Pe.pointToWorldFrame(i, o, t.pillarOffset, p), n.distanceTo(p) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (P = this.convexConvex(e, t.pillarConvex, n, p, s, o, r, l, null, null, d, f, null)), d && P || (t.getConvexTrianglePillar(A, F, !0), Pe.pointToWorldFrame(i, o, t.pillarOffset, p), n.distanceTo(p) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (P = this.convexConvex(e, t.pillarConvex, n, p, s, o, r, l, null, null, d, f, null)), d && P))
            return !0;
        }
  }
  sphereParticle(e, t, n, i, s, o, r, l, a, c, d) {
    const u = np;
    if (u.set(0, 0, 1), i.vsub(n, u), u.lengthSquared() <= e.radius * e.radius) {
      if (d)
        return !0;
      const g = this.createContactEquation(l, r, t, e, a, c);
      u.normalize(), g.rj.copy(u), g.rj.scale(e.radius, g.rj), g.ni.copy(u), g.ni.negate(g.ni), g.ri.set(0, 0, 0), this.result.push(g), this.createFrictionEquationsFromContact(g, this.frictionResult);
    }
  }
  planeParticle(e, t, n, i, s, o, r, l, a, c, d) {
    const u = Qf;
    u.set(0, 0, 1), r.quaternion.vmult(u, u);
    const m = ep;
    if (i.vsub(r.position, m), u.dot(m) <= 0) {
      if (d)
        return !0;
      const p = this.createContactEquation(l, r, t, e, a, c);
      p.ni.copy(u), p.ni.negate(p.ni), p.ri.set(0, 0, 0);
      const f = tp;
      u.scale(u.dot(i), f), i.vsub(f, f), p.rj.copy(f), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult);
    }
  }
  boxParticle(e, t, n, i, s, o, r, l, a, c, d) {
    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexParticle(e.convexPolyhedronRepresentation, t, n, i, s, o, r, l, e, t, d);
  }
  convexParticle(e, t, n, i, s, o, r, l, a, c, d) {
    let u = -1;
    const m = sp, g = rp;
    let p = null;
    const f = ip;
    if (f.copy(i), f.vsub(n, f), s.conjugate(Zr), Zr.vmult(f, f), e.pointIsInside(f)) {
      e.worldVerticesNeedsUpdate && e.computeWorldVertices(n, s), e.worldFaceNormalsNeedsUpdate && e.computeWorldFaceNormals(s);
      for (let v = 0, _ = e.faces.length; v !== _; v++) {
        const w = [e.worldVertices[e.faces[v][0]]], x = e.worldFaceNormals[v];
        i.vsub(w[0], $r);
        const M = -x.dot($r);
        if (p === null || Math.abs(M) < Math.abs(p)) {
          if (d)
            return !0;
          p = M, u = v, m.copy(x);
        }
      }
      if (u !== -1) {
        const v = this.createContactEquation(l, r, t, e, a, c);
        m.scale(p, g), g.vadd(i, g), g.vsub(n, g), v.rj.copy(g), m.negate(v.ni), v.ri.set(0, 0, 0);
        const _ = v.ri, w = v.rj;
        _.vadd(i, _), _.vsub(l.position, _), w.vadd(n, w), w.vsub(r.position, w), this.result.push(v), this.createFrictionEquationsFromContact(v, this.frictionResult);
      } else
        console.warn("Point found inside convex, but did not find penetrating face!");
    }
  }
  heightfieldCylinder(e, t, n, i, s, o, r, l, a, c, d) {
    return this.convexHeightfield(t, e, i, n, o, s, l, r, a, c, d);
  }
  particleCylinder(e, t, n, i, s, o, r, l, a, c, d) {
    return this.convexParticle(t, e, i, n, o, s, l, r, a, c, d);
  }
  sphereTrimesh(e, t, n, i, s, o, r, l, a, c, d) {
    const u = pf, m = mf, g = gf, p = _f, f = vf, v = xf, _ = Mf, w = ff, x = uf, M = Sf;
    Pe.pointToLocalFrame(i, o, n, f);
    const E = e.radius;
    _.lowerBound.set(f.x - E, f.y - E, f.z - E), _.upperBound.set(f.x + E, f.y + E, f.z + E), t.getTrianglesInAABB(_, M);
    const R = df, y = e.radius * e.radius;
    for (let z = 0; z < M.length; z++)
      for (let L = 0; L < 3; L++)
        if (t.getVertex(t.indices[M[z] * 3 + L], R), R.vsub(f, x), x.lengthSquared() <= y) {
          if (w.copy(R), Pe.pointToWorldFrame(i, o, w, R), R.vsub(n, x), d)
            return !0;
          let I = this.createContactEquation(r, l, e, t, a, c);
          I.ni.copy(x), I.ni.normalize(), I.ri.copy(I.ni), I.ri.scale(e.radius, I.ri), I.ri.vadd(n, I.ri), I.ri.vsub(r.position, I.ri), I.rj.copy(R), I.rj.vsub(l.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult);
        }
    for (let z = 0; z < M.length; z++)
      for (let L = 0; L < 3; L++) {
        t.getVertex(t.indices[M[z] * 3 + L], u), t.getVertex(t.indices[M[z] * 3 + (L + 1) % 3], m), m.vsub(u, g), f.vsub(m, v);
        const I = v.dot(g);
        f.vsub(u, v);
        let D = v.dot(g);
        if (D > 0 && I < 0 && (f.vsub(u, v), p.copy(g), p.normalize(), D = v.dot(p), p.scale(D, v), v.vadd(u, v), v.distanceTo(f) < e.radius)) {
          if (d)
            return !0;
          const k = this.createContactEquation(r, l, e, t, a, c);
          v.vsub(f, k.ni), k.ni.normalize(), k.ni.scale(e.radius, k.ri), k.ri.vadd(n, k.ri), k.ri.vsub(r.position, k.ri), Pe.pointToWorldFrame(i, o, v, v), v.vsub(l.position, k.rj), Pe.vectorToWorldFrame(o, k.ni, k.ni), Pe.vectorToWorldFrame(o, k.ri, k.ri), this.result.push(k), this.createFrictionEquationsFromContact(k, this.frictionResult);
        }
      }
    const A = yf, F = bf, P = wf, G = hf;
    for (let z = 0, L = M.length; z !== L; z++) {
      t.getTriangleVertices(M[z], A, F, P), t.getNormal(M[z], G), f.vsub(A, v);
      let I = v.dot(G);
      if (G.scale(I, v), f.vsub(v, v), I = v.distanceTo(f), Xe.pointInTriangle(v, A, F, P) && I < e.radius) {
        if (d)
          return !0;
        let D = this.createContactEquation(r, l, e, t, a, c);
        v.vsub(f, D.ni), D.ni.normalize(), D.ni.scale(e.radius, D.ri), D.ri.vadd(n, D.ri), D.ri.vsub(r.position, D.ri), Pe.pointToWorldFrame(i, o, v, v), v.vsub(l.position, D.rj), Pe.vectorToWorldFrame(o, D.ni, D.ni), Pe.vectorToWorldFrame(o, D.ri, D.ri), this.result.push(D), this.createFrictionEquationsFromContact(D, this.frictionResult);
      }
    }
    M.length = 0;
  }
  planeTrimesh(e, t, n, i, s, o, r, l, a, c, d) {
    const u = new b(), m = af;
    m.set(0, 0, 1), s.vmult(m, m);
    for (let g = 0; g < t.vertices.length / 3; g++) {
      t.getVertex(g, u);
      const p = new b();
      p.copy(u), Pe.pointToWorldFrame(i, o, p, u);
      const f = lf;
      if (u.vsub(n, f), m.dot(f) <= 0) {
        if (d)
          return !0;
        const _ = this.createContactEquation(r, l, e, t, a, c);
        _.ni.copy(m);
        const w = cf;
        m.scale(f.dot(m), w), u.vsub(w, w), _.ri.copy(w), _.ri.vsub(r.position, _.ri), _.rj.copy(u), _.rj.vsub(l.position, _.rj), this.result.push(_), this.createFrictionEquationsFromContact(_, this.frictionResult);
      }
    }
  }
}
const mn = new b(), qn = new b(), Xn = new b(), nf = new b(), sf = new b(), rf = new je(), of = new je(), af = new b(), lf = new b(), cf = new b(), hf = new b(), uf = new b();
new b();
const df = new b(), ff = new b(), pf = new b(), mf = new b(), gf = new b(), _f = new b(), vf = new b(), xf = new b(), yf = new b(), bf = new b(), wf = new b(), Mf = new vt(), Sf = [], Gi = new b(), Yr = new b(), Ef = new b(), Tf = new b(), Af = new b();
function Cf(h, e, t) {
  let n = null;
  const i = h.length;
  for (let s = 0; s !== i; s++) {
    const o = h[s], r = Ef;
    h[(s + 1) % i].vsub(o, r);
    const l = Tf;
    r.cross(e, l);
    const a = Af;
    t.vsub(o, a);
    const c = l.dot(a);
    if (n === null || c > 0 && n === !0 || c <= 0 && n === !1) {
      n === null && (n = c > 0);
      continue;
    } else
      return !1;
  }
  return !0;
}
const ki = new b(), Lf = new b(), Rf = new b(), Ff = new b(), Df = [new b(), new b(), new b(), new b(), new b(), new b()], Pf = new b(), If = new b(), zf = new b(), Bf = new b(), Nf = new b(), Of = new b(), Uf = new b(), Gf = new b(), kf = new b(), Wf = new b(), Vf = new b(), Hf = new b(), qf = new b(), Xf = new b();
new b();
new b();
const jf = new b(), Yf = new b(), Zf = new b(), $f = new b(), Kf = new b(), Jf = new b(), Qf = new b(), ep = new b(), tp = new b(), np = new b(), Zr = new je(), ip = new b();
new b();
const sp = new b(), $r = new b(), rp = new b(), op = new b(), ap = new b(), lp = [0], cp = new b(), hp = new b();
class Kr {
  constructor() {
    this.current = [], this.previous = [];
  }
  getKey(e, t) {
    if (t < e) {
      const n = t;
      t = e, e = n;
    }
    return e << 16 | t;
  }
  set(e, t) {
    const n = this.getKey(e, t), i = this.current;
    let s = 0;
    for (; n > i[s]; )
      s++;
    if (n !== i[s]) {
      for (let o = i.length - 1; o >= s; o--)
        i[o + 1] = i[o];
      i[s] = n;
    }
  }
  tick() {
    const e = this.current;
    this.current = this.previous, this.previous = e, this.current.length = 0;
  }
  getDiff(e, t) {
    const n = this.current, i = this.previous, s = n.length, o = i.length;
    let r = 0;
    for (let l = 0; l < s; l++) {
      let a = !1;
      const c = n[l];
      for (; c > i[r]; )
        r++;
      a = c === i[r], a || Jr(e, c);
    }
    r = 0;
    for (let l = 0; l < o; l++) {
      let a = !1;
      const c = i[l];
      for (; c > n[r]; )
        r++;
      a = n[r] === c, a || Jr(t, c);
    }
  }
}
function Jr(h, e) {
  h.push((e & 4294901760) >> 16, e & 65535);
}
const Fs = (h, e) => h < e ? `${h}-${e}` : `${e}-${h}`;
class up {
  constructor() {
    this.data = {
      keys: []
    };
  }
  get(e, t) {
    const n = Fs(e, t);
    return this.data[n];
  }
  set(e, t, n) {
    const i = Fs(e, t);
    this.get(e, t) || this.data.keys.push(i), this.data[i] = n;
  }
  delete(e, t) {
    const n = Fs(e, t), i = this.data.keys.indexOf(n);
    i !== -1 && this.data.keys.splice(i, 1), delete this.data[n];
  }
  reset() {
    const e = this.data, t = e.keys;
    for (; t.length > 0; ) {
      const n = t.pop();
      delete e[n];
    }
  }
}
class dp extends bo {
  constructor(e) {
    e === void 0 && (e = {}), super(), this.dt = -1, this.allowSleep = !!e.allowSleep, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = e.quatNormalizeSkip !== void 0 ? e.quatNormalizeSkip : 0, this.quatNormalizeFast = e.quatNormalizeFast !== void 0 ? e.quatNormalizeFast : !1, this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new b(), e.gravity && this.gravity.copy(e.gravity), e.frictionGravity && (this.frictionGravity = new b(), this.frictionGravity.copy(e.frictionGravity)), this.broadphase = e.broadphase !== void 0 ? e.broadphase : new wo(), this.bodies = [], this.hasActiveBodies = !1, this.solver = e.solver !== void 0 ? e.solver : new Zd(), this.constraints = [], this.narrowphase = new tf(this), this.collisionMatrix = new Nr(), this.collisionMatrixPrevious = new Nr(), this.bodyOverlapKeeper = new Kr(), this.shapeOverlapKeeper = new Kr(), this.contactmaterials = [], this.contactMaterialTable = new up(), this.defaultMaterial = new Sn("default"), this.defaultContactMaterial = new Mn(this.defaultMaterial, this.defaultMaterial, {
      friction: 0.3,
      restitution: 0
    }), this.doProfiling = !1, this.profile = {
      solve: 0,
      makeContactConstraints: 0,
      broadphase: 0,
      integrate: 0,
      narrowphase: 0
    }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = {
      type: "addBody",
      body: null
    }, this.removeBodyEvent = {
      type: "removeBody",
      body: null
    }, this.idToBodyMap = {}, this.broadphase.setWorld(this);
  }
  getContactMaterial(e, t) {
    return this.contactMaterialTable.get(e.id, t.id);
  }
  collisionMatrixTick() {
    const e = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = e, this.collisionMatrix.reset(), this.bodyOverlapKeeper.tick(), this.shapeOverlapKeeper.tick();
  }
  addConstraint(e) {
    this.constraints.push(e);
  }
  removeConstraint(e) {
    const t = this.constraints.indexOf(e);
    t !== -1 && this.constraints.splice(t, 1);
  }
  rayTest(e, t, n) {
    n instanceof Xi ? this.raycastClosest(e, t, {
      skipBackfaces: !0
    }, n) : this.raycastAll(e, t, {
      skipBackfaces: !0
    }, n);
  }
  raycastAll(e, t, n, i) {
    return n === void 0 && (n = {}), n.mode = Xe.ALL, n.from = e, n.to = t, n.callback = i, Ds.intersectWorld(this, n);
  }
  raycastAny(e, t, n, i) {
    return n === void 0 && (n = {}), n.mode = Xe.ANY, n.from = e, n.to = t, n.result = i, Ds.intersectWorld(this, n);
  }
  raycastClosest(e, t, n, i) {
    return n === void 0 && (n = {}), n.mode = Xe.CLOSEST, n.from = e, n.to = t, n.result = i, Ds.intersectWorld(this, n);
  }
  addBody(e) {
    this.bodies.includes(e) || (e.index = this.bodies.length, this.bodies.push(e), e.world = this, e.initPosition.copy(e.position), e.initVelocity.copy(e.velocity), e.timeLastSleepy = this.time, e instanceof ie && (e.initAngularVelocity.copy(e.angularVelocity), e.initQuaternion.copy(e.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = e, this.idToBodyMap[e.id] = e, this.dispatchEvent(this.addBodyEvent));
  }
  removeBody(e) {
    e.world = null;
    const t = this.bodies.length - 1, n = this.bodies, i = n.indexOf(e);
    if (i !== -1) {
      n.splice(i, 1);
      for (let s = 0; s !== n.length; s++)
        n[s].index = s;
      this.collisionMatrix.setNumObjects(t), this.removeBodyEvent.body = e, delete this.idToBodyMap[e.id], this.dispatchEvent(this.removeBodyEvent);
    }
  }
  getBodyById(e) {
    return this.idToBodyMap[e];
  }
  getShapeById(e) {
    const t = this.bodies;
    for (let n = 0; n < t.length; n++) {
      const i = t[n].shapes;
      for (let s = 0; s < i.length; s++) {
        const o = i[s];
        if (o.id === e)
          return o;
      }
    }
    return null;
  }
  addContactMaterial(e) {
    this.contactmaterials.push(e), this.contactMaterialTable.set(e.materials[0].id, e.materials[1].id, e);
  }
  removeContactMaterial(e) {
    const t = this.contactmaterials.indexOf(e);
    t !== -1 && (this.contactmaterials.splice(t, 1), this.contactMaterialTable.delete(e.materials[0].id, e.materials[1].id));
  }
  fixedStep(e, t) {
    e === void 0 && (e = 1 / 60), t === void 0 && (t = 10);
    const n = Ze.now() / 1e3;
    if (!this.lastCallTime)
      this.step(e, void 0, t);
    else {
      const i = n - this.lastCallTime;
      this.step(e, i, t);
    }
    this.lastCallTime = n;
  }
  step(e, t, n) {
    if (n === void 0 && (n = 10), t === void 0)
      this.internalStep(e), this.time += e;
    else {
      this.accumulator += t;
      const i = Ze.now();
      let s = 0;
      for (; this.accumulator >= e && s < n && (this.internalStep(e), this.accumulator -= e, s++, !(Ze.now() - i > e * 1e3)); )
        ;
      this.accumulator = this.accumulator % e;
      const o = this.accumulator / e;
      for (let r = 0; r !== this.bodies.length; r++) {
        const l = this.bodies[r];
        l.previousPosition.lerp(l.position, o, l.interpolatedPosition), l.previousQuaternion.slerp(l.quaternion, o, l.interpolatedQuaternion), l.previousQuaternion.normalize();
      }
      this.time += t;
    }
  }
  internalStep(e) {
    this.dt = e;
    const t = this.contacts, n = _p, i = vp, s = this.bodies.length, o = this.bodies, r = this.solver, l = this.gravity, a = this.doProfiling, c = this.profile, d = ie.DYNAMIC;
    let u = -1 / 0;
    const m = this.constraints, g = gp;
    l.length();
    const p = l.x, f = l.y, v = l.z;
    let _ = 0;
    for (a && (u = Ze.now()), _ = 0; _ !== s; _++) {
      const z = o[_];
      if (z.type === d) {
        const L = z.force, I = z.mass;
        L.x += I * p, L.y += I * f, L.z += I * v;
      }
    }
    for (let z = 0, L = this.subsystems.length; z !== L; z++)
      this.subsystems[z].update();
    a && (u = Ze.now()), n.length = 0, i.length = 0, this.broadphase.collisionPairs(this, n, i), a && (c.broadphase = Ze.now() - u);
    let w = m.length;
    for (_ = 0; _ !== w; _++) {
      const z = m[_];
      if (!z.collideConnected)
        for (let L = n.length - 1; L >= 0; L -= 1)
          (z.bodyA === n[L] && z.bodyB === i[L] || z.bodyB === n[L] && z.bodyA === i[L]) && (n.splice(L, 1), i.splice(L, 1));
    }
    this.collisionMatrixTick(), a && (u = Ze.now());
    const x = mp, M = t.length;
    for (_ = 0; _ !== M; _++)
      x.push(t[_]);
    t.length = 0;
    const E = this.frictionEquations.length;
    for (_ = 0; _ !== E; _++)
      g.push(this.frictionEquations[_]);
    for (this.frictionEquations.length = 0, this.narrowphase.getContacts(
      n,
      i,
      this,
      t,
      x,
      this.frictionEquations,
      g
    ), a && (c.narrowphase = Ze.now() - u), a && (u = Ze.now()), _ = 0; _ < this.frictionEquations.length; _++)
      r.addEquation(this.frictionEquations[_]);
    const R = t.length;
    for (let z = 0; z !== R; z++) {
      const L = t[z], I = L.bi, D = L.bj, q = L.si, k = L.sj;
      let N;
      if (I.material && D.material ? N = this.getContactMaterial(I.material, D.material) || this.defaultContactMaterial : N = this.defaultContactMaterial, N.friction, I.material && D.material && (I.material.friction >= 0 && D.material.friction >= 0 && I.material.friction * D.material.friction, I.material.restitution >= 0 && D.material.restitution >= 0 && (L.restitution = I.material.restitution * D.material.restitution)), r.addEquation(L), I.allowSleep && I.type === ie.DYNAMIC && I.sleepState === ie.SLEEPING && D.sleepState === ie.AWAKE && D.type !== ie.STATIC) {
        const H = D.velocity.lengthSquared() + D.angularVelocity.lengthSquared(), J = D.sleepSpeedLimit ** 2;
        H >= J * 2 && (I.wakeUpAfterNarrowphase = !0);
      }
      if (D.allowSleep && D.type === ie.DYNAMIC && D.sleepState === ie.SLEEPING && I.sleepState === ie.AWAKE && I.type !== ie.STATIC) {
        const H = I.velocity.lengthSquared() + I.angularVelocity.lengthSquared(), J = I.sleepSpeedLimit ** 2;
        H >= J * 2 && (D.wakeUpAfterNarrowphase = !0);
      }
      this.collisionMatrix.set(I, D, !0), this.collisionMatrixPrevious.get(I, D) || (ri.body = D, ri.contact = L, I.dispatchEvent(ri), ri.body = I, D.dispatchEvent(ri)), this.bodyOverlapKeeper.set(I.id, D.id), this.shapeOverlapKeeper.set(q.id, k.id);
    }
    for (this.emitContactEvents(), a && (c.makeContactConstraints = Ze.now() - u, u = Ze.now()), _ = 0; _ !== s; _++) {
      const z = o[_];
      z.wakeUpAfterNarrowphase && (z.wakeUp(), z.wakeUpAfterNarrowphase = !1);
    }
    for (w = m.length, _ = 0; _ !== w; _++) {
      const z = m[_];
      z.update();
      for (let L = 0, I = z.equations.length; L !== I; L++) {
        const D = z.equations[L];
        r.addEquation(D);
      }
    }
    r.solve(e, this), a && (c.solve = Ze.now() - u), r.removeAllEquations();
    const y = Math.pow;
    for (_ = 0; _ !== s; _++) {
      const z = o[_];
      if (z.type & d) {
        const L = y(1 - z.linearDamping, e), I = z.velocity;
        I.scale(L, I);
        const D = z.angularVelocity;
        if (D) {
          const q = y(1 - z.angularDamping, e);
          D.scale(q, D);
        }
      }
    }
    this.dispatchEvent(pp), a && (u = Ze.now());
    const F = this.stepnumber % (this.quatNormalizeSkip + 1) === 0, P = this.quatNormalizeFast;
    for (_ = 0; _ !== s; _++)
      o[_].integrate(e, F, P);
    this.clearForces(), this.broadphase.dirty = !0, a && (c.integrate = Ze.now() - u), this.stepnumber += 1, this.dispatchEvent(fp);
    let G = !0;
    if (this.allowSleep)
      for (G = !1, _ = 0; _ !== s; _++) {
        const z = o[_];
        z.sleepTick(this.time), z.sleepState !== ie.SLEEPING && (G = !0);
      }
    this.hasActiveBodies = G;
  }
  emitContactEvents() {
    const e = this.hasAnyEventListener("beginContact"), t = this.hasAnyEventListener("endContact");
    if ((e || t) && this.bodyOverlapKeeper.getDiff(Yt, Zt), e) {
      for (let s = 0, o = Yt.length; s < o; s += 2)
        oi.bodyA = this.getBodyById(Yt[s]), oi.bodyB = this.getBodyById(Yt[s + 1]), this.dispatchEvent(oi);
      oi.bodyA = oi.bodyB = null;
    }
    if (t) {
      for (let s = 0, o = Zt.length; s < o; s += 2)
        ai.bodyA = this.getBodyById(Zt[s]), ai.bodyB = this.getBodyById(Zt[s + 1]), this.dispatchEvent(ai);
      ai.bodyA = ai.bodyB = null;
    }
    Yt.length = Zt.length = 0;
    const n = this.hasAnyEventListener("beginShapeContact"), i = this.hasAnyEventListener("endShapeContact");
    if ((n || i) && this.shapeOverlapKeeper.getDiff(Yt, Zt), n) {
      for (let s = 0, o = Yt.length; s < o; s += 2) {
        const r = this.getShapeById(Yt[s]), l = this.getShapeById(Yt[s + 1]);
        $t.shapeA = r, $t.shapeB = l, r && ($t.bodyA = r.body), l && ($t.bodyB = l.body), this.dispatchEvent($t);
      }
      $t.bodyA = $t.bodyB = $t.shapeA = $t.shapeB = null;
    }
    if (i) {
      for (let s = 0, o = Zt.length; s < o; s += 2) {
        const r = this.getShapeById(Zt[s]), l = this.getShapeById(Zt[s + 1]);
        Kt.shapeA = r, Kt.shapeB = l, r && (Kt.bodyA = r.body), l && (Kt.bodyB = l.body), this.dispatchEvent(Kt);
      }
      Kt.bodyA = Kt.bodyB = Kt.shapeA = Kt.shapeB = null;
    }
  }
  clearForces() {
    const e = this.bodies, t = e.length;
    for (let n = 0; n !== t; n++) {
      const i = e[n];
      i.force, i.torque, i.force.set(0, 0, 0), i.torque.set(0, 0, 0);
    }
  }
}
new vt();
const Ds = new Xe(), Ze = globalThis.performance || {};
if (!Ze.now) {
  let h = Date.now();
  Ze.timing && Ze.timing.navigationStart && (h = Ze.timing.navigationStart), Ze.now = () => Date.now() - h;
}
new b();
const fp = {
  type: "postStep"
}, pp = {
  type: "preStep"
}, ri = {
  type: ie.COLLIDE_EVENT_NAME,
  body: null,
  contact: null
}, mp = [], gp = [], _p = [], vp = [], Yt = [], Zt = [], oi = {
  type: "beginContact",
  bodyA: null,
  bodyB: null
}, ai = {
  type: "endContact",
  bodyA: null,
  bodyB: null
}, $t = {
  type: "beginShapeContact",
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
}, Kt = {
  type: "endShapeContact",
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
};
class Qr {
  constructor(e) {
    typeof e == "object" && (e = e.notation), this.set = [], this.setkeys = [], this.setid = 0, this.groups = [], this.totalDice = 0, this.op = "", this.constant = null, this.result = [], this.error = !1, this.boost = 1, this.notation = "", this.vectors = [], (!e || e == "0") && (this.error = !0), this.parseNotation(e);
  }
  parseNotation(e) {
    if (e) {
      let u = e.split("!").length - 1 || 0;
      u > 0 && (this.boost = Math.min(Math.max(u, 0), 3) * 4), e = e.split("!").join(""), e = e.split(" ").join("");
      let m = e.split("(").length - 1, g = e.split(")").length - 1;
      m != g && (this.error = !0);
    }
    const t = this.notation.length > 0 ? "+" : "";
    this.notation += t + e;
    let n = e.split("@"), i = n[0], s = new RegExp(/(\+|\-|\*|\/|\%|\^|){0,1}()(\d*)([a-z]+\d+|[a-z]+|)(?:\{([a-z]+)(.*?|)\}|)()/, "i"), o = new RegExp(/(\b)*(\-\d+|\d+)(\b)*/, "gi"), r, l = 0, a = 30, c = 0, d = 0;
    for (; !this.error && i.length > 0 && (r = s.exec(i)) !== null && l < a; ) {
      l++, i = i.substring(r[0].length);
      let u = r[1], m = r[2] && r[2].length > 0, g = r[3], p = r[4], f = r[5] || "", v = r[6] || "", _ = r[7] && r[7].length > 0, w = !0;
      m && (c += r[2].length), v = v.split(","), (!v || v.length < 1) && (v = ""), v.shift(), l == 1 && i.length == 0 && !p && u && g ? (p = "d20", this.op = u, this.constant = parseInt(g), g = 1) : l > 1 && i.length == 0 && !p && (this.op = u, this.constant = parseInt(g), w = !1), w && this.addSet(g, p, d, c, f, v, u), _ && (c -= r[7].length, d += r[7].length);
    }
    !this.error && n[1] && (r = n[1].match(o)) !== null && this.result.push(...r);
  }
  stringify(e = !0) {
    let t = "";
    if (this.set.length < 1)
      return t;
    for (let n = 0; n < this.set.length; n++) {
      let i = this.set[n];
      t += n > 0 && i.op ? i.op : "", t += i.num + i.type, i.func && (t += "{", t += i.func ? i.func : "", t += i.args ? "," + (Array.isArray(i.args) ? i.args.join(",") : i.args) : "", t += "}");
    }
    return t += this.constant ? this.op + "" + Math.abs(this.constant) : "", e && this.result && this.result.length > 0 && (t += "@" + this.result.join(",")), this.boost > 1 && (t += "!".repeat(this.boost / 4)), t;
  }
  addSet(e, t, n = 0, i = 0, s = "", o = "", r = "+") {
    e = Math.abs(parseInt(e || 1));
    let l = r + "" + t + n + i + s + o, a = this.setkeys[l] != null, c = {};
    a && (c = this.set[this.setkeys[l] - 1]), e > 0 && (c.num = a ? e + c.num : e, c.type = t, c.sid = this.setid, c.gid = n, c.glvl = i, s && (c.func = s), o && (c.args = o), r && (c.op = r), a ? this.set[this.setkeys[l] - 1] = c : this.setkeys[l] = this.set.push(c)), a || ++this.setid;
  }
  static mergeNotation(e, t) {
    return {
      ...e,
      constant: e.constant + t.constant,
      notation: e.notation + "+" + t.notation,
      set: [
        ...e.set,
        ...t.set
      ],
      totalDice: e.vectors.length + t.vectors.length,
      vectors: [
        ...e.vectors,
        ...t.vectors
      ]
    };
  }
}
const Ps = {
  d2: {
    name: "d2",
    labels: ["1", "2"],
    values: [1, 2],
    inertia: 8,
    mass: 400,
    scale: 0.9,
    system: "dweird"
  },
  dc: {
    type: "d2",
    name: "Coin",
    labels: [
      "textures/silvercoin/tail.png",
      "textures/silvercoin/heads.png"
    ],
    setBumpMaps: [
      "textures/silvercoin/tail_bump.png",
      "textures/silvercoin/heads_bump.png"
    ],
    values: [0, 1],
    inertia: 8,
    mass: 400,
    scale: 0.9,
    colorset: "coin_silver"
  },
  d1: {
    name: "One-sided Dice",
    type: "d6",
    labels: ["1"],
    values: [1, 1],
    scale: 0.9,
    system: "dweird"
  },
  d3: {
    name: "Three-Sided Dice",
    type: "d6",
    labels: ["1", "2", "3"],
    values: [1, 3],
    scale: 0.9,
    system: "dweird"
  },
  df: {
    name: "Fudge Dice",
    type: "d6",
    labels: ["-", "0", "+"],
    values: [-1, 1],
    scale: 0.9,
    system: "dweird"
  },
  d4: {
    name: "Four-Sided Dice",
    labels: ["1", "2", "3", "4"],
    values: [1, 4],
    inertia: 5,
    scale: 1.2
  },
  d6: {
    name: "Six-Sided Dice (Numbers)",
    labels: ["1", "2", "3", "4", "5", "6"],
    values: [1, 6],
    scale: 0.9
  },
  dpip: {
    name: "Six-Sided Dice (Pips)",
    type: "d6",
    labels: [
      `   
 \u2B24 
   `,
      `\u2B24  
   
  \u2B24`,
      `\u2B24  
 \u2B24 
  \u2B24`,
      `\u2B24 \u2B24
   
\u2B24 \u2B24`,
      `\u2B24 \u2B24
 \u2B24 
\u2B24 \u2B24`,
      `\u2B24 \u2B24
\u2B24 \u2B24
\u2B24 \u2B24`
    ],
    values: [1, 6],
    scale: 0.9,
    font: "monospace"
  },
  dsex: {
    name: "Sex-Sided Emoji Dice",
    type: "d6",
    labels: ["\u{1F346}", "\u{1F351}", "\u{1F44C}", "\u{1F4A6}", "\u{1F64F}", "\u{1F4A5}"],
    values: [1, 6],
    scale: 0.9,
    display: "labels",
    system: "dweird"
  },
  dpoker: {
    name: "Poker Dice (9-Ace)",
    type: "d6",
    labels: ["A", "9", "10", "J", "Q", "K"],
    values: [1, 6],
    scale: 0.9,
    display: "labels",
    system: "dweird",
    font: "Times New Roman"
  },
  dspanpoker: {
    name: "Spanish Poker Dice (7-Ace)",
    type: "d8",
    labels: ["A", "7", "8", "9", "10", "J", "Q", "K"],
    values: [1, 8],
    display: "labels",
    system: "dweird",
    font: "Times New Roman"
  },
  disotope: {
    name: "Radioactive Twelve-Sided Dice",
    type: "d12",
    labels: ["", "", "", "", "", "", "", "", "", "", "", "\u2622\uFE0F"],
    values: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    mass: 350,
    inertia: 8,
    scale: 0.9,
    system: "dweird"
  },
  dsuit: {
    name: "Four-Suited Dice",
    type: "d4",
    labels: ["\u2660\uFE0F", "\u2665\uFE0F", "\u2666\uFE0F", "\u2663\uFE0F"],
    values: [1, 4],
    inertia: 5,
    scale: 1.2,
    display: "labels",
    system: "dweird"
  },
  d8: {
    name: "Eight-Sided Dice",
    labels: ["1", "2", "3", "4", "5", "6", "7", "8"],
    values: [1, 8]
  },
  d10: {
    name: "Ten-Sided Dice (Single Digit)",
    labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
    values: [1, 10],
    mass: 350,
    inertia: 9,
    scale: 0.9
  },
  d100: {
    name: "Ten-Sided Dice (Tens Digit)",
    type: "d10",
    labels: ["10", "20", "30", "40", "50", "60", "70", "80", "90", "00"],
    values: [10, 100, 10],
    mass: 350,
    inertia: 9,
    scale: 0.9
  },
  d12: {
    name: "Twelve-Sided Dice",
    labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    values: [1, 12],
    mass: 350,
    inertia: 8,
    scale: 0.9
  },
  d20: {
    name: "Twenty-Sided Dice",
    labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"],
    values: [1, 20],
    mass: 400,
    inertia: 6
  },
  dabi: {
    name: "Star Wars RPG: Ability Dice",
    type: "d8",
    labels: ["s", "a", `s
a`, `s
s`, "a", "s", `a
a`, ""],
    values: [1, 8],
    font: "SWRPG-Symbol-Regular",
    color: "#00FF00",
    colorset: "swrpg_abi",
    display: "labels",
    system: "swrpg"
  },
  ddif: {
    name: "Star Wars RPG: Difficulty Dice",
    type: "d8",
    labels: ["t", "f", `f
t`, "t", "", `t
t`, `f
f`, "t"],
    values: [1, 8],
    font: "SWRPG-Symbol-Regular",
    color: "#8000FC",
    colorset: "swrpg_dif",
    display: "labels",
    system: "swrpg"
  },
  dpro: {
    name: "Star Wars RPG: Proficiency Dice",
    type: "d12",
    labels: [`a
a`, "a", `a
a`, "x", "s", `s
a`, "s", `s
a`, `s
s`, `s
a`, `s
s`, ""],
    values: [1, 12],
    mass: 350,
    inertia: 8,
    scale: 0.9,
    font: "SWRPG-Symbol-Regular",
    color: "#FFFF00",
    colorset: "swrpg_pro",
    display: "labels",
    system: "swrpg"
  },
  dcha: {
    name: "Star Wars RPG: Challenge Dice",
    type: "d12",
    labels: [`t
t`, "t", `t
t`, "t", `t
f`, "f", `t
f`, "f", `f
f`, "y", `f
f`, ""],
    values: [1, 12],
    mass: 350,
    inertia: 8,
    scale: 0.9,
    font: "SWRPG-Symbol-Regular",
    color: "#FF0000",
    colorset: "swrpg_cha",
    display: "labels",
    system: "swrpg"
  },
  dfor: {
    name: "Star Wars RPG: Force Dice",
    type: "d12",
    labels: ["z", `Z
Z`, "z", `Z
Z`, "z", `Z
Z`, "z", "Z", "z", "Z", "z", `z
z`],
    values: [1, 12],
    mass: 350,
    inertia: 8,
    scale: 0.9,
    font: "SWRPG-Symbol-Regular",
    color: "#FFFFFF",
    colorset: "swrpg_for",
    display: "labels",
    system: "swrpg"
  },
  dboo: {
    name: "Star Wars RPG: Boost Dice",
    type: "d6",
    labels: [`s  
  a`, `a  
  a`, "s", "a", "", ""],
    values: [1, 6],
    scale: 0.9,
    font: "SWRPG-Symbol-Regular",
    color: "#00FFFF",
    colorset: "swrpg_boo",
    display: "labels",
    system: "swrpg"
  },
  dset: {
    name: "Star Wars RPG: Setback Dice",
    type: "d6",
    labels: ["", "t", "f"],
    values: [1, 3],
    scale: 0.9,
    font: "SWRPG-Symbol-Regular",
    color: "#111111",
    colorset: "swrpg_set",
    display: "labels",
    system: "swrpg"
  },
  swar: {
    name: "Star Wars Armada: Red Attack Dice",
    type: "d8",
    labels: ["F", "F", `F
F`, "E", "E", "G", "", ""],
    values: [1, 8],
    font: "Armada-Symbol-Regular",
    color: "#FF0000",
    colorset: "swa_red",
    display: "labels",
    system: "swarmada"
  },
  swab: {
    name: "Star Wars Armada: Blue Attack Dice",
    type: "d8",
    labels: ["F", "F", "F", "F", "E", "E", "G", "G"],
    values: [1, 8],
    font: "Armada-Symbol-Regular",
    color: "#0000FF",
    colorset: "swa_blue",
    display: "labels",
    system: "swarmada"
  },
  swak: {
    name: "Star Wars Armada: Black Attack Dice",
    type: "d8",
    labels: ["F", "F", "F", "F", `F
E`, `F
E`, "", ""],
    values: [1, 8],
    font: "Armada-Symbol-Regular",
    color: "#111111",
    colorset: "swa_black",
    display: "labels",
    system: "swarmada"
  },
  xwatk: {
    name: "Star Wars X-Wing: Red Attack Dice",
    type: "d8",
    labels: ["c", "d", "d", "d", "f", "f", "", ""],
    values: [1, 8],
    font: "XWing-Symbol-Regular",
    color: "#FF0000",
    colorset: "xwing_red",
    display: "labels",
    system: "xwing"
  },
  xwdef: {
    name: "Star Wars X-Wing: Green Defense Dice",
    type: "d8",
    labels: ["e", "e", "e", "f", "f", "", "", ""],
    values: [1, 8],
    font: "XWing-Symbol-Regular",
    color: "#00FF00",
    colorset: "xwing_green",
    display: "labels",
    system: "xwing"
  },
  swlar: {
    name: "Star Wars Legion: Red Attack Dice",
    type: "d8",
    labels: ["h", "h", "h", "h", "h", "c", "o", ""],
    values: [1, 8],
    font: "Legion-Symbol-Regular",
    color: "#FF0000",
    colorset: "swl_atkred",
    display: "labels",
    system: "legion"
  },
  swlab: {
    name: "Star Wars Legion: Black Attack Dice",
    type: "d8",
    labels: ["h", "h", "h", "", "", "c", "o", ""],
    values: [1, 8],
    font: "Legion-Symbol-Regular",
    color: "#111111",
    colorset: "swl_atkblack",
    display: "labels",
    system: "legion"
  },
  swlaw: {
    name: "Star Wars Legion: White Attack Dice",
    type: "d8",
    labels: ["h", "", "", "", "", "c", "o", ""],
    values: [1, 8],
    font: "Legion-Symbol-Regular",
    color: "#FFFFFF",
    colorset: "swl_atkwhite",
    display: "labels",
    system: "legion"
  },
  swldr: {
    name: "Star Wars Legion: Red Defense Dice",
    type: "d6",
    labels: ["s", "s", "s", "d", "", ""],
    values: [1, 6],
    scale: 0.9,
    font: "Legion-Symbol-Regular",
    color: "#FF0000",
    colorset: "swl_defred",
    display: "labels",
    system: "legion"
  },
  swldw: {
    name: "Star Wars Legion: White Defense Dice",
    type: "d6",
    labels: ["s", "", "", "d", "", ""],
    values: [1, 6],
    scale: 0.9,
    font: "Legion-Symbol-Regular",
    color: "#FFFFFF",
    colorset: "swl_defwhite",
    display: "labels",
    system: "legion"
  }
}, wt = {
  d4: {
    vertices: [[1, 1, 1], [-1, -1, 1], [-1, 1, -1], [1, -1, -1]],
    faces: [[1, 0, 2, 1], [0, 1, 3, 2], [0, 3, 2, 3], [1, 2, 3, 4]]
  },
  d6: {
    vertices: [[-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]],
    faces: [[0, 3, 2, 1, 1], [1, 2, 6, 5, 2], [0, 1, 5, 4, 3], [3, 7, 6, 2, 4], [0, 4, 7, 3, 5], [4, 5, 6, 7, 6]]
  },
  d8: {
    vertices: [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]],
    faces: [[0, 2, 4, 1], [0, 4, 3, 2], [0, 3, 5, 3], [0, 5, 2, 4], [1, 3, 4, 5], [1, 4, 2, 6], [1, 2, 5, 7], [1, 5, 3, 8]]
  },
  d10: {
    vertices: [[1, 0, -0.105], [0.809, 0.5877, 0.105], [0.309, 0.951, -0.105], [-0.309, 0.951, 0.105], [-0.809, 0.5877, -0.105], [-1, 0, 0.105], [-0.809, -0.587, -0.105], [-0.309, -0.951, 0.105], [0.309, -0.951, -0.105], [0.809, -0.5877, 0.105], [0, 0, -1], [0, 0, 1]],
    faces: [[5, 6, 7, 11, 0], [4, 3, 2, 10, 1], [1, 2, 3, 11, 2], [0, 9, 8, 10, 3], [7, 8, 9, 11, 4], [8, 7, 6, 10, 5], [9, 0, 1, 11, 6], [2, 1, 0, 10, 7], [3, 4, 5, 11, 8], [6, 5, 4, 10, 9]]
  },
  d12: {
    vertices: [[0, 0.618, 1.618], [0, 0.618, -1.618], [0, -0.618, 1.618], [0, -0.618, -1.618], [1.618, 0, 0.618], [1.618, 0, -0.618], [-1.618, 0, 0.618], [-1.618, 0, -0.618], [0.618, 1.618, 0], [0.618, -1.618, 0], [-0.618, 1.618, 0], [-0.618, -1.618, 0], [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]],
    faces: [[2, 14, 4, 12, 0, 1], [15, 9, 11, 19, 3, 2], [16, 10, 17, 7, 6, 3], [6, 7, 19, 11, 18, 4], [6, 18, 2, 0, 16, 5], [18, 11, 9, 14, 2, 6], [1, 17, 10, 8, 13, 7], [1, 13, 5, 15, 3, 8], [13, 8, 12, 4, 5, 9], [5, 4, 14, 9, 15, 10], [0, 12, 8, 10, 16, 11], [3, 19, 7, 17, 1, 12]]
  },
  d20: {
    vertices: [[-1, 1.618, 0], [1, 1.618, 0], [-1, -1.618, 0], [1, -1.618, 0], [0, -1, 1.618], [0, 1, 1.618], [0, -1, -1.618], [0, 1, -1.618], [1.618, 0, -1], [1.618, 0, 1], [-1.618, 0, -1], [-1.618, 0, 1]],
    faces: [[0, 11, 5, 1], [0, 5, 1, 2], [0, 1, 7, 3], [0, 7, 10, 4], [0, 10, 11, 5], [1, 5, 9, 6], [5, 11, 4, 7], [11, 10, 2, 8], [10, 7, 6, 9], [7, 1, 8, 10], [3, 9, 4, 11], [3, 4, 2, 12], [3, 2, 6, 13], [3, 6, 8, 14], [3, 8, 9, 15], [4, 9, 5, 16], [2, 4, 11, 17], [6, 2, 10, 18], [8, 6, 7, 19], [9, 8, 1, 20]]
  }
}, xp = {
  name: "",
  scale: 1,
  font: "Arial",
  color: "",
  labels: [],
  valueMap: [],
  values: [],
  normals: [],
  mass: 300,
  inertia: 13,
  geometry: null,
  display: "values",
  system: "d20"
};
class yp {
  constructor(e) {
    if (!Ps.hasOwnProperty(e))
      return console.error("dice type unavailable");
    Object.assign(this, xp, Ps[e]), this.shape = Ps[e].type || e, this.type = e, this.setLabels(this.labels), this.setValues(this.values[0], this.values[1], this.values[2]), this.setValueMap(this.valueMap), this.bumpMaps && this.setBumpMaps(this.bumpMaps);
  }
  setValues(e = 1, t = 20, n = 1) {
    this.values = this.range(e, t, n);
  }
  setValueMap(e) {
    for (let t = 0; t < this.values.length; t++) {
      let n = this.values[t];
      e[n] != null && (this.valueMap[n] = e[n]);
    }
  }
  registerFaces(e, t = "labels") {
    let n;
    if (t == "labels" ? n = this.labels : n = this.normals, n.unshift(""), ["d2", "d10"].includes(this.shape) || n.unshift(""), this.shape == "d4") {
      let i = e[0], s = e[1], o = e[2], r = e[3];
      this.labels = [
        [[], [0, 0, 0], [s, r, o], [i, o, r], [s, i, r], [i, s, o]],
        [[], [0, 0, 0], [s, o, r], [o, i, r], [s, r, i], [o, s, i]],
        [[], [0, 0, 0], [r, o, s], [o, r, i], [r, s, i], [o, i, s]],
        [[], [0, 0, 0], [r, s, o], [i, r, o], [r, i, s], [i, o, s]]
      ];
    } else
      Array.prototype.push.apply(n, e);
  }
  setLabels(e) {
    this.loadTextures(e, this.registerFaces.bind(this), "labels");
  }
  setBumpMaps(e) {
    this.loadTextures(e, this.registerFaces.bind(this), "bump");
  }
  loadTextures(e, t, n) {
    let i = 0, s = e.length, o = /\.(PNG|JPG|GIF|WEBP)$/i, r = Array(e.length), l = !1;
    for (let a = 0; a < s; a++) {
      if (e[a] == "" || !e[a].match(o)) {
        r[a] = e[a], ++i;
        continue;
      }
      l = !0, r[a] = new Image(), r[a].onload = function() {
        ++i >= s && t(r, n);
      }, r[a].src = e[a];
    }
    l || t(r, n);
  }
  range(e, t, n = 1) {
    for (var i = [e], s = e; s < t; )
      i.push(s += n || 1);
    return i;
  }
}
const bp = {
  none: {
    name: "Plastic"
  },
  perfectmetal: {
    name: "Perfect Metal",
    color: 14540253,
    roughness: 0,
    metalness: 1,
    envMapIntensity: 1
  },
  metal: {
    name: "Metal",
    color: 14540253,
    roughness: 0.5,
    metalness: 0.6,
    envMapIntensity: 1
  },
  wood: {
    name: "Wood",
    color: 14540253,
    roughness: 0.9,
    metalness: 0,
    envMapIntensity: 1
  },
  glass: {
    name: "Glass",
    color: 14540253,
    roughness: 0.1,
    metalness: 0,
    envMapIntensity: 1
  }
}, wp = {
  baseScale: 100,
  bumpMapping: !0
}, Yn = class {
  constructor(e) {
    this.geometries = {}, this.materials_cache = {}, this.cache_hits = 0, this.cache_misses = 0, this.label_color = "", this.dice_color = "", this.edge_color = "", this.label_outline = "", this.dice_texture = "", this.dice_material = "", this.material_options = {
      specular: 16777215,
      color: 11908533,
      shininess: 5,
      flatShading: !0
    }, Object.assign(this, wp, e);
  }
  updateConfig(e = {}) {
    Object.assign(this, e), e.scale && this.scaleGeometry();
  }
  setBumpMapping(e) {
    this.bumpMapping = e, this.materials_cache = {};
  }
  create(e) {
    let t = this.get(e);
    if (!t)
      return null;
    let n = this.geometries[e];
    if (n || (n = this.createGeometry(t.shape, t.scale * this.baseScale), this.geometries[e] = n), !n)
      return null;
    this.setMaterialInfo();
    let i = new Nt(n, this.createMaterials(t, this.baseScale / 2, 1));
    switch (i.result = [], i.shape = t.shape, i.rerolls = 0, i.resultReason = "natural", i.mass = t.mass, i.getFaceValue = function() {
      let s = this.resultReason, o = new O(0, 0, this.shape == "d4" ? -1 : 1), r, l = Math.PI * 2, a = this.geometry.getAttribute("normal").array;
      for (let p = 0, f = this.geometry.groups.length; p < f; ++p) {
        let v = this.geometry.groups[p];
        if (v.materialIndex == 0)
          continue;
        let _ = p * 9, x = new O(a[_], a[_ + 1], a[_ + 2]).clone().applyQuaternion(this.body.quaternion).angleTo(o);
        x < l && (l = x, r = v);
      }
      let c = r.materialIndex - 1, d = 2;
      const u = Yn.dice[this.notation.type];
      if (this.shape == "d4") {
        let p = c - 1 == 0 ? 5 : c;
        return { value: c, label: u.labels[c - 1][p][0], reason: s };
      }
      ["d10", "d2"].includes(this.shape) && (c += 1, d -= 1);
      let m = u.values[(c - 1) % u.values.length], g = u.labels[(c - 1) % (u.labels.length - 2) + d];
      return { value: m, label: g, reason: s };
    }, i.storeRolledValue = function(s) {
      this.resultReason = s || this.resultReason, this.result.push(this.getFaceValue());
    }, i.getLastValue = function() {
      return !this.result || this.result.length < 1 ? { value: void 0, label: "", reason: "" } : this.result[this.result.length - 1];
    }, i.ignoreLastValue = function(s) {
      let o = this.getLastValue();
      o.value !== void 0 && (o.ignore = s, this.setLastValue(o));
    }, i.setLastValue = function(s) {
      if (!(!this.result || this.result.length < 1) && !(!s || s.length < 1))
        return this.result[this.result.length - 1] = s;
    }, t.color && (i.material[0].color = new Ae(t.color), i.material[0].emissive = new Ae(t.color), i.material[0].emissiveIntensity = 1, i.material[0].needsUpdate = !0), t.values.length) {
      case 1:
        return this.fixmaterials(i, 1);
      case 2:
        return this.fixmaterials(i, 2);
      case 3:
        return this.fixmaterials(i, 3);
      default:
        return i;
    }
  }
  get(e) {
    let t;
    return Yn.dice.hasOwnProperty(e) ? t = Yn.dice[e] : (t = new yp(e), Yn.dice[e] = t), t;
  }
  getGeometry(e) {
    return this.geometries[e];
  }
  scaleGeometry() {
  }
  createMaterials(e, t, n, i = !0, s = 0) {
    let o = [], r = e.labels;
    e.shape == "d4" && (r = e.labels[s], t = this.baseScale / 2, n = this.baseScale * 2);
    for (var l = 0; l < r.length; ++l) {
      var a;
      this.dice_material != "none" ? (a = new Uu(bp[this.dice_material]), a.envMapIntensity = 0) : a = new Gu(this.material_options);
      let c;
      if (l == 0) {
        let d = { name: "none" };
        this.dice_texture_rand.composite != "source-over" && (d = this.dice_texture_rand), c = this.createTextMaterial(e, r, l, t, n, d, this.label_color_rand, this.label_outline_rand, this.edge_color_rand, i), a.map = c.composite;
      } else if (c = this.createTextMaterial(e, r, l, t, n, this.dice_texture_rand, this.label_color_rand, this.label_outline_rand, this.dice_color_rand, i), a.map = c.composite, this.bumpMapping) {
        {
          let d = 0.75;
          t > 35 && (d = 1), t > 40 && (d = 2.5), t > 45 && (d = 4), a.bumpScale = d;
        }
        c.bump && (a.bumpMap = c.bump), e.shape != "d4" && e.normals[l] && (a.bumpMap = new _t(e.normals[l]), a.bumpScale = 4, a.bumpMap.needsUpdate = !0);
      }
      a.opacity = 1, a.transparent = !0, a.depthTest = !1, a.needUpdate = !0, o.push(a);
    }
    return o;
  }
  createTextMaterial(e, t, n, i, s, o, r, l, a, c) {
    if (t[n] === void 0)
      return null;
    o = o || this.dice_texture_rand, r = r || this.label_color_rand, l = l || this.label_outline_rand, a = a || this.dice_color_rand, c = c == null ? !0 : c;
    let d = t[n], u = !1, m = d;
    d instanceof HTMLImageElement ? m = d.src : d instanceof Array && d.forEach((y) => {
      m += y.src;
    });
    let g = e.type + m + n + o.name + r + l + a;
    if (e.shape == "d4" && (g = e.type + m + o.name + r + l + a), c && this.materials_cache[g] != null)
      return this.cache_hits++, this.materials_cache[g];
    let p = document.createElement("canvas"), f = p.getContext("2d", { alpha: !0 });
    f.globalAlpha = 0, f.clearRect(0, 0, p.width, p.height);
    let v = document.createElement("canvas"), _ = v.getContext("2d", { alpha: !0 });
    _.globalAlpha = 0, _.clearRect(0, 0, v.width, v.height);
    let w;
    if (e.shape == "d4" ? w = this.calc_texture_size(i + s) * 4 : w = this.calc_texture_size(i + i * 2 * s) * 4, p.width = p.height = w, v.width = v.height = w, f.fillStyle = a, f.fillRect(0, 0, p.width, p.height), _.fillStyle = "#FFFFFF", _.fillRect(0, 0, v.width, v.height), o.texture && o.name != "" && o.name != "none" ? (f.globalCompositeOperation = o.composite || "source-over", f.drawImage(o.texture, 0, 0, p.width, p.height), f.globalCompositeOperation = "source-over", o.bump && (_.globalCompositeOperation = "source-over", _.drawImage(o.bump, 0, 0, p.width, p.height))) : f.globalCompositeOperation = "source-over", f.globalCompositeOperation = "source-over", f.textAlign = "center", f.textBaseline = "middle", _.textAlign = "center", _.textBaseline = "middle", e.shape != "d4") {
      let A = {
        d8: { even: -7.5, odd: -127.5 },
        d10: { all: -6 },
        d12: { all: 5 },
        d20: { all: -7.5 }
      }[e.shape];
      if (A) {
        let F;
        if (A.hasOwnProperty("all") ? F = A.all : n > 0 && n % 2 != 0 ? F = A.odd : F = A.even, F && F != 0) {
          var x = p.width / 2, M = p.height / 2;
          f.translate(x, M), f.rotate(F * (Math.PI / 180)), f.translate(-x, -M), _.translate(x, M), _.rotate(F * (Math.PI / 180)), _.translate(-x, -M);
        }
      }
      if (d instanceof HTMLImageElement)
        u = !0, f.drawImage(d, 0, 0, d.width, d.height, 0, 0, p.width, p.height);
      else {
        let F = w / (1 + 2 * s), P = p.height / 2 + 10, G = p.width / 2;
        e.shape == "d10" ? (F = F * 0.75, P = P * 1.15 - 10) : e.shape == "d20" && (G = G * 0.98), f.font = F + "pt " + e.font, _.font = F + "pt " + e.font;
        let z = f.measureText("M").width * 1.4, L = d.split(`
`);
        L.length > 1 && (F = F / L.length, f.font = F + "pt " + e.font, _.font = F + "pt " + e.font, z = f.measureText("M").width * 1.2, P -= z * L.length / 2);
        for (let I = 0, D = L.length; I < D; I++) {
          let q = L[I].trim();
          l != "none" && l != a && (f.strokeStyle = l, f.lineWidth = 5, f.strokeText(L[I], G, P), _.strokeStyle = "#000000", _.lineWidth = 5, _.strokeText(L[I], G, P), (q == "6" || q == "9") && (f.strokeText("  .", G, P), _.strokeText("  .", G, P))), f.fillStyle = r, f.fillText(L[I], G, P), _.fillStyle = "#000000", _.fillText(L[I], G, P), (q == "6" || q == "9") && (f.fillText("  .", G, P), _.fillText("  .", G, P)), P += z * 1.5;
        }
      }
    } else {
      var x = p.width / 2, M = p.height / 2;
      f.font = w / 128 * 24 + "pt " + e.font, _.font = w / 128 * 24 + "pt " + e.font;
      for (let F = 0; F < d.length; F++) {
        if (d[F] instanceof HTMLImageElement) {
          let P = d[F].width / p.width;
          f.drawImage(d[F], 0, 0, d[F].width, d[F].height, 100 / P, 25 / P, 60 / P, 60 / P);
        } else
          l != "none" && l != a && (f.strokeStyle = l, f.lineWidth = 5, f.strokeText(d[F], x, M - w * 0.3), _.strokeStyle = "#000000", _.lineWidth = 5, _.strokeText(d[F], x, M - w * 0.3)), f.fillStyle = r, f.fillText(d[F], x, M - w * 0.3), _.fillStyle = "#000000", _.fillText(d[F], x, M - w * 0.3);
        f.translate(x, M), f.rotate(Math.PI * 2 / 3), f.translate(-x, -M), _.translate(x, M), _.rotate(Math.PI * 2 / 3), _.translate(-x, -M);
      }
    }
    var E = new Rr(p), R;
    return u ? R = null : R = new Rr(v), c && (this.cache_misses++, this.materials_cache[g] = { composite: E, bump: R }), { composite: E, bump: R };
  }
  applyColorSet(e) {
    var t;
    this.colordata = e, this.label_color = e.foreground, this.dice_color = e.background, this.label_outline = e.outline, this.dice_texture = e.texture, this.dice_material = ((t = e == null ? void 0 : e.texture) == null ? void 0 : t.material) || "none", this.edge_color = e.hasOwnProperty("edge") ? e.edge : e.background;
  }
  setMaterialInfo(e = "") {
    let t = this.colordata, n = this.dice_texture, i = this.dice_material;
    if (this.dice_color_rand = "", this.label_color_rand = "", this.label_outline_rand = "", this.dice_texture_rand = "", this.dice_material_rand = "", this.edge_color_rand = "", Array.isArray(this.dice_color)) {
      var s = Math.floor(Math.random() * this.dice_color.length);
      Array.isArray(this.label_color) && this.label_color.length == this.dice_color.length && (this.label_color_rand = this.label_color[s], Array.isArray(this.label_outline) && this.label_outline.length == this.label_color.length && (this.label_outline_rand = this.label_outline[s])), Array.isArray(this.dice_texture) && this.dice_texture.length == this.dice_color.length && (this.dice_texture_rand = this.dice_texture[s], this.dice_material_rand = this.dice_texture_rand.material), Array.isArray(this.edge_color) && this.edge_color.length == this.dice_color.length && (this.edge_color_rand = this.edge_color[s]), this.dice_color_rand = this.dice_color[s];
    } else
      this.dice_color_rand = this.dice_color;
    if (this.edge_color_rand == "")
      if (Array.isArray(this.edge_color)) {
        var s = Math.floor(Math.random() * this.edge_color.length);
        this.edge_color_rand = this.edge_color[s];
      } else
        this.edge_color_rand = this.edge_color;
    if (this.label_color_rand == "" && Array.isArray(this.label_color)) {
      var s = this.label_color[Math.floor(Math.random() * this.label_color.length)];
      Array.isArray(this.label_outline) && this.label_outline.length == this.label_color.length && (this.label_outline_rand = this.label_outline[s]), this.label_color_rand = this.label_color[s];
    } else
      this.label_color_rand == "" && (this.label_color_rand = this.label_color);
    if (this.label_outline_rand == "" && Array.isArray(this.label_outline)) {
      var s = this.label_outline[Math.floor(Math.random() * this.label_outline.length)];
      this.label_outline_rand = this.label_outline[s];
    } else
      this.label_outline_rand == "" && (this.label_outline_rand = this.label_outline);
    this.dice_texture_rand == "" && Array.isArray(this.dice_texture) ? (this.dice_texture_rand = this.dice_texture[Math.floor(Math.random() * this.dice_texture.length)], this.dice_material_rand = this.dice_texture_rand.material || this.dice_material) : this.dice_texture_rand == "" && (this.dice_texture_rand = this.dice_texture, this.dice_material_rand = this.dice_texture_rand.material || this.dice_material), this.dice_material_rand == "" && Array.isArray(this.dice_material) ? this.dice_material_rand = this.dice_material[Math.floor(Math.random() * this.dice_material.length)] : this.dice_material_rand == "" && (this.dice_material_rand = this.dice_material), this.colordata && this.colordata.id != t.id && this.applyColorSet(t, n, i);
  }
  calc_texture_size(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.log(2)));
  }
  createGeometry(e, t, n = !1) {
    const i = n ? "create_shape" : "create_geom";
    switch (e) {
      case "d2":
        var s = new ks(1 * t, 1 * t, 0.1 * t, 32);
        return s.cannon_shape = new jd(1 * t, 1 * t, 0.1 * t, 8), s;
      case "d4":
        return this[i](wt.d4.vertices, wt.d4.faces, t, -0.1, Math.PI * 7 / 6, 0.96);
      case "d6":
        return this[i](wt.d6.vertices, wt.d6.faces, t, 0.1, Math.PI / 4, 0.96);
      case "d8":
        return this[i](wt.d8.vertices, wt.d8.faces, t, 0, -Math.PI / 4 / 2, 0.965);
      case "d10":
        return this[i](wt.d10.vertices, wt.d10.faces, t, 0.3, Math.PI, 0.945);
      case "d12":
        return this[i](wt.d12.vertices, wt.d12.faces, t, 0.2, -Math.PI / 4 / 2, 0.968);
      case "d20":
        return this[i](wt.d20.vertices, wt.d20.faces, t, -0.2, -Math.PI / 4 / 2, 0.955);
      default:
        return console.error(`Geometry for ${e} is not available`), null;
    }
  }
  fixmaterials(e, t) {
    for (let i = 0, s = e.geometry.groups.length; i < s; ++i) {
      var n = e.geometry.groups[i].materialIndex - 2;
      if (n < t)
        continue;
      let o = n % t;
      e.geometry.groups[i].materialIndex = o + 2;
    }
    return e.geometry.elementsNeedUpdate = !0, e;
  }
  create_shape(e, t, n) {
    for (var i = new Array(e.length), s = 0; s < e.length; ++s)
      i[s] = new O().fromArray(e[s]).normalize();
    for (var o = new Array(e.length), r = new Array(t.length), s = 0; s < i.length; ++s) {
      var l = i[s];
      o[s] = new b(l.x * n, l.y * n, l.z * n);
    }
    for (var s = 0; s < t.length; ++s)
      r[s] = t[s].slice(0, t[s].length - 1);
    return new wn({ vertices: o, faces: r });
  }
  make_geom(e, t, n, i, s) {
    let o = new Ut();
    for (let g = 0; g < e.length; ++g)
      e[g] = e[g].multiplyScalar(n);
    let r = [];
    const l = [], a = [], c = new O(), d = new O();
    let u, m = 0;
    for (let g = 0; g < t.length; ++g) {
      let p = t[g], f = p.length - 1, v = Math.PI * 2 / f;
      u = p[f] + 1;
      for (let w = 0; w < f - 2; ++w)
        r.push(...e[p[0]].toArray()), r.push(...e[p[w + 1]].toArray()), r.push(...e[p[w + 2]].toArray()), c.subVectors(e[p[w + 2]], e[p[w + 1]]), d.subVectors(e[p[0]], e[p[w + 1]]), c.cross(d), c.normalize(), l.push(...c.toArray()), l.push(...c.toArray()), l.push(...c.toArray()), a.push((Math.cos(s) + 1 + i) / 2 / (1 + i), (Math.sin(s) + 1 + i) / 2 / (1 + i)), a.push((Math.cos(v * (w + 1) + s) + 1 + i) / 2 / (1 + i), (Math.sin(v * (w + 1) + s) + 1 + i) / 2 / (1 + i)), a.push((Math.cos(v * (w + 2) + s) + 1 + i) / 2 / (1 + i), (Math.sin(v * (w + 2) + s) + 1 + i) / 2 / (1 + i));
      let _ = (f - 2) * 3;
      for (let w = 0; w < _ / 3; w++)
        o.addGroup(m, 3, u), m += 3;
    }
    return o.setAttribute("position", new st(r, 3)), o.setAttribute("normal", new st(l, 3)), o.setAttribute("uv", new st(a, 2)), o.boundingSphere = new ci(new O(), n), o;
  }
  make_d10_geom(e, t, n, i, s) {
    let o = new Ut();
    for (let w = 0; w < e.length; ++w)
      e[w] = e[w].multiplyScalar(n);
    let r = [];
    const l = [], a = [], c = new O(), d = new O();
    let u, m = 0;
    for (let w = 0; w < t.length; ++w) {
      let x = t[w], M = x.length - 1, E = Math.PI * 2 / M;
      u = x[M] + 1;
      var g = 0.65, p = 0.85, f = 1 - 1 * p, v = 1 - 0.895 / 1.105 * p, _ = 1;
      for (let y = 0; y < M - 2; ++y)
        r.push(...e[x[0]].toArray()), r.push(...e[x[y + 1]].toArray()), r.push(...e[x[y + 2]].toArray()), c.subVectors(e[x[y + 2]], e[x[y + 1]]), d.subVectors(e[x[0]], e[x[y + 1]]), c.cross(d), c.normalize(), l.push(...c.toArray()), l.push(...c.toArray()), l.push(...c.toArray()), t[w][t[w].length - 1] == -1 || y >= 2 ? (a.push((Math.cos(s) + 1 + i) / 2 / (1 + i), (Math.sin(s) + 1 + i) / 2 / (1 + i)), a.push((Math.cos(E * (y + 1) + s) + 1 + i) / 2 / (1 + i), (Math.sin(E * (y + 1) + s) + 1 + i) / 2 / (1 + i)), a.push((Math.cos(E * (y + 2) + s) + 1 + i) / 2 / (1 + i), (Math.sin(E * (y + 2) + s) + 1 + i) / 2 / (1 + i))) : y == 0 ? (a.push(0.5 - g / 2, v), a.push(0.5, f), a.push(0.5 + g / 2, v)) : y == 1 && (a.push(0.5 - g / 2, v), a.push(0.5 + g / 2, v), a.push(0.5, _));
      let R = (M - 2) * 3;
      for (let y = 0; y < R / 3; y++)
        o.addGroup(m, 3, u), m += 3;
    }
    return o.setAttribute("position", new st(r, 3)), o.setAttribute("normal", new st(l, 3)), o.setAttribute("uv", new st(a, 2)), o.boundingSphere = new ci(new O(), n), o;
  }
  chamfer_geom(e, t, n) {
    for (var i = [], s = [], o = new Array(e.length), r = 0; r < e.length; ++r)
      o[r] = [];
    for (var r = 0; r < t.length; ++r) {
      for (var l = t[r], a = l.length - 1, c = new O(), d = new Array(a), u = 0; u < a; ++u) {
        var m = e[l[u]].clone();
        c.add(m), o[l[u]].push(d[u] = i.push(m) - 1);
      }
      c.divideScalar(a);
      for (var u = 0; u < a; ++u) {
        var m = i[d[u]];
        m.subVectors(m, c).multiplyScalar(n).addVectors(m, c);
      }
      d.push(l[a]), s.push(d);
    }
    for (var r = 0; r < t.length - 1; ++r)
      for (var u = r + 1; u < t.length; ++u) {
        for (var g = [], p = -1, f = 0; f < t[r].length - 1; ++f) {
          var v = t[u].indexOf(t[r][f]);
          v >= 0 && v < t[u].length - 1 && (p >= 0 && f != p + 1 ? g.unshift([r, f], [u, v]) : g.push([r, f], [u, v]), p = f);
        }
        g.length == 4 && s.push([
          s[g[0][0]][g[0][1]],
          s[g[1][0]][g[1][1]],
          s[g[3][0]][g[3][1]],
          s[g[2][0]][g[2][1]],
          -1
        ]);
      }
    for (var r = 0; r < o.length; ++r) {
      for (var _ = o[r], d = [_[0]], w = _.length - 1; w; ) {
        for (var f = t.length; f < s.length; ++f) {
          var x = s[f].indexOf(d[d.length - 1]);
          if (x >= 0 && x < 4) {
            --x == -1 && (x = 3);
            var M = s[f][x];
            if (_.indexOf(M) >= 0) {
              d.push(M);
              break;
            }
          }
        }
        --w;
      }
      d.push(-1), s.push(d);
    }
    return { vectors: i, faces: s };
  }
  create_geom(e, t, n, i, s, o) {
    for (var r = new Array(e.length), l = 0; l < e.length; ++l)
      r[l] = new O().fromArray(e[l]).normalize();
    var a = this.chamfer_geom(r, t, o);
    if (t.length != 10)
      var c = this.make_geom(a.vectors, a.faces, n, i, s);
    else
      var c = this.make_d10_geom(a.vectors, a.faces, n, i, s);
    return c.cannon_shape = this.create_shape(e, t, n), c.name = "d" + t.length, c;
  }
};
let Hi = Yn;
Ys(Hi, "dice", {});
const Is = {
  cloudy: {
    name: "Clouds (Transparent)",
    composite: "destination-in",
    source: "textures/cloudy.webp",
    source_bump: "textures/cloudy.alt.webp"
  },
  cloudy_2: {
    name: "Clouds",
    composite: "multiply",
    source: "textures/cloudy.alt.webp",
    source_bump: "textures/cloudy.alt.webp"
  },
  fire: {
    name: "Fire",
    composite: "multiply",
    source: "textures/fire.webp",
    source_bump: "textures/fire.webp",
    material: "metal"
  },
  marble: {
    name: "Marble",
    composite: "multiply",
    source: "textures/marble.webp",
    source_bump: "",
    material: "glass"
  },
  water: {
    name: "Water",
    composite: "destination-in",
    source: "textures/water.webp",
    source_bump: "textures/water.webp",
    material: "glass"
  },
  ice: {
    name: "Ice",
    composite: "destination-in",
    source: "textures/ice.webp",
    source_bump: "textures/ice.webp",
    material: "glass"
  },
  paper: {
    name: "Paper",
    composite: "multiply",
    source: "textures/paper.webp",
    source_bump: "textures/paper-bump.webp",
    material: "wood"
  },
  speckles: {
    name: "Speckles",
    composite: "multiply",
    source: "textures/speckles.webp",
    source_bump: "textures/speckles.webp",
    material: "none"
  },
  glitter: {
    name: "Glitter",
    composite: "multiply",
    source: "textures/glitter.webp",
    source_bump: "textures/glitter-bump.webp",
    material: "none"
  },
  glitter_2: {
    name: "Glitter (Transparent)",
    composite: "destination-in",
    source: "textures/glitter-alpha.webp",
    source_bump: "",
    material: "none"
  },
  stars: {
    name: "Stars",
    composite: "multiply",
    source: "textures/stars.webp",
    source_bump: "textures/stars.webp",
    material: "none"
  },
  stainedglass: {
    name: "Stained Glass",
    composite: "multiply",
    source: "textures/stainedglass.webp",
    source_bump: "textures/stainedglass-bump.webp",
    material: "glass"
  },
  wood: {
    name: "Wood",
    composite: "multiply",
    source: "textures/wood.webp",
    source_bump: "textures/wood.webp",
    material: "wood"
  },
  metal: {
    name: "Stainless Steel",
    composite: "multiply",
    source: "textures/metal.webp",
    source_bump: "textures/metal-bump.webp",
    material: "metal"
  },
  skulls: {
    name: "Skulls",
    composite: "multiply",
    source: "textures/skulls.webp",
    source_bump: "textures/skulls.webp"
  },
  leopard: {
    name: "Leopard",
    composite: "multiply",
    source: "textures/leopard.webp",
    source_bump: "textures/leopard.webp",
    material: "wood"
  },
  tiger: {
    name: "Tiger",
    composite: "multiply",
    source: "textures/tiger.webp",
    source_bump: "textures/tiger.webp",
    material: "wood"
  },
  cheetah: {
    name: "Cheetah",
    composite: "multiply",
    source: "textures/cheetah.webp",
    source_bump: "textures/cheetah.webp",
    material: "wood"
  },
  dragon: {
    name: "Dragon",
    composite: "multiply",
    source: "textures/dragon.webp",
    source_bump: "textures/dragon-bump.webp",
    material: "none"
  },
  lizard: {
    name: "Lizard",
    composite: "multiply",
    source: "textures/lizard.webp",
    source_bump: "textures/lizard.webp",
    material: "none"
  },
  bird: {
    name: "Bird",
    composite: "multiply",
    source: "textures/feather.webp",
    source_bump: "textures/feather-bump.webp",
    material: "wood"
  },
  astral: {
    name: "Astral Sea",
    composite: "multiply",
    source: "textures/astral.webp",
    source_bump: "textures/stars.webp",
    material: "none"
  },
  acleaf: {
    name: "AC Leaf",
    composite: "multiply",
    source: "textures/acleaf.webp",
    source_bump: "textures/acleaf.webp",
    material: "none"
  },
  thecage: {
    name: "Nicholas Cage",
    composite: "multiply",
    source: "textures/thecage.webp",
    source_bump: "",
    material: "metal"
  },
  isabelle: {
    name: "Isabelle",
    composite: "source-over",
    source: "textures/isabelle.webp",
    source_bump: "",
    material: "none"
  },
  bronze01: {
    name: "bronze01",
    composite: "difference",
    source: "textures/bronze01.webp",
    source_bump: "",
    material: "metal"
  },
  bronze02: {
    name: "bronze02",
    composite: "difference",
    source: "textures/bronze02.webp",
    source_bump: "",
    material: "metal"
  },
  bronze03: {
    name: "bronze03",
    composite: "difference",
    source: "textures/bronze03.webp",
    source_bump: "",
    material: "metal"
  },
  bronze03a: {
    name: "bronze03a",
    composite: "difference",
    source: "textures/bronze03a.webp",
    source_bump: "",
    material: "metal"
  },
  bronze03b: {
    name: "bronze03b",
    composite: "difference",
    source: "textures/bronze03b.webp",
    source_bump: "",
    material: "metal"
  },
  bronze04: {
    name: "bronze04",
    composite: "difference",
    source: "textures/bronze04.webp",
    source_bump: "",
    material: "metal"
  },
  none: {
    name: "none",
    composite: "source-over",
    source: "",
    source_bump: "",
    material: ""
  },
  "": {
    name: "~ Preset ~",
    composite: "source-over",
    source: "",
    source_bump: "",
    material: ""
  }
}, eo = {
  coin_default: {
    name: "Gold Coin",
    description: "Gold Dragonhead Coin",
    category: "Other",
    foreground: "#f6c928",
    background: "#f6c928",
    outline: "none",
    texture: "metal"
  },
  coin_silver: {
    name: "Silver Coin",
    description: "Gold Dragonhead Coin",
    category: "Other",
    foreground: "#f6c928",
    background: "#f6c928",
    outline: "none",
    texture: "metal"
  },
  radiant: {
    name: "Radiant",
    category: "Damage Types",
    foreground: "#F9B333",
    background: "#FFFFFF",
    outline: "",
    texture: "paper",
    description: "Radiant"
  },
  fire: {
    name: "Fire",
    category: "Damage Types",
    foreground: "#f8d84f",
    background: ["#f8d84f", "#f9b02d", "#f43c04", "#910200", "#4c1009"],
    outline: "black",
    texture: "fire",
    description: "Fire"
  },
  ice: {
    name: "Ice",
    category: "Damage Types",
    foreground: "#60E9FF",
    background: ["#214fa3", "#3c6ac1", "#253f70", "#0b56e2", "#09317a"],
    outline: "black",
    texture: "ice",
    description: "Ice"
  },
  poison: {
    name: "Poison",
    category: "Damage Types",
    foreground: "#D6A8FF",
    background: ["#313866", "#504099", "#66409e", "#934fc3", "#c949fc"],
    outline: "black",
    texture: "cloudy",
    description: "Poison"
  },
  acid: {
    name: "Acid",
    category: "Damage Types",
    foreground: "#A9FF70",
    background: ["#a6ff00", "#83b625", "#5ace04", "#69f006", "#b0f006", "#93bc25"],
    outline: "black",
    texture: "marble",
    description: "Acid"
  },
  thunder: {
    name: "Thunder",
    category: "Damage Types",
    foreground: "#FFC500",
    background: "#7D7D7D",
    outline: "black",
    texture: "cloudy",
    description: "Thunder"
  },
  lightning: {
    name: "Lightning",
    category: "Damage Types",
    foreground: "#FFC500",
    background: ["#f17105", "#f3ca40", "#eddea4", "#df9a57", "#dea54b"],
    outline: "#7D7D7D",
    texture: "ice",
    description: "Lightning"
  },
  air: {
    name: "Air",
    category: "Damage Types",
    foreground: "#ffffff",
    background: ["#d0e5ea", "#c3dee5", "#a4ccd6", "#8dafb7", "#80a4ad"],
    outline: "black",
    texture: "cloudy",
    description: "Air"
  },
  water: {
    name: "Water",
    category: "Damage Types",
    foreground: "#60E9FF",
    background: ["#87b8c4", "#77a6b2", "#6b98a3", "#5b8691", "#4b757f"],
    outline: "black",
    texture: "water",
    description: "Water"
  },
  earth: {
    name: "Earth",
    category: "Damage Types",
    foreground: "#6C9943",
    background: ["#346804", "#184200", "#527f22", "#3a1d04", "#56341a", "#331c17", "#5a352a", "#302210"],
    outline: "black",
    texture: "speckles",
    description: "Earth"
  },
  force: {
    name: "Force",
    category: "Damage Types",
    foreground: "white",
    background: ["#FF97FF", "#FF68FF", "#C651C6"],
    outline: "#570000",
    texture: "stars",
    description: "Force"
  },
  psychic: {
    name: "Psychic",
    category: "Damage Types",
    foreground: "#D6A8FF",
    background: ["#313866", "#504099", "#66409E", "#934FC3", "#C949FC", "#313866"],
    outline: "black",
    texture: "speckles",
    description: "Psychic"
  },
  necrotic: {
    name: "Necrotic",
    category: "Damage Types",
    foreground: "#ffffff",
    background: "#6F0000",
    outline: "black",
    texture: "skulls",
    description: "Necrotic"
  },
  breebaby: {
    name: "Pastel Sunset",
    category: "Custom Sets",
    foreground: ["#5E175E", "#564A5E", "#45455E", "#3D5A5E", "#1E595E", "#5E3F3D", "#5E1E29", "#283C5E", "#25295E"],
    background: ["#FE89CF", "#DFD4F2", "#C2C2E8", "#CCE7FA", "#A1D9FC", "#F3C3C2", "#EB8993", "#8EA1D2", "#7477AD"],
    outline: "white",
    texture: "marble",
    description: "Pastel Sunset, for Breyanna"
  },
  pinkdreams: {
    name: "Pink Dreams",
    category: "Custom Sets",
    foreground: "white",
    background: ["#ff007c", "#df73ff", "#f400a1", "#df00ff", "#ff33cc"],
    outline: "#570000",
    texture: "skulls",
    description: "Pink Dreams, for Ethan"
  },
  inspired: {
    name: "Inspired",
    category: "Custom Sets",
    foreground: "#FFD800",
    background: "#C4C4B6",
    outline: "#8E8E86",
    texture: "none",
    description: "Inspired, for Austin"
  },
  bloodmoon: {
    name: "Blood Moon",
    category: "Custom Sets",
    foreground: "#CDB800",
    background: "#6F0000",
    outline: "black",
    texture: "marble",
    description: "Blood Moon, for Jared"
  },
  starynight: {
    name: "Stary Night",
    category: "Custom Sets",
    foreground: "#4F708F",
    background: ["#091636", "#233660", "#4F708F", "#8597AD", "#E2E2E2"],
    outline: "white",
    texture: "speckles",
    description: "Stary Night, for Mai"
  },
  glitterparty: {
    name: "Glitter Party",
    category: "Custom Sets",
    foreground: "white",
    background: ["#FFB5F5", "#7FC9FF", "#A17FFF"],
    outline: "none",
    texture: "glitter",
    description: "Glitter Party, for Austin"
  },
  astralsea: {
    name: "Astral Sea",
    category: "Custom Sets",
    foreground: "#565656",
    background: "white",
    outline: "none",
    texture: "astral",
    description: "The Astral Sea, for Austin"
  },
  bronze: {
    name: "Thylean Bronze",
    description: "Thylean Bronze by @SpencerThayer",
    category: "Custom Sets",
    foreground: ["#FF9159", "#FFB066", "#FFBF59", "#FFD059"],
    background: ["#705206", "#7A4E06", "#643100", "#7A2D06"],
    outline: ["#3D2D03", "#472D04", "#301700", "#471A04"],
    edge: ["#FF5D0D", "#FF7B00", "#FFA20D", "#FFBA0D"],
    texture: ["bronze01", "bronze02", "bronze03", "bronze03a", "bronze03b", "bronze04"]
  },
  dragons: {
    name: "Here be Dragons",
    category: "Custom Sets",
    foreground: "#FFFFFF",
    background: ["#B80000", "#4D5A5A", "#5BB8FF", "#7E934E", "#FFFFFF", "#F6ED7C", "#7797A3", "#A78437", "#862C1A", "#FFDF8A"],
    outline: "black",
    texture: ["dragon", "lizard"],
    description: "Here be Dragons"
  },
  birdup: {
    name: "Bird Up",
    category: "Custom Sets",
    foreground: "#FFFFFF",
    background: ["#F11602", "#FFC000", "#6EC832", "#0094BC", "#05608D", "#FEABB3", "#F75680", "#F3F0DF", "#C7A57F"],
    outline: "black",
    texture: "bird",
    description: "Bird Up!"
  },
  tigerking: {
    name: "Tiger King",
    category: "Other",
    foreground: "#ffffff",
    background: "#FFCC40",
    outline: "black",
    texture: ["leopard", "tiger", "cheetah"],
    description: "Leopard Print"
  },
  covid: {
    name: "COViD",
    category: "Other",
    foreground: "#A9FF70",
    background: ["#a6ff00", "#83b625", "#5ace04", "#69f006", "#b0f006", "#93bc25"],
    outline: "black",
    texture: "fire",
    description: "Covid-19"
  },
  acleaf: {
    name: "Animal Crossing",
    category: "Other",
    foreground: "#00FF00",
    background: "#07540A",
    outline: "black",
    texture: "acleaf",
    description: "Animal Crossing Leaf"
  },
  isabelle: {
    name: "Isabelle",
    category: "Other",
    foreground: "white",
    background: "#FEE5CC",
    outline: "black",
    texture: "isabelle",
    description: "Isabelle"
  },
  thecage: {
    name: "Nicholas Cage",
    category: "Other",
    foreground: "#ffffff",
    background: "#ffffff",
    outline: "black",
    texture: "thecage",
    description: "Nicholas Cage"
  },
  test: {
    name: "Test",
    category: "Colors",
    foreground: ["#00FF00", "#0000FF", "#FF0000"],
    background: ["#FF0000", "#00FF00", "#0000FF"],
    outline: "black",
    texture: "none",
    description: "Test"
  },
  rainbow: {
    name: "Rainblow",
    category: "Colors",
    foreground: ["#FF5959", "#FFA74F", "#FFFF56", "#59FF59", "#2374FF", "#00FFFF", "#FF59FF"],
    background: ["#900000", "#CE3900", "#BCBC00", "#00B500", "#00008E", "#008282", "#A500A5"],
    outline: "black",
    texture: "none",
    description: "Rainblow"
  },
  black: {
    name: "Black",
    category: "Colors",
    foreground: "#ffffff",
    background: "#000000",
    outline: "black",
    texture: "none",
    description: "Black"
  },
  white: {
    name: "White",
    category: "Colors",
    foreground: "#000000",
    background: "#FFFFFF",
    outline: "#FFFFFF",
    texture: "none",
    description: "White"
  },
  swrpg_abi: {
    name: "Star Wars RPG - Ability",
    category: "Star Wars\u2122 RPG",
    foreground: "#00FF00",
    background: ["#3D9238", "#52B848", "#5EAC56", "#9ECB9A"],
    outline: "#000000",
    texture: "cloudy_2",
    description: "Star Wars\u2122 RPG Ability Dice"
  },
  swrpg_pro: {
    name: "Star Wars RPG - Proficiency",
    category: "Star Wars\u2122 RPG",
    foreground: "#FFFF00",
    background: ["#CABB1C", "#F9E33B", "#FFE900", "#F0E49D"],
    outline: "#000000",
    texture: "paper",
    description: "Star Wars\u2122 RPG Proficiency Dice"
  },
  swrpg_dif: {
    name: "Star Wars RPG - Difficulty",
    category: "Star Wars\u2122 RPG",
    foreground: "#8000FC",
    background: ["#39165F", "#664B84", "#50247E", "#745F88"],
    outline: "#000000",
    texture: "cloudy_2",
    description: "Star Wars\u2122 RPG Difficulty Dice"
  },
  swrpg_cha: {
    name: "Star Wars RPG - Challenge",
    category: "Star Wars\u2122 RPG",
    foreground: "#FF0000",
    background: ["#A91F32", "#EB4254", "#E51836", "#BA3645"],
    outline: "#000000",
    texture: "paper",
    description: "Star Wars\u2122 RPG Challenge Dice"
  },
  swrpg_boo: {
    name: "Star Wars RPG - Boost",
    category: "Star Wars\u2122 RPG",
    foreground: "#00FFFF",
    background: ["#4B9DC6", "#689FC4", "#85CFF2", "#8FC0D8"],
    outline: "#000000",
    texture: "glitter",
    description: "Star Wars\u2122 RPG Boost Dice"
  },
  swrpg_set: {
    name: "Star Wars RPG - Setback",
    category: "Star Wars\u2122 RPG",
    foreground: "#111111",
    background: ["#252223", "#241F21", "#282828", "#111111"],
    outline: "#ffffff",
    texture: "glitter",
    description: "Star Wars\u2122 RPG Setback Dice"
  },
  swrpg_for: {
    name: "Star Wars RPG - Force",
    category: "Star Wars\u2122 RPG",
    foreground: "#000000",
    background: ["#F3F3F3", "#D3D3D3", "#BABABA", "#FFFFFF"],
    outline: "#FFFFFF",
    texture: "stars",
    description: "Star Wars\u2122 RPG Force Dice"
  },
  swa_red: {
    name: "Armada Attack - Red",
    category: "Star Wars\u2122 Armada",
    foreground: "#ffffff",
    background: ["#440D19", "#8A1425", "#C72336", "#C04551"],
    outline: "none",
    texture: "stainedglass",
    description: "Star Wars\u2122 Armada Red Attack Dice"
  },
  swa_blue: {
    name: "Armada Attack - Blue",
    category: "Star Wars\u2122 Armada",
    foreground: "#ffffff",
    background: ["#212642", "#28286E", "#2B348C", "#3D4BB5", "#5D64AB"],
    outline: "none",
    texture: "stainedglass",
    description: "Star Wars\u2122 Armada Blue Attack Dice"
  },
  swa_black: {
    name: "Armada Attack - Black",
    category: "Star Wars\u2122 Armada",
    foreground: "#ffffff",
    background: ["#252223", "#241F21", "#282828", "#111111"],
    outline: "none",
    texture: "stainedglass",
    description: "Star Wars\u2122 Armada Black Attack Dice"
  },
  xwing_red: {
    name: "X-Wing Attack - Red",
    category: "Star Wars\u2122 X-Wing",
    foreground: "#ffffff",
    background: ["#440D19", "#8A1425", "#C72336", "#C04551"],
    outline: "none",
    texture: "stars",
    description: "Star Wars\u2122 X-Wing Red Attack Dice"
  },
  xwing_green: {
    name: "X-Wing Attack - Green",
    category: "Star Wars\u2122 X-Wing",
    foreground: "#ffffff",
    background: ["#3D9238", "#52B848", "#5EAC56", "#9ECB9A"],
    outline: "none",
    texture: "stars",
    description: "Star Wars\u2122 X-Wing Green Attack Dice"
  },
  swl_atkred: {
    name: "Legion Attack - Red",
    category: "Star Wars\u2122 Legion",
    foreground: "#ffffff",
    background: ["#440D19", "#8A1425", "#C72336", "#C04551"],
    outline: "none",
    texture: "fire",
    description: "Star Wars\u2122 Legion Red Attack Dice"
  },
  swl_atkblack: {
    name: "Legion Attack - Black",
    category: "Star Wars\u2122 Legion",
    foreground: "#ffffff",
    background: ["#252223", "#241F21", "#282828", "#111111"],
    outline: "none",
    texture: "fire",
    description: "Star Wars\u2122 Legion Black Attack Dice"
  },
  swl_atkwhite: {
    name: "Legion Attack - White",
    category: "Star Wars\u2122 Legion",
    foreground: "#000000",
    background: ["#ffffff", "#DFF4FA", "#BCBCBC", "#F1EDE2", "#F2ECE0"],
    outline: "none",
    texture: "fire",
    description: "Star Wars\u2122 Legion White Attack Dice"
  },
  swl_defred: {
    name: "Legion Defense - Red",
    category: "Star Wars\u2122 Legion",
    foreground: "#ffffff",
    background: ["#440D19", "#8A1425", "#C72336", "#C04551"],
    outline: "none",
    texture: "fire",
    description: "Star Wars\u2122 Legion Red Defense Dice"
  },
  swl_defwhite: {
    name: "Legion Defense - White",
    category: "Star Wars\u2122 Legion",
    foreground: "#000000",
    background: ["#ffffff", "#DFF4FA", "#BCBCBC", "#F1EDE2", "#F2ECE0"],
    outline: "none",
    texture: "fire",
    description: "Star Wars\u2122 Legion White Defense Dice"
  }
};
class Mp {
  constructor(e = {}) {
    this.colorsets = [], this.assetPath = e.assetPath;
  }
  async ImageLoader(e) {
    if (Array.isArray(e)) {
      for (let t = 0, n = e.length; t < n; t++)
        e[t] = await this.ImageLoader(e[t]);
      return e;
    }
    return e.source && e.source != "" && (e.texture = await this.loadImage(e.source)), e.source_bump && e.source_bump != "" && (e.bump = await this.loadImage(e.source_bump)), e;
  }
  loadImage(e) {
    return new Promise((t, n) => {
      let i = new Image();
      i.onload = () => t(i), i.crossOrigin = "anonymous", i.src = this.assetPath + e, i.onerror = (s) => n(s);
    }).catch((t) => {
      console.error("Unable to load image texture");
    });
  }
  async getColorSet(e) {
    let t, n;
    if (typeof e == "string" && (t = e), typeof e == "object" && (t = e.colorset), this.colorsets.hasOwnProperty(t))
      return this.colorsets[t];
    let i = eo[t];
    return n = e.texture || i.texture, i.texture = this.getTexture(n), i.texture = await this.ImageLoader(i.texture), e.material && (i.texture.material = e.material), this.colorsets[t] = i, i;
  }
  async makeColorSet(e = {}) {
    if (this.colorsets.hasOwnProperty(e.name))
      return this.colorsets[e.name];
    let t = eo.white, n = Object.assign({}, t, e), i = this.getTexture(n.texture);
    return n.texture = await this.ImageLoader(i), e.material && (n.texture.material = e.material), n.name.toLowerCase() === "white" && (n.name = `${Date.now()}`), this.colorsets[n.name] = n, n;
  }
  getTexture(e) {
    if (Array.isArray(e)) {
      let t = [];
      for (let n = 0, i = e.length; n < i; n++)
        t.push(this.getTexture(e[n]));
      return t;
    }
    return Is.hasOwnProperty(e) ? Is[e] : Is.none;
  }
}
const Sp = {
  default: {
    name: "Solid Color",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "wood_tray",
    colors: { fg: "#9794ff", bg: "#0b1a3e" },
    cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"]
  },
  "blue-felt": {
    name: "Blue Felt",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "felt",
    colors: { fg: "#9794ff", bg: "#0b1a3e" },
    cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"]
  },
  "red-felt": {
    name: "Red Felt",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "felt",
    colors: { fg: "#ff9494", bg: "#4d1e1e" },
    cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"]
  },
  "green-felt": {
    name: "Green Felt",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "felt",
    colors: { fg: "#97ff94", bg: "#244d1e" },
    cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"]
  },
  taverntable: {
    name: "Old Tavern Table",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "wood_table",
    colors: { fg: "#9794ff", bg: "#0b1a3e" },
    cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]
  },
  mahogany: {
    name: "(Mah-Hog-Any)",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "wood_table",
    colors: { fg: "#9794ff", bg: "#0b1a3e" },
    cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]
  },
  stainless: {
    name: "Stainless Steel",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "metal",
    colors: { fg: "#9794ff", bg: "#0b1a3e" },
    cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]
  },
  cyberpunk: {
    name: "Neo-New-Future-City",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "metal",
    colors: { fg: "#3494A6", bg: "#440B28" },
    cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]
  },
  cagetown: {
    name: "Cage Town",
    author: "MajorVictory",
    showColorPicker: !0,
    surface: "wood_table",
    colors: { fg: "#D7A866", bg: "#282811" },
    cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"]
  }
}, Ep = (h) => {
  let e;
  return function() {
    let t = this, n = arguments;
    e && window.cancelAnimationFrame(e), e = window.requestAnimationFrame(function() {
      h.apply(t, n);
    });
  };
}, Tp = {
  assetPath: "./",
  framerate: 1 / 60,
  sounds: !1,
  volume: 100,
  color_spotlight: 15720405,
  shadows: !0,
  theme_surface: "green-felt",
  sound_dieMaterial: "plastic",
  theme_customColorset: null,
  theme_colorset: "white",
  theme_texture: "",
  theme_material: "glass",
  gravity_multiplier: 400,
  light_intensity: 0.7,
  baseScale: 100,
  strength: 1,
  iterationLimit: 1e3,
  onRollComplete: () => {
  },
  onRerollComplete: () => {
  },
  onAddDiceComplete: () => {
  },
  onRemoveDiceComplete: () => {
  }
};
class Cp {
  constructor(e, t = {}) {
    this.initialized = !1, this.container = document.querySelector(e), this.dimensions = new Ce(this.container.clientWidth, this.container.clientHeight), this.adaptive_timestep = !1, this.last_time = 0, this.running = !1, this.rolling = !1, this.threadid, this.display = {
      currentWidth: null,
      currentHeight: null,
      containerWidth: null,
      containerHeight: null,
      aspect: null,
      scale: null
    }, this.cameraHeight = {
      max: null,
      close: null,
      medium: null,
      far: null
    }, this.scene = new Nu(), this.world = new dp(), this.dice_body_material = new Sn(), this.sounds_table = {}, this.sounds_dice = [], this.lastSoundType = "", this.lastSoundStep = 0, this.lastSound = 0, this.iteration, this.renderer, this.barrier, this.camera, this.light, this.light_amb, this.desk, this.box_body = {}, this.bodies = [], this.meshes = [], this.diceList = [], this.notationVectors = null, this.dieIndex = 0, this.soundDelay = 10, this.animstate = "", this.selector = {
      animate: !0,
      rotate: !0,
      intersected: null,
      dice: []
    }, Object.assign(this, Tp, t), this.DiceColors = new Mp({ assetPath: this.assetPath }), this.DiceFactory = new Hi({
      baseScale: this.baseScale
    }), this.DiceFactory.setBumpMapping(!0), this.surface = Sp[this.theme_surface].surface;
  }
  enableShadows() {
    this.shadows = !0, this.renderer && (this.renderer.shadowMap.enabled = this.shadows), this.light && (this.light.castShadow = this.shadows), this.desk && (this.desk.receiveShadow = this.shadows);
  }
  disableShadows() {
    this.shadows = !1, this.renderer && (this.renderer.shadowMap.enabled = this.shadows), this.light && (this.light.castShadow = this.shadows), this.desk && (this.desk.receiveShadow = this.shadows);
  }
  async initialize() {
    this.renderer = new xo({ antialias: !0, alpha: !0 }), this.container.appendChild(this.renderer.domElement), this.renderer.shadowMap.enabled = this.shadows, this.renderer.shadowMap.type = 2, this.renderer.setClearColor(0, 0), this.setDimensions(this.dimensions), this.world.gravity.set(0, 0, -9.8 * this.gravity_multiplier), this.world.broadphase = new wo(), this.world.solver.iterations = 14, this.world.allowSleep = !0, this.makeWorldBox(), this.resizeWorld(), await this.loadTheme({
      colorset: this.theme_colorset,
      texture: this.theme_texture,
      material: this.theme_material
    }).catch((e) => {
      throw new Error("Unable to load theme");
    }), this.sounds && await this.loadSounds().catch((e) => {
      throw new Error("Unable to load sounds");
    }), this.initialized = !0, this.renderer.render(this.scene, this.camera);
  }
  makeWorldBox() {
    Object.keys(this.box_body).length && (this.world.removeBody(this.box_body.desk), this.world.removeBody(this.box_body.topWall), this.world.removeBody(this.box_body.bottomWall), this.world.removeBody(this.box_body.leftWall), this.world.removeBody(this.box_body.rightWall));
    const e = new Sn(), t = new Sn();
    this.world.addContactMaterial(new Mn(e, this.dice_body_material, { mass: 0, friction: 0.6, restitution: 0.5 })), this.world.addContactMaterial(new Mn(t, this.dice_body_material, { mass: 0, friction: 0.6, restitution: 1 })), this.world.addContactMaterial(new Mn(this.dice_body_material, this.dice_body_material, { mass: 0, friction: 0.6, restitution: 0.5 })), this.box_body.desk = new ie({ allowSleep: !1, mass: 0, shape: new si(), material: e }), this.world.addBody(this.box_body.desk), this.box_body.topWall = new ie({ allowSleep: !1, mass: 0, shape: new si(), material: t }), this.box_body.topWall.quaternion.setFromAxisAngle(new b(1, 0, 0), Math.PI / 2), this.box_body.topWall.position.set(0, this.display.containerHeight * 0.93, 0), this.world.addBody(this.box_body.topWall), this.box_body.bottomWall = new ie({ allowSleep: !1, mass: 0, shape: new si(), material: t }), this.box_body.bottomWall.quaternion.setFromAxisAngle(new b(1, 0, 0), -Math.PI / 2), this.box_body.bottomWall.position.set(0, -this.display.containerHeight * 0.93, 0), this.world.addBody(this.box_body.bottomWall), this.box_body.leftWall = new ie({ allowSleep: !1, mass: 0, shape: new si(), material: t }), this.box_body.leftWall.quaternion.setFromAxisAngle(new b(0, 1, 0), -Math.PI / 2), this.box_body.leftWall.position.set(this.display.containerWidth * 0.93, 0, 0), this.world.addBody(this.box_body.leftWall), this.box_body.rightWall = new ie({ allowSleep: !1, mass: 0, shape: new si(), material: t }), this.box_body.rightWall.quaternion.setFromAxisAngle(new b(0, 1, 0), Math.PI / 2), this.box_body.rightWall.position.set(-this.display.containerWidth * 0.93, 0, 0), this.world.addBody(this.box_body.rightWall);
  }
  async loadTheme(e) {
    let t;
    this.theme_customColorset ? t = await this.DiceColors.makeColorSet(this.theme_customColorset) : t = await this.DiceColors.getColorSet(e), this.DiceFactory.applyColorSet(t), this.colorData = t;
  }
  async loadSounds() {
    let e = {
      felt: 7,
      wood_table: 7,
      wood_tray: 7,
      metal: 9
    }, t = {
      coin: 6,
      metal: 12,
      plastic: 15,
      wood: 12
    };
    const n = this.colorData.texture.material.match(/wood|metal/g);
    if (this.sound_dieMaterial = n ? this.colorData.texture.material : "plastic", !this.sounds_table.hasOwnProperty(this.surface)) {
      this.sounds_table[this.surface] = [];
      let i = e[this.surface];
      for (let s = 1; s <= i; ++s) {
        const o = await this.loadAudio(this.assetPath + "sounds/surfaces/surface_" + this.surface + s + ".mp3");
        this.sounds_table[this.surface].push(o);
      }
    }
    if (!this.sounds_dice.hasOwnProperty("coin")) {
      this.sounds_dice.coin = [];
      let i = t.coin;
      for (let s = 1; s <= i; ++s) {
        const o = await this.loadAudio(this.assetPath + "sounds/dicehit/dicehit_coin" + s + ".mp3");
        this.sounds_dice.coin.push(o);
      }
    }
    if (!this.sounds_dice.hasOwnProperty(this.sound_dieMaterial)) {
      this.sounds_dice[this.sound_dieMaterial] = [];
      let i = t[this.sound_dieMaterial];
      for (let s = 1; s <= i; ++s) {
        const o = await this.loadAudio(this.assetPath + "sounds/dicehit/dicehit_" + this.sound_dieMaterial + s + ".mp3");
        this.sounds_dice[this.sound_dieMaterial].push(o);
      }
    }
  }
  loadAudio(e) {
    return new Promise((t, n) => {
      let i = new Audio();
      i.oncanplaythrough = () => t(i), i.crossOrigin = "anonymous", i.src = e, i.onerror = (s) => n(s);
    }).catch((t) => {
      console.error("Unable to load audio");
    });
  }
  async updateConfig(e = {}) {
    Object.apply(this, e), this.theme_customColorset = e.theme_customColorset ? e.theme_customColorset : null, e.theme_colorset && (this.theme_colorset = e.theme_colorset), e.theme_texture && (this.theme_texture = e.theme_texture), e.theme_material && (this.theme_material = e.theme_material), (e.theme_colorset || e.theme_texture || e.theme_material || e.theme_customColorset) && await this.loadTheme({
      colorset: this.theme_colorset,
      texture: this.theme_texture,
      material: this.theme_material
    });
  }
  setDimensions(e) {
    switch (this.display.currentWidth = this.container.clientWidth / 2, this.display.currentHeight = this.container.clientHeight / 2, e ? (this.display.containerWidth = e.x, this.display.containerHeight = e.y) : (this.display.containerWidth = this.display.currentWidth, this.display.containerHeight = this.display.currentHeight), this.display.aspect = Math.min(this.display.currentWidth / this.display.containerWidth, this.display.currentHeight / this.display.containerHeight), this.display.scale = Math.sqrt(this.display.containerWidth * this.display.containerWidth + this.display.containerHeight * this.display.containerHeight) / 13, this.makeWorldBox(), this.renderer.setSize(this.display.currentWidth * 2, this.display.currentHeight * 2), this.cameraHeight.max = this.display.currentHeight / this.display.aspect / Math.tan(10 * Math.PI / 180), this.cameraHeight.medium = this.cameraHeight.max / 1.5, this.cameraHeight.far = this.cameraHeight.max, this.cameraHeight.close = this.cameraHeight.max / 2, this.camera && this.scene.remove(this.camera), this.camera = new gt(20, this.display.currentWidth / this.display.currentHeight, 1, this.cameraHeight.max * 1.3), this.animstate) {
      case "selector":
        this.camera.position.z = this.selector.dice.length > 9 ? this.cameraHeight.far : this.selector.dice.length < 6 ? this.cameraHeight.close : this.cameraHeight.medium;
        break;
      case "throw":
      case "afterthrow":
      default:
        this.camera.position.z = this.cameraHeight.far;
    }
    this.camera.lookAt(new O(0, 0, 0));
    const t = Math.max(this.display.containerWidth, this.display.containerHeight);
    this.light && this.scene.remove(this.light), this.light_amb && this.scene.remove(this.light_amb), this.light = new Hu(this.color_spotlight, this.light_intensity), this.light.position.set(-t / 2, t / 2, t * 3), this.light.target.position.set(0, 0, 0), this.light.distance = t * 5, this.light.angle = Math.PI / 4, this.light.castShadow = this.shadows, this.light.shadow.camera.near = t / 10, this.light.shadow.camera.far = t * 5, this.light.shadow.camera.fov = 50, this.light.shadow.bias = 1e-3, this.light.shadow.mapSize.width = 1024, this.light.shadow.mapSize.height = 1024, this.scene.add(this.light), this.light_amb = new ku(16777147, 6776689, this.light_intensity), this.scene.add(this.light_amb), this.desk && this.scene.remove(this.desk);
    let n = new Ou();
    n.opacity = 0.5, this.desk = new Nt(new ji(this.display.containerWidth * 6, this.display.containerHeight * 6, 1, 1), n), this.desk.receiveShadow = this.shadows, this.scene.add(this.desk), this.renderer.render(this.scene, this.camera);
  }
  resizeWorld() {
    const t = Ep(() => {
      const n = this.renderer.domElement, i = this.container.clientWidth, s = this.container.clientHeight, o = n.width !== i || n.height !== s;
      return o && this.setDimensions(new Ce(this.container.clientWidth, this.container.clientHeight)), o;
    });
    window.addEventListener("resize", t);
  }
  vectorRand({ x: e, y: t }) {
    let n = Math.random() * Math.PI / 5 - Math.PI / 5 / 2, i = {
      x: e * Math.cos(n) - t * Math.sin(n),
      y: e * Math.sin(n) + t * Math.cos(n)
    };
    return i.x == 0 && (i.x = 0.01), i.y == 0 && (i.y = 0.01), i;
  }
  getNotationVectors(e, t, n, i) {
    let s = new Qr(e);
    for (let o in s.set) {
      const r = this.DiceFactory.get(s.set[o].type);
      let l = s.set[o].num, a = s.set[o].op, c = s.set[o].sid, d = s.set[o].gid, u = s.set[o].glvl, m = s.set[o].func, g = s.set[o].args;
      for (let p = 0; p < l; p++) {
        let f = this.vectorRand(t);
        f.x /= i, f.y /= i;
        let v = {
          x: this.display.containerWidth * (f.x > 0 ? -1 : 1) * 0.9,
          y: this.display.containerHeight * (f.y > 0 ? -1 : 1) * 0.9,
          z: Math.random() * 200 + 200
        }, _ = Math.abs(f.x / f.y);
        _ > 1 ? v.y /= _ : v.x *= _;
        let w = this.vectorRand(t);
        w.x /= i, w.y /= i;
        let x, M, E;
        r.shape != "d2" ? (x = {
          x: w.x * n,
          y: w.y * n,
          z: -10
        }, M = {
          x: -(Math.random() * f.y * 5 + r.inertia * f.y),
          y: Math.random() * f.x * 5 + r.inertia * f.x,
          z: 0
        }, E = {
          x: Math.random(),
          y: Math.random(),
          z: Math.random(),
          a: Math.random()
        }) : (x = {
          x: w.x * n / 10,
          y: w.y * n / 10,
          z: 3e3
        }, M = {
          x: 12 * r.inertia,
          y: 1 * r.inertia,
          z: 0
        }, E = {
          x: 1,
          y: 1,
          z: Math.random(),
          a: Math.random()
        }), s.vectors.push({
          index: this.dieIndex++,
          type: r.type,
          op: a,
          sid: c,
          gid: d,
          glvl: u,
          func: m,
          args: g,
          pos: v,
          velocity: x,
          angle: M,
          axis: E
        });
      }
    }
    return s;
  }
  swapDiceFace(e, t) {
    const n = this.DiceFactory.get(e.notation.type);
    if (e.resultReason = "forced", n.shape == "d4") {
      this.swapDiceFace_D4(e, t);
      return;
    }
    n.values;
    let i = parseInt(e.getLastValue().value);
    t = parseInt(t), e.notation.type == "d10" && i == 0 && (i = 10), e.notation.type == "d100" && i == 0 && (i = 100), e.notation.type == "d100" && i > 0 && i < 10 && (i *= 10), e.notation.type == "d10" && t == 0 && (t = 10), e.notation.type == "d100" && t == 0 && (t = 100), e.notation.type == "d100" && t > 0 && t < 10 && (t *= 10);
    let s = n.values.indexOf(i), o = n.values.indexOf(t);
    if (s < 0 || o < 0 || s == o)
      return;
    let r = e.geometry.clone(), l = [], a = [], c = 2;
    n.shape == "d10" && (c = 1);
    let d, u = o + c;
    n.shape != "d2" ? (d = s + c, u = o + c) : (d = s + 1, u = o + 1);
    for (var m = 0, g = r.groups.length; m < g; ++m) {
      const f = r.groups[m].materialIndex;
      if (f == d) {
        l.push(m);
        continue;
      }
      if (f == u) {
        a.push(m);
        continue;
      }
    }
    if (!(l.length <= 0 || a.length <= 0)) {
      for (let p = 0, f = a.length; p < f; p++)
        r.groups[a[p]].materialIndex = d;
      for (let p = 0, f = l.length; p < f; p++)
        r.groups[l[p]].materialIndex = u;
      e.geometry = r, e.result = [];
    }
  }
  swapDiceFace_D4(e, t) {
    const n = this.DiceFactory.get(e.notation.type);
    let i = parseInt(e.getLastValue().value);
    if (t = parseInt(t), !(i >= 1 && i <= 4))
      return;
    let s = t - i, o = e.geometry.clone();
    for (let r = 0, l = o.groups.length; r < l; ++r) {
      const a = o.groups[r];
      let c = a.materialIndex;
      if (c != 0) {
        for (c += s - 1; c > 4; )
          c -= 4;
        for (; c < 1; )
          c += 4;
        a.materialIndex = c + 1;
      }
    }
    s != 0 && (s < 0 && (s += 4), e.material = this.DiceFactory.createMaterials(n, 0, 0, !1, s)), e.geometry = o;
  }
  spawnDice(e, t = !1) {
    const { pos: n, axis: i, angle: s, velocity: o } = e;
    let r;
    if (t)
      r = t, r.stopped = 0, this.world.removeBody(r.body);
    else {
      if (r = this.DiceFactory.create(e.type, this.colorData), !r)
        return;
      r.notation = e, r.result = [], r.stopped = 0, r.castShadow = this.shadows, this.scene.add(r), this.diceList.push(r);
    }
    r.body = new ie({ allowSleep: !0, sleepSpeedLimit: 75, sleepTimeLimit: 0.9, mass: r.mass, shape: r.geometry.cannon_shape, material: this.dice_body_material }), r.body.type = ie.DYNAMIC, r.body.position.set(n.x, n.y, n.z), r.body.quaternion.setFromAxisAngle(new b(i.x, i.y, i.z), i.a * Math.PI * 2), r.body.angularVelocity.set(s.x, s.y, s.z), r.body.velocity.set(o.x, o.y, o.z), r.body.linearDamping = 0.1, r.body.angularDamping = 0.1, r.body.diceShape = r.shape, r.body.sleepState = 0, r.body.addEventListener("collide", this.eventCollide.bind(this)), this.world.addBody(r.body);
  }
  eventCollide({ body: e, target: t }) {
    if (this.animstate == "simulate" || !this.sounds || !e || this.volume <= 0)
      return;
    let n = Date.now(), i = e.mass > 0 ? "dice" : "table";
    if (!((this.lastSoundStep == e.world.stepnumber || this.lastSound > n) && i != "dice") && !((this.lastSoundStep == e.world.stepnumber || this.lastSound > n) && i == "dice" && this.lastSoundType == "dice")) {
      if (e.mass > 0) {
        let s = e.velocity.length();
        if (s < 250)
          return;
        let o;
        e.diceShape === "d2" ? o = this.sounds_dice.coin[Math.floor(Math.random() * this.sounds_dice.coin.length)] : o = this.sounds_dice[this.sound_dieMaterial][Math.floor(Math.random() * this.sounds_dice[this.sound_dieMaterial].length)], o && (o.volume = Math.min(s / 8e3, this.volume / 100), o.play().catch((r) => {
        })), this.lastSoundType = "dice";
      } else {
        let s = t.velocity.length();
        if (s < 250)
          return;
        let o = this.surface, r = this.sounds_table[o], l = r[Math.floor(Math.random() * r.length)];
        l && (l.volume = Math.min(s / 8e3, this.volume / 100), l.play().catch((a) => {
        })), this.lastSoundType = "table";
      }
      this.lastSoundStep = e.world.stepnumber, this.lastSound = n + this.soundDelay;
    }
  }
  checkForRethrow(e) {
    let t = e.notation.func ? e.notation.func.toLowerCase() : "", n, i = !1;
    if (t != "" && n && n.method) {
      t = e.notation.func.toLowerCase();
      let s = e.notation.args || "";
      i = n.method(e, s);
    }
    return i;
  }
  throwFinished() {
    const e = this.iteration > this.iterationLimit;
    for (let t = 0, n = this.diceList.length; t < n; ++t) {
      const i = this.diceList[t], s = ie.SLEEPING;
      if (i.body.sleepState < s && !e)
        return !1;
      if (i.body.sleepState == s || e) {
        if (i.body.type === ie.KINEMATIC)
          continue;
        let o = !1;
        if (i.result.length == 0 ? (i.storeRolledValue(i.resultReason), o = this.checkForRethrow(i)) : i.result.length > 0 && i.rerolling && (i.rerolling = !1, i.storeRolledValue("reroll"), o = this.checkForRethrow(i)), o)
          return i.rerolls += 1, i.rerolling = !0, i.body.wakeUp(), i.body.type = ie.DYNAMIC, i.body.angularVelocity = new b(25, 25, 25), i.body.velocity = new b(0, 0, 3e3), !1;
        i.rerolling = !1, i.body.type = ie.KINEMATIC;
      }
    }
    return !0;
  }
  simulateThrow() {
    for (this.animstate = "simulate", this.iteration = 0, this.rolling = !0; !this.throwFinished(!0); )
      ++this.iteration, this.world.step(this.framerate);
  }
  animateThrow(e, t) {
    this.animstate = "throw";
    let n = Date.now();
    this.last_time = this.last_time || n - this.framerate * 1e3;
    let i = (n - this.last_time) / 1e3;
    ++this.iteration;
    let s = Math.floor(i / this.framerate);
    for (let o = 0; o < s; o++)
      this.world.step(this.framerate), ++this.steps;
    for (let o in this.scene.children) {
      let r = this.scene.children[o];
      r.body != null && (r.position.copy(r.body.position), r.quaternion.copy(r.body.quaternion));
    }
    if (this.renderer.render(this.scene, this.camera), this.last_time = this.last_time + s * this.framerate * 1e3, this.running == e && this.throwFinished()) {
      this.running = !1, this.rolling = !1, t && t.call(this, this.notationVectors), this.running = Date.now(), this.animateAfterThrow(this.running);
      return;
    }
    this.running == e && ((o, r, l, a, c) => {
      !l && i < this.framerate ? setTimeout(() => {
        requestAnimationFrame(() => {
          o.call(this, r, a, c);
        });
      }, (this.framerate - i) * 1e3) : requestAnimationFrame(() => {
        o.call(this, r, a, c);
      });
    }).bind(this)(this.animateThrow, e, this.adaptive_timestep, t);
  }
  animateAfterThrow(e) {
    this.animstate = "afterthrow";
    let t = Date.now(), n = (t - this.last_time) / 1e3;
    n > 3 && (n = this.framerate), this.running = !1, this.last_time = t, this.renderer.render(this.scene, this.camera), this.running == e && ((i, s, o) => {
      !o && n < this.framerate ? setTimeout(() => {
        requestAnimationFrame(() => {
          i.call(this, s);
        });
      }, (this.framerate - n) * 1e3) : requestAnimationFrame(() => {
        i.call(this, s);
      });
    }).bind(this)(this.animateAfterThrow, e, this.adaptive_timestep);
  }
  startClickThrow(e) {
    this.rolling && (this.clearDice(), this.rolling = !1);
    let t = { x: (Math.random() * 2 - 0.5) * this.display.currentWidth, y: -(Math.random() * 2 - 0.5) * this.display.currentHeight }, n = Math.sqrt(t.x * t.x + t.y * t.y) + 100, i = (Math.random() + 3) * n * this.strength;
    return this.getNotationVectors(e, t, i, n);
  }
  clearDice() {
    this.running = !1;
    let e;
    for (; e = this.diceList.pop(); )
      this.scene.remove(e), e.body && this.world.removeBody(e.body);
    this.renderer.render(this.scene, this.camera), setTimeout(() => {
      this.renderer.render(this.scene, this.camera);
    }, 100);
  }
  getDiceResults(e) {
    if (e !== void 0)
      return {
        type: this.diceList[e].shape,
        sides: parseInt(this.diceList[e].shape.substring(1)),
        id: e,
        ...this.diceList[e].result.at(-1)
      };
    let t = 0;
    const n = this.notationVectors.constant ? parseInt(`${this.notationVectors.op}${this.notationVectors.constant}`) : 0;
    let i = n;
    return {
      notation: this.notationVectors.notation,
      sets: this.notationVectors.set.map((o) => {
        const r = t + o.num - 1;
        let l = 0;
        const a = [];
        for (let d = t; d <= r; d++) {
          if (this.diceList[t].result.at(-1).reason === "remove") {
            t++;
            continue;
          }
          a.push({
            type: o.type,
            sides: parseInt(o.type.substring(1)),
            id: t,
            ...this.diceList[t].result.at(-1)
          }), l += this.diceList[t].result.at(-1).value, t++;
        }
        const c = {
          num: o.num,
          type: o.type,
          sides: parseInt(o.type.substring(1)),
          rolls: a,
          total: l
        };
        return i += l, c;
      }),
      modifier: n,
      total: i
    };
  }
  async roll(e) {
    if (this.notationVectors = this.startClickThrow(e), this.notationVectors)
      return new Promise((t, n) => {
        this.rollDice(() => {
          const i = this.getDiceResults();
          this.onRollComplete(i);
          const s = new CustomEvent("rollComplete", { detail: i });
          document.dispatchEvent(s), t(i);
        });
      });
  }
  async reroll(e) {
    return this.rolling = !0, this.running = Date.now(), this.iteration = 0, new Promise((t, n) => {
      e.forEach((i) => {
        const s = this.diceList[i];
        s.rerolls += 1, s.rerolling = !0, s.body.wakeUp(), s.body.type = ie.DYNAMIC, s.body.angularVelocity = new b(25, 25, 25), s.body.velocity = new b(0, 0, 3e3);
      }), this.animateThrow(this.running, () => {
        const i = e.map((o) => this.getDiceResults(o));
        this.onRerollComplete(i);
        const s = new CustomEvent("rerollComplete", { detail: i });
        document.dispatchEvent(s), t(i);
      });
    });
  }
  async add(e) {
    let t = this.diceList.length;
    if (!t)
      return this.roll(e);
    let n = this.startClickThrow(e), i = [];
    for (let s = 0, o = n.vectors.length; s < o; ++s)
      this.spawnDice(n.vectors[s]);
    this.simulateThrow(), this.steps = 0, this.iteration = 0;
    for (let s = 0, o = n.vectors.length; s < o; ++s) {
      const r = t + s;
      !this.diceList[r] || (this.spawnDice(n.vectors[s], this.diceList[r]), i.push(r));
    }
    if (n.result && n.result.length > 0)
      for (let s = 0; s < n.result.length; s++) {
        const o = t + s;
        let r = this.diceList[o];
        !r || r.getLastValue().value != n.result[s] && this.swapDiceFace(r, n.result[s]);
      }
    return this.notationVectors = Qr.mergeNotation(this.notationVectors, n), new Promise((s, o) => {
      const r = () => {
        const l = i.map((c) => this.getDiceResults(c));
        this.onAddDiceComplete(l);
        const a = new CustomEvent("addDiceComplete", { detail: l });
        document.dispatchEvent(a), s(l);
      };
      this.rolling = !0, this.running = Date.now(), this.last_time = 0, this.animateThrow(this.running, r);
    });
  }
  async remove(e) {
    return new Promise((t, n) => {
      const i = [];
      e.forEach((o) => {
        const r = this.diceList[o];
        r.body && this.world.removeBody(r.body), this.scene.remove(r), r.storeRolledValue("remove"), i.push(this.getDiceResults(o));
      }), this.renderer.render(this.scene, this.camera), this.onRemoveDiceComplete(i);
      const s = new CustomEvent("removeDiceComplete", { detail: i });
      document.dispatchEvent(s), t(i);
    });
  }
  rollDice(e) {
    if (this.notationVectors.error) {
      e.call(this);
      return;
    }
    this.clearDice();
    for (let t = 0, n = this.notationVectors.vectors.length; t < n; ++t)
      this.spawnDice(this.notationVectors.vectors[t]);
    this.simulateThrow(), this.steps = 0, this.iteration = 0;
    for (let t = 0, n = this.diceList.length; t < n; ++t)
      !this.diceList[t] || this.spawnDice(this.notationVectors.vectors[t], this.diceList[t]);
    if (this.notationVectors.result && this.notationVectors.result.length > 0)
      for (let t = 0; t < this.notationVectors.result.length; t++) {
        let n = this.diceList[t];
        !n || n.getLastValue().value != this.notationVectors.result[t] && this.swapDiceFace(n, this.notationVectors.result[t]);
      }
    this.rolling = !0, this.running = Date.now(), this.last_time = 0, this.animateThrow(this.running, e);
  }
}



/***/ }),

/***/ "./src/classes/InitiativeCreature.ts":
/*!*******************************************!*\
  !*** ./src/classes/InitiativeCreature.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attitude: () => (/* binding */ Attitude),
/* harmony export */   "default": () => (/* binding */ InitiativeCreature)
/* harmony export */ });
/* harmony import */ var _dicebox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dicebox */ "./src/dicebox.ts");

var Attitude;
(function (Attitude) {
    Attitude[Attitude["Hostile"] = -1] = "Hostile";
    Attitude[Attitude["Neutral"] = 0] = "Neutral";
    Attitude[Attitude["Friendly"] = 1] = "Friendly";
})(Attitude || (Attitude = {}));
class InitiativeCreature {
    async rollInitiative() {
        // We use deterministic dice rolling to guarantee a result even if interrupted
        let roll = Math.floor(Math.random() * 20) + 1;
        await (0,_dicebox__WEBPACK_IMPORTED_MODULE_0__.rollDice)("1d20@" + roll);
        this.initiative = roll;
        return;
    }
    constructor(attitude = Attitude.Neutral) {
        this.id = 0;
        this.attitude = Attitude.Neutral;
        this.initiative = Number.MIN_SAFE_INTEGER;
        this.initBonus = 0;
        this.name = "";
        this.hit_points = NaN;
        this.armor_class = NaN;
        this.dmgTypeMod = [];
        this.rowElem = null;
        this.isTurn = false;
        this.notes = "";
        this.statBlockUrl = "";
        this.attitude = attitude;
    }
}


/***/ }),

/***/ "./src/classes/InitiativeOrder.ts":
/*!****************************************!*\
  !*** ./src/classes/InitiativeOrder.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dicebox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dicebox */ "./src/dicebox.ts");
/* harmony import */ var _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InitiativeTableHandler */ "./src/classes/InitiativeTableHandler.ts");


class InitiativeOrder {
    static addCreature(creature) {
        this.runningId++;
        creature.id = this.runningId;
        InitiativeOrder.initiativeCreatures.push(creature);
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
        return creature.id;
    }
    static getCreature(id) {
        return InitiativeOrder.initiativeCreatures.find(x => x.id === id);
    }
    static updateCreature(id, data) {
        console.log(InitiativeOrder.initiativeCreatures);
        let index = InitiativeOrder.initiativeCreatures.findIndex(x => x.id === id);
        data.id = InitiativeOrder.initiativeCreatures[index].id;
        InitiativeOrder.initiativeCreatures[index] = data;
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
    }
    static removeCreature(id) {
        InitiativeOrder.initiativeCreatures.filter(x => x.id !== id);
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
        return InitiativeOrder.initiativeCreatures.length;
    }
    static getAllCreatures() {
        return InitiativeOrder.initiativeCreatures;
    }
    static sortCreatures() {
        InitiativeOrder.initiativeCreatures = InitiativeOrder.initiativeCreatures.sort((a, b) => {
            // Preference for higher total initiative
            let sort = (b.initiative + b.initBonus) - (a.initiative + a.initBonus);
            // Secondary preference for friendly creatures
            if (sort == 0) {
                sort == b.attitude - a.attitude;
            }
            return sort;
        });
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
    }
    static async rollInitiative(creatureId) {
        const creature = this.getCreature(creatureId);
        if (!creature)
            return;
        await creature.rollInitiative();
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
    }
    static async rollInitiativeForAll() {
        let rolls = [];
        for (let creature of InitiativeOrder.initiativeCreatures) {
            // We use deterministic dice rolling to guarantee a result even if interrupted
            rolls.push(Math.floor(Math.random() * 20) + 1);
            creature.initiative = rolls[rolls.length - 1];
        }
        await (0,_dicebox__WEBPACK_IMPORTED_MODULE_0__.rollDice)(rolls.length + "d20@" + rolls.join());
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
    }
    static async rollInitiativeForAttitude(attitudes) {
        let rolls = [];
        for (let creature of InitiativeOrder.initiativeCreatures) {
            if (attitudes.includes(creature.attitude)) {
                // We use deterministic dice rolling to guarantee a result even if interrupted
                rolls.push(Math.floor(Math.random() * 20) + 1);
                creature.initiative = rolls[rolls.length - 1];
            }
        }
        await (0,_dicebox__WEBPACK_IMPORTED_MODULE_0__.rollDice)(rolls.length + "d20@" + rolls.join());
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
    }
    static clear() {
        InitiativeOrder.initiativeCreatures = [];
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
    }
    static updateCurrentTurn() {
        var _a, _b, _c, _d;
        if (InitiativeOrder.initiativeCreatures.length <= 1)
            return;
        let giveTurn = false;
        for (let creature of InitiativeOrder.initiativeCreatures) {
            if (giveTurn) {
                (_a = creature.rowElem) === null || _a === void 0 ? void 0 : _a.classList.add("current-turn");
                creature.isTurn = true;
                break;
            }
            else if (creature.isTurn) {
                giveTurn = true;
                (_b = creature.rowElem) === null || _b === void 0 ? void 0 : _b.classList.remove("current-turn");
                creature.isTurn = false;
            }
            else {
                (_c = creature.rowElem) === null || _c === void 0 ? void 0 : _c.classList.remove("current-turn");
                creature.isTurn = false;
            }
        }
        if (!giveTurn) {
            (_d = InitiativeOrder.initiativeCreatures[0].rowElem) === null || _d === void 0 ? void 0 : _d.classList.add("current-turn");
            InitiativeOrder.initiativeCreatures[0].isTurn = true;
        }
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].updateTable();
    }
}
InitiativeOrder.initiativeCreatures = [];
InitiativeOrder.runningId = 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InitiativeOrder);


/***/ }),

/***/ "./src/classes/InitiativeTableHandler.ts":
/*!***********************************************!*\
  !*** ./src/classes/InitiativeTableHandler.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _InitiativeCreature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InitiativeCreature */ "./src/classes/InitiativeCreature.ts");
/* harmony import */ var _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InitiativeOrder */ "./src/classes/InitiativeOrder.ts");
/* harmony import */ var _MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MonsterDropdown */ "./src/classes/MonsterDropdown.ts");



class InitiativeTableHandler {
    static createTable() {
        // Try to find a table with the correct ID
        InitiativeTableHandler.table = document.querySelector("table#initiative-table");
        if (InitiativeTableHandler.table === null)
            throw "Unable to find initiative table!";
        // Create the necessary child elements for it
        InitiativeTableHandler.caption = document.createElement("caption");
        InitiativeTableHandler.caption.textContent = "Initiative Order";
        InitiativeTableHandler.thead = document.createElement("thead");
        InitiativeTableHandler.tbody = document.createElement("tbody");
        InitiativeTableHandler.headRow = document.createElement("tr");
        // Initialize the table head with all the headers
        for (const column of InitiativeTableHandler.columns) {
            let th = document.createElement("th");
            th.classList.add(column.id + "-head");
            th.scope = "col";
            th.textContent = column.header;
            InitiativeTableHandler.headRow.appendChild(th);
        }
        InitiativeTableHandler.thead.appendChild(InitiativeTableHandler.headRow);
        // Append the caption, head, and body to the table
        InitiativeTableHandler.table.append(InitiativeTableHandler.caption, InitiativeTableHandler.thead, InitiativeTableHandler.tbody);
        _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].addCreature(new _InitiativeCreature__WEBPACK_IMPORTED_MODULE_0__["default"]());
        InitiativeTableHandler.updateTable();
    }
    static updateTable() {
        if (!InitiativeTableHandler.tbody)
            return;
        // Clear the table
        InitiativeTableHandler.tbody.innerHTML = "";
        // For each creature
        for (const creature of _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].getAllCreatures() || []) {
            // Create a new row in the tbody
            const row = InitiativeTableHandler.tbody.insertRow();
            // Add creature id to the row for easier access
            row.dataset.creatureId = creature.id.toString();
            // Add a class for styling based on the attitude
            if (creature.attitude == _InitiativeCreature__WEBPACK_IMPORTED_MODULE_0__.Attitude.Friendly)
                row.classList.add("attitude-friendly");
            if (creature.attitude == _InitiativeCreature__WEBPACK_IMPORTED_MODULE_0__.Attitude.Neutral)
                row.classList.add("attitude-neutral");
            if (creature.attitude == _InitiativeCreature__WEBPACK_IMPORTED_MODULE_0__.Attitude.Hostile)
                row.classList.add("attitude-hostile");
            // Add a class for the one with the current turn if it is their turn
            row.classList.toggle("current-turn", creature.isTurn);
            // Populate it with cells for each column
            for (const column of InitiativeTableHandler.columns) {
                const cell = column.create(creature);
                cell.classList.add(column.id + "-cell");
                row.appendChild(cell);
            }
        }
    }
    static createAndAppendInput(cell) {
        // We use a contenteditable div since it is much easier to style
        let input = document.createElement("div");
        input.contentEditable = "true";
        input.classList.add("editable");
        cell.append(input);
        // Add a listener to focus the input when clicking within the cell
        cell.addEventListener("click", () => {
            input.focus();
        });
        return input;
    }
    static createInitiativeCell(creature) {
        // Create the cell
        let cell = document.createElement("td");
        // Create a button for rolling initiative and append it to the cell
        let btn = document.createElement("button");
        btn.classList.add("creature-init-btn");
        btn.title = "Roll Initiative";
        btn.addEventListener("click", () => _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].rollInitiative(creature.id));
        // Add an image to the button
        let btnImg = document.createElement("img");
        btnImg.src = "./img/d20.svg";
        btn.append(btnImg);
        cell.append(btn);
        // Create an input for editing and append it to the cell
        let input = InitiativeTableHandler.createAndAppendInput(cell);
        // Event listener to update initiative based on input value
        input.addEventListener("change", (e) => {
            if (!(e.target instanceof HTMLInputElement))
                return;
            let c = _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].getCreature(creature.id);
            if (!c)
                return;
            c.initiative = +e.target.value;
            _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].updateCreature(creature.id, c);
        });
        console.log(creature.initiative);
        // If the creature has an initiative assigned to it
        if (creature.initiative > Number.MIN_SAFE_INTEGER) {
            // Set the value to that initiative
            input.textContent = creature.initiative.toString();
        }
        // Add a string to the dataset for use in CSS, used to show the initiative bonus
        cell.dataset.initiativeBonusString = " (+" + creature.initBonus.toString() + ")";
        return cell;
    }
    static createNameCell(creature) {
        // Create the cell
        let cell = document.createElement("td");
        // Create an input for editing and append it to the cell
        let input = InitiativeTableHandler.createAndAppendInput(cell);
        // Event listener to update name based on input value
        input.addEventListener("change", (e) => {
            if (!(e.target instanceof HTMLInputElement))
                return;
            let c = _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].getCreature(creature.id);
            if (!c)
                return;
            c.name = e.target.value;
            _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].updateCreature(creature.id, c);
        });
        // Add event listeners for the input to search monsters
        input.addEventListener("input", _MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__["default"].searchDropdownEdit);
        input.addEventListener("focusout", _MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__["default"].searchDropdownRemove);
        input.addEventListener("change", _MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__["default"].searchDropdownRemove);
        input.addEventListener("keypress", (event) => {
            if (event.key == "Enter") {
                event.preventDefault();
                _MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__["default"].searchPickFirst();
            }
            _MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__["default"].searchDropdownEdit(event);
        });
        input.textContent = creature.name;
        // If there is a statblock URL, add it
        if (creature.statBlockUrl) {
            let link = document.createElement("a");
            link.href = creature.statBlockUrl;
            link.classList.add("monster-link");
            link.target = "_blank";
            cell.prepend(link);
        }
        return cell;
    }
    static createHPCell(creature) {
        // Create the cell
        let cell = document.createElement("td");
        // Create an input for editing and append it to the cell
        let input = InitiativeTableHandler.createAndAppendInput(cell);
        // Event listener to update HP based on input value
        input.addEventListener("change", (e) => {
            if (!(e.target instanceof HTMLInputElement))
                return;
            let c = _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].getCreature(creature.id);
            if (!c)
                return;
            c.hit_points = +e.target.value;
            _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].updateCreature(creature.id, c);
        });
        // If the creature has an HP assigned to it
        if (!isNaN(creature.hit_points)) {
            // Set the value to that HP
            input.textContent = creature.hit_points.toString();
        }
        return cell;
    }
    static createACCell(creature) {
        // Create the cell
        let cell = document.createElement("td");
        // Create an input for editing and append it to the cell
        let input = InitiativeTableHandler.createAndAppendInput(cell);
        // Event listener to update AC based on input value
        input.addEventListener("change", (e) => {
            if (!(e.target instanceof HTMLInputElement))
                return;
            let c = _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].getCreature(creature.id);
            if (!c)
                return;
            c.armor_class = +e.target.value;
            _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].updateCreature(creature.id, c);
        });
        // If the creature has an AC assigned to it
        if (!isNaN(creature.armor_class)) {
            // Set the value to that AC
            input.textContent = creature.armor_class.toString();
        }
        return cell;
    }
    static createNotesCell(creature) {
        // Create the cell
        let cell = document.createElement("td");
        // Create an input for editing and append it to the cell
        let input = InitiativeTableHandler.createAndAppendInput(cell);
        // Event listener to update notes based on input value
        input.addEventListener("change", (e) => {
            if (!(e.target instanceof HTMLInputElement))
                return;
            let c = _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].getCreature(creature.id);
            if (!c)
                return;
            c.notes = e.target.value;
            _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].updateCreature(creature.id, c);
        });
        input.textContent = creature.notes;
        return cell;
    }
    static createDamageTypeModifierCell(creature) {
        // Create the cell
        let cell = document.createElement("td");
        for (let mod of creature.dmgTypeMod) {
            let img = document.createElement("div");
            img.classList.add("dmgtypemod");
            img.classList.add(mod.type);
            img.classList.add(mod.magical);
            img.classList.add(mod.modifier);
            img.classList.add(mod.adamantine);
            img.classList.add(mod.silvered);
            img.title = mod.desc;
            cell.appendChild(img);
        }
        return cell;
    }
}
InitiativeTableHandler.table = null;
InitiativeTableHandler.caption = null;
InitiativeTableHandler.thead = null;
InitiativeTableHandler.tbody = null;
InitiativeTableHandler.headRow = null;
InitiativeTableHandler.columns = [
    {
        header: "Initiative", id: "initiative",
        create: InitiativeTableHandler.createInitiativeCell
    },
    {
        header: "Name", id: "name",
        create: InitiativeTableHandler.createNameCell
    },
    {
        header: "HP", id: "hit-points",
        create: InitiativeTableHandler.createHPCell
    },
    {
        header: "AC", id: "armor-class",
        create: InitiativeTableHandler.createACCell
    },
    {
        header: "Notes", id: "notes",
        create: InitiativeTableHandler.createNotesCell
    },
    {
        header: "Damage Type Modifiers", id: "damage-type-modifiers",
        create: InitiativeTableHandler.createDamageTypeModifierCell
    },
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InitiativeTableHandler);


/***/ }),

/***/ "./src/classes/MonsterDropdown.ts":
/*!****************************************!*\
  !*** ./src/classes/MonsterDropdown.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals */ "./src/globals.ts");
/* harmony import */ var _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InitiativeOrder */ "./src/classes/InitiativeOrder.ts");
/* harmony import */ var _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InitiativeTableHandler */ "./src/classes/InitiativeTableHandler.ts");
/* harmony import */ var _MonsterList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MonsterList */ "./src/classes/MonsterList.ts");




const MONSTER_DROPDOWN_ID = "monster-dropdown";
class MonsterDropdown {
    static async fetchMonsters() {
        MonsterDropdown.monsters = await _MonsterList__WEBPACK_IMPORTED_MODULE_3__["default"].fetch();
    }
    static searchPickFirst() {
        if (MonsterDropdown.dropdown && MonsterDropdown.dropdown.children[0] instanceof HTMLElement) {
            MonsterDropdown.dropdown.children[0].click();
        }
    }
    static searchDropdownEdit(event) {
        // Typescript type checking
        if (MonsterDropdown.monsters == null)
            return;
        const input = event.target;
        if (input == null || !(input instanceof HTMLElement))
            return;
        const cell = input.parentElement;
        if (cell == null)
            return;
        // Get the value of the input that is requesting the search
        let search = input.textContent || "";
        // Filter the MonsterDropdown.monsters to only the ones that contain the search
        let result = MonsterDropdown.monsters.searchMonsters(search);
        // Remove the old MonsterDropdown.dropdown
        MonsterDropdown.searchDropdownRemove();
        // Create a new MonsterDropdown.dropdown
        MonsterDropdown.dropdown = document.createElement("ul");
        MonsterDropdown.dropdown.id = MONSTER_DROPDOWN_ID;
        // Populate it with new elements
        for (let monster of result) {
            const li = document.createElement("li");
            li.textContent = monster.name;
            // Store the url in the dataset for use when we click it
            li.dataset.monsterUrl = monster.url;
            li.addEventListener("mousedown", MonsterDropdown.clickSearchItem);
            MonsterDropdown.dropdown.appendChild(li);
        }
        // Append the MonsterDropdown.dropdown to the cell the input is in for positioning
        cell.appendChild(MonsterDropdown.dropdown);
    }
    static searchDropdownRemove() {
        var _a, _b;
        if (MonsterDropdown.dropdown)
            (_a = MonsterDropdown.dropdown.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(MonsterDropdown.dropdown);
        let oldDropdown = document.getElementById(MONSTER_DROPDOWN_ID);
        if (oldDropdown)
            (_b = oldDropdown.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(oldDropdown);
    }
    static async clickSearchItem(event) {
        var _a, _b;
        // Typescript type checking
        if (event.target == null || !(event.target instanceof HTMLLIElement))
            return;
        // The current cell where this MonsterDropdown.dropdown is attached
        let cell = (_a = event.target.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        if (cell == null)
            return;
        if (!MonsterDropdown.dropdown)
            return;
        // Remove the MonsterDropdown.dropdown
        MonsterDropdown.searchDropdownRemove();
        // Fetch the full details of the monster from the API based on the URL in the dataset
        let request = await fetch(_globals__WEBPACK_IMPORTED_MODULE_0__.API_URL + event.target.dataset.monsterUrl);
        let monster = await request.json();
        // Figure out which creature to edit
        const row = cell.parentElement;
        if (!row)
            return;
        const creatureId = +((_b = row.dataset.creatureId) !== null && _b !== void 0 ? _b : NaN);
        if (isNaN(creatureId))
            return;
        // Edit the creature based on the data from the API
        let creature = _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].getCreature(creatureId);
        if (!creature)
            return;
        creature.armor_class = monster.armor_class[0].value;
        creature.initBonus = Math.floor((monster.dexterity - 10) / 2);
        creature.hit_points = monster.hit_points;
        creature.name = monster.name;
        creature.dmgTypeMod = [];
        creature.notes = monster.size + " " + monster.type + ", " + monster.alignment;
        creature.statBlockUrl = `https://www.aidedd.org/dnd/monstres.php?vo=${monster.index}`;
        let res = monster.damage_resistances.map(resistance => ({ type: "resistance", data: resistance }));
        let vul = monster.damage_vulnerabilities.map(vulnerability => ({ type: "vulnerability", data: vulnerability }));
        let imm = monster.damage_immunities.map(immunity => ({ type: "immunity", data: immunity }));
        let modifiers = [...vul, ...res, ...imm];
        // Loop through the modifiers
        for (let mod of modifiers) {
            // If it is a physical damage resistance, break it down into its parts
            if (mod.data.startsWith("bludgeoning, piercing, and slashing")) {
                let suffix = mod.data.substr(mod.data.indexOf("slashing") + 8);
                modifiers.push({ type: mod.type, data: "bludgeoning" + suffix });
                modifiers.push({ type: mod.type, data: "piercing" + suffix });
                modifiers.push({ type: mod.type, data: "slashing" + suffix });
                continue;
            }
            creature.dmgTypeMod.push(MonsterDropdown.handleModifier(mod));
        }
        _InitiativeOrder__WEBPACK_IMPORTED_MODULE_1__["default"].updateCreature(creatureId, creature);
        _InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_2__["default"].updateTable();
    }
    static handleModifier(mod) {
        const tooltip = mod.type + " to " + mod.data;
        // Determine if the modifier only applies magical, nonmagical, or both
        const magical = mod.data.indexOf(" magical") >= 0;
        const nonmagical = mod.data.indexOf("nonmagical") >= 0;
        const bothM = magical == nonmagical;
        // Determine if the modifier only applies silvered, nonsilver, or both
        const silvered = mod.data.indexOf(" silvered") >= 0;
        const nonsilvered = mod.data.indexOf("nonsilver") >= 0;
        const bothS = silvered == nonsilvered;
        // Determine if the modifier only applies amantine, nonadamantine, or both
        const adamantine = mod.data.indexOf("are adamantine") >= 0;
        const nonadamantine = mod.data.indexOf("aren't adamantine") >= 0;
        const bothA = adamantine == nonadamantine;
        if (!bothM || !bothS) {
            mod.data = mod.data.replace("from magical/silvered weapons", "");
            mod.data = mod.data.replace("from nonmagical/nonsilver weapons", "");
            mod.data = mod.data.replace("from magical weapons", "");
            mod.data = mod.data.replace("from nonmagical weapons", "");
            mod.data = mod.data.replace("from silvered weapons", "");
            mod.data = mod.data.replace("from nonsilver weapons", "");
            mod.data = mod.data.replace("that aren't adamantine", "");
            mod.data = mod.data.replace("that are adamantine", "");
            mod.data = mod.data.replace("  ", " ");
            mod.data = mod.data.trim();
        }
        if (!_globals__WEBPACK_IMPORTED_MODULE_0__.DAMAGE_TYPES.includes(mod.data)) {
            console.log("Unrecognised damage type: " + mod.data);
            mod.data = "other";
        }
        // Create the modifier
        return {
            type: mod.data,
            magical: bothM ? "both-magical" : magical ? "magical" : "nonmagical",
            silvered: bothS ? "both-silver" : silvered ? "silvered" : "nonsilvered",
            adamantine: bothA ? "both-adamantine" : adamantine ? "adamantine" : "nonadamantine",
            modifier: mod.type,
            desc: tooltip
        };
    }
}
MonsterDropdown.dropdown = null;
MonsterDropdown.monsters = null;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MonsterDropdown);


/***/ }),

/***/ "./src/classes/MonsterList.ts":
/*!************************************!*\
  !*** ./src/classes/MonsterList.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MonsterList)
/* harmony export */ });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals */ "./src/globals.ts");

class MonsterList {
    constructor(monsters) {
        this.monsters = [];
        this.monsters = monsters;
    }
    static async fetch() {
        const response = await fetch(_globals__WEBPACK_IMPORTED_MODULE_0__.API_URL + "/api/monsters");
        const json = await response.json();
        return new MonsterList(json.results);
    }
    getMonsters() {
        return this.monsters;
    }
    searchMonsters(search) {
        search = search.toLowerCase();
        // Filter the monsters to only the ones that contain the search
        let result = this.monsters.filter(monster => {
            return monster.name.toLowerCase().includes(search);
        });
        // Sort the monsters based on which contains the search first
        return result.sort((a, b) => {
            return a.name.toLowerCase().indexOf(search) - b.name.toLowerCase().indexOf(search);
        });
    }
}


/***/ }),

/***/ "./src/dicebox.ts":
/*!************************!*\
  !*** ./src/dicebox.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rollDice: () => (/* binding */ rollDice)
/* harmony export */ });
/* harmony import */ var _3d_dice_dice_box_threejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @3d-dice/dice-box-threejs */ "./node_modules/@3d-dice/dice-box-threejs/dist/dice-box-threejs.es.js");

let dicebox = null;
let diceClearTimeout = NaN;
async function initDiceBox() {
    dicebox = new _3d_dice_dice_box_threejs__WEBPACK_IMPORTED_MODULE_0__["default"]("#dicebox", {
        sounds: true
    });
    await dicebox.initialize();
}
async function rollDice(dice) {
    console.log(dice);
    if (dicebox === null)
        await initDiceBox();
    let boxElem = document.querySelector("#dicebox");
    return new Promise(async (resolve, reject) => {
        window.setTimeout(resolve, 5000);
        boxElem.style.opacity = "1";
        await dicebox.roll(dice);
        window.clearTimeout(diceClearTimeout);
        diceClearTimeout = window.setTimeout(() => boxElem.style.opacity = "0", 1000);
        resolve();
    });
}


/***/ }),

/***/ "./src/globals.ts":
/*!************************!*\
  !*** ./src/globals.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   API_URL: () => (/* binding */ API_URL),
/* harmony export */   DAMAGE_TYPES: () => (/* binding */ DAMAGE_TYPES)
/* harmony export */ });
const API_URL = "https://www.dnd5eapi.co";
const DAMAGE_TYPES = [
    "acid",
    "bludgeoning",
    "cold",
    "fire",
    "force",
    "lightning",
    "necrotic",
    "piercing",
    "poison",
    "psychic",
    "radiant",
    "slashing",
    "thunder"
];


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes/InitiativeOrder */ "./src/classes/InitiativeOrder.ts");
/* harmony import */ var _classes_InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/InitiativeTableHandler */ "./src/classes/InitiativeTableHandler.ts");
/* harmony import */ var _classes_MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/MonsterDropdown */ "./src/classes/MonsterDropdown.ts");
/* harmony import */ var _classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/InitiativeCreature */ "./src/classes/InitiativeCreature.ts");




document.addEventListener("DOMContentLoaded", () => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    _classes_MonsterDropdown__WEBPACK_IMPORTED_MODULE_2__["default"].fetchMonsters();
    _classes_InitiativeTableHandler__WEBPACK_IMPORTED_MODULE_1__["default"].createTable();
    (_a = document.querySelector(".clear-btn")) === null || _a === void 0 ? void 0 : _a.addEventListener("click", () => _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].clear());
    (_b = document.querySelector(".roll-all-btn")) === null || _b === void 0 ? void 0 : _b.addEventListener("click", () => _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].rollInitiativeForAll());
    (_c = document.querySelector(".roll-nonfriendly-btn")) === null || _c === void 0 ? void 0 : _c.addEventListener("click", () => {
        _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].rollInitiativeForAttitude([_classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__.Attitude.Hostile, _classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__.Attitude.Neutral]);
    });
    (_d = document.querySelector(".sort-btn")) === null || _d === void 0 ? void 0 : _d.addEventListener("click", () => _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].sortCreatures());
    (_e = document.querySelector(".next-btn")) === null || _e === void 0 ? void 0 : _e.addEventListener("click", _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].updateCurrentTurn);
    (_f = document.querySelector(".plus-btn.friendly")) === null || _f === void 0 ? void 0 : _f.addEventListener("click", () => _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].addCreature(new _classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__["default"](_classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__.Attitude.Friendly)));
    (_g = document.querySelector(".plus-btn.neutral")) === null || _g === void 0 ? void 0 : _g.addEventListener("click", () => _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].addCreature(new _classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__["default"](_classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__.Attitude.Neutral)));
    (_h = document.querySelector(".plus-btn.hostile")) === null || _h === void 0 ? void 0 : _h.addEventListener("click", () => _classes_InitiativeOrder__WEBPACK_IMPORTED_MODULE_0__["default"].addCreature(new _classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__["default"](_classes_InitiativeCreature__WEBPACK_IMPORTED_MODULE_3__.Attitude.Hostile)));
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQixVQUFVO0FBQ1YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVMsa0JBQWtCLFNBQVMsa0JBQWtCLFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsR0FBRyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxZQUFZLGVBQWUsR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtFQUFrRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxhQUFhLDhoQkFBOGhCO0FBQ2puQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0NBQXdDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdDQUF3QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpVkFBaVYsZUFBZSxTQUFTO0FBQ3pXO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJYQUEyWDtBQUMzWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhLHE3QkFBcTdCO0FBQ3pnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwweU5BQTB5TjtBQUMxeU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU1BQXVNLHNCQUFzQjtBQUM3TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhLDBHQUEwRywyQkFBMkIsNEhBQTRILHdCQUF3QjtBQUNuWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0NBQWtDLE9BQU87QUFDekM7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwT0FBME87QUFDMU87QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVOQUF1TjtBQUN2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3Qix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx3RkFBd0Ysb0JBQW9CO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaU5BQWlOLG9NQUFvTTtBQUNyWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0TUFBNE07QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc09BQXNPO0FBQ3RPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLGlDQUFpQyxnQkFBZ0I7QUFDakQsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkZBQTZGO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLFVBQVU7QUFDekIsV0FBVyxhQUFhO0FBQ3hCLG1CQUFtQixpQ0FBaUM7QUFDcEQsb0JBQW9CLGlDQUFpQztBQUNyRCxnQkFBZ0IsYUFBYTtBQUM3QixpQkFBaUI7QUFDakIsR0FBRztBQUNIO0FBQ0EsbUJBQW1CO0FBQ25CLEdBQUc7QUFDSDtBQUNBLGNBQWMsYUFBYTtBQUMzQixrQkFBa0IsV0FBVztBQUM3QixvQkFBb0IsVUFBVTtBQUM5QixXQUFXLFlBQVk7QUFDdkIsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBLGFBQWEsYUFBYTtBQUMxQixzQkFBc0I7QUFDdEIsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IseUJBQXlCO0FBQ3pCLEdBQUc7QUFDSDtBQUNBLG1CQUFtQjtBQUNuQixHQUFHO0FBQ0g7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLG1CQUFtQjtBQUNuQixHQUFHO0FBQ0g7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQyx5QkFBeUIsVUFBVTtBQUNuQyx3QkFBd0I7QUFDeEIsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQixHQUFHO0FBQ0g7QUFDQSxtQkFBbUI7QUFDbkIsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEMsZUFBZSxVQUFVO0FBQ3pCLGNBQWMsWUFBWTtBQUMxQixnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEMsa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBLE9BQU87QUFDUCwrQkFBK0I7QUFDL0Isb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQSxPQUFPO0FBQ1AsNEJBQTRCLFdBQVc7QUFDdkMsK0JBQStCLFdBQVc7QUFDMUMsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCO0FBQ0EsT0FBTztBQUNQLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBLE9BQU87QUFDUCxxQkFBcUIsV0FBVztBQUNoQyx3QkFBd0IsV0FBVztBQUNuQyxtQkFBbUI7QUFDbkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Y7QUFDQSxPQUFPO0FBQ1AseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLFdBQVc7QUFDakMseUJBQXlCLFdBQVc7QUFDcEMsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmO0FBQ0EsT0FBTztBQUNQLGFBQWEsYUFBYTtBQUMxQixhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0EsZUFBZSx5Q0FBeUM7QUFDeEQsZUFBZSxVQUFVO0FBQ3pCLFlBQVksVUFBVTtBQUN0QixhQUFhLFVBQVU7QUFDdkIsV0FBVyxhQUFhO0FBQ3hCLGdCQUFnQixhQUFhO0FBQzdCLGlCQUFpQixVQUFVO0FBQzNCLG1CQUFtQjtBQUNuQixHQUFHO0FBQ0g7QUFDQSxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLFVBQVU7QUFDekIsY0FBYyx5Q0FBeUM7QUFDdkQsZ0JBQWdCLFVBQVU7QUFDMUIsV0FBVyxhQUFhO0FBQ3hCLGdCQUFnQixhQUFhO0FBQzdCLGlCQUFpQixVQUFVO0FBQzNCLG1CQUFtQjtBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQsb0JBQW9CLHdDQUF3QztBQUM1RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RCxxQkFBcUIsVUFBVTtBQUMvQixxQkFBcUIsVUFBVTtBQUMvQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0Isb0JBQW9CLFVBQVU7QUFDOUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3RELGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdELHdCQUF3QixVQUFVO0FBQ2xDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QixzQkFBc0IsYUFBYTtBQUNuQyw0QkFBNEIsVUFBVTtBQUN0QywrQkFBK0IsYUFBYTtBQUM1Qyw4QkFBOEIscUNBQXFDO0FBQ25FLDRCQUE0QixhQUFhO0FBQ3pDLHFCQUFxQixVQUFVO0FBQy9CLHdCQUF3QixhQUFhO0FBQ3JDLHdCQUF3QixZQUFZO0FBQ3BDLHFDQUFxQyxZQUFZO0FBQ2pELHFDQUFxQyxZQUFZO0FBQ2pELGlDQUFpQyxhQUFhO0FBQzlDLGVBQWUsVUFBVTtBQUN6QixvQkFBb0Isa0NBQWtDO0FBQ3RELHVCQUF1QixhQUFhO0FBQ3BDLHdCQUF3QixVQUFVO0FBQ2xDLDJCQUEyQixhQUFhO0FBQ3hDLHNCQUFzQixVQUFVO0FBQ2hDLHlCQUF5QixhQUFhO0FBQ3RDLGlDQUFpQyxpQ0FBaUM7QUFDbEUsZ0NBQWdDLGFBQWE7QUFDN0MsbUJBQW1CLFVBQVU7QUFDN0Isc0JBQXNCLGFBQWE7QUFDbkMsNkJBQTZCLFVBQVU7QUFDdkMsMEJBQTBCLGtDQUFrQztBQUM1RCwyQkFBMkIsVUFBVTtBQUNyQyw4QkFBOEIsYUFBYTtBQUMzQyx1QkFBdUIsd0NBQXdDO0FBQy9ELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0EsY0FBYztBQUNkLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBLGNBQWM7QUFDZCwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdPQUFnTztBQUNoTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpUUFBaVE7QUFDalE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLFNBQVMsNkVBQTZFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUUsZ0RBQWdELEdBQUcscUNBQXFDLEdBQUc7QUFDekk7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFO0FBQzNCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixVQUFVO0FBQzNCLHFCQUFxQixXQUFXO0FBQ2hDLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixVQUFVO0FBQzFCLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QixvQkFBb0I7QUFDcEIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9CLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEI7O0FBRTFCLEtBQUs7O0FBRUwseUJBQXlCOztBQUV6QixLQUFLOztBQUVMO0FBQ0EsMEJBQTBCOztBQUUxQixLQUFLOztBQUVMO0FBQ0EsMEJBQTBCOztBQUUxQixLQUFLOztBQUVMLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0EsY0FBYyxxQkFBcUIsRUFBRSxFQUFFLElBQUksS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQ0FBcUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUNBQXVDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxZQUFZLFlBQVksZUFBZSxHQUFHLHdFQUF3RSxvQkFBb0Isb0JBQW9CLFdBQVc7QUFDbE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsK0RBQStELG9CQUFvQix1QkFBdUIsOEJBQThCLGtCQUFrQjtBQUMxSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEMsb0JBQW9CLGlCQUFpQjtBQUNyQyxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHF2QkFBcXZCLGtCQUFrQixRQUFRO0FBQy93QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJJQUEySSw0QkFBNEIsY0FBYztBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNLQUFzSyxxQkFBcUI7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSxtSkFBbUosb0JBQW9CO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBLQUEwSyxzQkFBc0I7QUFDaE07QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBLHFEQUFxRCwrQkFBK0I7QUFDcEY7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyxtR0FBbUcsY0FBYztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0UUFBNFEsY0FBYztBQUMxUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnREFBZ0QsYUFBYSxRQUFRLGFBQWEsUUFBUSxnQkFBZ0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTyxHQUFHLE9BQU8sR0FBRyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sR0FBRyxPQUFPLEdBQUcsT0FBTyxHQUFHLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQyxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLFdBQVcsYUFBYTtBQUNoRSx3QkFBd0IsMEJBQTBCO0FBQ2xELG9DQUFvQyxpQkFBaUIsV0FBVywyQ0FBMkM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEMsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFrRDtBQUM3RDtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IscURBQXFELEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUU7QUFDMUU7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixlQUFlO0FBQ3JDLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0Isd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLHVCQUF1QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlIQUFpSDtBQUM5SDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsbUNBQW1DO0FBQzNHO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csU0FBUztBQUNqSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsSUFBSSwrQkFBK0IsZ0JBQWdCO0FBQzVILFdBQVcsa0VBQWtFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLDZFQUE2RSxtSEFBbUg7QUFDaE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTSxPQUFPLE1BQU0sT0FBTyxNQUFNLE9BQU8sTUFBTSxPQUFPLE1BQU0sT0FBTyxNQUFNO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsd0RBQXdELHVDQUF1QztBQUMvRixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsV0FBVztBQUNsRjtBQUNBLHVFQUF1RSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyx1QkFBdUIsS0FBSztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQSxzRUFBc0UsY0FBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLGlGQUFpRixPQUFPO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsMEJBQTBCLGNBQWM7QUFDeEMsd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsdURBQXVELEdBQUc7QUFDMUQsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLG9KQUFvSixXQUFXO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwR0FBMEcsaU5BQWlOO0FBQ2hVO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5REFBeUQsMkJBQTJCO0FBQ3pGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSwwQ0FBMEMsdUVBQXVFLHdDQUF3Qyw2RkFBNkYsMENBQTBDLGtDQUFrQyx1REFBdUQsNEVBQTRFLHVEQUF1RCxpUEFBaVAsdURBQXVELDBQQUEwUCx1REFBdUQsbVBBQW1QLHVEQUF1RDtBQUN0OEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJJQUEySTtBQUNqSztBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlCQUF5QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNIQUFzSDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdCQUF3QixFQUFFLDhCQUE4QjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdEQUF3RCxXQUFXO0FBQ25FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE9BQU87QUFDcEU7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQSxzQkFBc0Isd0NBQXdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFOzs7Ozs7Ozs7Ozs7Ozs7OztBQy8xaEJvQztBQUMvQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDZDtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJzQztBQUN3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsK0RBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFRO0FBQ3RCLFFBQVEsK0RBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBUTtBQUN0QixRQUFRLCtEQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxlQUFlLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZHcUM7QUFDcEI7QUFDQTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBZSxpQkFBaUIsMkRBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5REFBUTtBQUM3QztBQUNBLHFDQUFxQyx5REFBUTtBQUM3QztBQUNBLHFDQUFxQyx5REFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3REFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQWU7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQWU7QUFDM0IsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLHdEQUFlO0FBQ3ZELDJDQUEyQyx3REFBZTtBQUMxRCx5Q0FBeUMsd0RBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFlO0FBQy9CO0FBQ0EsWUFBWSx3REFBZTtBQUMzQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFlO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFlO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFlO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNQYTtBQUNIO0FBQ2M7QUFDdEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9EQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkNBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsY0FBYztBQUM1RixrRUFBa0Usc0NBQXNDO0FBQ3hHLHlFQUF5RSw0Q0FBNEM7QUFDckgsK0RBQStELGtDQUFrQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQThDO0FBQy9FLGlDQUFpQywyQ0FBMkM7QUFDNUUsaUNBQWlDLDJDQUEyQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQWU7QUFDdkIsUUFBUSwrREFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrREFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLGVBQWUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JKTTtBQUN0QjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkNBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFPO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Qk87QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7VUNmQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7O0FDTndEO0FBQ2M7QUFDZDtBQUNvQjtBQUM1RTtBQUNBO0FBQ0EsSUFBSSxnRUFBZTtBQUNuQixJQUFJLHVFQUFzQjtBQUMxQix3SEFBd0gsZ0VBQWU7QUFDdkksMkhBQTJILGdFQUFlO0FBQzFJO0FBQ0EsUUFBUSxnRUFBZSw0QkFBNEIsaUVBQVEsVUFBVSxpRUFBUTtBQUM3RSxLQUFLO0FBQ0wsdUhBQXVILGdFQUFlO0FBQ3RJLGlIQUFpSCxnRUFBZTtBQUNoSSxnSUFBZ0ksZ0VBQWUsaUJBQWlCLG1FQUFrQixDQUFDLGlFQUFRO0FBQzNMLCtIQUErSCxnRUFBZSxpQkFBaUIsbUVBQWtCLENBQUMsaUVBQVE7QUFDMUwsK0hBQStILGdFQUFlLGlCQUFpQixtRUFBa0IsQ0FBQyxpRUFBUTtBQUMxTCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5pdGlhdGl2ZS10cmFja2VyLXJld3JpdGUvLi9ub2RlX21vZHVsZXMvQDNkLWRpY2UvZGljZS1ib3gtdGhyZWVqcy9kaXN0L2RpY2UtYm94LXRocmVlanMuZXMuanMiLCJ3ZWJwYWNrOi8vaW5pdGlhdGl2ZS10cmFja2VyLXJld3JpdGUvLi9zcmMvY2xhc3Nlcy9Jbml0aWF0aXZlQ3JlYXR1cmUudHMiLCJ3ZWJwYWNrOi8vaW5pdGlhdGl2ZS10cmFja2VyLXJld3JpdGUvLi9zcmMvY2xhc3Nlcy9Jbml0aWF0aXZlT3JkZXIudHMiLCJ3ZWJwYWNrOi8vaW5pdGlhdGl2ZS10cmFja2VyLXJld3JpdGUvLi9zcmMvY2xhc3Nlcy9Jbml0aWF0aXZlVGFibGVIYW5kbGVyLnRzIiwid2VicGFjazovL2luaXRpYXRpdmUtdHJhY2tlci1yZXdyaXRlLy4vc3JjL2NsYXNzZXMvTW9uc3RlckRyb3Bkb3duLnRzIiwid2VicGFjazovL2luaXRpYXRpdmUtdHJhY2tlci1yZXdyaXRlLy4vc3JjL2NsYXNzZXMvTW9uc3Rlckxpc3QudHMiLCJ3ZWJwYWNrOi8vaW5pdGlhdGl2ZS10cmFja2VyLXJld3JpdGUvLi9zcmMvZGljZWJveC50cyIsIndlYnBhY2s6Ly9pbml0aWF0aXZlLXRyYWNrZXItcmV3cml0ZS8uL3NyYy9nbG9iYWxzLnRzIiwid2VicGFjazovL2luaXRpYXRpdmUtdHJhY2tlci1yZXdyaXRlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2luaXRpYXRpdmUtdHJhY2tlci1yZXdyaXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9pbml0aWF0aXZlLXRyYWNrZXItcmV3cml0ZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2luaXRpYXRpdmUtdHJhY2tlci1yZXdyaXRlL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vaW5pdGlhdGl2ZS10cmFja2VyLXJld3JpdGUvLi9zcmMvYXBwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6byA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBCbyA9IChoLCBlLCB0KSA9PiBlIGluIGggPyB6byhoLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaFtlXSA9IHQ7XG52YXIgWXMgPSAoaCwgZSwgdCkgPT4gKEJvKGgsIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIHQpLCB0KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEwLTIwMjIgVGhyZWUuanMgQXV0aG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG5jb25zdCBPcyA9IFwiMTQzXCI7XG5jb25zdCBKdCA9IFwic3JnYlwiLCB5biA9IFwic3JnYi1saW5lYXJcIjtcbmNvbnN0IFpzID0gXCIzMDAgZXNcIjtcbmNsYXNzICRuIHtcbiAgYWRkRXZlbnRMaXN0ZW5lcihlLCB0KSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID09PSB2b2lkIDAgJiYgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICBjb25zdCBuID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIG5bZV0gPT09IHZvaWQgMCAmJiAobltlXSA9IFtdKSwgbltlXS5pbmRleE9mKHQpID09PSAtMSAmJiBuW2VdLnB1c2godCk7XG4gIH1cbiAgaGFzRXZlbnRMaXN0ZW5lcihlLCB0KSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgcmV0dXJuIG5bZV0gIT09IHZvaWQgMCAmJiBuW2VdLmluZGV4T2YodCkgIT09IC0xO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgdCkge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy5fbGlzdGVuZXJzW2VdO1xuICAgIGlmIChpICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHMgPSBpLmluZGV4T2YodCk7XG4gICAgICBzICE9PSAtMSAmJiBpLnNwbGljZShzLCAxKTtcbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnNbZS50eXBlXTtcbiAgICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgICBlLnRhcmdldCA9IHRoaXM7XG4gICAgICBjb25zdCBpID0gbi5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IHMgPSAwLCBvID0gaS5sZW5ndGg7IHMgPCBvOyBzKyspXG4gICAgICAgIGlbc10uY2FsbCh0aGlzLCBlKTtcbiAgICAgIGUudGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG50ID0gW1wiMDBcIiwgXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIwYVwiLCBcIjBiXCIsIFwiMGNcIiwgXCIwZFwiLCBcIjBlXCIsIFwiMGZcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIiwgXCIxM1wiLCBcIjE0XCIsIFwiMTVcIiwgXCIxNlwiLCBcIjE3XCIsIFwiMThcIiwgXCIxOVwiLCBcIjFhXCIsIFwiMWJcIiwgXCIxY1wiLCBcIjFkXCIsIFwiMWVcIiwgXCIxZlwiLCBcIjIwXCIsIFwiMjFcIiwgXCIyMlwiLCBcIjIzXCIsIFwiMjRcIiwgXCIyNVwiLCBcIjI2XCIsIFwiMjdcIiwgXCIyOFwiLCBcIjI5XCIsIFwiMmFcIiwgXCIyYlwiLCBcIjJjXCIsIFwiMmRcIiwgXCIyZVwiLCBcIjJmXCIsIFwiMzBcIiwgXCIzMVwiLCBcIjMyXCIsIFwiMzNcIiwgXCIzNFwiLCBcIjM1XCIsIFwiMzZcIiwgXCIzN1wiLCBcIjM4XCIsIFwiMzlcIiwgXCIzYVwiLCBcIjNiXCIsIFwiM2NcIiwgXCIzZFwiLCBcIjNlXCIsIFwiM2ZcIiwgXCI0MFwiLCBcIjQxXCIsIFwiNDJcIiwgXCI0M1wiLCBcIjQ0XCIsIFwiNDVcIiwgXCI0NlwiLCBcIjQ3XCIsIFwiNDhcIiwgXCI0OVwiLCBcIjRhXCIsIFwiNGJcIiwgXCI0Y1wiLCBcIjRkXCIsIFwiNGVcIiwgXCI0ZlwiLCBcIjUwXCIsIFwiNTFcIiwgXCI1MlwiLCBcIjUzXCIsIFwiNTRcIiwgXCI1NVwiLCBcIjU2XCIsIFwiNTdcIiwgXCI1OFwiLCBcIjU5XCIsIFwiNWFcIiwgXCI1YlwiLCBcIjVjXCIsIFwiNWRcIiwgXCI1ZVwiLCBcIjVmXCIsIFwiNjBcIiwgXCI2MVwiLCBcIjYyXCIsIFwiNjNcIiwgXCI2NFwiLCBcIjY1XCIsIFwiNjZcIiwgXCI2N1wiLCBcIjY4XCIsIFwiNjlcIiwgXCI2YVwiLCBcIjZiXCIsIFwiNmNcIiwgXCI2ZFwiLCBcIjZlXCIsIFwiNmZcIiwgXCI3MFwiLCBcIjcxXCIsIFwiNzJcIiwgXCI3M1wiLCBcIjc0XCIsIFwiNzVcIiwgXCI3NlwiLCBcIjc3XCIsIFwiNzhcIiwgXCI3OVwiLCBcIjdhXCIsIFwiN2JcIiwgXCI3Y1wiLCBcIjdkXCIsIFwiN2VcIiwgXCI3ZlwiLCBcIjgwXCIsIFwiODFcIiwgXCI4MlwiLCBcIjgzXCIsIFwiODRcIiwgXCI4NVwiLCBcIjg2XCIsIFwiODdcIiwgXCI4OFwiLCBcIjg5XCIsIFwiOGFcIiwgXCI4YlwiLCBcIjhjXCIsIFwiOGRcIiwgXCI4ZVwiLCBcIjhmXCIsIFwiOTBcIiwgXCI5MVwiLCBcIjkyXCIsIFwiOTNcIiwgXCI5NFwiLCBcIjk1XCIsIFwiOTZcIiwgXCI5N1wiLCBcIjk4XCIsIFwiOTlcIiwgXCI5YVwiLCBcIjliXCIsIFwiOWNcIiwgXCI5ZFwiLCBcIjllXCIsIFwiOWZcIiwgXCJhMFwiLCBcImExXCIsIFwiYTJcIiwgXCJhM1wiLCBcImE0XCIsIFwiYTVcIiwgXCJhNlwiLCBcImE3XCIsIFwiYThcIiwgXCJhOVwiLCBcImFhXCIsIFwiYWJcIiwgXCJhY1wiLCBcImFkXCIsIFwiYWVcIiwgXCJhZlwiLCBcImIwXCIsIFwiYjFcIiwgXCJiMlwiLCBcImIzXCIsIFwiYjRcIiwgXCJiNVwiLCBcImI2XCIsIFwiYjdcIiwgXCJiOFwiLCBcImI5XCIsIFwiYmFcIiwgXCJiYlwiLCBcImJjXCIsIFwiYmRcIiwgXCJiZVwiLCBcImJmXCIsIFwiYzBcIiwgXCJjMVwiLCBcImMyXCIsIFwiYzNcIiwgXCJjNFwiLCBcImM1XCIsIFwiYzZcIiwgXCJjN1wiLCBcImM4XCIsIFwiYzlcIiwgXCJjYVwiLCBcImNiXCIsIFwiY2NcIiwgXCJjZFwiLCBcImNlXCIsIFwiY2ZcIiwgXCJkMFwiLCBcImQxXCIsIFwiZDJcIiwgXCJkM1wiLCBcImQ0XCIsIFwiZDVcIiwgXCJkNlwiLCBcImQ3XCIsIFwiZDhcIiwgXCJkOVwiLCBcImRhXCIsIFwiZGJcIiwgXCJkY1wiLCBcImRkXCIsIFwiZGVcIiwgXCJkZlwiLCBcImUwXCIsIFwiZTFcIiwgXCJlMlwiLCBcImUzXCIsIFwiZTRcIiwgXCJlNVwiLCBcImU2XCIsIFwiZTdcIiwgXCJlOFwiLCBcImU5XCIsIFwiZWFcIiwgXCJlYlwiLCBcImVjXCIsIFwiZWRcIiwgXCJlZVwiLCBcImVmXCIsIFwiZjBcIiwgXCJmMVwiLCBcImYyXCIsIFwiZjNcIiwgXCJmNFwiLCBcImY1XCIsIFwiZjZcIiwgXCJmN1wiLCBcImY4XCIsIFwiZjlcIiwgXCJmYVwiLCBcImZiXCIsIFwiZmNcIiwgXCJmZFwiLCBcImZlXCIsIFwiZmZcIl0sIFFpID0gTWF0aC5QSSAvIDE4MCwgenMgPSAxODAgLyBNYXRoLlBJO1xuZnVuY3Rpb24gaGkoKSB7XG4gIGNvbnN0IGggPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDAsIGUgPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDAsIHQgPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDAsIG4gPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDA7XG4gIHJldHVybiAobnRbaCAmIDI1NV0gKyBudFtoID4+IDggJiAyNTVdICsgbnRbaCA+PiAxNiAmIDI1NV0gKyBudFtoID4+IDI0ICYgMjU1XSArIFwiLVwiICsgbnRbZSAmIDI1NV0gKyBudFtlID4+IDggJiAyNTVdICsgXCItXCIgKyBudFtlID4+IDE2ICYgMTUgfCA2NF0gKyBudFtlID4+IDI0ICYgMjU1XSArIFwiLVwiICsgbnRbdCAmIDYzIHwgMTI4XSArIG50W3QgPj4gOCAmIDI1NV0gKyBcIi1cIiArIG50W3QgPj4gMTYgJiAyNTVdICsgbnRbdCA+PiAyNCAmIDI1NV0gKyBudFtuICYgMjU1XSArIG50W24gPj4gOCAmIDI1NV0gKyBudFtuID4+IDE2ICYgMjU1XSArIG50W24gPj4gMjQgJiAyNTVdKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbXQoaCwgZSwgdCkge1xuICByZXR1cm4gTWF0aC5tYXgoZSwgTWF0aC5taW4odCwgaCkpO1xufVxuZnVuY3Rpb24gTm8oaCwgZSkge1xuICByZXR1cm4gKGggJSBlICsgZSkgJSBlO1xufVxuZnVuY3Rpb24gZXMoaCwgZSwgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqIGggKyB0ICogZTtcbn1cbmZ1bmN0aW9uICRzKGgpIHtcbiAgcmV0dXJuIChoICYgaCAtIDEpID09PSAwICYmIGggIT09IDA7XG59XG5mdW5jdGlvbiBCcyhoKSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKGgpIC8gTWF0aC5MTjIpKTtcbn1cbmNsYXNzIENlIHtcbiAgY29uc3RydWN0b3IoZSA9IDAsIHQgPSAwKSB7XG4gICAgQ2UucHJvdG90eXBlLmlzVmVjdG9yMiA9ICEwLCB0aGlzLnggPSBlLCB0aGlzLnkgPSB0O1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy54O1xuICB9XG4gIHNldCB3aWR0aChlKSB7XG4gICAgdGhpcy54ID0gZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnk7XG4gIH1cbiAgc2V0IGhlaWdodChlKSB7XG4gICAgdGhpcy55ID0gZTtcbiAgfVxuICBzZXQoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzLnkgPSB0LCB0aGlzO1xuICB9XG4gIHNldFNjYWxhcihlKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUsIHRoaXMueSA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0WChlKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0WShlKSB7XG4gICAgcmV0dXJuIHRoaXMueSA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0Q29tcG9uZW50KGUsIHQpIHtcbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy54ID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMueSA9IHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIiArIGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRDb21wb25lbnQoZSkge1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIiArIGUpO1xuICAgIH1cbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLngsIHRoaXMueSA9IGUueSwgdGhpcztcbiAgfVxuICBhZGQoZSkge1xuICAgIHJldHVybiB0aGlzLnggKz0gZS54LCB0aGlzLnkgKz0gZS55LCB0aGlzO1xuICB9XG4gIGFkZFNjYWxhcihlKSB7XG4gICAgcmV0dXJuIHRoaXMueCArPSBlLCB0aGlzLnkgKz0gZSwgdGhpcztcbiAgfVxuICBhZGRWZWN0b3JzKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZS54ICsgdC54LCB0aGlzLnkgPSBlLnkgKyB0LnksIHRoaXM7XG4gIH1cbiAgYWRkU2NhbGVkVmVjdG9yKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ICs9IGUueCAqIHQsIHRoaXMueSArPSBlLnkgKiB0LCB0aGlzO1xuICB9XG4gIHN1YihlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAtPSBlLngsIHRoaXMueSAtPSBlLnksIHRoaXM7XG4gIH1cbiAgc3ViU2NhbGFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy54IC09IGUsIHRoaXMueSAtPSBlLCB0aGlzO1xuICB9XG4gIHN1YlZlY3RvcnMoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLnggLSB0LngsIHRoaXMueSA9IGUueSAtIHQueSwgdGhpcztcbiAgfVxuICBtdWx0aXBseShlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqPSBlLngsIHRoaXMueSAqPSBlLnksIHRoaXM7XG4gIH1cbiAgbXVsdGlwbHlTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLnggKj0gZSwgdGhpcy55ICo9IGUsIHRoaXM7XG4gIH1cbiAgZGl2aWRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy54IC89IGUueCwgdGhpcy55IC89IGUueSwgdGhpcztcbiAgfVxuICBkaXZpZGVTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBlKTtcbiAgfVxuICBhcHBseU1hdHJpeDMoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLngsIG4gPSB0aGlzLnksIGkgPSBlLmVsZW1lbnRzO1xuICAgIHJldHVybiB0aGlzLnggPSBpWzBdICogdCArIGlbM10gKiBuICsgaVs2XSwgdGhpcy55ID0gaVsxXSAqIHQgKyBpWzRdICogbiArIGlbN10sIHRoaXM7XG4gIH1cbiAgbWluKGUpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCBlLngpLCB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIGUueSksIHRoaXM7XG4gIH1cbiAgbWF4KGUpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBlLngpLCB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIGUueSksIHRoaXM7XG4gIH1cbiAgY2xhbXAoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heChlLngsIE1hdGgubWluKHQueCwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KGUueSwgTWF0aC5taW4odC55LCB0aGlzLnkpKSwgdGhpcztcbiAgfVxuICBjbGFtcFNjYWxhcihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KGUsIE1hdGgubWluKHQsIHRoaXMueCkpLCB0aGlzLnkgPSBNYXRoLm1heChlLCBNYXRoLm1pbih0LCB0aGlzLnkpKSwgdGhpcztcbiAgfVxuICBjbGFtcExlbmd0aChlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMubGVuZ3RoKCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKG4gfHwgMSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgoZSwgTWF0aC5taW4odCwgbikpKTtcbiAgfVxuICBmbG9vcigpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpLCB0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSksIHRoaXM7XG4gIH1cbiAgY2VpbCgpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCksIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpLCB0aGlzO1xuICB9XG4gIHJvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCksIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KSwgdGhpcztcbiAgfVxuICByb3VuZFRvWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gdGhpcy54IDwgMCA/IE1hdGguY2VpbCh0aGlzLngpIDogTWF0aC5mbG9vcih0aGlzLngpLCB0aGlzLnkgPSB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSksIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnggPSAtdGhpcy54LCB0aGlzLnkgPSAtdGhpcy55LCB0aGlzO1xuICB9XG4gIGRvdChlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIGUueCArIHRoaXMueSAqIGUueTtcbiAgfVxuICBjcm9zcyhlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIGUueSAtIHRoaXMueSAqIGUueDtcbiAgfVxuICBsZW5ndGhTcSgpIHtcbiAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuICB9XG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gIH1cbiAgbWFuaGF0dGFuTGVuZ3RoKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KTtcbiAgfVxuICBub3JtYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG4gIH1cbiAgYW5nbGUoKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoLXRoaXMueSwgLXRoaXMueCkgKyBNYXRoLlBJO1xuICB9XG4gIGRpc3RhbmNlVG8oZSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZChlKSk7XG4gIH1cbiAgZGlzdGFuY2VUb1NxdWFyZWQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnggLSBlLngsIG4gPSB0aGlzLnkgLSBlLnk7XG4gICAgcmV0dXJuIHQgKiB0ICsgbiAqIG47XG4gIH1cbiAgbWFuaGF0dGFuRGlzdGFuY2VUbyhlKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIGUueCkgKyBNYXRoLmFicyh0aGlzLnkgLSBlLnkpO1xuICB9XG4gIHNldExlbmd0aChlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZSk7XG4gIH1cbiAgbGVycChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCArPSAoZS54IC0gdGhpcy54KSAqIHQsIHRoaXMueSArPSAoZS55IC0gdGhpcy55KSAqIHQsIHRoaXM7XG4gIH1cbiAgbGVycFZlY3RvcnMoZSwgdCwgbikge1xuICAgIHJldHVybiB0aGlzLnggPSBlLnggKyAodC54IC0gZS54KSAqIG4sIHRoaXMueSA9IGUueSArICh0LnkgLSBlLnkpICogbiwgdGhpcztcbiAgfVxuICBlcXVhbHMoZSkge1xuICAgIHJldHVybiBlLnggPT09IHRoaXMueCAmJiBlLnkgPT09IHRoaXMueTtcbiAgfVxuICBmcm9tQXJyYXkoZSwgdCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZVt0XSwgdGhpcy55ID0gZVt0ICsgMV0sIHRoaXM7XG4gIH1cbiAgdG9BcnJheShlID0gW10sIHQgPSAwKSB7XG4gICAgcmV0dXJuIGVbdF0gPSB0aGlzLngsIGVbdCArIDFdID0gdGhpcy55LCBlO1xuICB9XG4gIGZyb21CdWZmZXJBdHRyaWJ1dGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLmdldFgodCksIHRoaXMueSA9IGUuZ2V0WSh0KSwgdGhpcztcbiAgfVxuICByb3RhdGVBcm91bmQoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBNYXRoLmNvcyh0KSwgaSA9IE1hdGguc2luKHQpLCBzID0gdGhpcy54IC0gZS54LCBvID0gdGhpcy55IC0gZS55O1xuICAgIHJldHVybiB0aGlzLnggPSBzICogbiAtIG8gKiBpICsgZS54LCB0aGlzLnkgPSBzICogaSArIG8gKiBuICsgZS55LCB0aGlzO1xuICB9XG4gIHJhbmRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5yYW5kb20oKSwgdGhpcy55ID0gTWF0aC5yYW5kb20oKSwgdGhpcztcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQgdGhpcy54LCB5aWVsZCB0aGlzLnk7XG4gIH1cbn1cbmNsYXNzIE10IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgTXQucHJvdG90eXBlLmlzTWF0cml4MyA9ICEwLCB0aGlzLmVsZW1lbnRzID0gW1xuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgXTtcbiAgfVxuICBzZXQoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiBjWzBdID0gZSwgY1sxXSA9IGksIGNbMl0gPSByLCBjWzNdID0gdCwgY1s0XSA9IHMsIGNbNV0gPSBsLCBjWzZdID0gbiwgY1s3XSA9IG8sIGNbOF0gPSBhLCB0aGlzO1xuICB9XG4gIGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgICksIHRoaXM7XG4gIH1cbiAgY29weShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIG4gPSBlLmVsZW1lbnRzO1xuICAgIHJldHVybiB0WzBdID0gblswXSwgdFsxXSA9IG5bMV0sIHRbMl0gPSBuWzJdLCB0WzNdID0gblszXSwgdFs0XSA9IG5bNF0sIHRbNV0gPSBuWzVdLCB0WzZdID0gbls2XSwgdFs3XSA9IG5bN10sIHRbOF0gPSBuWzhdLCB0aGlzO1xuICB9XG4gIGV4dHJhY3RCYXNpcyhlLCB0LCBuKSB7XG4gICAgcmV0dXJuIGUuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMCksIHQuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMSksIG4uc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMiksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbU1hdHJpeDQoZSkge1xuICAgIGNvbnN0IHQgPSBlLmVsZW1lbnRzO1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIHRbMF0sXG4gICAgICB0WzRdLFxuICAgICAgdFs4XSxcbiAgICAgIHRbMV0sXG4gICAgICB0WzVdLFxuICAgICAgdFs5XSxcbiAgICAgIHRbMl0sXG4gICAgICB0WzZdLFxuICAgICAgdFsxMF1cbiAgICApLCB0aGlzO1xuICB9XG4gIG11bHRpcGx5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsIGUpO1xuICB9XG4gIHByZW11bHRpcGx5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKGUsIHRoaXMpO1xuICB9XG4gIG11bHRpcGx5TWF0cmljZXMoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBlLmVsZW1lbnRzLCBpID0gdC5lbGVtZW50cywgcyA9IHRoaXMuZWxlbWVudHMsIG8gPSBuWzBdLCByID0gblszXSwgbCA9IG5bNl0sIGEgPSBuWzFdLCBjID0gbls0XSwgZCA9IG5bN10sIHUgPSBuWzJdLCBtID0gbls1XSwgZyA9IG5bOF0sIHAgPSBpWzBdLCBmID0gaVszXSwgdiA9IGlbNl0sIF8gPSBpWzFdLCB3ID0gaVs0XSwgeCA9IGlbN10sIE0gPSBpWzJdLCBFID0gaVs1XSwgUiA9IGlbOF07XG4gICAgcmV0dXJuIHNbMF0gPSBvICogcCArIHIgKiBfICsgbCAqIE0sIHNbM10gPSBvICogZiArIHIgKiB3ICsgbCAqIEUsIHNbNl0gPSBvICogdiArIHIgKiB4ICsgbCAqIFIsIHNbMV0gPSBhICogcCArIGMgKiBfICsgZCAqIE0sIHNbNF0gPSBhICogZiArIGMgKiB3ICsgZCAqIEUsIHNbN10gPSBhICogdiArIGMgKiB4ICsgZCAqIFIsIHNbMl0gPSB1ICogcCArIG0gKiBfICsgZyAqIE0sIHNbNV0gPSB1ICogZiArIG0gKiB3ICsgZyAqIEUsIHNbOF0gPSB1ICogdiArIG0gKiB4ICsgZyAqIFIsIHRoaXM7XG4gIH1cbiAgbXVsdGlwbHlTY2FsYXIoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiB0WzBdICo9IGUsIHRbM10gKj0gZSwgdFs2XSAqPSBlLCB0WzFdICo9IGUsIHRbNF0gKj0gZSwgdFs3XSAqPSBlLCB0WzJdICo9IGUsIHRbNV0gKj0gZSwgdFs4XSAqPSBlLCB0aGlzO1xuICB9XG4gIGRldGVybWluYW50KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCB0ID0gZVswXSwgbiA9IGVbMV0sIGkgPSBlWzJdLCBzID0gZVszXSwgbyA9IGVbNF0sIHIgPSBlWzVdLCBsID0gZVs2XSwgYSA9IGVbN10sIGMgPSBlWzhdO1xuICAgIHJldHVybiB0ICogbyAqIGMgLSB0ICogciAqIGEgLSBuICogcyAqIGMgKyBuICogciAqIGwgKyBpICogcyAqIGEgLSBpICogbyAqIGw7XG4gIH1cbiAgaW52ZXJ0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCB0ID0gZVswXSwgbiA9IGVbMV0sIGkgPSBlWzJdLCBzID0gZVszXSwgbyA9IGVbNF0sIHIgPSBlWzVdLCBsID0gZVs2XSwgYSA9IGVbN10sIGMgPSBlWzhdLCBkID0gYyAqIG8gLSByICogYSwgdSA9IHIgKiBsIC0gYyAqIHMsIG0gPSBhICogcyAtIG8gKiBsLCBnID0gdCAqIGQgKyBuICogdSArIGkgKiBtO1xuICAgIGlmIChnID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IHAgPSAxIC8gZztcbiAgICByZXR1cm4gZVswXSA9IGQgKiBwLCBlWzFdID0gKGkgKiBhIC0gYyAqIG4pICogcCwgZVsyXSA9IChyICogbiAtIGkgKiBvKSAqIHAsIGVbM10gPSB1ICogcCwgZVs0XSA9IChjICogdCAtIGkgKiBsKSAqIHAsIGVbNV0gPSAoaSAqIHMgLSByICogdCkgKiBwLCBlWzZdID0gbSAqIHAsIGVbN10gPSAobiAqIGwgLSBhICogdCkgKiBwLCBlWzhdID0gKG8gKiB0IC0gbiAqIHMpICogcCwgdGhpcztcbiAgfVxuICB0cmFuc3Bvc2UoKSB7XG4gICAgbGV0IGU7XG4gICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIGUgPSB0WzFdLCB0WzFdID0gdFszXSwgdFszXSA9IGUsIGUgPSB0WzJdLCB0WzJdID0gdFs2XSwgdFs2XSA9IGUsIGUgPSB0WzVdLCB0WzVdID0gdFs3XSwgdFs3XSA9IGUsIHRoaXM7XG4gIH1cbiAgZ2V0Tm9ybWFsTWF0cml4KGUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NChlKS5pbnZlcnQoKS50cmFuc3Bvc2UoKTtcbiAgfVxuICB0cmFuc3Bvc2VJbnRvQXJyYXkoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiBlWzBdID0gdFswXSwgZVsxXSA9IHRbM10sIGVbMl0gPSB0WzZdLCBlWzNdID0gdFsxXSwgZVs0XSA9IHRbNF0sIGVbNV0gPSB0WzddLCBlWzZdID0gdFsyXSwgZVs3XSA9IHRbNV0sIGVbOF0gPSB0WzhdLCB0aGlzO1xuICB9XG4gIHNldFV2VHJhbnNmb3JtKGUsIHQsIG4sIGksIHMsIG8sIHIpIHtcbiAgICBjb25zdCBsID0gTWF0aC5jb3MocyksIGEgPSBNYXRoLnNpbihzKTtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICBuICogbCxcbiAgICAgIG4gKiBhLFxuICAgICAgLW4gKiAobCAqIG8gKyBhICogcikgKyBvICsgZSxcbiAgICAgIC1pICogYSxcbiAgICAgIGkgKiBsLFxuICAgICAgLWkgKiAoLWEgKiBvICsgbCAqIHIpICsgciArIHQsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICApLCB0aGlzO1xuICB9XG4gIHNjYWxlKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gblswXSAqPSBlLCBuWzNdICo9IGUsIG5bNl0gKj0gZSwgblsxXSAqPSB0LCBuWzRdICo9IHQsIG5bN10gKj0gdCwgdGhpcztcbiAgfVxuICByb3RhdGUoZSkge1xuICAgIGNvbnN0IHQgPSBNYXRoLmNvcyhlKSwgbiA9IE1hdGguc2luKGUpLCBpID0gdGhpcy5lbGVtZW50cywgcyA9IGlbMF0sIG8gPSBpWzNdLCByID0gaVs2XSwgbCA9IGlbMV0sIGEgPSBpWzRdLCBjID0gaVs3XTtcbiAgICByZXR1cm4gaVswXSA9IHQgKiBzICsgbiAqIGwsIGlbM10gPSB0ICogbyArIG4gKiBhLCBpWzZdID0gdCAqIHIgKyBuICogYywgaVsxXSA9IC1uICogcyArIHQgKiBsLCBpWzRdID0gLW4gKiBvICsgdCAqIGEsIGlbN10gPSAtbiAqIHIgKyB0ICogYywgdGhpcztcbiAgfVxuICB0cmFuc2xhdGUoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiBuWzBdICs9IGUgKiBuWzJdLCBuWzNdICs9IGUgKiBuWzVdLCBuWzZdICs9IGUgKiBuWzhdLCBuWzFdICs9IHQgKiBuWzJdLCBuWzRdICs9IHQgKiBuWzVdLCBuWzddICs9IHQgKiBuWzhdLCB0aGlzO1xuICB9XG4gIGVxdWFscyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIG4gPSBlLmVsZW1lbnRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKVxuICAgICAgaWYgKHRbaV0gIT09IG5baV0pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgZnJvbUFycmF5KGUsIHQgPSAwKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCA5OyBuKyspXG4gICAgICB0aGlzLmVsZW1lbnRzW25dID0gZVtuICsgdF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9BcnJheShlID0gW10sIHQgPSAwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIGVbdF0gPSBuWzBdLCBlW3QgKyAxXSA9IG5bMV0sIGVbdCArIDJdID0gblsyXSwgZVt0ICsgM10gPSBuWzNdLCBlW3QgKyA0XSA9IG5bNF0sIGVbdCArIDVdID0gbls1XSwgZVt0ICsgNl0gPSBuWzZdLCBlW3QgKyA3XSA9IG5bN10sIGVbdCArIDhdID0gbls4XSwgZTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvKGgpIHtcbiAgZm9yIChsZXQgZSA9IGgubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpXG4gICAgaWYgKGhbZV0gPiA2NTUzNSlcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcWkoaCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBoKTtcbn1cbmZ1bmN0aW9uIGJuKGgpIHtcbiAgcmV0dXJuIGggPCAwLjA0MDQ1ID8gaCAqIDAuMDc3Mzk5MzgwOCA6IE1hdGgucG93KGggKiAwLjk0Nzg2NzI5ODYgKyAwLjA1MjEzMjcwMTQsIDIuNCk7XG59XG5mdW5jdGlvbiBXaShoKSB7XG4gIHJldHVybiBoIDwgMzEzMDhlLTcgPyBoICogMTIuOTIgOiAxLjA1NSAqIE1hdGgucG93KGgsIDAuNDE2NjYpIC0gMC4wNTU7XG59XG5jb25zdCB0cyA9IHtcbiAgW0p0XTogeyBbeW5dOiBibiB9LFxuICBbeW5dOiB7IFtKdF06IFdpIH1cbn0sIFN0ID0ge1xuICBsZWdhY3lNb2RlOiAhMCxcbiAgZ2V0IHdvcmtpbmdDb2xvclNwYWNlKCkge1xuICAgIHJldHVybiB5bjtcbiAgfSxcbiAgc2V0IHdvcmtpbmdDb2xvclNwYWNlKGgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5Db2xvck1hbmFnZW1lbnQ6IC53b3JraW5nQ29sb3JTcGFjZSBpcyByZWFkb25seS5cIik7XG4gIH0sXG4gIGNvbnZlcnQ6IGZ1bmN0aW9uKGgsIGUsIHQpIHtcbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlIHx8IGUgPT09IHQgfHwgIWUgfHwgIXQpXG4gICAgICByZXR1cm4gaDtcbiAgICBpZiAodHNbZV0gJiYgdHNbZV1bdF0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgbiA9IHRzW2VdW3RdO1xuICAgICAgcmV0dXJuIGguciA9IG4oaC5yKSwgaC5nID0gbihoLmcpLCBoLmIgPSBuKGguYiksIGg7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24uXCIpO1xuICB9LFxuICBmcm9tV29ya2luZ0NvbG9yU3BhY2U6IGZ1bmN0aW9uKGgsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0KGgsIHRoaXMud29ya2luZ0NvbG9yU3BhY2UsIGUpO1xuICB9LFxuICB0b1dvcmtpbmdDb2xvclNwYWNlOiBmdW5jdGlvbihoLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udmVydChoLCBlLCB0aGlzLndvcmtpbmdDb2xvclNwYWNlKTtcbiAgfVxufSwgbm8gPSB7XG4gIGFsaWNlYmx1ZTogMTU3OTIzODMsXG4gIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXG4gIGFxdWE6IDY1NTM1LFxuICBhcXVhbWFyaW5lOiA4Mzg4NTY0LFxuICBhenVyZTogMTU3OTQxNzUsXG4gIGJlaWdlOiAxNjExOTI2MCxcbiAgYmlzcXVlOiAxNjc3MDI0NCxcbiAgYmxhY2s6IDAsXG4gIGJsYW5jaGVkYWxtb25kOiAxNjc3MjA0NSxcbiAgYmx1ZTogMjU1LFxuICBibHVldmlvbGV0OiA5MDU1MjAyLFxuICBicm93bjogMTA4MjQyMzQsXG4gIGJ1cmx5d29vZDogMTQ1OTYyMzEsXG4gIGNhZGV0Ymx1ZTogNjI2NjUyOCxcbiAgY2hhcnRyZXVzZTogODM4ODM1MixcbiAgY2hvY29sYXRlOiAxMzc4OTQ3MCxcbiAgY29yYWw6IDE2NzQ0MjcyLFxuICBjb3JuZmxvd2VyYmx1ZTogNjU5MTk4MSxcbiAgY29ybnNpbGs6IDE2Nzc1Mzg4LFxuICBjcmltc29uOiAxNDQyMzEwMCxcbiAgY3lhbjogNjU1MzUsXG4gIGRhcmtibHVlOiAxMzksXG4gIGRhcmtjeWFuOiAzNTcyMyxcbiAgZGFya2dvbGRlbnJvZDogMTIwOTI5MzksXG4gIGRhcmtncmF5OiAxMTExOTAxNyxcbiAgZGFya2dyZWVuOiAyNTYwMCxcbiAgZGFya2dyZXk6IDExMTE5MDE3LFxuICBkYXJra2hha2k6IDEyNDMzMjU5LFxuICBkYXJrbWFnZW50YTogOTEwOTY0MyxcbiAgZGFya29saXZlZ3JlZW46IDU1OTc5OTksXG4gIGRhcmtvcmFuZ2U6IDE2NzQ3NTIwLFxuICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcbiAgZGFya3JlZDogOTEwOTUwNCxcbiAgZGFya3NhbG1vbjogMTUzMDg0MTAsXG4gIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcbiAgZGFya3NsYXRlYmx1ZTogNDczNDM0NyxcbiAgZGFya3NsYXRlZ3JheTogMzEwMDQ5NSxcbiAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcbiAgZGFya3R1cnF1b2lzZTogNTI5NDUsXG4gIGRhcmt2aW9sZXQ6IDk2OTk1MzksXG4gIGRlZXBwaW5rOiAxNjcxNjk0NyxcbiAgZGVlcHNreWJsdWU6IDQ5MTUxLFxuICBkaW1ncmF5OiA2OTA4MjY1LFxuICBkaW1ncmV5OiA2OTA4MjY1LFxuICBkb2RnZXJibHVlOiAyMDAzMTk5LFxuICBmaXJlYnJpY2s6IDExNjc0MTQ2LFxuICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXG4gIGZvcmVzdGdyZWVuOiAyMjYzODQyLFxuICBmdWNoc2lhOiAxNjcxMTkzNSxcbiAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcbiAgZ2hvc3R3aGl0ZTogMTYzMTY2NzEsXG4gIGdvbGQ6IDE2NzY2NzIwLFxuICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxuICBncmF5OiA4NDIxNTA0LFxuICBncmVlbjogMzI3NjgsXG4gIGdyZWVueWVsbG93OiAxMTQwMzA1NSxcbiAgZ3JleTogODQyMTUwNCxcbiAgaG9uZXlkZXc6IDE1Nzk0MTYwLFxuICBob3RwaW5rOiAxNjczODc0MCxcbiAgaW5kaWFucmVkOiAxMzQ1ODUyNCxcbiAgaW5kaWdvOiA0OTE1MzMwLFxuICBpdm9yeTogMTY3NzcyMDAsXG4gIGtoYWtpOiAxNTc4NzY2MCxcbiAgbGF2ZW5kZXI6IDE1MTMyNDEwLFxuICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcbiAgbGF3bmdyZWVuOiA4MTkwOTc2LFxuICBsZW1vbmNoaWZmb246IDE2Nzc1ODg1LFxuICBsaWdodGJsdWU6IDExMzkzMjU0LFxuICBsaWdodGNvcmFsOiAxNTc2MTUzNixcbiAgbGlnaHRjeWFuOiAxNDc0NTU5OSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxuICBsaWdodGdyYXk6IDEzODgyMzIzLFxuICBsaWdodGdyZWVuOiA5NDk4MjU2LFxuICBsaWdodGdyZXk6IDEzODgyMzIzLFxuICBsaWdodHBpbms6IDE2NzU4NDY1LFxuICBsaWdodHNhbG1vbjogMTY3NTI3NjIsXG4gIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXG4gIGxpZ2h0c2t5Ymx1ZTogODkwMDM0NixcbiAgbGlnaHRzbGF0ZWdyYXk6IDc4MzM3NTMsXG4gIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxuICBsaWdodHN0ZWVsYmx1ZTogMTE1ODQ3MzQsXG4gIGxpZ2h0eWVsbG93OiAxNjc3NzE4NCxcbiAgbGltZTogNjUyODAsXG4gIGxpbWVncmVlbjogMzMyOTMzMCxcbiAgbGluZW46IDE2NDQ1NjcwLFxuICBtYWdlbnRhOiAxNjcxMTkzNSxcbiAgbWFyb29uOiA4Mzg4NjA4LFxuICBtZWRpdW1hcXVhbWFyaW5lOiA2NzM3MzIyLFxuICBtZWRpdW1ibHVlOiAyMDUsXG4gIG1lZGl1bW9yY2hpZDogMTIyMTE2NjcsXG4gIG1lZGl1bXB1cnBsZTogOTY2MjY4MyxcbiAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogODA4Nzc5MCxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDY0MTU0LFxuICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXG4gIG1lZGl1bXZpb2xldHJlZDogMTMwNDcxNzMsXG4gIG1pZG5pZ2h0Ymx1ZTogMTY0NDkxMixcbiAgbWludGNyZWFtOiAxNjEyMTg1MCxcbiAgbWlzdHlyb3NlOiAxNjc3MDI3MyxcbiAgbW9jY2FzaW46IDE2NzcwMjI5LFxuICBuYXZham93aGl0ZTogMTY3Njg2ODUsXG4gIG5hdnk6IDEyOCxcbiAgb2xkbGFjZTogMTY2NDM1NTgsXG4gIG9saXZlOiA4NDIxMzc2LFxuICBvbGl2ZWRyYWI6IDcwNDg3MzksXG4gIG9yYW5nZTogMTY3NTM5MjAsXG4gIG9yYW5nZXJlZDogMTY3MjkzNDQsXG4gIG9yY2hpZDogMTQzMTU3MzQsXG4gIHBhbGVnb2xkZW5yb2Q6IDE1NjU3MTMwLFxuICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxuICBwYWxldHVycXVvaXNlOiAxMTUyOTk2NixcbiAgcGFsZXZpb2xldHJlZDogMTQzODEyMDMsXG4gIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxuICBwZWFjaHB1ZmY6IDE2NzY3NjczLFxuICBwZXJ1OiAxMzQ2ODk5MSxcbiAgcGluazogMTY3NjEwMzUsXG4gIHBsdW06IDE0NTI0NjM3LFxuICBwb3dkZXJibHVlOiAxMTU5MTkxMCxcbiAgcHVycGxlOiA4Mzg4NzM2LFxuICByZWJlY2NhcHVycGxlOiA2Njk3ODgxLFxuICByZWQ6IDE2NzExNjgwLFxuICByb3N5YnJvd246IDEyMzU3NTE5LFxuICByb3lhbGJsdWU6IDQyODY5NDUsXG4gIHNhZGRsZWJyb3duOiA5MTI3MTg3LFxuICBzYWxtb246IDE2NDE2ODgyLFxuICBzYW5keWJyb3duOiAxNjAzMjg2NCxcbiAgc2VhZ3JlZW46IDMwNTAzMjcsXG4gIHNlYXNoZWxsOiAxNjc3NDYzOCxcbiAgc2llbm5hOiAxMDUwNjc5NyxcbiAgc2lsdmVyOiAxMjYzMjI1NixcbiAgc2t5Ymx1ZTogODkwMDMzMSxcbiAgc2xhdGVibHVlOiA2OTcwMDYxLFxuICBzbGF0ZWdyYXk6IDczNzI5NDQsXG4gIHNsYXRlZ3JleTogNzM3Mjk0NCxcbiAgc25vdzogMTY3NzU5MzAsXG4gIHNwcmluZ2dyZWVuOiA2NTQwNyxcbiAgc3RlZWxibHVlOiA0NjIwOTgwLFxuICB0YW46IDEzODA4NzgwLFxuICB0ZWFsOiAzMjg5NixcbiAgdGhpc3RsZTogMTQyMDQ4ODgsXG4gIHRvbWF0bzogMTY3MzcwOTUsXG4gIHR1cnF1b2lzZTogNDI1MTg1NixcbiAgdmlvbGV0OiAxNTYzMTA4NixcbiAgd2hlYXQ6IDE2MTEzMzMxLFxuICB3aGl0ZTogMTY3NzcyMTUsXG4gIHdoaXRlc21va2U6IDE2MTE5Mjg1LFxuICB5ZWxsb3c6IDE2Nzc2OTYwLFxuICB5ZWxsb3dncmVlbjogMTAxNDUwNzRcbn0sIFllID0geyByOiAwLCBnOiAwLCBiOiAwIH0sIEV0ID0geyBoOiAwLCBzOiAwLCBsOiAwIH0sIGdpID0geyBoOiAwLCBzOiAwLCBsOiAwIH07XG5mdW5jdGlvbiBucyhoLCBlLCB0KSB7XG4gIHJldHVybiB0IDwgMCAmJiAodCArPSAxKSwgdCA+IDEgJiYgKHQgLT0gMSksIHQgPCAxIC8gNiA/IGggKyAoZSAtIGgpICogNiAqIHQgOiB0IDwgMSAvIDIgPyBlIDogdCA8IDIgLyAzID8gaCArIChlIC0gaCkgKiA2ICogKDIgLyAzIC0gdCkgOiBoO1xufVxuZnVuY3Rpb24gX2koaCwgZSkge1xuICByZXR1cm4gZS5yID0gaC5yLCBlLmcgPSBoLmcsIGUuYiA9IGguYiwgZTtcbn1cbmNsYXNzIEFlIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHJldHVybiB0aGlzLmlzQ29sb3IgPSAhMCwgdGhpcy5yID0gMSwgdGhpcy5nID0gMSwgdGhpcy5iID0gMSwgdCA9PT0gdm9pZCAwICYmIG4gPT09IHZvaWQgMCA/IHRoaXMuc2V0KGUpIDogdGhpcy5zZXRSR0IoZSwgdCwgbik7XG4gIH1cbiAgc2V0KGUpIHtcbiAgICByZXR1cm4gZSAmJiBlLmlzQ29sb3IgPyB0aGlzLmNvcHkoZSkgOiB0eXBlb2YgZSA9PSBcIm51bWJlclwiID8gdGhpcy5zZXRIZXgoZSkgOiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiICYmIHRoaXMuc2V0U3R5bGUoZSksIHRoaXM7XG4gIH1cbiAgc2V0U2NhbGFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5yID0gZSwgdGhpcy5nID0gZSwgdGhpcy5iID0gZSwgdGhpcztcbiAgfVxuICBzZXRIZXgoZSwgdCA9IEp0KSB7XG4gICAgcmV0dXJuIGUgPSBNYXRoLmZsb29yKGUpLCB0aGlzLnIgPSAoZSA+PiAxNiAmIDI1NSkgLyAyNTUsIHRoaXMuZyA9IChlID4+IDggJiAyNTUpIC8gMjU1LCB0aGlzLmIgPSAoZSAmIDI1NSkgLyAyNTUsIFN0LnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcywgdCksIHRoaXM7XG4gIH1cbiAgc2V0UkdCKGUsIHQsIG4sIGkgPSB5bikge1xuICAgIHJldHVybiB0aGlzLnIgPSBlLCB0aGlzLmcgPSB0LCB0aGlzLmIgPSBuLCBTdC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGkpLCB0aGlzO1xuICB9XG4gIHNldEhTTChlLCB0LCBuLCBpID0geW4pIHtcbiAgICBpZiAoZSA9IE5vKGUsIDEpLCB0ID0gbXQodCwgMCwgMSksIG4gPSBtdChuLCAwLCAxKSwgdCA9PT0gMClcbiAgICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IG47XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBzID0gbiA8PSAwLjUgPyBuICogKDEgKyB0KSA6IG4gKyB0IC0gbiAqIHQsIG8gPSAyICogbiAtIHM7XG4gICAgICB0aGlzLnIgPSBucyhvLCBzLCBlICsgMSAvIDMpLCB0aGlzLmcgPSBucyhvLCBzLCBlKSwgdGhpcy5iID0gbnMobywgcywgZSAtIDEgLyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0LnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcywgaSksIHRoaXM7XG4gIH1cbiAgc2V0U3R5bGUoZSwgdCA9IEp0KSB7XG4gICAgZnVuY3Rpb24gbihzKSB7XG4gICAgICBzICE9PSB2b2lkIDAgJiYgcGFyc2VGbG9hdChzKSA8IDEgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiBcIiArIGUgKyBcIiB3aWxsIGJlIGlnbm9yZWQuXCIpO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBpZiAoaSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoKFteXFwpXSopXFwpLy5leGVjKGUpKSB7XG4gICAgICBsZXQgcztcbiAgICAgIGNvbnN0IG8gPSBpWzFdLCByID0gaVsyXTtcbiAgICAgIHN3aXRjaCAobykge1xuICAgICAgICBjYXNlIFwicmdiXCI6XG4gICAgICAgIGNhc2UgXCJyZ2JhXCI6XG4gICAgICAgICAgaWYgKHMgPSAvXlxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMocikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yID0gTWF0aC5taW4oMjU1LCBwYXJzZUludChzWzFdLCAxMCkpIC8gMjU1LCB0aGlzLmcgPSBNYXRoLm1pbigyNTUsIHBhcnNlSW50KHNbMl0sIDEwKSkgLyAyNTUsIHRoaXMuYiA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoc1szXSwgMTApKSAvIDI1NSwgU3QudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLCB0KSwgbihzWzRdKSwgdGhpcztcbiAgICAgICAgICBpZiAocyA9IC9eXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyhyKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnIgPSBNYXRoLm1pbigxMDAsIHBhcnNlSW50KHNbMV0sIDEwKSkgLyAxMDAsIHRoaXMuZyA9IE1hdGgubWluKDEwMCwgcGFyc2VJbnQoc1syXSwgMTApKSAvIDEwMCwgdGhpcy5iID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChzWzNdLCAxMCkpIC8gMTAwLCBTdC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIHQpLCBuKHNbNF0pLCB0aGlzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaHNsXCI6XG4gICAgICAgIGNhc2UgXCJoc2xhXCI6XG4gICAgICAgICAgaWYgKHMgPSAvXlxccyooXFxkKlxcLj9cXGQrKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyhyKSkge1xuICAgICAgICAgICAgY29uc3QgbCA9IHBhcnNlRmxvYXQoc1sxXSkgLyAzNjAsIGEgPSBwYXJzZUludChzWzJdLCAxMCkgLyAxMDAsIGMgPSBwYXJzZUludChzWzNdLCAxMCkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gbihzWzRdKSwgdGhpcy5zZXRIU0wobCwgYSwgYywgdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaSA9IC9eXFwjKFtBLUZhLWZcXGRdKykkLy5leGVjKGUpKSB7XG4gICAgICBjb25zdCBzID0gaVsxXSwgbyA9IHMubGVuZ3RoO1xuICAgICAgaWYgKG8gPT09IDMpXG4gICAgICAgIHJldHVybiB0aGlzLnIgPSBwYXJzZUludChzLmNoYXJBdCgwKSArIHMuY2hhckF0KDApLCAxNikgLyAyNTUsIHRoaXMuZyA9IHBhcnNlSW50KHMuY2hhckF0KDEpICsgcy5jaGFyQXQoMSksIDE2KSAvIDI1NSwgdGhpcy5iID0gcGFyc2VJbnQocy5jaGFyQXQoMikgKyBzLmNoYXJBdCgyKSwgMTYpIC8gMjU1LCBTdC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIHQpLCB0aGlzO1xuICAgICAgaWYgKG8gPT09IDYpXG4gICAgICAgIHJldHVybiB0aGlzLnIgPSBwYXJzZUludChzLmNoYXJBdCgwKSArIHMuY2hhckF0KDEpLCAxNikgLyAyNTUsIHRoaXMuZyA9IHBhcnNlSW50KHMuY2hhckF0KDIpICsgcy5jaGFyQXQoMyksIDE2KSAvIDI1NSwgdGhpcy5iID0gcGFyc2VJbnQocy5jaGFyQXQoNCkgKyBzLmNoYXJBdCg1KSwgMTYpIC8gMjU1LCBTdC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIHQpLCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZSAmJiBlLmxlbmd0aCA+IDAgPyB0aGlzLnNldENvbG9yTmFtZShlLCB0KSA6IHRoaXM7XG4gIH1cbiAgc2V0Q29sb3JOYW1lKGUsIHQgPSBKdCkge1xuICAgIGNvbnN0IG4gPSBub1tlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBuICE9PSB2b2lkIDAgPyB0aGlzLnNldEhleChuLCB0KSA6IGNvbnNvbGUud2FybihcIlRIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yIFwiICsgZSksIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLnIgPSBlLnIsIHRoaXMuZyA9IGUuZywgdGhpcy5iID0gZS5iLCB0aGlzO1xuICB9XG4gIGNvcHlTUkdCVG9MaW5lYXIoZSkge1xuICAgIHJldHVybiB0aGlzLnIgPSBibihlLnIpLCB0aGlzLmcgPSBibihlLmcpLCB0aGlzLmIgPSBibihlLmIpLCB0aGlzO1xuICB9XG4gIGNvcHlMaW5lYXJUb1NSR0IoZSkge1xuICAgIHJldHVybiB0aGlzLnIgPSBXaShlLnIpLCB0aGlzLmcgPSBXaShlLmcpLCB0aGlzLmIgPSBXaShlLmIpLCB0aGlzO1xuICB9XG4gIGNvbnZlcnRTUkdCVG9MaW5lYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weVNSR0JUb0xpbmVhcih0aGlzKSwgdGhpcztcbiAgfVxuICBjb252ZXJ0TGluZWFyVG9TUkdCKCkge1xuICAgIHJldHVybiB0aGlzLmNvcHlMaW5lYXJUb1NSR0IodGhpcyksIHRoaXM7XG4gIH1cbiAgZ2V0SGV4KGUgPSBKdCkge1xuICAgIHJldHVybiBTdC5mcm9tV29ya2luZ0NvbG9yU3BhY2UoX2kodGhpcywgWWUpLCBlKSwgbXQoWWUuciAqIDI1NSwgMCwgMjU1KSA8PCAxNiBeIG10KFllLmcgKiAyNTUsIDAsIDI1NSkgPDwgOCBeIG10KFllLmIgKiAyNTUsIDAsIDI1NSkgPDwgMDtcbiAgfVxuICBnZXRIZXhTdHJpbmcoZSA9IEp0KSB7XG4gICAgcmV0dXJuIChcIjAwMDAwMFwiICsgdGhpcy5nZXRIZXgoZSkudG9TdHJpbmcoMTYpKS5zbGljZSgtNik7XG4gIH1cbiAgZ2V0SFNMKGUsIHQgPSB5bikge1xuICAgIFN0LmZyb21Xb3JraW5nQ29sb3JTcGFjZShfaSh0aGlzLCBZZSksIHQpO1xuICAgIGNvbnN0IG4gPSBZZS5yLCBpID0gWWUuZywgcyA9IFllLmIsIG8gPSBNYXRoLm1heChuLCBpLCBzKSwgciA9IE1hdGgubWluKG4sIGksIHMpO1xuICAgIGxldCBsLCBhO1xuICAgIGNvbnN0IGMgPSAociArIG8pIC8gMjtcbiAgICBpZiAociA9PT0gbylcbiAgICAgIGwgPSAwLCBhID0gMDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGQgPSBvIC0gcjtcbiAgICAgIHN3aXRjaCAoYSA9IGMgPD0gMC41ID8gZCAvIChvICsgcikgOiBkIC8gKDIgLSBvIC0gciksIG8pIHtcbiAgICAgICAgY2FzZSBuOlxuICAgICAgICAgIGwgPSAoaSAtIHMpIC8gZCArIChpIDwgcyA/IDYgOiAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpOlxuICAgICAgICAgIGwgPSAocyAtIG4pIC8gZCArIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgczpcbiAgICAgICAgICBsID0gKG4gLSBpKSAvIGQgKyA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbCAvPSA2O1xuICAgIH1cbiAgICByZXR1cm4gZS5oID0gbCwgZS5zID0gYSwgZS5sID0gYywgZTtcbiAgfVxuICBnZXRSR0IoZSwgdCA9IHluKSB7XG4gICAgcmV0dXJuIFN0LmZyb21Xb3JraW5nQ29sb3JTcGFjZShfaSh0aGlzLCBZZSksIHQpLCBlLnIgPSBZZS5yLCBlLmcgPSBZZS5nLCBlLmIgPSBZZS5iLCBlO1xuICB9XG4gIGdldFN0eWxlKGUgPSBKdCkge1xuICAgIHJldHVybiBTdC5mcm9tV29ya2luZ0NvbG9yU3BhY2UoX2kodGhpcywgWWUpLCBlKSwgZSAhPT0gSnQgPyBgY29sb3IoJHtlfSAke1llLnJ9ICR7WWUuZ30gJHtZZS5ifSlgIDogYHJnYigke1llLnIgKiAyNTUgfCAwfSwke1llLmcgKiAyNTUgfCAwfSwke1llLmIgKiAyNTUgfCAwfSlgO1xuICB9XG4gIG9mZnNldEhTTChlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SFNMKEV0KSwgRXQuaCArPSBlLCBFdC5zICs9IHQsIEV0LmwgKz0gbiwgdGhpcy5zZXRIU0woRXQuaCwgRXQucywgRXQubCksIHRoaXM7XG4gIH1cbiAgYWRkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5yICs9IGUuciwgdGhpcy5nICs9IGUuZywgdGhpcy5iICs9IGUuYiwgdGhpcztcbiAgfVxuICBhZGRDb2xvcnMoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnIgPSBlLnIgKyB0LnIsIHRoaXMuZyA9IGUuZyArIHQuZywgdGhpcy5iID0gZS5iICsgdC5iLCB0aGlzO1xuICB9XG4gIGFkZFNjYWxhcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuciArPSBlLCB0aGlzLmcgKz0gZSwgdGhpcy5iICs9IGUsIHRoaXM7XG4gIH1cbiAgc3ViKGUpIHtcbiAgICByZXR1cm4gdGhpcy5yID0gTWF0aC5tYXgoMCwgdGhpcy5yIC0gZS5yKSwgdGhpcy5nID0gTWF0aC5tYXgoMCwgdGhpcy5nIC0gZS5nKSwgdGhpcy5iID0gTWF0aC5tYXgoMCwgdGhpcy5iIC0gZS5iKSwgdGhpcztcbiAgfVxuICBtdWx0aXBseShlKSB7XG4gICAgcmV0dXJuIHRoaXMuciAqPSBlLnIsIHRoaXMuZyAqPSBlLmcsIHRoaXMuYiAqPSBlLmIsIHRoaXM7XG4gIH1cbiAgbXVsdGlwbHlTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLnIgKj0gZSwgdGhpcy5nICo9IGUsIHRoaXMuYiAqPSBlLCB0aGlzO1xuICB9XG4gIGxlcnAoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnIgKz0gKGUuciAtIHRoaXMucikgKiB0LCB0aGlzLmcgKz0gKGUuZyAtIHRoaXMuZykgKiB0LCB0aGlzLmIgKz0gKGUuYiAtIHRoaXMuYikgKiB0LCB0aGlzO1xuICB9XG4gIGxlcnBDb2xvcnMoZSwgdCwgbikge1xuICAgIHJldHVybiB0aGlzLnIgPSBlLnIgKyAodC5yIC0gZS5yKSAqIG4sIHRoaXMuZyA9IGUuZyArICh0LmcgLSBlLmcpICogbiwgdGhpcy5iID0gZS5iICsgKHQuYiAtIGUuYikgKiBuLCB0aGlzO1xuICB9XG4gIGxlcnBIU0woZSwgdCkge1xuICAgIHRoaXMuZ2V0SFNMKEV0KSwgZS5nZXRIU0woZ2kpO1xuICAgIGNvbnN0IG4gPSBlcyhFdC5oLCBnaS5oLCB0KSwgaSA9IGVzKEV0LnMsIGdpLnMsIHQpLCBzID0gZXMoRXQubCwgZ2kubCwgdCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0SFNMKG4sIGksIHMpLCB0aGlzO1xuICB9XG4gIGVxdWFscyhlKSB7XG4gICAgcmV0dXJuIGUuciA9PT0gdGhpcy5yICYmIGUuZyA9PT0gdGhpcy5nICYmIGUuYiA9PT0gdGhpcy5iO1xuICB9XG4gIGZyb21BcnJheShlLCB0ID0gMCkge1xuICAgIHJldHVybiB0aGlzLnIgPSBlW3RdLCB0aGlzLmcgPSBlW3QgKyAxXSwgdGhpcy5iID0gZVt0ICsgMl0sIHRoaXM7XG4gIH1cbiAgdG9BcnJheShlID0gW10sIHQgPSAwKSB7XG4gICAgcmV0dXJuIGVbdF0gPSB0aGlzLnIsIGVbdCArIDFdID0gdGhpcy5nLCBlW3QgKyAyXSA9IHRoaXMuYiwgZTtcbiAgfVxuICBmcm9tQnVmZmVyQXR0cmlidXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5yID0gZS5nZXRYKHQpLCB0aGlzLmcgPSBlLmdldFkodCksIHRoaXMuYiA9IGUuZ2V0Wih0KSwgZS5ub3JtYWxpemVkID09PSAhMCAmJiAodGhpcy5yIC89IDI1NSwgdGhpcy5nIC89IDI1NSwgdGhpcy5iIC89IDI1NSksIHRoaXM7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmdldEhleCgpO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICB5aWVsZCB0aGlzLnIsIHlpZWxkIHRoaXMuZywgeWllbGQgdGhpcy5iO1xuICB9XG59XG5BZS5OQU1FUyA9IG5vO1xubGV0IEZuO1xuY2xhc3MgaW8ge1xuICBzdGF0aWMgZ2V0RGF0YVVSTChlKSB7XG4gICAgaWYgKC9eZGF0YTovaS50ZXN0KGUuc3JjKSB8fCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgPiBcInVcIilcbiAgICAgIHJldHVybiBlLnNyYztcbiAgICBsZXQgdDtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KVxuICAgICAgdCA9IGU7XG4gICAgZWxzZSB7XG4gICAgICBGbiA9PT0gdm9pZCAwICYmIChGbiA9IHFpKFwiY2FudmFzXCIpKSwgRm4ud2lkdGggPSBlLndpZHRoLCBGbi5oZWlnaHQgPSBlLmhlaWdodDtcbiAgICAgIGNvbnN0IG4gPSBGbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBlIGluc3RhbmNlb2YgSW1hZ2VEYXRhID8gbi5wdXRJbWFnZURhdGEoZSwgMCwgMCkgOiBuLmRyYXdJbWFnZShlLCAwLCAwLCBlLndpZHRoLCBlLmhlaWdodCksIHQgPSBGbjtcbiAgICB9XG4gICAgcmV0dXJuIHQud2lkdGggPiAyMDQ4IHx8IHQuaGVpZ2h0ID4gMjA0OCA/IChjb25zb2xlLndhcm4oXCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcIiwgZSksIHQudG9EYXRhVVJMKFwiaW1hZ2UvanBlZ1wiLCAwLjYpKSA6IHQudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9XG4gIHN0YXRpYyBzUkdCVG9MaW5lYXIoZSkge1xuICAgIGlmICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCA8IFwidVwiICYmIGUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCA8IFwidVwiICYmIGUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCB0eXBlb2YgSW1hZ2VCaXRtYXAgPCBcInVcIiAmJiBlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgIGNvbnN0IHQgPSBxaShcImNhbnZhc1wiKTtcbiAgICAgIHQud2lkdGggPSBlLndpZHRoLCB0LmhlaWdodCA9IGUuaGVpZ2h0O1xuICAgICAgY29uc3QgbiA9IHQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgbi5kcmF3SW1hZ2UoZSwgMCwgMCwgZS53aWR0aCwgZS5oZWlnaHQpO1xuICAgICAgY29uc3QgaSA9IG4uZ2V0SW1hZ2VEYXRhKDAsIDAsIGUud2lkdGgsIGUuaGVpZ2h0KSwgcyA9IGkuZGF0YTtcbiAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKylcbiAgICAgICAgc1tvXSA9IGJuKHNbb10gLyAyNTUpICogMjU1O1xuICAgICAgcmV0dXJuIG4ucHV0SW1hZ2VEYXRhKGksIDAsIDApLCB0O1xuICAgIH0gZWxzZSBpZiAoZS5kYXRhKSB7XG4gICAgICBjb25zdCB0ID0gZS5kYXRhLnNsaWNlKDApO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgICAgICB0IGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgPyB0W25dID0gTWF0aC5mbG9vcihibih0W25dIC8gMjU1KSAqIDI1NSkgOiB0W25dID0gYm4odFtuXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB0LFxuICAgICAgICB3aWR0aDogZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlLmhlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5JbWFnZVV0aWxzLnNSR0JUb0xpbmVhcigpOiBVbnN1cHBvcnRlZCBpbWFnZSB0eXBlLiBObyBjb2xvciBzcGFjZSBjb252ZXJzaW9uIGFwcGxpZWQuXCIpLCBlO1xuICB9XG59XG5jbGFzcyBzbyB7XG4gIGNvbnN0cnVjdG9yKGUgPSBudWxsKSB7XG4gICAgdGhpcy5pc1NvdXJjZSA9ICEwLCB0aGlzLnV1aWQgPSBoaSgpLCB0aGlzLmRhdGEgPSBlLCB0aGlzLnZlcnNpb24gPSAwO1xuICB9XG4gIHNldCBuZWVkc1VwZGF0ZShlKSB7XG4gICAgZSA9PT0gITAgJiYgdGhpcy52ZXJzaW9uKys7XG4gIH1cbiAgdG9KU09OKGUpIHtcbiAgICBjb25zdCB0ID0gZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwic3RyaW5nXCI7XG4gICAgaWYgKCF0ICYmIGUuaW1hZ2VzW3RoaXMudXVpZF0gIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBlLmltYWdlc1t0aGlzLnV1aWRdO1xuICAgIGNvbnN0IG4gPSB7XG4gICAgICB1dWlkOiB0aGlzLnV1aWQsXG4gICAgICB1cmw6IFwiXCJcbiAgICB9LCBpID0gdGhpcy5kYXRhO1xuICAgIGlmIChpICE9PSBudWxsKSB7XG4gICAgICBsZXQgcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGkpKSB7XG4gICAgICAgIHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbyA9IDAsIHIgPSBpLmxlbmd0aDsgbyA8IHI7IG8rKylcbiAgICAgICAgICBpW29dLmlzRGF0YVRleHR1cmUgPyBzLnB1c2goaXMoaVtvXS5pbWFnZSkpIDogcy5wdXNoKGlzKGlbb10pKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBzID0gaXMoaSk7XG4gICAgICBuLnVybCA9IHM7XG4gICAgfVxuICAgIHJldHVybiB0IHx8IChlLmltYWdlc1t0aGlzLnV1aWRdID0gbiksIG47XG4gIH1cbn1cbmZ1bmN0aW9uIGlzKGgpIHtcbiAgcmV0dXJuIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50IDwgXCJ1XCIgJiYgaCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50IDwgXCJ1XCIgJiYgaCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IHR5cGVvZiBJbWFnZUJpdG1hcCA8IFwidVwiICYmIGggaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCA/IGlvLmdldERhdGFVUkwoaCkgOiBoLmRhdGEgPyB7XG4gICAgZGF0YTogQXJyYXkuZnJvbShoLmRhdGEpLFxuICAgIHdpZHRoOiBoLndpZHRoLFxuICAgIGhlaWdodDogaC5oZWlnaHQsXG4gICAgdHlwZTogaC5kYXRhLmNvbnN0cnVjdG9yLm5hbWVcbiAgfSA6IChjb25zb2xlLndhcm4oXCJUSFJFRS5UZXh0dXJlOiBVbmFibGUgdG8gc2VyaWFsaXplIFRleHR1cmUuXCIpLCB7fSk7XG59XG5sZXQgT28gPSAwO1xuY2xhc3MgX3QgZXh0ZW5kcyAkbiB7XG4gIGNvbnN0cnVjdG9yKGUgPSBfdC5ERUZBVUxUX0lNQUdFLCB0ID0gX3QuREVGQVVMVF9NQVBQSU5HLCBuID0gMTAwMSwgaSA9IDEwMDEsIHMgPSAxMDA2LCBvID0gMTAwOCwgciA9IDEwMjMsIGwgPSAxMDA5LCBhID0gMSwgYyA9IDNlMykge1xuICAgIHN1cGVyKCksIHRoaXMuaXNUZXh0dXJlID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHsgdmFsdWU6IE9vKysgfSksIHRoaXMudXVpZCA9IGhpKCksIHRoaXMubmFtZSA9IFwiXCIsIHRoaXMuc291cmNlID0gbmV3IHNvKGUpLCB0aGlzLm1pcG1hcHMgPSBbXSwgdGhpcy5tYXBwaW5nID0gdCwgdGhpcy53cmFwUyA9IG4sIHRoaXMud3JhcFQgPSBpLCB0aGlzLm1hZ0ZpbHRlciA9IHMsIHRoaXMubWluRmlsdGVyID0gbywgdGhpcy5hbmlzb3Ryb3B5ID0gYSwgdGhpcy5mb3JtYXQgPSByLCB0aGlzLmludGVybmFsRm9ybWF0ID0gbnVsbCwgdGhpcy50eXBlID0gbCwgdGhpcy5vZmZzZXQgPSBuZXcgQ2UoMCwgMCksIHRoaXMucmVwZWF0ID0gbmV3IENlKDEsIDEpLCB0aGlzLmNlbnRlciA9IG5ldyBDZSgwLCAwKSwgdGhpcy5yb3RhdGlvbiA9IDAsIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9ICEwLCB0aGlzLm1hdHJpeCA9IG5ldyBNdCgpLCB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9ICEwLCB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSAhMSwgdGhpcy5mbGlwWSA9ICEwLCB0aGlzLnVucGFja0FsaWdubWVudCA9IDQsIHRoaXMuZW5jb2RpbmcgPSBjLCB0aGlzLnVzZXJEYXRhID0ge30sIHRoaXMudmVyc2lvbiA9IDAsIHRoaXMub25VcGRhdGUgPSBudWxsLCB0aGlzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9ICExLCB0aGlzLm5lZWRzUE1SRU1VcGRhdGUgPSAhMTtcbiAgfVxuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmRhdGE7XG4gIH1cbiAgc2V0IGltYWdlKGUpIHtcbiAgICB0aGlzLnNvdXJjZS5kYXRhID0gZTtcbiAgfVxuICB1cGRhdGVNYXRyaXgoKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0odGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSwgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSwgdGhpcy5yb3RhdGlvbiwgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lID0gZS5uYW1lLCB0aGlzLnNvdXJjZSA9IGUuc291cmNlLCB0aGlzLm1pcG1hcHMgPSBlLm1pcG1hcHMuc2xpY2UoMCksIHRoaXMubWFwcGluZyA9IGUubWFwcGluZywgdGhpcy53cmFwUyA9IGUud3JhcFMsIHRoaXMud3JhcFQgPSBlLndyYXBULCB0aGlzLm1hZ0ZpbHRlciA9IGUubWFnRmlsdGVyLCB0aGlzLm1pbkZpbHRlciA9IGUubWluRmlsdGVyLCB0aGlzLmFuaXNvdHJvcHkgPSBlLmFuaXNvdHJvcHksIHRoaXMuZm9ybWF0ID0gZS5mb3JtYXQsIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBlLmludGVybmFsRm9ybWF0LCB0aGlzLnR5cGUgPSBlLnR5cGUsIHRoaXMub2Zmc2V0LmNvcHkoZS5vZmZzZXQpLCB0aGlzLnJlcGVhdC5jb3B5KGUucmVwZWF0KSwgdGhpcy5jZW50ZXIuY29weShlLmNlbnRlciksIHRoaXMucm90YXRpb24gPSBlLnJvdGF0aW9uLCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBlLm1hdHJpeEF1dG9VcGRhdGUsIHRoaXMubWF0cml4LmNvcHkoZS5tYXRyaXgpLCB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGUuZ2VuZXJhdGVNaXBtYXBzLCB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBlLnByZW11bHRpcGx5QWxwaGEsIHRoaXMuZmxpcFkgPSBlLmZsaXBZLCB0aGlzLnVucGFja0FsaWdubWVudCA9IGUudW5wYWNrQWxpZ25tZW50LCB0aGlzLmVuY29kaW5nID0gZS5lbmNvZGluZywgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLCB0aGlzLm5lZWRzVXBkYXRlID0gITAsIHRoaXM7XG4gIH1cbiAgdG9KU09OKGUpIHtcbiAgICBjb25zdCB0ID0gZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwic3RyaW5nXCI7XG4gICAgaWYgKCF0ICYmIGUudGV4dHVyZXNbdGhpcy51dWlkXSAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGUudGV4dHVyZXNbdGhpcy51dWlkXTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC41LFxuICAgICAgICB0eXBlOiBcIlRleHR1cmVcIixcbiAgICAgICAgZ2VuZXJhdG9yOiBcIlRleHR1cmUudG9KU09OXCJcbiAgICAgIH0sXG4gICAgICB1dWlkOiB0aGlzLnV1aWQsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBpbWFnZTogdGhpcy5zb3VyY2UudG9KU09OKGUpLnV1aWQsXG4gICAgICBtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG4gICAgICByZXBlYXQ6IFt0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55XSxcbiAgICAgIG9mZnNldDogW3RoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnldLFxuICAgICAgY2VudGVyOiBbdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueV0sXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHdyYXA6IFt0aGlzLndyYXBTLCB0aGlzLndyYXBUXSxcbiAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBlbmNvZGluZzogdGhpcy5lbmNvZGluZyxcbiAgICAgIG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXG4gICAgICBtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxuICAgICAgYW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5LFxuICAgICAgZmxpcFk6IHRoaXMuZmxpcFksXG4gICAgICBwcmVtdWx0aXBseUFscGhhOiB0aGlzLnByZW11bHRpcGx5QWxwaGEsXG4gICAgICB1bnBhY2tBbGlnbm1lbnQ6IHRoaXMudW5wYWNrQWxpZ25tZW50XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy51c2VyRGF0YSkgIT09IFwie31cIiAmJiAobi51c2VyRGF0YSA9IHRoaXMudXNlckRhdGEpLCB0IHx8IChlLnRleHR1cmVzW3RoaXMudXVpZF0gPSBuKSwgbjtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiZGlzcG9zZVwiIH0pO1xuICB9XG4gIHRyYW5zZm9ybVV2KGUpIHtcbiAgICBpZiAodGhpcy5tYXBwaW5nICE9PSAzMDApXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAoZS5hcHBseU1hdHJpeDModGhpcy5tYXRyaXgpLCBlLnggPCAwIHx8IGUueCA+IDEpXG4gICAgICBzd2l0Y2ggKHRoaXMud3JhcFMpIHtcbiAgICAgICAgY2FzZSAxZTM6XG4gICAgICAgICAgZS54ID0gZS54IC0gTWF0aC5mbG9vcihlLngpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwMDE6XG4gICAgICAgICAgZS54ID0gZS54IDwgMCA/IDAgOiAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwMDI6XG4gICAgICAgICAgTWF0aC5hYnMoTWF0aC5mbG9vcihlLngpICUgMikgPT09IDEgPyBlLnggPSBNYXRoLmNlaWwoZS54KSAtIGUueCA6IGUueCA9IGUueCAtIE1hdGguZmxvb3IoZS54KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBpZiAoZS55IDwgMCB8fCBlLnkgPiAxKVxuICAgICAgc3dpdGNoICh0aGlzLndyYXBUKSB7XG4gICAgICAgIGNhc2UgMWUzOlxuICAgICAgICAgIGUueSA9IGUueSAtIE1hdGguZmxvb3IoZS55KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDAxOlxuICAgICAgICAgIGUueSA9IGUueSA8IDAgPyAwIDogMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDAyOlxuICAgICAgICAgIE1hdGguYWJzKE1hdGguZmxvb3IoZS55KSAlIDIpID09PSAxID8gZS55ID0gTWF0aC5jZWlsKGUueSkgLSBlLnkgOiBlLnkgPSBlLnkgLSBNYXRoLmZsb29yKGUueSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmxpcFkgJiYgKGUueSA9IDEgLSBlLnkpLCBlO1xuICB9XG4gIHNldCBuZWVkc1VwZGF0ZShlKSB7XG4gICAgZSA9PT0gITAgJiYgKHRoaXMudmVyc2lvbisrLCB0aGlzLnNvdXJjZS5uZWVkc1VwZGF0ZSA9ICEwKTtcbiAgfVxufVxuX3QuREVGQVVMVF9JTUFHRSA9IG51bGw7XG5fdC5ERUZBVUxUX01BUFBJTkcgPSAzMDA7XG5jbGFzcyAkZSB7XG4gIGNvbnN0cnVjdG9yKGUgPSAwLCB0ID0gMCwgbiA9IDAsIGkgPSAxKSB7XG4gICAgJGUucHJvdG90eXBlLmlzVmVjdG9yNCA9ICEwLCB0aGlzLnggPSBlLCB0aGlzLnkgPSB0LCB0aGlzLnogPSBuLCB0aGlzLncgPSBpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy56O1xuICB9XG4gIHNldCB3aWR0aChlKSB7XG4gICAgdGhpcy56ID0gZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnc7XG4gIH1cbiAgc2V0IGhlaWdodChlKSB7XG4gICAgdGhpcy53ID0gZTtcbiAgfVxuICBzZXQoZSwgdCwgbiwgaSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzLnkgPSB0LCB0aGlzLnogPSBuLCB0aGlzLncgPSBpLCB0aGlzO1xuICB9XG4gIHNldFNjYWxhcihlKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUsIHRoaXMueSA9IGUsIHRoaXMueiA9IGUsIHRoaXMudyA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0WChlKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0WShlKSB7XG4gICAgcmV0dXJuIHRoaXMueSA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0WihlKSB7XG4gICAgcmV0dXJuIHRoaXMueiA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0VyhlKSB7XG4gICAgcmV0dXJuIHRoaXMudyA9IGUsIHRoaXM7XG4gIH1cbiAgc2V0Q29tcG9uZW50KGUsIHQpIHtcbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy54ID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMueSA9IHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLnogPSB0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhpcy53ID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldENvbXBvbmVudChlKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLno7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLnc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgZSk7XG4gICAgfVxuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLngsIHRoaXMueSA9IGUueSwgdGhpcy56ID0gZS56LCB0aGlzLncgPSBlLncgIT09IHZvaWQgMCA/IGUudyA6IDEsIHRoaXM7XG4gIH1cbiAgYWRkKGUpIHtcbiAgICByZXR1cm4gdGhpcy54ICs9IGUueCwgdGhpcy55ICs9IGUueSwgdGhpcy56ICs9IGUueiwgdGhpcy53ICs9IGUudywgdGhpcztcbiAgfVxuICBhZGRTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLnggKz0gZSwgdGhpcy55ICs9IGUsIHRoaXMueiArPSBlLCB0aGlzLncgKz0gZSwgdGhpcztcbiAgfVxuICBhZGRWZWN0b3JzKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZS54ICsgdC54LCB0aGlzLnkgPSBlLnkgKyB0LnksIHRoaXMueiA9IGUueiArIHQueiwgdGhpcy53ID0gZS53ICsgdC53LCB0aGlzO1xuICB9XG4gIGFkZFNjYWxlZFZlY3RvcihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCArPSBlLnggKiB0LCB0aGlzLnkgKz0gZS55ICogdCwgdGhpcy56ICs9IGUueiAqIHQsIHRoaXMudyArPSBlLncgKiB0LCB0aGlzO1xuICB9XG4gIHN1YihlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAtPSBlLngsIHRoaXMueSAtPSBlLnksIHRoaXMueiAtPSBlLnosIHRoaXMudyAtPSBlLncsIHRoaXM7XG4gIH1cbiAgc3ViU2NhbGFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy54IC09IGUsIHRoaXMueSAtPSBlLCB0aGlzLnogLT0gZSwgdGhpcy53IC09IGUsIHRoaXM7XG4gIH1cbiAgc3ViVmVjdG9ycyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUueCAtIHQueCwgdGhpcy55ID0gZS55IC0gdC55LCB0aGlzLnogPSBlLnogLSB0LnosIHRoaXMudyA9IGUudyAtIHQudywgdGhpcztcbiAgfVxuICBtdWx0aXBseShlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqPSBlLngsIHRoaXMueSAqPSBlLnksIHRoaXMueiAqPSBlLnosIHRoaXMudyAqPSBlLncsIHRoaXM7XG4gIH1cbiAgbXVsdGlwbHlTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLnggKj0gZSwgdGhpcy55ICo9IGUsIHRoaXMueiAqPSBlLCB0aGlzLncgKj0gZSwgdGhpcztcbiAgfVxuICBhcHBseU1hdHJpeDQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLngsIG4gPSB0aGlzLnksIGkgPSB0aGlzLnosIHMgPSB0aGlzLncsIG8gPSBlLmVsZW1lbnRzO1xuICAgIHJldHVybiB0aGlzLnggPSBvWzBdICogdCArIG9bNF0gKiBuICsgb1s4XSAqIGkgKyBvWzEyXSAqIHMsIHRoaXMueSA9IG9bMV0gKiB0ICsgb1s1XSAqIG4gKyBvWzldICogaSArIG9bMTNdICogcywgdGhpcy56ID0gb1syXSAqIHQgKyBvWzZdICogbiArIG9bMTBdICogaSArIG9bMTRdICogcywgdGhpcy53ID0gb1szXSAqIHQgKyBvWzddICogbiArIG9bMTFdICogaSArIG9bMTVdICogcywgdGhpcztcbiAgfVxuICBkaXZpZGVTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBlKTtcbiAgfVxuICBzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbihlKSB7XG4gICAgdGhpcy53ID0gMiAqIE1hdGguYWNvcyhlLncpO1xuICAgIGNvbnN0IHQgPSBNYXRoLnNxcnQoMSAtIGUudyAqIGUudyk7XG4gICAgcmV0dXJuIHQgPCAxZS00ID8gKHRoaXMueCA9IDEsIHRoaXMueSA9IDAsIHRoaXMueiA9IDApIDogKHRoaXMueCA9IGUueCAvIHQsIHRoaXMueSA9IGUueSAvIHQsIHRoaXMueiA9IGUueiAvIHQpLCB0aGlzO1xuICB9XG4gIHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeChlKSB7XG4gICAgbGV0IHQsIG4sIGksIHM7XG4gICAgY29uc3QgbCA9IGUuZWxlbWVudHMsIGEgPSBsWzBdLCBjID0gbFs0XSwgZCA9IGxbOF0sIHUgPSBsWzFdLCBtID0gbFs1XSwgZyA9IGxbOV0sIHAgPSBsWzJdLCBmID0gbFs2XSwgdiA9IGxbMTBdO1xuICAgIGlmIChNYXRoLmFicyhjIC0gdSkgPCAwLjAxICYmIE1hdGguYWJzKGQgLSBwKSA8IDAuMDEgJiYgTWF0aC5hYnMoZyAtIGYpIDwgMC4wMSkge1xuICAgICAgaWYgKE1hdGguYWJzKGMgKyB1KSA8IDAuMSAmJiBNYXRoLmFicyhkICsgcCkgPCAwLjEgJiYgTWF0aC5hYnMoZyArIGYpIDwgMC4xICYmIE1hdGguYWJzKGEgKyBtICsgdiAtIDMpIDwgMC4xKVxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoMSwgMCwgMCwgMCksIHRoaXM7XG4gICAgICB0ID0gTWF0aC5QSTtcbiAgICAgIGNvbnN0IHcgPSAoYSArIDEpIC8gMiwgeCA9IChtICsgMSkgLyAyLCBNID0gKHYgKyAxKSAvIDIsIEUgPSAoYyArIHUpIC8gNCwgUiA9IChkICsgcCkgLyA0LCB5ID0gKGcgKyBmKSAvIDQ7XG4gICAgICByZXR1cm4gdyA+IHggJiYgdyA+IE0gPyB3IDwgMC4wMSA/IChuID0gMCwgaSA9IDAuNzA3MTA2NzgxLCBzID0gMC43MDcxMDY3ODEpIDogKG4gPSBNYXRoLnNxcnQodyksIGkgPSBFIC8gbiwgcyA9IFIgLyBuKSA6IHggPiBNID8geCA8IDAuMDEgPyAobiA9IDAuNzA3MTA2NzgxLCBpID0gMCwgcyA9IDAuNzA3MTA2NzgxKSA6IChpID0gTWF0aC5zcXJ0KHgpLCBuID0gRSAvIGksIHMgPSB5IC8gaSkgOiBNIDwgMC4wMSA/IChuID0gMC43MDcxMDY3ODEsIGkgPSAwLjcwNzEwNjc4MSwgcyA9IDApIDogKHMgPSBNYXRoLnNxcnQoTSksIG4gPSBSIC8gcywgaSA9IHkgLyBzKSwgdGhpcy5zZXQobiwgaSwgcywgdCksIHRoaXM7XG4gICAgfVxuICAgIGxldCBfID0gTWF0aC5zcXJ0KChmIC0gZykgKiAoZiAtIGcpICsgKGQgLSBwKSAqIChkIC0gcCkgKyAodSAtIGMpICogKHUgLSBjKSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKF8pIDwgMWUtMyAmJiAoXyA9IDEpLCB0aGlzLnggPSAoZiAtIGcpIC8gXywgdGhpcy55ID0gKGQgLSBwKSAvIF8sIHRoaXMueiA9ICh1IC0gYykgLyBfLCB0aGlzLncgPSBNYXRoLmFjb3MoKGEgKyBtICsgdiAtIDEpIC8gMiksIHRoaXM7XG4gIH1cbiAgbWluKGUpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCBlLngpLCB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIGUueSksIHRoaXMueiA9IE1hdGgubWluKHRoaXMueiwgZS56KSwgdGhpcy53ID0gTWF0aC5taW4odGhpcy53LCBlLncpLCB0aGlzO1xuICB9XG4gIG1heChlKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgZS54KSwgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBlLnkpLCB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIGUueiksIHRoaXMudyA9IE1hdGgubWF4KHRoaXMudywgZS53KSwgdGhpcztcbiAgfVxuICBjbGFtcChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KGUueCwgTWF0aC5taW4odC54LCB0aGlzLngpKSwgdGhpcy55ID0gTWF0aC5tYXgoZS55LCBNYXRoLm1pbih0LnksIHRoaXMueSkpLCB0aGlzLnogPSBNYXRoLm1heChlLnosIE1hdGgubWluKHQueiwgdGhpcy56KSksIHRoaXMudyA9IE1hdGgubWF4KGUudywgTWF0aC5taW4odC53LCB0aGlzLncpKSwgdGhpcztcbiAgfVxuICBjbGFtcFNjYWxhcihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KGUsIE1hdGgubWluKHQsIHRoaXMueCkpLCB0aGlzLnkgPSBNYXRoLm1heChlLCBNYXRoLm1pbih0LCB0aGlzLnkpKSwgdGhpcy56ID0gTWF0aC5tYXgoZSwgTWF0aC5taW4odCwgdGhpcy56KSksIHRoaXMudyA9IE1hdGgubWF4KGUsIE1hdGgubWluKHQsIHRoaXMudykpLCB0aGlzO1xuICB9XG4gIGNsYW1wTGVuZ3RoKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5sZW5ndGgoKTtcbiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobiB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChlLCBNYXRoLm1pbih0LCBuKSkpO1xuICB9XG4gIGZsb29yKCkge1xuICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KSwgdGhpcy56ID0gTWF0aC5mbG9vcih0aGlzLnopLCB0aGlzLncgPSBNYXRoLmZsb29yKHRoaXMudyksIHRoaXM7XG4gIH1cbiAgY2VpbCgpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCksIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLmNlaWwodGhpcy56KSwgdGhpcy53ID0gTWF0aC5jZWlsKHRoaXMudyksIHRoaXM7XG4gIH1cbiAgcm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueiksIHRoaXMudyA9IE1hdGgucm91bmQodGhpcy53KSwgdGhpcztcbiAgfVxuICByb3VuZFRvWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gdGhpcy54IDwgMCA/IE1hdGguY2VpbCh0aGlzLngpIDogTWF0aC5mbG9vcih0aGlzLngpLCB0aGlzLnkgPSB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSksIHRoaXMueiA9IHRoaXMueiA8IDAgPyBNYXRoLmNlaWwodGhpcy56KSA6IE1hdGguZmxvb3IodGhpcy56KSwgdGhpcy53ID0gdGhpcy53IDwgMCA/IE1hdGguY2VpbCh0aGlzLncpIDogTWF0aC5mbG9vcih0aGlzLncpLCB0aGlzO1xuICB9XG4gIG5lZ2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gLXRoaXMueCwgdGhpcy55ID0gLXRoaXMueSwgdGhpcy56ID0gLXRoaXMueiwgdGhpcy53ID0gLXRoaXMudywgdGhpcztcbiAgfVxuICBkb3QoZSkge1xuICAgIHJldHVybiB0aGlzLnggKiBlLnggKyB0aGlzLnkgKiBlLnkgKyB0aGlzLnogKiBlLnogKyB0aGlzLncgKiBlLnc7XG4gIH1cbiAgbGVuZ3RoU3EoKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpO1xuICB9XG4gIG1hbmhhdHRhbkxlbmd0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopICsgTWF0aC5hYnModGhpcy53KTtcbiAgfVxuICBub3JtYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG4gIH1cbiAgc2V0TGVuZ3RoKGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihlKTtcbiAgfVxuICBsZXJwKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ICs9IChlLnggLSB0aGlzLngpICogdCwgdGhpcy55ICs9IChlLnkgLSB0aGlzLnkpICogdCwgdGhpcy56ICs9IChlLnogLSB0aGlzLnopICogdCwgdGhpcy53ICs9IChlLncgLSB0aGlzLncpICogdCwgdGhpcztcbiAgfVxuICBsZXJwVmVjdG9ycyhlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUueCArICh0LnggLSBlLngpICogbiwgdGhpcy55ID0gZS55ICsgKHQueSAtIGUueSkgKiBuLCB0aGlzLnogPSBlLnogKyAodC56IC0gZS56KSAqIG4sIHRoaXMudyA9IGUudyArICh0LncgLSBlLncpICogbiwgdGhpcztcbiAgfVxuICBlcXVhbHMoZSkge1xuICAgIHJldHVybiBlLnggPT09IHRoaXMueCAmJiBlLnkgPT09IHRoaXMueSAmJiBlLnogPT09IHRoaXMueiAmJiBlLncgPT09IHRoaXMudztcbiAgfVxuICBmcm9tQXJyYXkoZSwgdCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZVt0XSwgdGhpcy55ID0gZVt0ICsgMV0sIHRoaXMueiA9IGVbdCArIDJdLCB0aGlzLncgPSBlW3QgKyAzXSwgdGhpcztcbiAgfVxuICB0b0FycmF5KGUgPSBbXSwgdCA9IDApIHtcbiAgICByZXR1cm4gZVt0XSA9IHRoaXMueCwgZVt0ICsgMV0gPSB0aGlzLnksIGVbdCArIDJdID0gdGhpcy56LCBlW3QgKyAzXSA9IHRoaXMudywgZTtcbiAgfVxuICBmcm9tQnVmZmVyQXR0cmlidXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZS5nZXRYKHQpLCB0aGlzLnkgPSBlLmdldFkodCksIHRoaXMueiA9IGUuZ2V0Wih0KSwgdGhpcy53ID0gZS5nZXRXKHQpLCB0aGlzO1xuICB9XG4gIHJhbmRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5yYW5kb20oKSwgdGhpcy55ID0gTWF0aC5yYW5kb20oKSwgdGhpcy56ID0gTWF0aC5yYW5kb20oKSwgdGhpcy53ID0gTWF0aC5yYW5kb20oKSwgdGhpcztcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQgdGhpcy54LCB5aWVsZCB0aGlzLnksIHlpZWxkIHRoaXMueiwgeWllbGQgdGhpcy53O1xuICB9XG59XG5jbGFzcyBFbiBleHRlbmRzICRuIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiA9IHt9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0ID0gITAsIHRoaXMud2lkdGggPSBlLCB0aGlzLmhlaWdodCA9IHQsIHRoaXMuZGVwdGggPSAxLCB0aGlzLnNjaXNzb3IgPSBuZXcgJGUoMCwgMCwgZSwgdCksIHRoaXMuc2Npc3NvclRlc3QgPSAhMSwgdGhpcy52aWV3cG9ydCA9IG5ldyAkZSgwLCAwLCBlLCB0KTtcbiAgICBjb25zdCBpID0geyB3aWR0aDogZSwgaGVpZ2h0OiB0LCBkZXB0aDogMSB9O1xuICAgIHRoaXMudGV4dHVyZSA9IG5ldyBfdChpLCBuLm1hcHBpbmcsIG4ud3JhcFMsIG4ud3JhcFQsIG4ubWFnRmlsdGVyLCBuLm1pbkZpbHRlciwgbi5mb3JtYXQsIG4udHlwZSwgbi5hbmlzb3Ryb3B5LCBuLmVuY29kaW5nKSwgdGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9ICEwLCB0aGlzLnRleHR1cmUuZmxpcFkgPSAhMSwgdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG4uZ2VuZXJhdGVNaXBtYXBzICE9PSB2b2lkIDAgPyBuLmdlbmVyYXRlTWlwbWFwcyA6ICExLCB0aGlzLnRleHR1cmUuaW50ZXJuYWxGb3JtYXQgPSBuLmludGVybmFsRm9ybWF0ICE9PSB2b2lkIDAgPyBuLmludGVybmFsRm9ybWF0IDogbnVsbCwgdGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG4ubWluRmlsdGVyICE9PSB2b2lkIDAgPyBuLm1pbkZpbHRlciA6IDEwMDYsIHRoaXMuZGVwdGhCdWZmZXIgPSBuLmRlcHRoQnVmZmVyICE9PSB2b2lkIDAgPyBuLmRlcHRoQnVmZmVyIDogITAsIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG4uc3RlbmNpbEJ1ZmZlciAhPT0gdm9pZCAwID8gbi5zdGVuY2lsQnVmZmVyIDogITEsIHRoaXMuZGVwdGhUZXh0dXJlID0gbi5kZXB0aFRleHR1cmUgIT09IHZvaWQgMCA/IG4uZGVwdGhUZXh0dXJlIDogbnVsbCwgdGhpcy5zYW1wbGVzID0gbi5zYW1wbGVzICE9PSB2b2lkIDAgPyBuLnNhbXBsZXMgOiAwO1xuICB9XG4gIHNldFNpemUoZSwgdCwgbiA9IDEpIHtcbiAgICAodGhpcy53aWR0aCAhPT0gZSB8fCB0aGlzLmhlaWdodCAhPT0gdCB8fCB0aGlzLmRlcHRoICE9PSBuKSAmJiAodGhpcy53aWR0aCA9IGUsIHRoaXMuaGVpZ2h0ID0gdCwgdGhpcy5kZXB0aCA9IG4sIHRoaXMudGV4dHVyZS5pbWFnZS53aWR0aCA9IGUsIHRoaXMudGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0LCB0aGlzLnRleHR1cmUuaW1hZ2UuZGVwdGggPSBuLCB0aGlzLmRpc3Bvc2UoKSksIHRoaXMudmlld3BvcnQuc2V0KDAsIDAsIGUsIHQpLCB0aGlzLnNjaXNzb3Iuc2V0KDAsIDAsIGUsIHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gIH1cbiAgY29weShlKSB7XG4gICAgdGhpcy53aWR0aCA9IGUud2lkdGgsIHRoaXMuaGVpZ2h0ID0gZS5oZWlnaHQsIHRoaXMuZGVwdGggPSBlLmRlcHRoLCB0aGlzLnZpZXdwb3J0LmNvcHkoZS52aWV3cG9ydCksIHRoaXMudGV4dHVyZSA9IGUudGV4dHVyZS5jbG9uZSgpLCB0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gITA7XG4gICAgY29uc3QgdCA9IE9iamVjdC5hc3NpZ24oe30sIGUudGV4dHVyZS5pbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZS5zb3VyY2UgPSBuZXcgc28odCksIHRoaXMuZGVwdGhCdWZmZXIgPSBlLmRlcHRoQnVmZmVyLCB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBlLnN0ZW5jaWxCdWZmZXIsIGUuZGVwdGhUZXh0dXJlICE9PSBudWxsICYmICh0aGlzLmRlcHRoVGV4dHVyZSA9IGUuZGVwdGhUZXh0dXJlLmNsb25lKCkpLCB0aGlzLnNhbXBsZXMgPSBlLnNhbXBsZXMsIHRoaXM7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImRpc3Bvc2VcIiB9KTtcbiAgfVxufVxuY2xhc3Mgcm8gZXh0ZW5kcyBfdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSBudWxsLCB0ID0gMSwgbiA9IDEsIGkgPSAxKSB7XG4gICAgc3VwZXIobnVsbCksIHRoaXMuaXNEYXRhQXJyYXlUZXh0dXJlID0gITAsIHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGUsIHdpZHRoOiB0LCBoZWlnaHQ6IG4sIGRlcHRoOiBpIH0sIHRoaXMubWFnRmlsdGVyID0gMTAwMywgdGhpcy5taW5GaWx0ZXIgPSAxMDAzLCB0aGlzLndyYXBSID0gMTAwMSwgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSAhMSwgdGhpcy5mbGlwWSA9ICExLCB0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XG4gIH1cbn1cbmNsYXNzIFVvIGV4dGVuZHMgX3Qge1xuICBjb25zdHJ1Y3RvcihlID0gbnVsbCwgdCA9IDEsIG4gPSAxLCBpID0gMSkge1xuICAgIHN1cGVyKG51bGwpLCB0aGlzLmlzRGF0YTNEVGV4dHVyZSA9ICEwLCB0aGlzLmltYWdlID0geyBkYXRhOiBlLCB3aWR0aDogdCwgaGVpZ2h0OiBuLCBkZXB0aDogaSB9LCB0aGlzLm1hZ0ZpbHRlciA9IDEwMDMsIHRoaXMubWluRmlsdGVyID0gMTAwMywgdGhpcy53cmFwUiA9IDEwMDEsIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gITEsIHRoaXMuZmxpcFkgPSAhMSwgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuICB9XG59XG5jbGFzcyB1aSB7XG4gIGNvbnN0cnVjdG9yKGUgPSAwLCB0ID0gMCwgbiA9IDAsIGkgPSAxKSB7XG4gICAgdGhpcy5pc1F1YXRlcm5pb24gPSAhMCwgdGhpcy5feCA9IGUsIHRoaXMuX3kgPSB0LCB0aGlzLl96ID0gbiwgdGhpcy5fdyA9IGk7XG4gIH1cbiAgc3RhdGljIHNsZXJwRmxhdChlLCB0LCBuLCBpLCBzLCBvLCByKSB7XG4gICAgbGV0IGwgPSBuW2kgKyAwXSwgYSA9IG5baSArIDFdLCBjID0gbltpICsgMl0sIGQgPSBuW2kgKyAzXTtcbiAgICBjb25zdCB1ID0gc1tvICsgMF0sIG0gPSBzW28gKyAxXSwgZyA9IHNbbyArIDJdLCBwID0gc1tvICsgM107XG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIGVbdCArIDBdID0gbCwgZVt0ICsgMV0gPSBhLCBlW3QgKyAyXSA9IGMsIGVbdCArIDNdID0gZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHIgPT09IDEpIHtcbiAgICAgIGVbdCArIDBdID0gdSwgZVt0ICsgMV0gPSBtLCBlW3QgKyAyXSA9IGcsIGVbdCArIDNdID0gcDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGQgIT09IHAgfHwgbCAhPT0gdSB8fCBhICE9PSBtIHx8IGMgIT09IGcpIHtcbiAgICAgIGxldCBmID0gMSAtIHI7XG4gICAgICBjb25zdCB2ID0gbCAqIHUgKyBhICogbSArIGMgKiBnICsgZCAqIHAsIF8gPSB2ID49IDAgPyAxIDogLTEsIHcgPSAxIC0gdiAqIHY7XG4gICAgICBpZiAodyA+IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgIGNvbnN0IE0gPSBNYXRoLnNxcnQodyksIEUgPSBNYXRoLmF0YW4yKE0sIHYgKiBfKTtcbiAgICAgICAgZiA9IE1hdGguc2luKGYgKiBFKSAvIE0sIHIgPSBNYXRoLnNpbihyICogRSkgLyBNO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IHIgKiBfO1xuICAgICAgaWYgKGwgPSBsICogZiArIHUgKiB4LCBhID0gYSAqIGYgKyBtICogeCwgYyA9IGMgKiBmICsgZyAqIHgsIGQgPSBkICogZiArIHAgKiB4LCBmID09PSAxIC0gcikge1xuICAgICAgICBjb25zdCBNID0gMSAvIE1hdGguc3FydChsICogbCArIGEgKiBhICsgYyAqIGMgKyBkICogZCk7XG4gICAgICAgIGwgKj0gTSwgYSAqPSBNLCBjICo9IE0sIGQgKj0gTTtcbiAgICAgIH1cbiAgICB9XG4gICAgZVt0XSA9IGwsIGVbdCArIDFdID0gYSwgZVt0ICsgMl0gPSBjLCBlW3QgKyAzXSA9IGQ7XG4gIH1cbiAgc3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KGUsIHQsIG4sIGksIHMsIG8pIHtcbiAgICBjb25zdCByID0gbltpXSwgbCA9IG5baSArIDFdLCBhID0gbltpICsgMl0sIGMgPSBuW2kgKyAzXSwgZCA9IHNbb10sIHUgPSBzW28gKyAxXSwgbSA9IHNbbyArIDJdLCBnID0gc1tvICsgM107XG4gICAgcmV0dXJuIGVbdF0gPSByICogZyArIGMgKiBkICsgbCAqIG0gLSBhICogdSwgZVt0ICsgMV0gPSBsICogZyArIGMgKiB1ICsgYSAqIGQgLSByICogbSwgZVt0ICsgMl0gPSBhICogZyArIGMgKiBtICsgciAqIHUgLSBsICogZCwgZVt0ICsgM10gPSBjICogZyAtIHIgKiBkIC0gbCAqIHUgLSBhICogbSwgZTtcbiAgfVxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfVxuICBzZXQgeChlKSB7XG4gICAgdGhpcy5feCA9IGUsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5feTtcbiAgfVxuICBzZXQgeShlKSB7XG4gICAgdGhpcy5feSA9IGUsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpcy5fejtcbiAgfVxuICBzZXQgeihlKSB7XG4gICAgdGhpcy5feiA9IGUsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuICBnZXQgdygpIHtcbiAgICByZXR1cm4gdGhpcy5fdztcbiAgfVxuICBzZXQgdyhlKSB7XG4gICAgdGhpcy5fdyA9IGUsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuICBzZXQoZSwgdCwgbiwgaSkge1xuICAgIHJldHVybiB0aGlzLl94ID0gZSwgdGhpcy5feSA9IHQsIHRoaXMuX3ogPSBuLCB0aGlzLl93ID0gaSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93KTtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5feCA9IGUueCwgdGhpcy5feSA9IGUueSwgdGhpcy5feiA9IGUueiwgdGhpcy5fdyA9IGUudywgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzO1xuICB9XG4gIHNldEZyb21FdWxlcihlLCB0KSB7XG4gICAgaWYgKCEoZSAmJiBlLmlzRXVsZXIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuXCIpO1xuICAgIGNvbnN0IG4gPSBlLl94LCBpID0gZS5feSwgcyA9IGUuX3osIG8gPSBlLl9vcmRlciwgciA9IE1hdGguY29zLCBsID0gTWF0aC5zaW4sIGEgPSByKG4gLyAyKSwgYyA9IHIoaSAvIDIpLCBkID0gcihzIC8gMiksIHUgPSBsKG4gLyAyKSwgbSA9IGwoaSAvIDIpLCBnID0gbChzIC8gMik7XG4gICAgc3dpdGNoIChvKSB7XG4gICAgICBjYXNlIFwiWFlaXCI6XG4gICAgICAgIHRoaXMuX3ggPSB1ICogYyAqIGQgKyBhICogbSAqIGcsIHRoaXMuX3kgPSBhICogbSAqIGQgLSB1ICogYyAqIGcsIHRoaXMuX3ogPSBhICogYyAqIGcgKyB1ICogbSAqIGQsIHRoaXMuX3cgPSBhICogYyAqIGQgLSB1ICogbSAqIGc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIllYWlwiOlxuICAgICAgICB0aGlzLl94ID0gdSAqIGMgKiBkICsgYSAqIG0gKiBnLCB0aGlzLl95ID0gYSAqIG0gKiBkIC0gdSAqIGMgKiBnLCB0aGlzLl96ID0gYSAqIGMgKiBnIC0gdSAqIG0gKiBkLCB0aGlzLl93ID0gYSAqIGMgKiBkICsgdSAqIG0gKiBnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJaWFlcIjpcbiAgICAgICAgdGhpcy5feCA9IHUgKiBjICogZCAtIGEgKiBtICogZywgdGhpcy5feSA9IGEgKiBtICogZCArIHUgKiBjICogZywgdGhpcy5feiA9IGEgKiBjICogZyArIHUgKiBtICogZCwgdGhpcy5fdyA9IGEgKiBjICogZCAtIHUgKiBtICogZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiWllYXCI6XG4gICAgICAgIHRoaXMuX3ggPSB1ICogYyAqIGQgLSBhICogbSAqIGcsIHRoaXMuX3kgPSBhICogbSAqIGQgKyB1ICogYyAqIGcsIHRoaXMuX3ogPSBhICogYyAqIGcgLSB1ICogbSAqIGQsIHRoaXMuX3cgPSBhICogYyAqIGQgKyB1ICogbSAqIGc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIllaWFwiOlxuICAgICAgICB0aGlzLl94ID0gdSAqIGMgKiBkICsgYSAqIG0gKiBnLCB0aGlzLl95ID0gYSAqIG0gKiBkICsgdSAqIGMgKiBnLCB0aGlzLl96ID0gYSAqIGMgKiBnIC0gdSAqIG0gKiBkLCB0aGlzLl93ID0gYSAqIGMgKiBkIC0gdSAqIG0gKiBnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJYWllcIjpcbiAgICAgICAgdGhpcy5feCA9IHUgKiBjICogZCAtIGEgKiBtICogZywgdGhpcy5feSA9IGEgKiBtICogZCAtIHUgKiBjICogZywgdGhpcy5feiA9IGEgKiBjICogZyArIHUgKiBtICogZCwgdGhpcy5fdyA9IGEgKiBjICogZCArIHUgKiBtICogZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogXCIgKyBvKTtcbiAgICB9XG4gICAgcmV0dXJuIHQgIT09ICExICYmIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpcztcbiAgfVxuICBzZXRGcm9tQXhpc0FuZ2xlKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdCAvIDIsIGkgPSBNYXRoLnNpbihuKTtcbiAgICByZXR1cm4gdGhpcy5feCA9IGUueCAqIGksIHRoaXMuX3kgPSBlLnkgKiBpLCB0aGlzLl96ID0gZS56ICogaSwgdGhpcy5fdyA9IE1hdGguY29zKG4pLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpIHtcbiAgICBjb25zdCB0ID0gZS5lbGVtZW50cywgbiA9IHRbMF0sIGkgPSB0WzRdLCBzID0gdFs4XSwgbyA9IHRbMV0sIHIgPSB0WzVdLCBsID0gdFs5XSwgYSA9IHRbMl0sIGMgPSB0WzZdLCBkID0gdFsxMF0sIHUgPSBuICsgciArIGQ7XG4gICAgaWYgKHUgPiAwKSB7XG4gICAgICBjb25zdCBtID0gMC41IC8gTWF0aC5zcXJ0KHUgKyAxKTtcbiAgICAgIHRoaXMuX3cgPSAwLjI1IC8gbSwgdGhpcy5feCA9IChjIC0gbCkgKiBtLCB0aGlzLl95ID0gKHMgLSBhKSAqIG0sIHRoaXMuX3ogPSAobyAtIGkpICogbTtcbiAgICB9IGVsc2UgaWYgKG4gPiByICYmIG4gPiBkKSB7XG4gICAgICBjb25zdCBtID0gMiAqIE1hdGguc3FydCgxICsgbiAtIHIgLSBkKTtcbiAgICAgIHRoaXMuX3cgPSAoYyAtIGwpIC8gbSwgdGhpcy5feCA9IDAuMjUgKiBtLCB0aGlzLl95ID0gKGkgKyBvKSAvIG0sIHRoaXMuX3ogPSAocyArIGEpIC8gbTtcbiAgICB9IGVsc2UgaWYgKHIgPiBkKSB7XG4gICAgICBjb25zdCBtID0gMiAqIE1hdGguc3FydCgxICsgciAtIG4gLSBkKTtcbiAgICAgIHRoaXMuX3cgPSAocyAtIGEpIC8gbSwgdGhpcy5feCA9IChpICsgbykgLyBtLCB0aGlzLl95ID0gMC4yNSAqIG0sIHRoaXMuX3ogPSAobCArIGMpIC8gbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbSA9IDIgKiBNYXRoLnNxcnQoMSArIGQgLSBuIC0gcik7XG4gICAgICB0aGlzLl93ID0gKG8gLSBpKSAvIG0sIHRoaXMuX3ggPSAocyArIGEpIC8gbSwgdGhpcy5feSA9IChsICsgYykgLyBtLCB0aGlzLl96ID0gMC4yNSAqIG07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbVVuaXRWZWN0b3JzKGUsIHQpIHtcbiAgICBsZXQgbiA9IGUuZG90KHQpICsgMTtcbiAgICByZXR1cm4gbiA8IE51bWJlci5FUFNJTE9OID8gKG4gPSAwLCBNYXRoLmFicyhlLngpID4gTWF0aC5hYnMoZS56KSA/ICh0aGlzLl94ID0gLWUueSwgdGhpcy5feSA9IGUueCwgdGhpcy5feiA9IDAsIHRoaXMuX3cgPSBuKSA6ICh0aGlzLl94ID0gMCwgdGhpcy5feSA9IC1lLnosIHRoaXMuX3ogPSBlLnksIHRoaXMuX3cgPSBuKSkgOiAodGhpcy5feCA9IGUueSAqIHQueiAtIGUueiAqIHQueSwgdGhpcy5feSA9IGUueiAqIHQueCAtIGUueCAqIHQueiwgdGhpcy5feiA9IGUueCAqIHQueSAtIGUueSAqIHQueCwgdGhpcy5fdyA9IG4pLCB0aGlzLm5vcm1hbGl6ZSgpO1xuICB9XG4gIGFuZ2xlVG8oZSkge1xuICAgIHJldHVybiAyICogTWF0aC5hY29zKE1hdGguYWJzKG10KHRoaXMuZG90KGUpLCAtMSwgMSkpKTtcbiAgfVxuICByb3RhdGVUb3dhcmRzKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5hbmdsZVRvKGUpO1xuICAgIGlmIChuID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgaSA9IE1hdGgubWluKDEsIHQgLyBuKTtcbiAgICByZXR1cm4gdGhpcy5zbGVycChlLCBpKSwgdGhpcztcbiAgfVxuICBpZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMSk7XG4gIH1cbiAgaW52ZXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuICB9XG4gIGNvbmp1Z2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5feCAqPSAtMSwgdGhpcy5feSAqPSAtMSwgdGhpcy5feiAqPSAtMSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzO1xuICB9XG4gIGRvdChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKiBlLl94ICsgdGhpcy5feSAqIGUuX3kgKyB0aGlzLl96ICogZS5feiArIHRoaXMuX3cgKiBlLl93O1xuICB9XG4gIGxlbmd0aFNxKCkge1xuICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyk7XG4gIH1cbiAgbm9ybWFsaXplKCkge1xuICAgIGxldCBlID0gdGhpcy5sZW5ndGgoKTtcbiAgICByZXR1cm4gZSA9PT0gMCA/ICh0aGlzLl94ID0gMCwgdGhpcy5feSA9IDAsIHRoaXMuX3ogPSAwLCB0aGlzLl93ID0gMSkgOiAoZSA9IDEgLyBlLCB0aGlzLl94ID0gdGhpcy5feCAqIGUsIHRoaXMuX3kgPSB0aGlzLl95ICogZSwgdGhpcy5feiA9IHRoaXMuX3ogKiBlLCB0aGlzLl93ID0gdGhpcy5fdyAqIGUpLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7XG4gIH1cbiAgbXVsdGlwbHkoZSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModGhpcywgZSk7XG4gIH1cbiAgcHJlbXVsdGlwbHkoZSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoZSwgdGhpcyk7XG4gIH1cbiAgbXVsdGlwbHlRdWF0ZXJuaW9ucyhlLCB0KSB7XG4gICAgY29uc3QgbiA9IGUuX3gsIGkgPSBlLl95LCBzID0gZS5feiwgbyA9IGUuX3csIHIgPSB0Ll94LCBsID0gdC5feSwgYSA9IHQuX3osIGMgPSB0Ll93O1xuICAgIHJldHVybiB0aGlzLl94ID0gbiAqIGMgKyBvICogciArIGkgKiBhIC0gcyAqIGwsIHRoaXMuX3kgPSBpICogYyArIG8gKiBsICsgcyAqIHIgLSBuICogYSwgdGhpcy5feiA9IHMgKiBjICsgbyAqIGEgKyBuICogbCAtIGkgKiByLCB0aGlzLl93ID0gbyAqIGMgLSBuICogciAtIGkgKiBsIC0gcyAqIGEsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpcztcbiAgfVxuICBzbGVycChlLCB0KSB7XG4gICAgaWYgKHQgPT09IDApXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodCA9PT0gMSlcbiAgICAgIHJldHVybiB0aGlzLmNvcHkoZSk7XG4gICAgY29uc3QgbiA9IHRoaXMuX3gsIGkgPSB0aGlzLl95LCBzID0gdGhpcy5feiwgbyA9IHRoaXMuX3c7XG4gICAgbGV0IHIgPSBvICogZS5fdyArIG4gKiBlLl94ICsgaSAqIGUuX3kgKyBzICogZS5fejtcbiAgICBpZiAociA8IDAgPyAodGhpcy5fdyA9IC1lLl93LCB0aGlzLl94ID0gLWUuX3gsIHRoaXMuX3kgPSAtZS5feSwgdGhpcy5feiA9IC1lLl96LCByID0gLXIpIDogdGhpcy5jb3B5KGUpLCByID49IDEpXG4gICAgICByZXR1cm4gdGhpcy5fdyA9IG8sIHRoaXMuX3ggPSBuLCB0aGlzLl95ID0gaSwgdGhpcy5feiA9IHMsIHRoaXM7XG4gICAgY29uc3QgbCA9IDEgLSByICogcjtcbiAgICBpZiAobCA8PSBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgY29uc3QgbSA9IDEgLSB0O1xuICAgICAgcmV0dXJuIHRoaXMuX3cgPSBtICogbyArIHQgKiB0aGlzLl93LCB0aGlzLl94ID0gbSAqIG4gKyB0ICogdGhpcy5feCwgdGhpcy5feSA9IG0gKiBpICsgdCAqIHRoaXMuX3ksIHRoaXMuX3ogPSBtICogcyArIHQgKiB0aGlzLl96LCB0aGlzLm5vcm1hbGl6ZSgpLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBNYXRoLnNxcnQobCksIGMgPSBNYXRoLmF0YW4yKGEsIHIpLCBkID0gTWF0aC5zaW4oKDEgLSB0KSAqIGMpIC8gYSwgdSA9IE1hdGguc2luKHQgKiBjKSAvIGE7XG4gICAgcmV0dXJuIHRoaXMuX3cgPSBvICogZCArIHRoaXMuX3cgKiB1LCB0aGlzLl94ID0gbiAqIGQgKyB0aGlzLl94ICogdSwgdGhpcy5feSA9IGkgKiBkICsgdGhpcy5feSAqIHUsIHRoaXMuX3ogPSBzICogZCArIHRoaXMuX3ogKiB1LCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7XG4gIH1cbiAgc2xlcnBRdWF0ZXJuaW9ucyhlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weShlKS5zbGVycCh0LCBuKTtcbiAgfVxuICByYW5kb20oKSB7XG4gICAgY29uc3QgZSA9IE1hdGgucmFuZG9tKCksIHQgPSBNYXRoLnNxcnQoMSAtIGUpLCBuID0gTWF0aC5zcXJ0KGUpLCBpID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpLCBzID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIHQgKiBNYXRoLmNvcyhpKSxcbiAgICAgIG4gKiBNYXRoLnNpbihzKSxcbiAgICAgIG4gKiBNYXRoLmNvcyhzKSxcbiAgICAgIHQgKiBNYXRoLnNpbihpKVxuICAgICk7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICByZXR1cm4gZS5feCA9PT0gdGhpcy5feCAmJiBlLl95ID09PSB0aGlzLl95ICYmIGUuX3ogPT09IHRoaXMuX3ogJiYgZS5fdyA9PT0gdGhpcy5fdztcbiAgfVxuICBmcm9tQXJyYXkoZSwgdCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5feCA9IGVbdF0sIHRoaXMuX3kgPSBlW3QgKyAxXSwgdGhpcy5feiA9IGVbdCArIDJdLCB0aGlzLl93ID0gZVt0ICsgM10sIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpcztcbiAgfVxuICB0b0FycmF5KGUgPSBbXSwgdCA9IDApIHtcbiAgICByZXR1cm4gZVt0XSA9IHRoaXMuX3gsIGVbdCArIDFdID0gdGhpcy5feSwgZVt0ICsgMl0gPSB0aGlzLl96LCBlW3QgKyAzXSA9IHRoaXMuX3csIGU7XG4gIH1cbiAgZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggPSBlLmdldFgodCksIHRoaXMuX3kgPSBlLmdldFkodCksIHRoaXMuX3ogPSBlLmdldFoodCksIHRoaXMuX3cgPSBlLmdldFcodCksIHRoaXM7XG4gIH1cbiAgX29uQ2hhbmdlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGUsIHRoaXM7XG4gIH1cbiAgX29uQ2hhbmdlQ2FsbGJhY2soKSB7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkIHRoaXMuX3gsIHlpZWxkIHRoaXMuX3ksIHlpZWxkIHRoaXMuX3osIHlpZWxkIHRoaXMuX3c7XG4gIH1cbn1cbmNsYXNzIE8ge1xuICBjb25zdHJ1Y3RvcihlID0gMCwgdCA9IDAsIG4gPSAwKSB7XG4gICAgTy5wcm90b3R5cGUuaXNWZWN0b3IzID0gITAsIHRoaXMueCA9IGUsIHRoaXMueSA9IHQsIHRoaXMueiA9IG47XG4gIH1cbiAgc2V0KGUsIHQsIG4pIHtcbiAgICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gdGhpcy56KSwgdGhpcy54ID0gZSwgdGhpcy55ID0gdCwgdGhpcy56ID0gbiwgdGhpcztcbiAgfVxuICBzZXRTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzLnkgPSBlLCB0aGlzLnogPSBlLCB0aGlzO1xuICB9XG4gIHNldFgoZSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzO1xuICB9XG4gIHNldFkoZSkge1xuICAgIHJldHVybiB0aGlzLnkgPSBlLCB0aGlzO1xuICB9XG4gIHNldFooZSkge1xuICAgIHJldHVybiB0aGlzLnogPSBlLCB0aGlzO1xuICB9XG4gIHNldENvbXBvbmVudChlLCB0KSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMueCA9IHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLnkgPSB0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy56ID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldENvbXBvbmVudChlKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLno7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgZSk7XG4gICAgfVxuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZS54LCB0aGlzLnkgPSBlLnksIHRoaXMueiA9IGUueiwgdGhpcztcbiAgfVxuICBhZGQoZSkge1xuICAgIHJldHVybiB0aGlzLnggKz0gZS54LCB0aGlzLnkgKz0gZS55LCB0aGlzLnogKz0gZS56LCB0aGlzO1xuICB9XG4gIGFkZFNjYWxhcihlKSB7XG4gICAgcmV0dXJuIHRoaXMueCArPSBlLCB0aGlzLnkgKz0gZSwgdGhpcy56ICs9IGUsIHRoaXM7XG4gIH1cbiAgYWRkVmVjdG9ycyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUueCArIHQueCwgdGhpcy55ID0gZS55ICsgdC55LCB0aGlzLnogPSBlLnogKyB0LnosIHRoaXM7XG4gIH1cbiAgYWRkU2NhbGVkVmVjdG9yKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ICs9IGUueCAqIHQsIHRoaXMueSArPSBlLnkgKiB0LCB0aGlzLnogKz0gZS56ICogdCwgdGhpcztcbiAgfVxuICBzdWIoZSkge1xuICAgIHJldHVybiB0aGlzLnggLT0gZS54LCB0aGlzLnkgLT0gZS55LCB0aGlzLnogLT0gZS56LCB0aGlzO1xuICB9XG4gIHN1YlNjYWxhcihlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAtPSBlLCB0aGlzLnkgLT0gZSwgdGhpcy56IC09IGUsIHRoaXM7XG4gIH1cbiAgc3ViVmVjdG9ycyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUueCAtIHQueCwgdGhpcy55ID0gZS55IC0gdC55LCB0aGlzLnogPSBlLnogLSB0LnosIHRoaXM7XG4gIH1cbiAgbXVsdGlwbHkoZSkge1xuICAgIHJldHVybiB0aGlzLnggKj0gZS54LCB0aGlzLnkgKj0gZS55LCB0aGlzLnogKj0gZS56LCB0aGlzO1xuICB9XG4gIG11bHRpcGx5U2NhbGFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy54ICo9IGUsIHRoaXMueSAqPSBlLCB0aGlzLnogKj0gZSwgdGhpcztcbiAgfVxuICBtdWx0aXBseVZlY3RvcnMoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLnggKiB0LngsIHRoaXMueSA9IGUueSAqIHQueSwgdGhpcy56ID0gZS56ICogdC56LCB0aGlzO1xuICB9XG4gIGFwcGx5RXVsZXIoZSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihLcy5zZXRGcm9tRXVsZXIoZSkpO1xuICB9XG4gIGFwcGx5QXhpc0FuZ2xlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oS3Muc2V0RnJvbUF4aXNBbmdsZShlLCB0KSk7XG4gIH1cbiAgYXBwbHlNYXRyaXgzKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy54LCBuID0gdGhpcy55LCBpID0gdGhpcy56LCBzID0gZS5lbGVtZW50cztcbiAgICByZXR1cm4gdGhpcy54ID0gc1swXSAqIHQgKyBzWzNdICogbiArIHNbNl0gKiBpLCB0aGlzLnkgPSBzWzFdICogdCArIHNbNF0gKiBuICsgc1s3XSAqIGksIHRoaXMueiA9IHNbMl0gKiB0ICsgc1s1XSAqIG4gKyBzWzhdICogaSwgdGhpcztcbiAgfVxuICBhcHBseU5vcm1hbE1hdHJpeChlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXgzKGUpLm5vcm1hbGl6ZSgpO1xuICB9XG4gIGFwcGx5TWF0cml4NChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgcyA9IGUuZWxlbWVudHMsIG8gPSAxIC8gKHNbM10gKiB0ICsgc1s3XSAqIG4gKyBzWzExXSAqIGkgKyBzWzE1XSk7XG4gICAgcmV0dXJuIHRoaXMueCA9IChzWzBdICogdCArIHNbNF0gKiBuICsgc1s4XSAqIGkgKyBzWzEyXSkgKiBvLCB0aGlzLnkgPSAoc1sxXSAqIHQgKyBzWzVdICogbiArIHNbOV0gKiBpICsgc1sxM10pICogbywgdGhpcy56ID0gKHNbMl0gKiB0ICsgc1s2XSAqIG4gKyBzWzEwXSAqIGkgKyBzWzE0XSkgKiBvLCB0aGlzO1xuICB9XG4gIGFwcGx5UXVhdGVybmlvbihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgcyA9IGUueCwgbyA9IGUueSwgciA9IGUueiwgbCA9IGUudywgYSA9IGwgKiB0ICsgbyAqIGkgLSByICogbiwgYyA9IGwgKiBuICsgciAqIHQgLSBzICogaSwgZCA9IGwgKiBpICsgcyAqIG4gLSBvICogdCwgdSA9IC1zICogdCAtIG8gKiBuIC0gciAqIGk7XG4gICAgcmV0dXJuIHRoaXMueCA9IGEgKiBsICsgdSAqIC1zICsgYyAqIC1yIC0gZCAqIC1vLCB0aGlzLnkgPSBjICogbCArIHUgKiAtbyArIGQgKiAtcyAtIGEgKiAtciwgdGhpcy56ID0gZCAqIGwgKyB1ICogLXIgKyBhICogLW8gLSBjICogLXMsIHRoaXM7XG4gIH1cbiAgcHJvamVjdChlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGUubWF0cml4V29ybGRJbnZlcnNlKS5hcHBseU1hdHJpeDQoZS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgfVxuICB1bnByb2plY3QoZSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKS5hcHBseU1hdHJpeDQoZS5tYXRyaXhXb3JsZCk7XG4gIH1cbiAgdHJhbnNmb3JtRGlyZWN0aW9uKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy54LCBuID0gdGhpcy55LCBpID0gdGhpcy56LCBzID0gZS5lbGVtZW50cztcbiAgICByZXR1cm4gdGhpcy54ID0gc1swXSAqIHQgKyBzWzRdICogbiArIHNbOF0gKiBpLCB0aGlzLnkgPSBzWzFdICogdCArIHNbNV0gKiBuICsgc1s5XSAqIGksIHRoaXMueiA9IHNbMl0gKiB0ICsgc1s2XSAqIG4gKyBzWzEwXSAqIGksIHRoaXMubm9ybWFsaXplKCk7XG4gIH1cbiAgZGl2aWRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy54IC89IGUueCwgdGhpcy55IC89IGUueSwgdGhpcy56IC89IGUueiwgdGhpcztcbiAgfVxuICBkaXZpZGVTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBlKTtcbiAgfVxuICBtaW4oZSkge1xuICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIGUueCksIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgZS55KSwgdGhpcy56ID0gTWF0aC5taW4odGhpcy56LCBlLnopLCB0aGlzO1xuICB9XG4gIG1heChlKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgZS54KSwgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBlLnkpLCB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIGUueiksIHRoaXM7XG4gIH1cbiAgY2xhbXAoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heChlLngsIE1hdGgubWluKHQueCwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KGUueSwgTWF0aC5taW4odC55LCB0aGlzLnkpKSwgdGhpcy56ID0gTWF0aC5tYXgoZS56LCBNYXRoLm1pbih0LnosIHRoaXMueikpLCB0aGlzO1xuICB9XG4gIGNsYW1wU2NhbGFyKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgoZSwgTWF0aC5taW4odCwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KGUsIE1hdGgubWluKHQsIHRoaXMueSkpLCB0aGlzLnogPSBNYXRoLm1heChlLCBNYXRoLm1pbih0LCB0aGlzLnopKSwgdGhpcztcbiAgfVxuICBjbGFtcExlbmd0aChlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMubGVuZ3RoKCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKG4gfHwgMSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgoZSwgTWF0aC5taW4odCwgbikpKTtcbiAgfVxuICBmbG9vcigpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpLCB0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSksIHRoaXMueiA9IE1hdGguZmxvb3IodGhpcy56KSwgdGhpcztcbiAgfVxuICBjZWlsKCkge1xuICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KSwgdGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSksIHRoaXMueiA9IE1hdGguY2VpbCh0aGlzLnopLCB0aGlzO1xuICB9XG4gIHJvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCksIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KSwgdGhpcy56ID0gTWF0aC5yb3VuZCh0aGlzLnopLCB0aGlzO1xuICB9XG4gIHJvdW5kVG9aZXJvKCkge1xuICAgIHJldHVybiB0aGlzLnggPSB0aGlzLnggPCAwID8gTWF0aC5jZWlsKHRoaXMueCkgOiBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSA9IHRoaXMueSA8IDAgPyBNYXRoLmNlaWwodGhpcy55KSA6IE1hdGguZmxvb3IodGhpcy55KSwgdGhpcy56ID0gdGhpcy56IDwgMCA/IE1hdGguY2VpbCh0aGlzLnopIDogTWF0aC5mbG9vcih0aGlzLnopLCB0aGlzO1xuICB9XG4gIG5lZ2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gLXRoaXMueCwgdGhpcy55ID0gLXRoaXMueSwgdGhpcy56ID0gLXRoaXMueiwgdGhpcztcbiAgfVxuICBkb3QoZSkge1xuICAgIHJldHVybiB0aGlzLnggKiBlLnggKyB0aGlzLnkgKiBlLnkgKyB0aGlzLnogKiBlLno7XG4gIH1cbiAgbGVuZ3RoU3EoKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xuICB9XG4gIG1hbmhhdHRhbkxlbmd0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopO1xuICB9XG4gIG5vcm1hbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSB8fCAxKTtcbiAgfVxuICBzZXRMZW5ndGgoZSkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGUpO1xuICB9XG4gIGxlcnAoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnggKz0gKGUueCAtIHRoaXMueCkgKiB0LCB0aGlzLnkgKz0gKGUueSAtIHRoaXMueSkgKiB0LCB0aGlzLnogKz0gKGUueiAtIHRoaXMueikgKiB0LCB0aGlzO1xuICB9XG4gIGxlcnBWZWN0b3JzKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZS54ICsgKHQueCAtIGUueCkgKiBuLCB0aGlzLnkgPSBlLnkgKyAodC55IC0gZS55KSAqIG4sIHRoaXMueiA9IGUueiArICh0LnogLSBlLnopICogbiwgdGhpcztcbiAgfVxuICBjcm9zcyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsIGUpO1xuICB9XG4gIGNyb3NzVmVjdG9ycyhlLCB0KSB7XG4gICAgY29uc3QgbiA9IGUueCwgaSA9IGUueSwgcyA9IGUueiwgbyA9IHQueCwgciA9IHQueSwgbCA9IHQuejtcbiAgICByZXR1cm4gdGhpcy54ID0gaSAqIGwgLSBzICogciwgdGhpcy55ID0gcyAqIG8gLSBuICogbCwgdGhpcy56ID0gbiAqIHIgLSBpICogbywgdGhpcztcbiAgfVxuICBwcm9qZWN0T25WZWN0b3IoZSkge1xuICAgIGNvbnN0IHQgPSBlLmxlbmd0aFNxKCk7XG4gICAgaWYgKHQgPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCk7XG4gICAgY29uc3QgbiA9IGUuZG90KHRoaXMpIC8gdDtcbiAgICByZXR1cm4gdGhpcy5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKG4pO1xuICB9XG4gIHByb2plY3RPblBsYW5lKGUpIHtcbiAgICByZXR1cm4gc3MuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IoZSksIHRoaXMuc3ViKHNzKTtcbiAgfVxuICByZWZsZWN0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdWIoc3MuY29weShlKS5tdWx0aXBseVNjYWxhcigyICogdGhpcy5kb3QoZSkpKTtcbiAgfVxuICBhbmdsZVRvKGUpIHtcbiAgICBjb25zdCB0ID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSAqIGUubGVuZ3RoU3EoKSk7XG4gICAgaWYgKHQgPT09IDApXG4gICAgICByZXR1cm4gTWF0aC5QSSAvIDI7XG4gICAgY29uc3QgbiA9IHRoaXMuZG90KGUpIC8gdDtcbiAgICByZXR1cm4gTWF0aC5hY29zKG10KG4sIC0xLCAxKSk7XG4gIH1cbiAgZGlzdGFuY2VUbyhlKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKGUpKTtcbiAgfVxuICBkaXN0YW5jZVRvU3F1YXJlZChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMueCAtIGUueCwgbiA9IHRoaXMueSAtIGUueSwgaSA9IHRoaXMueiAtIGUuejtcbiAgICByZXR1cm4gdCAqIHQgKyBuICogbiArIGkgKiBpO1xuICB9XG4gIG1hbmhhdHRhbkRpc3RhbmNlVG8oZSkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSBlLngpICsgTWF0aC5hYnModGhpcy55IC0gZS55KSArIE1hdGguYWJzKHRoaXMueiAtIGUueik7XG4gIH1cbiAgc2V0RnJvbVNwaGVyaWNhbChlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3JkcyhlLnJhZGl1cywgZS5waGksIGUudGhldGEpO1xuICB9XG4gIHNldEZyb21TcGhlcmljYWxDb29yZHMoZSwgdCwgbikge1xuICAgIGNvbnN0IGkgPSBNYXRoLnNpbih0KSAqIGU7XG4gICAgcmV0dXJuIHRoaXMueCA9IGkgKiBNYXRoLnNpbihuKSwgdGhpcy55ID0gTWF0aC5jb3ModCkgKiBlLCB0aGlzLnogPSBpICogTWF0aC5jb3MobiksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbUN5bGluZHJpY2FsKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoZS5yYWRpdXMsIGUudGhldGEsIGUueSk7XG4gIH1cbiAgc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZSAqIE1hdGguc2luKHQpLCB0aGlzLnkgPSBuLCB0aGlzLnogPSBlICogTWF0aC5jb3ModCksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUpIHtcbiAgICBjb25zdCB0ID0gZS5lbGVtZW50cztcbiAgICByZXR1cm4gdGhpcy54ID0gdFsxMl0sIHRoaXMueSA9IHRbMTNdLCB0aGlzLnogPSB0WzE0XSwgdGhpcztcbiAgfVxuICBzZXRGcm9tTWF0cml4U2NhbGUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oZSwgMCkubGVuZ3RoKCksIG4gPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oZSwgMSkubGVuZ3RoKCksIGkgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oZSwgMikubGVuZ3RoKCk7XG4gICAgcmV0dXJuIHRoaXMueCA9IHQsIHRoaXMueSA9IG4sIHRoaXMueiA9IGksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbU1hdHJpeENvbHVtbihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KGUuZWxlbWVudHMsIHQgKiA0KTtcbiAgfVxuICBzZXRGcm9tTWF0cml4M0NvbHVtbihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KGUuZWxlbWVudHMsIHQgKiAzKTtcbiAgfVxuICBzZXRGcm9tRXVsZXIoZSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLl94LCB0aGlzLnkgPSBlLl95LCB0aGlzLnogPSBlLl96LCB0aGlzO1xuICB9XG4gIGVxdWFscyhlKSB7XG4gICAgcmV0dXJuIGUueCA9PT0gdGhpcy54ICYmIGUueSA9PT0gdGhpcy55ICYmIGUueiA9PT0gdGhpcy56O1xuICB9XG4gIGZyb21BcnJheShlLCB0ID0gMCkge1xuICAgIHJldHVybiB0aGlzLnggPSBlW3RdLCB0aGlzLnkgPSBlW3QgKyAxXSwgdGhpcy56ID0gZVt0ICsgMl0sIHRoaXM7XG4gIH1cbiAgdG9BcnJheShlID0gW10sIHQgPSAwKSB7XG4gICAgcmV0dXJuIGVbdF0gPSB0aGlzLngsIGVbdCArIDFdID0gdGhpcy55LCBlW3QgKyAyXSA9IHRoaXMueiwgZTtcbiAgfVxuICBmcm9tQnVmZmVyQXR0cmlidXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZS5nZXRYKHQpLCB0aGlzLnkgPSBlLmdldFkodCksIHRoaXMueiA9IGUuZ2V0Wih0KSwgdGhpcztcbiAgfVxuICByYW5kb20oKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucmFuZG9tKCksIHRoaXMueSA9IE1hdGgucmFuZG9tKCksIHRoaXMueiA9IE1hdGgucmFuZG9tKCksIHRoaXM7XG4gIH1cbiAgcmFuZG9tRGlyZWN0aW9uKCkge1xuICAgIGNvbnN0IGUgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLCB0ID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLCBuID0gTWF0aC5zcXJ0KDEgLSBlICoqIDIpO1xuICAgIHJldHVybiB0aGlzLnggPSBuICogTWF0aC5jb3ModCksIHRoaXMueSA9IG4gKiBNYXRoLnNpbih0KSwgdGhpcy56ID0gZSwgdGhpcztcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQgdGhpcy54LCB5aWVsZCB0aGlzLnksIHlpZWxkIHRoaXMuejtcbiAgfVxufVxuY29uc3Qgc3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgS3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IHVpKCk7XG5jbGFzcyBkaSB7XG4gIGNvbnN0cnVjdG9yKGUgPSBuZXcgTygxIC8gMCwgMSAvIDAsIDEgLyAwKSwgdCA9IG5ldyBPKC0xIC8gMCwgLTEgLyAwLCAtMSAvIDApKSB7XG4gICAgdGhpcy5pc0JveDMgPSAhMCwgdGhpcy5taW4gPSBlLCB0aGlzLm1heCA9IHQ7XG4gIH1cbiAgc2V0KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5taW4uY29weShlKSwgdGhpcy5tYXguY29weSh0KSwgdGhpcztcbiAgfVxuICBzZXRGcm9tQXJyYXkoZSkge1xuICAgIGxldCB0ID0gMSAvIDAsIG4gPSAxIC8gMCwgaSA9IDEgLyAwLCBzID0gLTEgLyAwLCBvID0gLTEgLyAwLCByID0gLTEgLyAwO1xuICAgIGZvciAobGV0IGwgPSAwLCBhID0gZS5sZW5ndGg7IGwgPCBhOyBsICs9IDMpIHtcbiAgICAgIGNvbnN0IGMgPSBlW2xdLCBkID0gZVtsICsgMV0sIHUgPSBlW2wgKyAyXTtcbiAgICAgIGMgPCB0ICYmICh0ID0gYyksIGQgPCBuICYmIChuID0gZCksIHUgPCBpICYmIChpID0gdSksIGMgPiBzICYmIChzID0gYyksIGQgPiBvICYmIChvID0gZCksIHUgPiByICYmIChyID0gdSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1pbi5zZXQodCwgbiwgaSksIHRoaXMubWF4LnNldChzLCBvLCByKSwgdGhpcztcbiAgfVxuICBzZXRGcm9tQnVmZmVyQXR0cmlidXRlKGUpIHtcbiAgICBsZXQgdCA9IDEgLyAwLCBuID0gMSAvIDAsIGkgPSAxIC8gMCwgcyA9IC0xIC8gMCwgbyA9IC0xIC8gMCwgciA9IC0xIC8gMDtcbiAgICBmb3IgKGxldCBsID0gMCwgYSA9IGUuY291bnQ7IGwgPCBhOyBsKyspIHtcbiAgICAgIGNvbnN0IGMgPSBlLmdldFgobCksIGQgPSBlLmdldFkobCksIHUgPSBlLmdldFoobCk7XG4gICAgICBjIDwgdCAmJiAodCA9IGMpLCBkIDwgbiAmJiAobiA9IGQpLCB1IDwgaSAmJiAoaSA9IHUpLCBjID4gcyAmJiAocyA9IGMpLCBkID4gbyAmJiAobyA9IGQpLCB1ID4gciAmJiAociA9IHUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5taW4uc2V0KHQsIG4sIGkpLCB0aGlzLm1heC5zZXQocywgbywgciksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbVBvaW50cyhlKSB7XG4gICAgdGhpcy5tYWtlRW1wdHkoKTtcbiAgICBmb3IgKGxldCB0ID0gMCwgbiA9IGUubGVuZ3RoOyB0IDwgbjsgdCsrKVxuICAgICAgdGhpcy5leHBhbmRCeVBvaW50KGVbdF0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEZyb21DZW50ZXJBbmRTaXplKGUsIHQpIHtcbiAgICBjb25zdCBuID0gZG4uY29weSh0KS5tdWx0aXBseVNjYWxhcigwLjUpO1xuICAgIHJldHVybiB0aGlzLm1pbi5jb3B5KGUpLnN1YihuKSwgdGhpcy5tYXguY29weShlKS5hZGQobiksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbU9iamVjdChlLCB0ID0gITEpIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlRW1wdHkoKSwgdGhpcy5leHBhbmRCeU9iamVjdChlLCB0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLm1pbi5jb3B5KGUubWluKSwgdGhpcy5tYXguY29weShlLm1heCksIHRoaXM7XG4gIH1cbiAgbWFrZUVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSAxIC8gMCwgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLTEgLyAwLCB0aGlzO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4LnggPCB0aGlzLm1pbi54IHx8IHRoaXMubWF4LnkgPCB0aGlzLm1pbi55IHx8IHRoaXMubWF4LnogPCB0aGlzLm1pbi56O1xuICB9XG4gIGdldENlbnRlcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gZS5zZXQoMCwgMCwgMCkgOiBlLmFkZFZlY3RvcnModGhpcy5taW4sIHRoaXMubWF4KS5tdWx0aXBseVNjYWxhcigwLjUpO1xuICB9XG4gIGdldFNpemUoZSkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IGUuc2V0KDAsIDAsIDApIDogZS5zdWJWZWN0b3JzKHRoaXMubWF4LCB0aGlzLm1pbik7XG4gIH1cbiAgZXhwYW5kQnlQb2ludChlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluLm1pbihlKSwgdGhpcy5tYXgubWF4KGUpLCB0aGlzO1xuICB9XG4gIGV4cGFuZEJ5VmVjdG9yKGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4uc3ViKGUpLCB0aGlzLm1heC5hZGQoZSksIHRoaXM7XG4gIH1cbiAgZXhwYW5kQnlTY2FsYXIoZSkge1xuICAgIHJldHVybiB0aGlzLm1pbi5hZGRTY2FsYXIoLWUpLCB0aGlzLm1heC5hZGRTY2FsYXIoZSksIHRoaXM7XG4gIH1cbiAgZXhwYW5kQnlPYmplY3QoZSwgdCA9ICExKSB7XG4gICAgZS51cGRhdGVXb3JsZE1hdHJpeCghMSwgITEpO1xuICAgIGNvbnN0IG4gPSBlLmdlb21ldHJ5O1xuICAgIGlmIChuICE9PSB2b2lkIDApXG4gICAgICBpZiAodCAmJiBuLmF0dHJpYnV0ZXMgIT0gbnVsbCAmJiBuLmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzID0gbi5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgICBmb3IgKGxldCBvID0gMCwgciA9IHMuY291bnQ7IG8gPCByOyBvKyspXG4gICAgICAgICAgZG4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLCBvKS5hcHBseU1hdHJpeDQoZS5tYXRyaXhXb3JsZCksIHRoaXMuZXhwYW5kQnlQb2ludChkbik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbi5ib3VuZGluZ0JveCA9PT0gbnVsbCAmJiBuLmNvbXB1dGVCb3VuZGluZ0JveCgpLCBycy5jb3B5KG4uYm91bmRpbmdCb3gpLCBycy5hcHBseU1hdHJpeDQoZS5tYXRyaXhXb3JsZCksIHRoaXMudW5pb24ocnMpO1xuICAgIGNvbnN0IGkgPSBlLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IHMgPSAwLCBvID0gaS5sZW5ndGg7IHMgPCBvOyBzKyspXG4gICAgICB0aGlzLmV4cGFuZEJ5T2JqZWN0KGlbc10sIHQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQoZSkge1xuICAgIHJldHVybiAhKGUueCA8IHRoaXMubWluLnggfHwgZS54ID4gdGhpcy5tYXgueCB8fCBlLnkgPCB0aGlzLm1pbi55IHx8IGUueSA+IHRoaXMubWF4LnkgfHwgZS56IDwgdGhpcy5taW4ueiB8fCBlLnogPiB0aGlzLm1heC56KTtcbiAgfVxuICBjb250YWluc0JveChlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluLnggPD0gZS5taW4ueCAmJiBlLm1heC54IDw9IHRoaXMubWF4LnggJiYgdGhpcy5taW4ueSA8PSBlLm1pbi55ICYmIGUubWF4LnkgPD0gdGhpcy5tYXgueSAmJiB0aGlzLm1pbi56IDw9IGUubWluLnogJiYgZS5tYXgueiA8PSB0aGlzLm1heC56O1xuICB9XG4gIGdldFBhcmFtZXRlcihlLCB0KSB7XG4gICAgcmV0dXJuIHQuc2V0KFxuICAgICAgKGUueCAtIHRoaXMubWluLngpIC8gKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSxcbiAgICAgIChlLnkgLSB0aGlzLm1pbi55KSAvICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSksXG4gICAgICAoZS56IC0gdGhpcy5taW4ueikgLyAodGhpcy5tYXgueiAtIHRoaXMubWluLnopXG4gICAgKTtcbiAgfVxuICBpbnRlcnNlY3RzQm94KGUpIHtcbiAgICByZXR1cm4gIShlLm1heC54IDwgdGhpcy5taW4ueCB8fCBlLm1pbi54ID4gdGhpcy5tYXgueCB8fCBlLm1heC55IDwgdGhpcy5taW4ueSB8fCBlLm1pbi55ID4gdGhpcy5tYXgueSB8fCBlLm1heC56IDwgdGhpcy5taW4ueiB8fCBlLm1pbi56ID4gdGhpcy5tYXgueik7XG4gIH1cbiAgaW50ZXJzZWN0c1NwaGVyZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhbXBQb2ludChlLmNlbnRlciwgZG4pLCBkbi5kaXN0YW5jZVRvU3F1YXJlZChlLmNlbnRlcikgPD0gZS5yYWRpdXMgKiBlLnJhZGl1cztcbiAgfVxuICBpbnRlcnNlY3RzUGxhbmUoZSkge1xuICAgIGxldCB0LCBuO1xuICAgIHJldHVybiBlLm5vcm1hbC54ID4gMCA/ICh0ID0gZS5ub3JtYWwueCAqIHRoaXMubWluLngsIG4gPSBlLm5vcm1hbC54ICogdGhpcy5tYXgueCkgOiAodCA9IGUubm9ybWFsLnggKiB0aGlzLm1heC54LCBuID0gZS5ub3JtYWwueCAqIHRoaXMubWluLngpLCBlLm5vcm1hbC55ID4gMCA/ICh0ICs9IGUubm9ybWFsLnkgKiB0aGlzLm1pbi55LCBuICs9IGUubm9ybWFsLnkgKiB0aGlzLm1heC55KSA6ICh0ICs9IGUubm9ybWFsLnkgKiB0aGlzLm1heC55LCBuICs9IGUubm9ybWFsLnkgKiB0aGlzLm1pbi55KSwgZS5ub3JtYWwueiA+IDAgPyAodCArPSBlLm5vcm1hbC56ICogdGhpcy5taW4ueiwgbiArPSBlLm5vcm1hbC56ICogdGhpcy5tYXgueikgOiAodCArPSBlLm5vcm1hbC56ICogdGhpcy5tYXgueiwgbiArPSBlLm5vcm1hbC56ICogdGhpcy5taW4ueiksIHQgPD0gLWUuY29uc3RhbnQgJiYgbiA+PSAtZS5jb25zdGFudDtcbiAgfVxuICBpbnRlcnNlY3RzVHJpYW5nbGUoZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB0aGlzLmdldENlbnRlcihlaSksIHZpLnN1YlZlY3RvcnModGhpcy5tYXgsIGVpKSwgRG4uc3ViVmVjdG9ycyhlLmEsIGVpKSwgUG4uc3ViVmVjdG9ycyhlLmIsIGVpKSwgSW4uc3ViVmVjdG9ycyhlLmMsIGVpKSwgbm4uc3ViVmVjdG9ycyhQbiwgRG4pLCBzbi5zdWJWZWN0b3JzKEluLCBQbiksIGZuLnN1YlZlY3RvcnMoRG4sIEluKTtcbiAgICBsZXQgdCA9IFtcbiAgICAgIDAsXG4gICAgICAtbm4ueixcbiAgICAgIG5uLnksXG4gICAgICAwLFxuICAgICAgLXNuLnosXG4gICAgICBzbi55LFxuICAgICAgMCxcbiAgICAgIC1mbi56LFxuICAgICAgZm4ueSxcbiAgICAgIG5uLnosXG4gICAgICAwLFxuICAgICAgLW5uLngsXG4gICAgICBzbi56LFxuICAgICAgMCxcbiAgICAgIC1zbi54LFxuICAgICAgZm4ueixcbiAgICAgIDAsXG4gICAgICAtZm4ueCxcbiAgICAgIC1ubi55LFxuICAgICAgbm4ueCxcbiAgICAgIDAsXG4gICAgICAtc24ueSxcbiAgICAgIHNuLngsXG4gICAgICAwLFxuICAgICAgLWZuLnksXG4gICAgICBmbi54LFxuICAgICAgMFxuICAgIF07XG4gICAgcmV0dXJuICFvcyh0LCBEbiwgUG4sIEluLCB2aSkgfHwgKHQgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0sICFvcyh0LCBEbiwgUG4sIEluLCB2aSkpID8gITEgOiAoeGkuY3Jvc3NWZWN0b3JzKG5uLCBzbiksIHQgPSBbeGkueCwgeGkueSwgeGkuel0sIG9zKHQsIERuLCBQbiwgSW4sIHZpKSk7XG4gIH1cbiAgY2xhbXBQb2ludChlLCB0KSB7XG4gICAgcmV0dXJuIHQuY29weShlKS5jbGFtcCh0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICB9XG4gIGRpc3RhbmNlVG9Qb2ludChlKSB7XG4gICAgcmV0dXJuIGRuLmNvcHkoZSkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KS5zdWIoZSkubGVuZ3RoKCk7XG4gIH1cbiAgZ2V0Qm91bmRpbmdTcGhlcmUoZSkge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlcihlLmNlbnRlciksIGUucmFkaXVzID0gdGhpcy5nZXRTaXplKGRuKS5sZW5ndGgoKSAqIDAuNSwgZTtcbiAgfVxuICBpbnRlcnNlY3QoZSkge1xuICAgIHJldHVybiB0aGlzLm1pbi5tYXgoZS5taW4pLCB0aGlzLm1heC5taW4oZS5tYXgpLCB0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLm1ha2VFbXB0eSgpLCB0aGlzO1xuICB9XG4gIHVuaW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4ubWluKGUubWluKSwgdGhpcy5tYXgubWF4KGUubWF4KSwgdGhpcztcbiAgfVxuICBhcHBseU1hdHJpeDQoZSkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRoaXMgOiAoV3RbMF0uc2V0KHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChlKSwgV3RbMV0uc2V0KHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChlKSwgV3RbMl0uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChlKSwgV3RbM10uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChlKSwgV3RbNF0uc2V0KHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChlKSwgV3RbNV0uc2V0KHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChlKSwgV3RbNl0uc2V0KHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChlKSwgV3RbN10uc2V0KHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChlKSwgdGhpcy5zZXRGcm9tUG9pbnRzKFd0KSwgdGhpcyk7XG4gIH1cbiAgdHJhbnNsYXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4uYWRkKGUpLCB0aGlzLm1heC5hZGQoZSksIHRoaXM7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICByZXR1cm4gZS5taW4uZXF1YWxzKHRoaXMubWluKSAmJiBlLm1heC5lcXVhbHModGhpcy5tYXgpO1xuICB9XG59XG5jb25zdCBXdCA9IFtcbiAgLyogQF9fUFVSRV9fICovIG5ldyBPKCksXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSxcbiAgLyogQF9fUFVSRV9fICovIG5ldyBPKCksXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSxcbiAgLyogQF9fUFVSRV9fICovIG5ldyBPKCksXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpXG5dLCBkbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZGkoKSwgRG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgUG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgSW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgbm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgc24gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgZm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgZWkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgdmkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgeGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgcG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKTtcbmZ1bmN0aW9uIG9zKGgsIGUsIHQsIG4sIGkpIHtcbiAgZm9yIChsZXQgcyA9IDAsIG8gPSBoLmxlbmd0aCAtIDM7IHMgPD0gbzsgcyArPSAzKSB7XG4gICAgcG4uZnJvbUFycmF5KGgsIHMpO1xuICAgIGNvbnN0IHIgPSBpLnggKiBNYXRoLmFicyhwbi54KSArIGkueSAqIE1hdGguYWJzKHBuLnkpICsgaS56ICogTWF0aC5hYnMocG4ueiksIGwgPSBlLmRvdChwbiksIGEgPSB0LmRvdChwbiksIGMgPSBuLmRvdChwbik7XG4gICAgaWYgKE1hdGgubWF4KC1NYXRoLm1heChsLCBhLCBjKSwgTWF0aC5taW4obCwgYSwgYykpID4gcilcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5jb25zdCBHbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZGkoKSwgSnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgeWkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgYXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKTtcbmNsYXNzIGNpIHtcbiAgY29uc3RydWN0b3IoZSA9IG5ldyBPKCksIHQgPSAtMSkge1xuICAgIHRoaXMuY2VudGVyID0gZSwgdGhpcy5yYWRpdXMgPSB0O1xuICB9XG4gIHNldChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2VudGVyLmNvcHkoZSksIHRoaXMucmFkaXVzID0gdCwgdGhpcztcbiAgfVxuICBzZXRGcm9tUG9pbnRzKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5jZW50ZXI7XG4gICAgdCAhPT0gdm9pZCAwID8gbi5jb3B5KHQpIDogR28uc2V0RnJvbVBvaW50cyhlKS5nZXRDZW50ZXIobik7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHMgPSAwLCBvID0gZS5sZW5ndGg7IHMgPCBvOyBzKyspXG4gICAgICBpID0gTWF0aC5tYXgoaSwgbi5kaXN0YW5jZVRvU3F1YXJlZChlW3NdKSk7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KGkpLCB0aGlzO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLmNlbnRlci5jb3B5KGUuY2VudGVyKSwgdGhpcy5yYWRpdXMgPSBlLnJhZGl1cywgdGhpcztcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cyA8IDA7XG4gIH1cbiAgbWFrZUVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmNlbnRlci5zZXQoMCwgMCwgMCksIHRoaXMucmFkaXVzID0gLTEsIHRoaXM7XG4gIH1cbiAgY29udGFpbnNQb2ludChlKSB7XG4gICAgcmV0dXJuIGUuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpIDw9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG4gIH1cbiAgZGlzdGFuY2VUb1BvaW50KGUpIHtcbiAgICByZXR1cm4gZS5kaXN0YW5jZVRvKHRoaXMuY2VudGVyKSAtIHRoaXMucmFkaXVzO1xuICB9XG4gIGludGVyc2VjdHNTcGhlcmUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnJhZGl1cyArIGUucmFkaXVzO1xuICAgIHJldHVybiBlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcikgPD0gdCAqIHQ7XG4gIH1cbiAgaW50ZXJzZWN0c0JveChlKSB7XG4gICAgcmV0dXJuIGUuaW50ZXJzZWN0c1NwaGVyZSh0aGlzKTtcbiAgfVxuICBpbnRlcnNlY3RzUGxhbmUoZSkge1xuICAgIHJldHVybiBNYXRoLmFicyhlLmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpIDw9IHRoaXMucmFkaXVzO1xuICB9XG4gIGNsYW1wUG9pbnQoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChlKTtcbiAgICByZXR1cm4gdC5jb3B5KGUpLCBuID4gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyAmJiAodC5zdWIodGhpcy5jZW50ZXIpLm5vcm1hbGl6ZSgpLCB0Lm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKS5hZGQodGhpcy5jZW50ZXIpKSwgdDtcbiAgfVxuICBnZXRCb3VuZGluZ0JveChlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gKGUubWFrZUVtcHR5KCksIGUpIDogKGUuc2V0KHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciksIGUuZXhwYW5kQnlTY2FsYXIodGhpcy5yYWRpdXMpLCBlKTtcbiAgfVxuICBhcHBseU1hdHJpeDQoZSkge1xuICAgIHJldHVybiB0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoZSksIHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBlLmdldE1heFNjYWxlT25BeGlzKCksIHRoaXM7XG4gIH1cbiAgdHJhbnNsYXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5jZW50ZXIuYWRkKGUpLCB0aGlzO1xuICB9XG4gIGV4cGFuZEJ5UG9pbnQoZSkge1xuICAgIGFzLnN1YlZlY3RvcnMoZSwgdGhpcy5jZW50ZXIpO1xuICAgIGNvbnN0IHQgPSBhcy5sZW5ndGhTcSgpO1xuICAgIGlmICh0ID4gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykge1xuICAgICAgY29uc3QgbiA9IE1hdGguc3FydCh0KSwgaSA9IChuIC0gdGhpcy5yYWRpdXMpICogMC41O1xuICAgICAgdGhpcy5jZW50ZXIuYWRkKGFzLm11bHRpcGx5U2NhbGFyKGkgLyBuKSksIHRoaXMucmFkaXVzICs9IGk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVuaW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5jZW50ZXIuZXF1YWxzKGUuY2VudGVyKSA9PT0gITAgPyB5aS5zZXQoMCwgMCwgMSkubXVsdGlwbHlTY2FsYXIoZS5yYWRpdXMpIDogeWkuc3ViVmVjdG9ycyhlLmNlbnRlciwgdGhpcy5jZW50ZXIpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGUucmFkaXVzKSwgdGhpcy5leHBhbmRCeVBvaW50KEpzLmNvcHkoZS5jZW50ZXIpLmFkZCh5aSkpLCB0aGlzLmV4cGFuZEJ5UG9pbnQoSnMuY29weShlLmNlbnRlcikuc3ViKHlpKSksIHRoaXM7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICByZXR1cm4gZS5jZW50ZXIuZXF1YWxzKHRoaXMuY2VudGVyKSAmJiBlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgfVxufVxuY29uc3QgVnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgYmkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgcm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgY3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgd2kgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgaHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKTtcbmNsYXNzIGtvIHtcbiAgY29uc3RydWN0b3IoZSA9IG5ldyBPKCksIHQgPSBuZXcgTygwLCAwLCAtMSkpIHtcbiAgICB0aGlzLm9yaWdpbiA9IGUsIHRoaXMuZGlyZWN0aW9uID0gdDtcbiAgfVxuICBzZXQoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbi5jb3B5KGUpLCB0aGlzLmRpcmVjdGlvbi5jb3B5KHQpLCB0aGlzO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbi5jb3B5KGUub3JpZ2luKSwgdGhpcy5kaXJlY3Rpb24uY29weShlLmRpcmVjdGlvbiksIHRoaXM7XG4gIH1cbiAgYXQoZSwgdCkge1xuICAgIHJldHVybiB0LmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGUpLmFkZCh0aGlzLm9yaWdpbik7XG4gIH1cbiAgbG9va0F0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24uY29weShlKS5zdWIodGhpcy5vcmlnaW4pLm5vcm1hbGl6ZSgpLCB0aGlzO1xuICB9XG4gIHJlY2FzdChlKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luLmNvcHkodGhpcy5hdChlLCBWdCkpLCB0aGlzO1xuICB9XG4gIGNsb3Nlc3RQb2ludFRvUG9pbnQoZSwgdCkge1xuICAgIHQuc3ViVmVjdG9ycyhlLCB0aGlzLm9yaWdpbik7XG4gICAgY29uc3QgbiA9IHQuZG90KHRoaXMuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbiA8IDAgPyB0LmNvcHkodGhpcy5vcmlnaW4pIDogdC5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihuKS5hZGQodGhpcy5vcmlnaW4pO1xuICB9XG4gIGRpc3RhbmNlVG9Qb2ludChlKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3FUb1BvaW50KGUpKTtcbiAgfVxuICBkaXN0YW5jZVNxVG9Qb2ludChlKSB7XG4gICAgY29uc3QgdCA9IFZ0LnN1YlZlY3RvcnMoZSwgdGhpcy5vcmlnaW4pLmRvdCh0aGlzLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIHQgPCAwID8gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoZSkgOiAoVnQuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIodCkuYWRkKHRoaXMub3JpZ2luKSwgVnQuZGlzdGFuY2VUb1NxdWFyZWQoZSkpO1xuICB9XG4gIGRpc3RhbmNlU3FUb1NlZ21lbnQoZSwgdCwgbiwgaSkge1xuICAgIGxzLmNvcHkoZSkuYWRkKHQpLm11bHRpcGx5U2NhbGFyKDAuNSksIGJpLmNvcHkodCkuc3ViKGUpLm5vcm1hbGl6ZSgpLCBybi5jb3B5KHRoaXMub3JpZ2luKS5zdWIobHMpO1xuICAgIGNvbnN0IHMgPSBlLmRpc3RhbmNlVG8odCkgKiAwLjUsIG8gPSAtdGhpcy5kaXJlY3Rpb24uZG90KGJpKSwgciA9IHJuLmRvdCh0aGlzLmRpcmVjdGlvbiksIGwgPSAtcm4uZG90KGJpKSwgYSA9IHJuLmxlbmd0aFNxKCksIGMgPSBNYXRoLmFicygxIC0gbyAqIG8pO1xuICAgIGxldCBkLCB1LCBtLCBnO1xuICAgIGlmIChjID4gMClcbiAgICAgIGlmIChkID0gbyAqIGwgLSByLCB1ID0gbyAqIHIgLSBsLCBnID0gcyAqIGMsIGQgPj0gMClcbiAgICAgICAgaWYgKHUgPj0gLWcpXG4gICAgICAgICAgaWYgKHUgPD0gZykge1xuICAgICAgICAgICAgY29uc3QgcCA9IDEgLyBjO1xuICAgICAgICAgICAgZCAqPSBwLCB1ICo9IHAsIG0gPSBkICogKGQgKyBvICogdSArIDIgKiByKSArIHUgKiAobyAqIGQgKyB1ICsgMiAqIGwpICsgYTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHUgPSBzLCBkID0gTWF0aC5tYXgoMCwgLShvICogdSArIHIpKSwgbSA9IC1kICogZCArIHUgKiAodSArIDIgKiBsKSArIGE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB1ID0gLXMsIGQgPSBNYXRoLm1heCgwLCAtKG8gKiB1ICsgcikpLCBtID0gLWQgKiBkICsgdSAqICh1ICsgMiAqIGwpICsgYTtcbiAgICAgIGVsc2VcbiAgICAgICAgdSA8PSAtZyA/IChkID0gTWF0aC5tYXgoMCwgLSgtbyAqIHMgKyByKSksIHUgPSBkID4gMCA/IC1zIDogTWF0aC5taW4oTWF0aC5tYXgoLXMsIC1sKSwgcyksIG0gPSAtZCAqIGQgKyB1ICogKHUgKyAyICogbCkgKyBhKSA6IHUgPD0gZyA/IChkID0gMCwgdSA9IE1hdGgubWluKE1hdGgubWF4KC1zLCAtbCksIHMpLCBtID0gdSAqICh1ICsgMiAqIGwpICsgYSkgOiAoZCA9IE1hdGgubWF4KDAsIC0obyAqIHMgKyByKSksIHUgPSBkID4gMCA/IHMgOiBNYXRoLm1pbihNYXRoLm1heCgtcywgLWwpLCBzKSwgbSA9IC1kICogZCArIHUgKiAodSArIDIgKiBsKSArIGEpO1xuICAgIGVsc2VcbiAgICAgIHUgPSBvID4gMCA/IC1zIDogcywgZCA9IE1hdGgubWF4KDAsIC0obyAqIHUgKyByKSksIG0gPSAtZCAqIGQgKyB1ICogKHUgKyAyICogbCkgKyBhO1xuICAgIHJldHVybiBuICYmIG4uY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoZCkuYWRkKHRoaXMub3JpZ2luKSwgaSAmJiBpLmNvcHkoYmkpLm11bHRpcGx5U2NhbGFyKHUpLmFkZChscyksIG07XG4gIH1cbiAgaW50ZXJzZWN0U3BoZXJlKGUsIHQpIHtcbiAgICBWdC5zdWJWZWN0b3JzKGUuY2VudGVyLCB0aGlzLm9yaWdpbik7XG4gICAgY29uc3QgbiA9IFZ0LmRvdCh0aGlzLmRpcmVjdGlvbiksIGkgPSBWdC5kb3QoVnQpIC0gbiAqIG4sIHMgPSBlLnJhZGl1cyAqIGUucmFkaXVzO1xuICAgIGlmIChpID4gcylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG8gPSBNYXRoLnNxcnQocyAtIGkpLCByID0gbiAtIG8sIGwgPSBuICsgbztcbiAgICByZXR1cm4gciA8IDAgJiYgbCA8IDAgPyBudWxsIDogciA8IDAgPyB0aGlzLmF0KGwsIHQpIDogdGhpcy5hdChyLCB0KTtcbiAgfVxuICBpbnRlcnNlY3RzU3BoZXJlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVNxVG9Qb2ludChlLmNlbnRlcikgPD0gZS5yYWRpdXMgKiBlLnJhZGl1cztcbiAgfVxuICBkaXN0YW5jZVRvUGxhbmUoZSkge1xuICAgIGNvbnN0IHQgPSBlLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pO1xuICAgIGlmICh0ID09PSAwKVxuICAgICAgcmV0dXJuIGUuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKSA9PT0gMCA/IDAgOiBudWxsO1xuICAgIGNvbnN0IG4gPSAtKHRoaXMub3JpZ2luLmRvdChlLm5vcm1hbCkgKyBlLmNvbnN0YW50KSAvIHQ7XG4gICAgcmV0dXJuIG4gPj0gMCA/IG4gOiBudWxsO1xuICB9XG4gIGludGVyc2VjdFBsYW5lKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoZSk7XG4gICAgcmV0dXJuIG4gPT09IG51bGwgPyBudWxsIDogdGhpcy5hdChuLCB0KTtcbiAgfVxuICBpbnRlcnNlY3RzUGxhbmUoZSkge1xuICAgIGNvbnN0IHQgPSBlLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuIHQgPT09IDAgfHwgZS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKSAqIHQgPCAwO1xuICB9XG4gIGludGVyc2VjdEJveChlLCB0KSB7XG4gICAgbGV0IG4sIGksIHMsIG8sIHIsIGw7XG4gICAgY29uc3QgYSA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LCBjID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksIGQgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueiwgdSA9IHRoaXMub3JpZ2luO1xuICAgIHJldHVybiBhID49IDAgPyAobiA9IChlLm1pbi54IC0gdS54KSAqIGEsIGkgPSAoZS5tYXgueCAtIHUueCkgKiBhKSA6IChuID0gKGUubWF4LnggLSB1LngpICogYSwgaSA9IChlLm1pbi54IC0gdS54KSAqIGEpLCBjID49IDAgPyAocyA9IChlLm1pbi55IC0gdS55KSAqIGMsIG8gPSAoZS5tYXgueSAtIHUueSkgKiBjKSA6IChzID0gKGUubWF4LnkgLSB1LnkpICogYywgbyA9IChlLm1pbi55IC0gdS55KSAqIGMpLCBuID4gbyB8fCBzID4gaSB8fCAoKHMgPiBuIHx8IG4gIT09IG4pICYmIChuID0gcyksIChvIDwgaSB8fCBpICE9PSBpKSAmJiAoaSA9IG8pLCBkID49IDAgPyAociA9IChlLm1pbi56IC0gdS56KSAqIGQsIGwgPSAoZS5tYXgueiAtIHUueikgKiBkKSA6IChyID0gKGUubWF4LnogLSB1LnopICogZCwgbCA9IChlLm1pbi56IC0gdS56KSAqIGQpLCBuID4gbCB8fCByID4gaSkgfHwgKChyID4gbiB8fCBuICE9PSBuKSAmJiAobiA9IHIpLCAobCA8IGkgfHwgaSAhPT0gaSkgJiYgKGkgPSBsKSwgaSA8IDApID8gbnVsbCA6IHRoaXMuYXQobiA+PSAwID8gbiA6IGksIHQpO1xuICB9XG4gIGludGVyc2VjdHNCb3goZSkge1xuICAgIHJldHVybiB0aGlzLmludGVyc2VjdEJveChlLCBWdCkgIT09IG51bGw7XG4gIH1cbiAgaW50ZXJzZWN0VHJpYW5nbGUoZSwgdCwgbiwgaSwgcykge1xuICAgIGNzLnN1YlZlY3RvcnModCwgZSksIHdpLnN1YlZlY3RvcnMobiwgZSksIGhzLmNyb3NzVmVjdG9ycyhjcywgd2kpO1xuICAgIGxldCBvID0gdGhpcy5kaXJlY3Rpb24uZG90KGhzKSwgcjtcbiAgICBpZiAobyA+IDApIHtcbiAgICAgIGlmIChpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHIgPSAxO1xuICAgIH0gZWxzZSBpZiAobyA8IDApXG4gICAgICByID0gLTEsIG8gPSAtbztcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBybi5zdWJWZWN0b3JzKHRoaXMub3JpZ2luLCBlKTtcbiAgICBjb25zdCBsID0gciAqIHRoaXMuZGlyZWN0aW9uLmRvdCh3aS5jcm9zc1ZlY3RvcnMocm4sIHdpKSk7XG4gICAgaWYgKGwgPCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYSA9IHIgKiB0aGlzLmRpcmVjdGlvbi5kb3QoY3MuY3Jvc3Mocm4pKTtcbiAgICBpZiAoYSA8IDAgfHwgbCArIGEgPiBvKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYyA9IC1yICogcm4uZG90KGhzKTtcbiAgICByZXR1cm4gYyA8IDAgPyBudWxsIDogdGhpcy5hdChjIC8gbywgcyk7XG4gIH1cbiAgYXBwbHlNYXRyaXg0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KGUpLCB0aGlzLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oZSksIHRoaXM7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICByZXR1cm4gZS5vcmlnaW4uZXF1YWxzKHRoaXMub3JpZ2luKSAmJiBlLmRpcmVjdGlvbi5lcXVhbHModGhpcy5kaXJlY3Rpb24pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gIH1cbn1cbmNsYXNzIEtlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgS2UucHJvdG90eXBlLmlzTWF0cml4NCA9ICEwLCB0aGlzLmVsZW1lbnRzID0gW1xuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgIF07XG4gIH1cbiAgc2V0KGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEsIGMsIGQsIHUsIG0sIGcsIHAsIGYpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gdlswXSA9IGUsIHZbNF0gPSB0LCB2WzhdID0gbiwgdlsxMl0gPSBpLCB2WzFdID0gcywgdls1XSA9IG8sIHZbOV0gPSByLCB2WzEzXSA9IGwsIHZbMl0gPSBhLCB2WzZdID0gYywgdlsxMF0gPSBkLCB2WzE0XSA9IHUsIHZbM10gPSBtLCB2WzddID0gZywgdlsxMV0gPSBwLCB2WzE1XSA9IGYsIHRoaXM7XG4gIH1cbiAgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgICksIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBLZSgpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cywgbiA9IGUuZWxlbWVudHM7XG4gICAgcmV0dXJuIHRbMF0gPSBuWzBdLCB0WzFdID0gblsxXSwgdFsyXSA9IG5bMl0sIHRbM10gPSBuWzNdLCB0WzRdID0gbls0XSwgdFs1XSA9IG5bNV0sIHRbNl0gPSBuWzZdLCB0WzddID0gbls3XSwgdFs4XSA9IG5bOF0sIHRbOV0gPSBuWzldLCB0WzEwXSA9IG5bMTBdLCB0WzExXSA9IG5bMTFdLCB0WzEyXSA9IG5bMTJdLCB0WzEzXSA9IG5bMTNdLCB0WzE0XSA9IG5bMTRdLCB0WzE1XSA9IG5bMTVdLCB0aGlzO1xuICB9XG4gIGNvcHlQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIG4gPSBlLmVsZW1lbnRzO1xuICAgIHJldHVybiB0WzEyXSA9IG5bMTJdLCB0WzEzXSA9IG5bMTNdLCB0WzE0XSA9IG5bMTRdLCB0aGlzO1xuICB9XG4gIHNldEZyb21NYXRyaXgzKGUpIHtcbiAgICBjb25zdCB0ID0gZS5lbGVtZW50cztcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICB0WzBdLFxuICAgICAgdFszXSxcbiAgICAgIHRbNl0sXG4gICAgICAwLFxuICAgICAgdFsxXSxcbiAgICAgIHRbNF0sXG4gICAgICB0WzddLFxuICAgICAgMCxcbiAgICAgIHRbMl0sXG4gICAgICB0WzVdLFxuICAgICAgdFs4XSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgKSwgdGhpcztcbiAgfVxuICBleHRyYWN0QmFzaXMoZSwgdCwgbikge1xuICAgIHJldHVybiBlLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMCksIHQuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAxKSwgbi5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDIpLCB0aGlzO1xuICB9XG4gIG1ha2VCYXNpcyhlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgZS54LFxuICAgICAgdC54LFxuICAgICAgbi54LFxuICAgICAgMCxcbiAgICAgIGUueSxcbiAgICAgIHQueSxcbiAgICAgIG4ueSxcbiAgICAgIDAsXG4gICAgICBlLnosXG4gICAgICB0LnosXG4gICAgICBuLnosXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgICksIHRoaXM7XG4gIH1cbiAgZXh0cmFjdFJvdGF0aW9uKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cywgbiA9IGUuZWxlbWVudHMsIGkgPSAxIC8gem4uc2V0RnJvbU1hdHJpeENvbHVtbihlLCAwKS5sZW5ndGgoKSwgcyA9IDEgLyB6bi5zZXRGcm9tTWF0cml4Q29sdW1uKGUsIDEpLmxlbmd0aCgpLCBvID0gMSAvIHpuLnNldEZyb21NYXRyaXhDb2x1bW4oZSwgMikubGVuZ3RoKCk7XG4gICAgcmV0dXJuIHRbMF0gPSBuWzBdICogaSwgdFsxXSA9IG5bMV0gKiBpLCB0WzJdID0gblsyXSAqIGksIHRbM10gPSAwLCB0WzRdID0gbls0XSAqIHMsIHRbNV0gPSBuWzVdICogcywgdFs2XSA9IG5bNl0gKiBzLCB0WzddID0gMCwgdFs4XSA9IG5bOF0gKiBvLCB0WzldID0gbls5XSAqIG8sIHRbMTBdID0gblsxMF0gKiBvLCB0WzExXSA9IDAsIHRbMTJdID0gMCwgdFsxM10gPSAwLCB0WzE0XSA9IDAsIHRbMTVdID0gMSwgdGhpcztcbiAgfVxuICBtYWtlUm90YXRpb25Gcm9tRXVsZXIoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzLCBuID0gZS54LCBpID0gZS55LCBzID0gZS56LCBvID0gTWF0aC5jb3MobiksIHIgPSBNYXRoLnNpbihuKSwgbCA9IE1hdGguY29zKGkpLCBhID0gTWF0aC5zaW4oaSksIGMgPSBNYXRoLmNvcyhzKSwgZCA9IE1hdGguc2luKHMpO1xuICAgIGlmIChlLm9yZGVyID09PSBcIlhZWlwiKSB7XG4gICAgICBjb25zdCB1ID0gbyAqIGMsIG0gPSBvICogZCwgZyA9IHIgKiBjLCBwID0gciAqIGQ7XG4gICAgICB0WzBdID0gbCAqIGMsIHRbNF0gPSAtbCAqIGQsIHRbOF0gPSBhLCB0WzFdID0gbSArIGcgKiBhLCB0WzVdID0gdSAtIHAgKiBhLCB0WzldID0gLXIgKiBsLCB0WzJdID0gcCAtIHUgKiBhLCB0WzZdID0gZyArIG0gKiBhLCB0WzEwXSA9IG8gKiBsO1xuICAgIH0gZWxzZSBpZiAoZS5vcmRlciA9PT0gXCJZWFpcIikge1xuICAgICAgY29uc3QgdSA9IGwgKiBjLCBtID0gbCAqIGQsIGcgPSBhICogYywgcCA9IGEgKiBkO1xuICAgICAgdFswXSA9IHUgKyBwICogciwgdFs0XSA9IGcgKiByIC0gbSwgdFs4XSA9IG8gKiBhLCB0WzFdID0gbyAqIGQsIHRbNV0gPSBvICogYywgdFs5XSA9IC1yLCB0WzJdID0gbSAqIHIgLSBnLCB0WzZdID0gcCArIHUgKiByLCB0WzEwXSA9IG8gKiBsO1xuICAgIH0gZWxzZSBpZiAoZS5vcmRlciA9PT0gXCJaWFlcIikge1xuICAgICAgY29uc3QgdSA9IGwgKiBjLCBtID0gbCAqIGQsIGcgPSBhICogYywgcCA9IGEgKiBkO1xuICAgICAgdFswXSA9IHUgLSBwICogciwgdFs0XSA9IC1vICogZCwgdFs4XSA9IGcgKyBtICogciwgdFsxXSA9IG0gKyBnICogciwgdFs1XSA9IG8gKiBjLCB0WzldID0gcCAtIHUgKiByLCB0WzJdID0gLW8gKiBhLCB0WzZdID0gciwgdFsxMF0gPSBvICogbDtcbiAgICB9IGVsc2UgaWYgKGUub3JkZXIgPT09IFwiWllYXCIpIHtcbiAgICAgIGNvbnN0IHUgPSBvICogYywgbSA9IG8gKiBkLCBnID0gciAqIGMsIHAgPSByICogZDtcbiAgICAgIHRbMF0gPSBsICogYywgdFs0XSA9IGcgKiBhIC0gbSwgdFs4XSA9IHUgKiBhICsgcCwgdFsxXSA9IGwgKiBkLCB0WzVdID0gcCAqIGEgKyB1LCB0WzldID0gbSAqIGEgLSBnLCB0WzJdID0gLWEsIHRbNl0gPSByICogbCwgdFsxMF0gPSBvICogbDtcbiAgICB9IGVsc2UgaWYgKGUub3JkZXIgPT09IFwiWVpYXCIpIHtcbiAgICAgIGNvbnN0IHUgPSBvICogbCwgbSA9IG8gKiBhLCBnID0gciAqIGwsIHAgPSByICogYTtcbiAgICAgIHRbMF0gPSBsICogYywgdFs0XSA9IHAgLSB1ICogZCwgdFs4XSA9IGcgKiBkICsgbSwgdFsxXSA9IGQsIHRbNV0gPSBvICogYywgdFs5XSA9IC1yICogYywgdFsyXSA9IC1hICogYywgdFs2XSA9IG0gKiBkICsgZywgdFsxMF0gPSB1IC0gcCAqIGQ7XG4gICAgfSBlbHNlIGlmIChlLm9yZGVyID09PSBcIlhaWVwiKSB7XG4gICAgICBjb25zdCB1ID0gbyAqIGwsIG0gPSBvICogYSwgZyA9IHIgKiBsLCBwID0gciAqIGE7XG4gICAgICB0WzBdID0gbCAqIGMsIHRbNF0gPSAtZCwgdFs4XSA9IGEgKiBjLCB0WzFdID0gdSAqIGQgKyBwLCB0WzVdID0gbyAqIGMsIHRbOV0gPSBtICogZCAtIGcsIHRbMl0gPSBnICogZCAtIG0sIHRbNl0gPSByICogYywgdFsxMF0gPSBwICogZCArIHU7XG4gICAgfVxuICAgIHJldHVybiB0WzNdID0gMCwgdFs3XSA9IDAsIHRbMTFdID0gMCwgdFsxMl0gPSAwLCB0WzEzXSA9IDAsIHRbMTRdID0gMCwgdFsxNV0gPSAxLCB0aGlzO1xuICB9XG4gIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb3NlKFdvLCBlLCBWbyk7XG4gIH1cbiAgbG9va0F0KGUsIHQsIG4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gZnQuc3ViVmVjdG9ycyhlLCB0KSwgZnQubGVuZ3RoU3EoKSA9PT0gMCAmJiAoZnQueiA9IDEpLCBmdC5ub3JtYWxpemUoKSwgb24uY3Jvc3NWZWN0b3JzKG4sIGZ0KSwgb24ubGVuZ3RoU3EoKSA9PT0gMCAmJiAoTWF0aC5hYnMobi56KSA9PT0gMSA/IGZ0LnggKz0gMWUtNCA6IGZ0LnogKz0gMWUtNCwgZnQubm9ybWFsaXplKCksIG9uLmNyb3NzVmVjdG9ycyhuLCBmdCkpLCBvbi5ub3JtYWxpemUoKSwgTWkuY3Jvc3NWZWN0b3JzKGZ0LCBvbiksIGlbMF0gPSBvbi54LCBpWzRdID0gTWkueCwgaVs4XSA9IGZ0LngsIGlbMV0gPSBvbi55LCBpWzVdID0gTWkueSwgaVs5XSA9IGZ0LnksIGlbMl0gPSBvbi56LCBpWzZdID0gTWkueiwgaVsxMF0gPSBmdC56LCB0aGlzO1xuICB9XG4gIG11bHRpcGx5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsIGUpO1xuICB9XG4gIHByZW11bHRpcGx5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKGUsIHRoaXMpO1xuICB9XG4gIG11bHRpcGx5TWF0cmljZXMoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBlLmVsZW1lbnRzLCBpID0gdC5lbGVtZW50cywgcyA9IHRoaXMuZWxlbWVudHMsIG8gPSBuWzBdLCByID0gbls0XSwgbCA9IG5bOF0sIGEgPSBuWzEyXSwgYyA9IG5bMV0sIGQgPSBuWzVdLCB1ID0gbls5XSwgbSA9IG5bMTNdLCBnID0gblsyXSwgcCA9IG5bNl0sIGYgPSBuWzEwXSwgdiA9IG5bMTRdLCBfID0gblszXSwgdyA9IG5bN10sIHggPSBuWzExXSwgTSA9IG5bMTVdLCBFID0gaVswXSwgUiA9IGlbNF0sIHkgPSBpWzhdLCBBID0gaVsxMl0sIEYgPSBpWzFdLCBQID0gaVs1XSwgRyA9IGlbOV0sIHogPSBpWzEzXSwgTCA9IGlbMl0sIEkgPSBpWzZdLCBEID0gaVsxMF0sIHEgPSBpWzE0XSwgayA9IGlbM10sIE4gPSBpWzddLCBIID0gaVsxMV0sIEogPSBpWzE1XTtcbiAgICByZXR1cm4gc1swXSA9IG8gKiBFICsgciAqIEYgKyBsICogTCArIGEgKiBrLCBzWzRdID0gbyAqIFIgKyByICogUCArIGwgKiBJICsgYSAqIE4sIHNbOF0gPSBvICogeSArIHIgKiBHICsgbCAqIEQgKyBhICogSCwgc1sxMl0gPSBvICogQSArIHIgKiB6ICsgbCAqIHEgKyBhICogSiwgc1sxXSA9IGMgKiBFICsgZCAqIEYgKyB1ICogTCArIG0gKiBrLCBzWzVdID0gYyAqIFIgKyBkICogUCArIHUgKiBJICsgbSAqIE4sIHNbOV0gPSBjICogeSArIGQgKiBHICsgdSAqIEQgKyBtICogSCwgc1sxM10gPSBjICogQSArIGQgKiB6ICsgdSAqIHEgKyBtICogSiwgc1syXSA9IGcgKiBFICsgcCAqIEYgKyBmICogTCArIHYgKiBrLCBzWzZdID0gZyAqIFIgKyBwICogUCArIGYgKiBJICsgdiAqIE4sIHNbMTBdID0gZyAqIHkgKyBwICogRyArIGYgKiBEICsgdiAqIEgsIHNbMTRdID0gZyAqIEEgKyBwICogeiArIGYgKiBxICsgdiAqIEosIHNbM10gPSBfICogRSArIHcgKiBGICsgeCAqIEwgKyBNICogaywgc1s3XSA9IF8gKiBSICsgdyAqIFAgKyB4ICogSSArIE0gKiBOLCBzWzExXSA9IF8gKiB5ICsgdyAqIEcgKyB4ICogRCArIE0gKiBILCBzWzE1XSA9IF8gKiBBICsgdyAqIHogKyB4ICogcSArIE0gKiBKLCB0aGlzO1xuICB9XG4gIG11bHRpcGx5U2NhbGFyKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gdFswXSAqPSBlLCB0WzRdICo9IGUsIHRbOF0gKj0gZSwgdFsxMl0gKj0gZSwgdFsxXSAqPSBlLCB0WzVdICo9IGUsIHRbOV0gKj0gZSwgdFsxM10gKj0gZSwgdFsyXSAqPSBlLCB0WzZdICo9IGUsIHRbMTBdICo9IGUsIHRbMTRdICo9IGUsIHRbM10gKj0gZSwgdFs3XSAqPSBlLCB0WzExXSAqPSBlLCB0WzE1XSAqPSBlLCB0aGlzO1xuICB9XG4gIGRldGVybWluYW50KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCB0ID0gZVswXSwgbiA9IGVbNF0sIGkgPSBlWzhdLCBzID0gZVsxMl0sIG8gPSBlWzFdLCByID0gZVs1XSwgbCA9IGVbOV0sIGEgPSBlWzEzXSwgYyA9IGVbMl0sIGQgPSBlWzZdLCB1ID0gZVsxMF0sIG0gPSBlWzE0XSwgZyA9IGVbM10sIHAgPSBlWzddLCBmID0gZVsxMV0sIHYgPSBlWzE1XTtcbiAgICByZXR1cm4gZyAqICgrcyAqIGwgKiBkIC0gaSAqIGEgKiBkIC0gcyAqIHIgKiB1ICsgbiAqIGEgKiB1ICsgaSAqIHIgKiBtIC0gbiAqIGwgKiBtKSArIHAgKiAoK3QgKiBsICogbSAtIHQgKiBhICogdSArIHMgKiBvICogdSAtIGkgKiBvICogbSArIGkgKiBhICogYyAtIHMgKiBsICogYykgKyBmICogKCt0ICogYSAqIGQgLSB0ICogciAqIG0gLSBzICogbyAqIGQgKyBuICogbyAqIG0gKyBzICogciAqIGMgLSBuICogYSAqIGMpICsgdiAqICgtaSAqIHIgKiBjIC0gdCAqIGwgKiBkICsgdCAqIHIgKiB1ICsgaSAqIG8gKiBkIC0gbiAqIG8gKiB1ICsgbiAqIGwgKiBjKTtcbiAgfVxuICB0cmFuc3Bvc2UoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IHQ7XG4gICAgcmV0dXJuIHQgPSBlWzFdLCBlWzFdID0gZVs0XSwgZVs0XSA9IHQsIHQgPSBlWzJdLCBlWzJdID0gZVs4XSwgZVs4XSA9IHQsIHQgPSBlWzZdLCBlWzZdID0gZVs5XSwgZVs5XSA9IHQsIHQgPSBlWzNdLCBlWzNdID0gZVsxMl0sIGVbMTJdID0gdCwgdCA9IGVbN10sIGVbN10gPSBlWzEzXSwgZVsxM10gPSB0LCB0ID0gZVsxMV0sIGVbMTFdID0gZVsxNF0sIGVbMTRdID0gdCwgdGhpcztcbiAgfVxuICBzZXRQb3NpdGlvbihlLCB0LCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIGUuaXNWZWN0b3IzID8gKGlbMTJdID0gZS54LCBpWzEzXSA9IGUueSwgaVsxNF0gPSBlLnopIDogKGlbMTJdID0gZSwgaVsxM10gPSB0LCBpWzE0XSA9IG4pLCB0aGlzO1xuICB9XG4gIGludmVydCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cywgdCA9IGVbMF0sIG4gPSBlWzFdLCBpID0gZVsyXSwgcyA9IGVbM10sIG8gPSBlWzRdLCByID0gZVs1XSwgbCA9IGVbNl0sIGEgPSBlWzddLCBjID0gZVs4XSwgZCA9IGVbOV0sIHUgPSBlWzEwXSwgbSA9IGVbMTFdLCBnID0gZVsxMl0sIHAgPSBlWzEzXSwgZiA9IGVbMTRdLCB2ID0gZVsxNV0sIF8gPSBkICogZiAqIGEgLSBwICogdSAqIGEgKyBwICogbCAqIG0gLSByICogZiAqIG0gLSBkICogbCAqIHYgKyByICogdSAqIHYsIHcgPSBnICogdSAqIGEgLSBjICogZiAqIGEgLSBnICogbCAqIG0gKyBvICogZiAqIG0gKyBjICogbCAqIHYgLSBvICogdSAqIHYsIHggPSBjICogcCAqIGEgLSBnICogZCAqIGEgKyBnICogciAqIG0gLSBvICogcCAqIG0gLSBjICogciAqIHYgKyBvICogZCAqIHYsIE0gPSBnICogZCAqIGwgLSBjICogcCAqIGwgLSBnICogciAqIHUgKyBvICogcCAqIHUgKyBjICogciAqIGYgLSBvICogZCAqIGYsIEUgPSB0ICogXyArIG4gKiB3ICsgaSAqIHggKyBzICogTTtcbiAgICBpZiAoRSA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICBjb25zdCBSID0gMSAvIEU7XG4gICAgcmV0dXJuIGVbMF0gPSBfICogUiwgZVsxXSA9IChwICogdSAqIHMgLSBkICogZiAqIHMgLSBwICogaSAqIG0gKyBuICogZiAqIG0gKyBkICogaSAqIHYgLSBuICogdSAqIHYpICogUiwgZVsyXSA9IChyICogZiAqIHMgLSBwICogbCAqIHMgKyBwICogaSAqIGEgLSBuICogZiAqIGEgLSByICogaSAqIHYgKyBuICogbCAqIHYpICogUiwgZVszXSA9IChkICogbCAqIHMgLSByICogdSAqIHMgLSBkICogaSAqIGEgKyBuICogdSAqIGEgKyByICogaSAqIG0gLSBuICogbCAqIG0pICogUiwgZVs0XSA9IHcgKiBSLCBlWzVdID0gKGMgKiBmICogcyAtIGcgKiB1ICogcyArIGcgKiBpICogbSAtIHQgKiBmICogbSAtIGMgKiBpICogdiArIHQgKiB1ICogdikgKiBSLCBlWzZdID0gKGcgKiBsICogcyAtIG8gKiBmICogcyAtIGcgKiBpICogYSArIHQgKiBmICogYSArIG8gKiBpICogdiAtIHQgKiBsICogdikgKiBSLCBlWzddID0gKG8gKiB1ICogcyAtIGMgKiBsICogcyArIGMgKiBpICogYSAtIHQgKiB1ICogYSAtIG8gKiBpICogbSArIHQgKiBsICogbSkgKiBSLCBlWzhdID0geCAqIFIsIGVbOV0gPSAoZyAqIGQgKiBzIC0gYyAqIHAgKiBzIC0gZyAqIG4gKiBtICsgdCAqIHAgKiBtICsgYyAqIG4gKiB2IC0gdCAqIGQgKiB2KSAqIFIsIGVbMTBdID0gKG8gKiBwICogcyAtIGcgKiByICogcyArIGcgKiBuICogYSAtIHQgKiBwICogYSAtIG8gKiBuICogdiArIHQgKiByICogdikgKiBSLCBlWzExXSA9IChjICogciAqIHMgLSBvICogZCAqIHMgLSBjICogbiAqIGEgKyB0ICogZCAqIGEgKyBvICogbiAqIG0gLSB0ICogciAqIG0pICogUiwgZVsxMl0gPSBNICogUiwgZVsxM10gPSAoYyAqIHAgKiBpIC0gZyAqIGQgKiBpICsgZyAqIG4gKiB1IC0gdCAqIHAgKiB1IC0gYyAqIG4gKiBmICsgdCAqIGQgKiBmKSAqIFIsIGVbMTRdID0gKGcgKiByICogaSAtIG8gKiBwICogaSAtIGcgKiBuICogbCArIHQgKiBwICogbCArIG8gKiBuICogZiAtIHQgKiByICogZikgKiBSLCBlWzE1XSA9IChvICogZCAqIGkgLSBjICogciAqIGkgKyBjICogbiAqIGwgLSB0ICogZCAqIGwgLSBvICogbiAqIHUgKyB0ICogciAqIHUpICogUiwgdGhpcztcbiAgfVxuICBzY2FsZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIG4gPSBlLngsIGkgPSBlLnksIHMgPSBlLno7XG4gICAgcmV0dXJuIHRbMF0gKj0gbiwgdFs0XSAqPSBpLCB0WzhdICo9IHMsIHRbMV0gKj0gbiwgdFs1XSAqPSBpLCB0WzldICo9IHMsIHRbMl0gKj0gbiwgdFs2XSAqPSBpLCB0WzEwXSAqPSBzLCB0WzNdICo9IG4sIHRbN10gKj0gaSwgdFsxMV0gKj0gcywgdGhpcztcbiAgfVxuICBnZXRNYXhTY2FsZU9uQXhpcygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cywgdCA9IGVbMF0gKiBlWzBdICsgZVsxXSAqIGVbMV0gKyBlWzJdICogZVsyXSwgbiA9IGVbNF0gKiBlWzRdICsgZVs1XSAqIGVbNV0gKyBlWzZdICogZVs2XSwgaSA9IGVbOF0gKiBlWzhdICsgZVs5XSAqIGVbOV0gKyBlWzEwXSAqIGVbMTBdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgodCwgbiwgaSkpO1xuICB9XG4gIG1ha2VUcmFuc2xhdGlvbihlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIHQsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICBuLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgICksIHRoaXM7XG4gIH1cbiAgbWFrZVJvdGF0aW9uWChlKSB7XG4gICAgY29uc3QgdCA9IE1hdGguY29zKGUpLCBuID0gTWF0aC5zaW4oZSk7XG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB0LFxuICAgICAgLW4sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG4sXG4gICAgICB0LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICApLCB0aGlzO1xuICB9XG4gIG1ha2VSb3RhdGlvblkoZSkge1xuICAgIGNvbnN0IHQgPSBNYXRoLmNvcyhlKSwgbiA9IE1hdGguc2luKGUpO1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIHQsXG4gICAgICAwLFxuICAgICAgbixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLW4sXG4gICAgICAwLFxuICAgICAgdCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgKSwgdGhpcztcbiAgfVxuICBtYWtlUm90YXRpb25aKGUpIHtcbiAgICBjb25zdCB0ID0gTWF0aC5jb3MoZSksIG4gPSBNYXRoLnNpbihlKTtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICB0LFxuICAgICAgLW4sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG4sXG4gICAgICB0LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgICksIHRoaXM7XG4gIH1cbiAgbWFrZVJvdGF0aW9uQXhpcyhlLCB0KSB7XG4gICAgY29uc3QgbiA9IE1hdGguY29zKHQpLCBpID0gTWF0aC5zaW4odCksIHMgPSAxIC0gbiwgbyA9IGUueCwgciA9IGUueSwgbCA9IGUueiwgYSA9IHMgKiBvLCBjID0gcyAqIHI7XG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgYSAqIG8gKyBuLFxuICAgICAgYSAqIHIgLSBpICogbCxcbiAgICAgIGEgKiBsICsgaSAqIHIsXG4gICAgICAwLFxuICAgICAgYSAqIHIgKyBpICogbCxcbiAgICAgIGMgKiByICsgbixcbiAgICAgIGMgKiBsIC0gaSAqIG8sXG4gICAgICAwLFxuICAgICAgYSAqIGwgLSBpICogcixcbiAgICAgIGMgKiBsICsgaSAqIG8sXG4gICAgICBzICogbCAqIGwgKyBuLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICApLCB0aGlzO1xuICB9XG4gIG1ha2VTY2FsZShlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgZSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB0LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG4sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgICksIHRoaXM7XG4gIH1cbiAgbWFrZVNoZWFyKGUsIHQsIG4sIGksIHMsIG8pIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAxLFxuICAgICAgbixcbiAgICAgIHMsXG4gICAgICAwLFxuICAgICAgZSxcbiAgICAgIDEsXG4gICAgICBvLFxuICAgICAgMCxcbiAgICAgIHQsXG4gICAgICBpLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgKSwgdGhpcztcbiAgfVxuICBjb21wb3NlKGUsIHQsIG4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5lbGVtZW50cywgcyA9IHQuX3gsIG8gPSB0Ll95LCByID0gdC5feiwgbCA9IHQuX3csIGEgPSBzICsgcywgYyA9IG8gKyBvLCBkID0gciArIHIsIHUgPSBzICogYSwgbSA9IHMgKiBjLCBnID0gcyAqIGQsIHAgPSBvICogYywgZiA9IG8gKiBkLCB2ID0gciAqIGQsIF8gPSBsICogYSwgdyA9IGwgKiBjLCB4ID0gbCAqIGQsIE0gPSBuLngsIEUgPSBuLnksIFIgPSBuLno7XG4gICAgcmV0dXJuIGlbMF0gPSAoMSAtIChwICsgdikpICogTSwgaVsxXSA9IChtICsgeCkgKiBNLCBpWzJdID0gKGcgLSB3KSAqIE0sIGlbM10gPSAwLCBpWzRdID0gKG0gLSB4KSAqIEUsIGlbNV0gPSAoMSAtICh1ICsgdikpICogRSwgaVs2XSA9IChmICsgXykgKiBFLCBpWzddID0gMCwgaVs4XSA9IChnICsgdykgKiBSLCBpWzldID0gKGYgLSBfKSAqIFIsIGlbMTBdID0gKDEgLSAodSArIHApKSAqIFIsIGlbMTFdID0gMCwgaVsxMl0gPSBlLngsIGlbMTNdID0gZS55LCBpWzE0XSA9IGUueiwgaVsxNV0gPSAxLCB0aGlzO1xuICB9XG4gIGRlY29tcG9zZShlLCB0LCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IHMgPSB6bi5zZXQoaVswXSwgaVsxXSwgaVsyXSkubGVuZ3RoKCk7XG4gICAgY29uc3QgbyA9IHpuLnNldChpWzRdLCBpWzVdLCBpWzZdKS5sZW5ndGgoKSwgciA9IHpuLnNldChpWzhdLCBpWzldLCBpWzEwXSkubGVuZ3RoKCk7XG4gICAgdGhpcy5kZXRlcm1pbmFudCgpIDwgMCAmJiAocyA9IC1zKSwgZS54ID0gaVsxMl0sIGUueSA9IGlbMTNdLCBlLnogPSBpWzE0XSwgVHQuY29weSh0aGlzKTtcbiAgICBjb25zdCBhID0gMSAvIHMsIGMgPSAxIC8gbywgZCA9IDEgLyByO1xuICAgIHJldHVybiBUdC5lbGVtZW50c1swXSAqPSBhLCBUdC5lbGVtZW50c1sxXSAqPSBhLCBUdC5lbGVtZW50c1syXSAqPSBhLCBUdC5lbGVtZW50c1s0XSAqPSBjLCBUdC5lbGVtZW50c1s1XSAqPSBjLCBUdC5lbGVtZW50c1s2XSAqPSBjLCBUdC5lbGVtZW50c1s4XSAqPSBkLCBUdC5lbGVtZW50c1s5XSAqPSBkLCBUdC5lbGVtZW50c1sxMF0gKj0gZCwgdC5zZXRGcm9tUm90YXRpb25NYXRyaXgoVHQpLCBuLnggPSBzLCBuLnkgPSBvLCBuLnogPSByLCB0aGlzO1xuICB9XG4gIG1ha2VQZXJzcGVjdGl2ZShlLCB0LCBuLCBpLCBzLCBvKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZWxlbWVudHMsIGwgPSAyICogcyAvICh0IC0gZSksIGEgPSAyICogcyAvIChuIC0gaSksIGMgPSAodCArIGUpIC8gKHQgLSBlKSwgZCA9IChuICsgaSkgLyAobiAtIGkpLCB1ID0gLShvICsgcykgLyAobyAtIHMpLCBtID0gLTIgKiBvICogcyAvIChvIC0gcyk7XG4gICAgcmV0dXJuIHJbMF0gPSBsLCByWzRdID0gMCwgcls4XSA9IGMsIHJbMTJdID0gMCwgclsxXSA9IDAsIHJbNV0gPSBhLCByWzldID0gZCwgclsxM10gPSAwLCByWzJdID0gMCwgcls2XSA9IDAsIHJbMTBdID0gdSwgclsxNF0gPSBtLCByWzNdID0gMCwgcls3XSA9IDAsIHJbMTFdID0gLTEsIHJbMTVdID0gMCwgdGhpcztcbiAgfVxuICBtYWtlT3J0aG9ncmFwaGljKGUsIHQsIG4sIGksIHMsIG8pIHtcbiAgICBjb25zdCByID0gdGhpcy5lbGVtZW50cywgbCA9IDEgLyAodCAtIGUpLCBhID0gMSAvIChuIC0gaSksIGMgPSAxIC8gKG8gLSBzKSwgZCA9ICh0ICsgZSkgKiBsLCB1ID0gKG4gKyBpKSAqIGEsIG0gPSAobyArIHMpICogYztcbiAgICByZXR1cm4gclswXSA9IDIgKiBsLCByWzRdID0gMCwgcls4XSA9IDAsIHJbMTJdID0gLWQsIHJbMV0gPSAwLCByWzVdID0gMiAqIGEsIHJbOV0gPSAwLCByWzEzXSA9IC11LCByWzJdID0gMCwgcls2XSA9IDAsIHJbMTBdID0gLTIgKiBjLCByWzE0XSA9IC1tLCByWzNdID0gMCwgcls3XSA9IDAsIHJbMTFdID0gMCwgclsxNV0gPSAxLCB0aGlzO1xuICB9XG4gIGVxdWFscyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIG4gPSBlLmVsZW1lbnRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICAgIGlmICh0W2ldICE9PSBuW2ldKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGZyb21BcnJheShlLCB0ID0gMCkge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMTY7IG4rKylcbiAgICAgIHRoaXMuZWxlbWVudHNbbl0gPSBlW24gKyB0XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b0FycmF5KGUgPSBbXSwgdCA9IDApIHtcbiAgICBjb25zdCBuID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gZVt0XSA9IG5bMF0sIGVbdCArIDFdID0gblsxXSwgZVt0ICsgMl0gPSBuWzJdLCBlW3QgKyAzXSA9IG5bM10sIGVbdCArIDRdID0gbls0XSwgZVt0ICsgNV0gPSBuWzVdLCBlW3QgKyA2XSA9IG5bNl0sIGVbdCArIDddID0gbls3XSwgZVt0ICsgOF0gPSBuWzhdLCBlW3QgKyA5XSA9IG5bOV0sIGVbdCArIDEwXSA9IG5bMTBdLCBlW3QgKyAxMV0gPSBuWzExXSwgZVt0ICsgMTJdID0gblsxMl0sIGVbdCArIDEzXSA9IG5bMTNdLCBlW3QgKyAxNF0gPSBuWzE0XSwgZVt0ICsgMTVdID0gblsxNV0sIGU7XG4gIH1cbn1cbmNvbnN0IHpuID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIFR0ID0gLyogQF9fUFVSRV9fICovIG5ldyBLZSgpLCBXbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygwLCAwLCAwKSwgVm8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oMSwgMSwgMSksIG9uID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIE1pID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIGZ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIFFzID0gLyogQF9fUFVSRV9fICovIG5ldyBLZSgpLCBlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdWkoKTtcbmNsYXNzIGZpIHtcbiAgY29uc3RydWN0b3IoZSA9IDAsIHQgPSAwLCBuID0gMCwgaSA9IGZpLkRlZmF1bHRPcmRlcikge1xuICAgIHRoaXMuaXNFdWxlciA9ICEwLCB0aGlzLl94ID0gZSwgdGhpcy5feSA9IHQsIHRoaXMuX3ogPSBuLCB0aGlzLl9vcmRlciA9IGk7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cbiAgc2V0IHgoZSkge1xuICAgIHRoaXMuX3ggPSBlLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH1cbiAgc2V0IHkoZSkge1xuICAgIHRoaXMuX3kgPSBlLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cbiAgZ2V0IHooKSB7XG4gICAgcmV0dXJuIHRoaXMuX3o7XG4gIH1cbiAgc2V0IHooZSkge1xuICAgIHRoaXMuX3ogPSBlLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cbiAgZ2V0IG9yZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRlcjtcbiAgfVxuICBzZXQgb3JkZXIoZSkge1xuICAgIHRoaXMuX29yZGVyID0gZSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG4gIHNldChlLCB0LCBuLCBpID0gdGhpcy5fb3JkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5feCA9IGUsIHRoaXMuX3kgPSB0LCB0aGlzLl96ID0gbiwgdGhpcy5fb3JkZXIgPSBpLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyKTtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5feCA9IGUuX3gsIHRoaXMuX3kgPSBlLl95LCB0aGlzLl96ID0gZS5feiwgdGhpcy5fb3JkZXIgPSBlLl9vcmRlciwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzO1xuICB9XG4gIHNldEZyb21Sb3RhdGlvbk1hdHJpeChlLCB0ID0gdGhpcy5fb3JkZXIsIG4gPSAhMCkge1xuICAgIGNvbnN0IGkgPSBlLmVsZW1lbnRzLCBzID0gaVswXSwgbyA9IGlbNF0sIHIgPSBpWzhdLCBsID0gaVsxXSwgYSA9IGlbNV0sIGMgPSBpWzldLCBkID0gaVsyXSwgdSA9IGlbNl0sIG0gPSBpWzEwXTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgXCJYWVpcIjpcbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbihtdChyLCAtMSwgMSkpLCBNYXRoLmFicyhyKSA8IDAuOTk5OTk5OSA/ICh0aGlzLl94ID0gTWF0aC5hdGFuMigtYywgbSksIHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1vLCBzKSkgOiAodGhpcy5feCA9IE1hdGguYXRhbjIodSwgYSksIHRoaXMuX3ogPSAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiWVhaXCI6XG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oLW10KGMsIC0xLCAxKSksIE1hdGguYWJzKGMpIDwgMC45OTk5OTk5ID8gKHRoaXMuX3kgPSBNYXRoLmF0YW4yKHIsIG0pLCB0aGlzLl96ID0gTWF0aC5hdGFuMihsLCBhKSkgOiAodGhpcy5feSA9IE1hdGguYXRhbjIoLWQsIHMpLCB0aGlzLl96ID0gMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlpYWVwiOlxuICAgICAgICB0aGlzLl94ID0gTWF0aC5hc2luKG10KHUsIC0xLCAxKSksIE1hdGguYWJzKHUpIDwgMC45OTk5OTk5ID8gKHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1kLCBtKSwgdGhpcy5feiA9IE1hdGguYXRhbjIoLW8sIGEpKSA6ICh0aGlzLl95ID0gMCwgdGhpcy5feiA9IE1hdGguYXRhbjIobCwgcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJaWVhcIjpcbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbigtbXQoZCwgLTEsIDEpKSwgTWF0aC5hYnMoZCkgPCAwLjk5OTk5OTkgPyAodGhpcy5feCA9IE1hdGguYXRhbjIodSwgbSksIHRoaXMuX3ogPSBNYXRoLmF0YW4yKGwsIHMpKSA6ICh0aGlzLl94ID0gMCwgdGhpcy5feiA9IE1hdGguYXRhbjIoLW8sIGEpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiWVpYXCI6XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4obXQobCwgLTEsIDEpKSwgTWF0aC5hYnMobCkgPCAwLjk5OTk5OTkgPyAodGhpcy5feCA9IE1hdGguYXRhbjIoLWMsIGEpLCB0aGlzLl95ID0gTWF0aC5hdGFuMigtZCwgcykpIDogKHRoaXMuX3ggPSAwLCB0aGlzLl95ID0gTWF0aC5hdGFuMihyLCBtKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlhaWVwiOlxuICAgICAgICB0aGlzLl96ID0gTWF0aC5hc2luKC1tdChvLCAtMSwgMSkpLCBNYXRoLmFicyhvKSA8IDAuOTk5OTk5OSA/ICh0aGlzLl94ID0gTWF0aC5hdGFuMih1LCBhKSwgdGhpcy5feSA9IE1hdGguYXRhbjIociwgcykpIDogKHRoaXMuX3ggPSBNYXRoLmF0YW4yKC1jLCBtKSwgdGhpcy5feSA9IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogXCIgKyB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29yZGVyID0gdCwgbiA9PT0gITAgJiYgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzO1xuICB9XG4gIHNldEZyb21RdWF0ZXJuaW9uKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gUXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oZSksIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KFFzLCB0LCBuKTtcbiAgfVxuICBzZXRGcm9tVmVjdG9yMyhlLCB0ID0gdGhpcy5fb3JkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoZS54LCBlLnksIGUueiwgdCk7XG4gIH1cbiAgcmVvcmRlcihlKSB7XG4gICAgcmV0dXJuIGVyLnNldEZyb21FdWxlcih0aGlzKSwgdGhpcy5zZXRGcm9tUXVhdGVybmlvbihlciwgZSk7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICByZXR1cm4gZS5feCA9PT0gdGhpcy5feCAmJiBlLl95ID09PSB0aGlzLl95ICYmIGUuX3ogPT09IHRoaXMuX3ogJiYgZS5fb3JkZXIgPT09IHRoaXMuX29yZGVyO1xuICB9XG4gIGZyb21BcnJheShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggPSBlWzBdLCB0aGlzLl95ID0gZVsxXSwgdGhpcy5feiA9IGVbMl0sIGVbM10gIT09IHZvaWQgMCAmJiAodGhpcy5fb3JkZXIgPSBlWzNdKSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzO1xuICB9XG4gIHRvQXJyYXkoZSA9IFtdLCB0ID0gMCkge1xuICAgIHJldHVybiBlW3RdID0gdGhpcy5feCwgZVt0ICsgMV0gPSB0aGlzLl95LCBlW3QgKyAyXSA9IHRoaXMuX3osIGVbdCArIDNdID0gdGhpcy5fb3JkZXIsIGU7XG4gIH1cbiAgX29uQ2hhbmdlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGUsIHRoaXM7XG4gIH1cbiAgX29uQ2hhbmdlQ2FsbGJhY2soKSB7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkIHRoaXMuX3gsIHlpZWxkIHRoaXMuX3ksIHlpZWxkIHRoaXMuX3osIHlpZWxkIHRoaXMuX29yZGVyO1xuICB9XG4gIHRvVmVjdG9yMygpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuRXVsZXI6IC50b1ZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tRXVsZXIoKSBpbnN0ZWFkXCIpO1xuICB9XG59XG5maS5EZWZhdWx0T3JkZXIgPSBcIlhZWlwiO1xuZmkuUm90YXRpb25PcmRlcnMgPSBbXCJYWVpcIiwgXCJZWlhcIiwgXCJaWFlcIiwgXCJYWllcIiwgXCJZWFpcIiwgXCJaWVhcIl07XG5jbGFzcyBvbyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWFzayA9IDE7XG4gIH1cbiAgc2V0KGUpIHtcbiAgICB0aGlzLm1hc2sgPSAoMSA8PCBlIHwgMCkgPj4+IDA7XG4gIH1cbiAgZW5hYmxlKGUpIHtcbiAgICB0aGlzLm1hc2sgfD0gMSA8PCBlIHwgMDtcbiAgfVxuICBlbmFibGVBbGwoKSB7XG4gICAgdGhpcy5tYXNrID0gLTE7XG4gIH1cbiAgdG9nZ2xlKGUpIHtcbiAgICB0aGlzLm1hc2sgXj0gMSA8PCBlIHwgMDtcbiAgfVxuICBkaXNhYmxlKGUpIHtcbiAgICB0aGlzLm1hc2sgJj0gfigxIDw8IGUgfCAwKTtcbiAgfVxuICBkaXNhYmxlQWxsKCkge1xuICAgIHRoaXMubWFzayA9IDA7XG4gIH1cbiAgdGVzdChlKSB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiBlLm1hc2spICE9PSAwO1xuICB9XG4gIGlzRW5hYmxlZChlKSB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiAoMSA8PCBlIHwgMCkpICE9PSAwO1xuICB9XG59XG5sZXQgSG8gPSAwO1xuY29uc3QgdHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgQm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IHVpKCksIEh0ID0gLyogQF9fUFVSRV9fICovIG5ldyBLZSgpLCBTaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCB0aSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBxbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBYbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdWkoKSwgbnIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oMSwgMCwgMCksIGlyID0gLyogQF9fUFVSRV9fICovIG5ldyBPKDAsIDEsIDApLCBzciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygwLCAwLCAxKSwgam8gPSB7IHR5cGU6IFwiYWRkZWRcIiB9LCByciA9IHsgdHlwZTogXCJyZW1vdmVkXCIgfTtcbmNsYXNzIGF0IGV4dGVuZHMgJG4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzT2JqZWN0M0QgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgeyB2YWx1ZTogSG8rKyB9KSwgdGhpcy51dWlkID0gaGkoKSwgdGhpcy5uYW1lID0gXCJcIiwgdGhpcy50eXBlID0gXCJPYmplY3QzRFwiLCB0aGlzLnBhcmVudCA9IG51bGwsIHRoaXMuY2hpbGRyZW4gPSBbXSwgdGhpcy51cCA9IGF0LkRlZmF1bHRVcC5jbG9uZSgpO1xuICAgIGNvbnN0IGUgPSBuZXcgTygpLCB0ID0gbmV3IGZpKCksIG4gPSBuZXcgdWkoKSwgaSA9IG5ldyBPKDEsIDEsIDEpO1xuICAgIGZ1bmN0aW9uIHMoKSB7XG4gICAgICBuLnNldEZyb21FdWxlcih0LCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICB0LnNldEZyb21RdWF0ZXJuaW9uKG4sIHZvaWQgMCwgITEpO1xuICAgIH1cbiAgICB0Ll9vbkNoYW5nZShzKSwgbi5fb25DaGFuZ2UobyksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZVxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogdFxuICAgICAgfSxcbiAgICAgIHF1YXRlcm5pb246IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBuXG4gICAgICB9LFxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBpXG4gICAgICB9LFxuICAgICAgbW9kZWxWaWV3TWF0cml4OiB7XG4gICAgICAgIHZhbHVlOiBuZXcgS2UoKVxuICAgICAgfSxcbiAgICAgIG5vcm1hbE1hdHJpeDoge1xuICAgICAgICB2YWx1ZTogbmV3IE10KClcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5tYXRyaXggPSBuZXcgS2UoKSwgdGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBLZSgpLCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBhdC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSwgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gITEsIHRoaXMubGF5ZXJzID0gbmV3IG9vKCksIHRoaXMudmlzaWJsZSA9ICEwLCB0aGlzLmNhc3RTaGFkb3cgPSAhMSwgdGhpcy5yZWNlaXZlU2hhZG93ID0gITEsIHRoaXMuZnJ1c3R1bUN1bGxlZCA9ICEwLCB0aGlzLnJlbmRlck9yZGVyID0gMCwgdGhpcy5hbmltYXRpb25zID0gW10sIHRoaXMudXNlckRhdGEgPSB7fTtcbiAgfVxuICBvbkJlZm9yZVJlbmRlcigpIHtcbiAgfVxuICBvbkFmdGVyUmVuZGVyKCkge1xuICB9XG4gIGFwcGx5TWF0cml4NChlKSB7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCksIHRoaXMubWF0cml4LnByZW11bHRpcGx5KGUpLCB0aGlzLm1hdHJpeC5kZWNvbXBvc2UodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlKTtcbiAgfVxuICBhcHBseVF1YXRlcm5pb24oZSkge1xuICAgIHJldHVybiB0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoZSksIHRoaXM7XG4gIH1cbiAgc2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKGUsIHQpIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShlLCB0KTtcbiAgfVxuICBzZXRSb3RhdGlvbkZyb21FdWxlcihlKSB7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihlLCAhMCk7XG4gIH1cbiAgc2V0Um90YXRpb25Gcm9tTWF0cml4KGUpIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGUpO1xuICB9XG4gIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oZSkge1xuICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KGUpO1xuICB9XG4gIHJvdGF0ZU9uQXhpcyhlLCB0KSB7XG4gICAgcmV0dXJuIEJuLnNldEZyb21BeGlzQW5nbGUoZSwgdCksIHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShCbiksIHRoaXM7XG4gIH1cbiAgcm90YXRlT25Xb3JsZEF4aXMoZSwgdCkge1xuICAgIHJldHVybiBCbi5zZXRGcm9tQXhpc0FuZ2xlKGUsIHQpLCB0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoQm4pLCB0aGlzO1xuICB9XG4gIHJvdGF0ZVgoZSkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhuciwgZSk7XG4gIH1cbiAgcm90YXRlWShlKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGlyLCBlKTtcbiAgfVxuICByb3RhdGVaKGUpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoc3IsIGUpO1xuICB9XG4gIHRyYW5zbGF0ZU9uQXhpcyhlLCB0KSB7XG4gICAgcmV0dXJuIHRyLmNvcHkoZSkuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbiksIHRoaXMucG9zaXRpb24uYWRkKHRyLm11bHRpcGx5U2NhbGFyKHQpKSwgdGhpcztcbiAgfVxuICB0cmFuc2xhdGVYKGUpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMobnIsIGUpO1xuICB9XG4gIHRyYW5zbGF0ZVkoZSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhpciwgZSk7XG4gIH1cbiAgdHJhbnNsYXRlWihlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKHNyLCBlKTtcbiAgfVxuICBsb2NhbFRvV29ybGQoZSkge1xuICAgIHJldHVybiBlLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgfVxuICB3b3JsZFRvTG9jYWwoZSkge1xuICAgIHJldHVybiBlLmFwcGx5TWF0cml4NChIdC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpKTtcbiAgfVxuICBsb29rQXQoZSwgdCwgbikge1xuICAgIGUuaXNWZWN0b3IzID8gU2kuY29weShlKSA6IFNpLnNldChlLCB0LCBuKTtcbiAgICBjb25zdCBpID0gdGhpcy5wYXJlbnQ7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwgITEpLCB0aS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCksIHRoaXMuaXNDYW1lcmEgfHwgdGhpcy5pc0xpZ2h0ID8gSHQubG9va0F0KHRpLCBTaSwgdGhpcy51cCkgOiBIdC5sb29rQXQoU2ksIHRpLCB0aGlzLnVwKSwgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChIdCksIGkgJiYgKEh0LmV4dHJhY3RSb3RhdGlvbihpLm1hdHJpeFdvcmxkKSwgQm4uc2V0RnJvbVJvdGF0aW9uTWF0cml4KEh0KSwgdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KEJuLmludmVydCgpKSk7XG4gIH1cbiAgYWRkKGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKVxuICAgICAgICB0aGlzLmFkZChhcmd1bWVudHNbdF0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlID09PSB0aGlzID8gKGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiwgZSksIHRoaXMpIDogKGUgJiYgZS5pc09iamVjdDNEID8gKGUucGFyZW50ICE9PSBudWxsICYmIGUucGFyZW50LnJlbW92ZShlKSwgZS5wYXJlbnQgPSB0aGlzLCB0aGlzLmNoaWxkcmVuLnB1c2goZSksIGUuZGlzcGF0Y2hFdmVudChqbykpIDogY29uc29sZS5lcnJvcihcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgZSksIHRoaXMpO1xuICB9XG4gIHJlbW92ZShlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGFyZ3VtZW50cy5sZW5ndGg7IG4rKylcbiAgICAgICAgdGhpcy5yZW1vdmUoYXJndW1lbnRzW25dKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB0ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGUpO1xuICAgIHJldHVybiB0ICE9PSAtMSAmJiAoZS5wYXJlbnQgPSBudWxsLCB0aGlzLmNoaWxkcmVuLnNwbGljZSh0LCAxKSwgZS5kaXNwYXRjaEV2ZW50KHJyKSksIHRoaXM7XG4gIH1cbiAgcmVtb3ZlRnJvbVBhcmVudCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5wYXJlbnQ7XG4gICAgcmV0dXJuIGUgIT09IG51bGwgJiYgZS5yZW1vdmUodGhpcyksIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgZSsrKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5jaGlsZHJlbltlXTtcbiAgICAgIHQucGFyZW50ID0gbnVsbCwgdC5kaXNwYXRjaEV2ZW50KHJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gMCwgdGhpcztcbiAgfVxuICBhdHRhY2goZSkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCAhMSksIEh0LmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCksIGUucGFyZW50ICE9PSBudWxsICYmIChlLnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCghMCwgITEpLCBIdC5tdWx0aXBseShlLnBhcmVudC5tYXRyaXhXb3JsZCkpLCBlLmFwcGx5TWF0cml4NChIdCksIHRoaXMuYWRkKGUpLCBlLnVwZGF0ZVdvcmxkTWF0cml4KCExLCAhMCksIHRoaXM7XG4gIH1cbiAgZ2V0T2JqZWN0QnlJZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eShcImlkXCIsIGUpO1xuICB9XG4gIGdldE9iamVjdEJ5TmFtZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eShcIm5hbWVcIiwgZSk7XG4gIH1cbiAgZ2V0T2JqZWN0QnlQcm9wZXJ0eShlLCB0KSB7XG4gICAgaWYgKHRoaXNbZV0gPT09IHQpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBmb3IgKGxldCBuID0gMCwgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBuIDwgaTsgbisrKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5jaGlsZHJlbltuXS5nZXRPYmplY3RCeVByb3BlcnR5KGUsIHQpO1xuICAgICAgaWYgKG8gIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICB9XG4gIGdldFdvcmxkUG9zaXRpb24oZSkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCAhMSksIGUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuICB9XG4gIGdldFdvcmxkUXVhdGVybmlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsICExKSwgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UodGksIGUsIHFvKSwgZTtcbiAgfVxuICBnZXRXb3JsZFNjYWxlKGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwgITEpLCB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSh0aSwgWG8sIGUpLCBlO1xuICB9XG4gIGdldFdvcmxkRGlyZWN0aW9uKGUpIHtcbiAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCAhMSk7XG4gICAgY29uc3QgdCA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG4gICAgcmV0dXJuIGUuc2V0KHRbOF0sIHRbOV0sIHRbMTBdKS5ub3JtYWxpemUoKTtcbiAgfVxuICByYXljYXN0KCkge1xuICB9XG4gIHRyYXZlcnNlKGUpIHtcbiAgICBlKHRoaXMpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IG4gPSAwLCBpID0gdC5sZW5ndGg7IG4gPCBpOyBuKyspXG4gICAgICB0W25dLnRyYXZlcnNlKGUpO1xuICB9XG4gIHRyYXZlcnNlVmlzaWJsZShlKSB7XG4gICAgaWYgKHRoaXMudmlzaWJsZSA9PT0gITEpXG4gICAgICByZXR1cm47XG4gICAgZSh0aGlzKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBuID0gMCwgaSA9IHQubGVuZ3RoOyBuIDwgaTsgbisrKVxuICAgICAgdFtuXS50cmF2ZXJzZVZpc2libGUoZSk7XG4gIH1cbiAgdHJhdmVyc2VBbmNlc3RvcnMoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnBhcmVudDtcbiAgICB0ICE9PSBudWxsICYmIChlKHQpLCB0LnRyYXZlcnNlQW5jZXN0b3JzKGUpKTtcbiAgfVxuICB1cGRhdGVNYXRyaXgoKSB7XG4gICAgdGhpcy5tYXRyaXguY29tcG9zZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUpLCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSAhMDtcbiAgfVxuICB1cGRhdGVNYXRyaXhXb3JsZChlKSB7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCksICh0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZSkgJiYgKHRoaXMucGFyZW50ID09PSBudWxsID8gdGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KSA6IHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXgpLCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSAhMSwgZSA9ICEwKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBuID0gMCwgaSA9IHQubGVuZ3RoOyBuIDwgaTsgbisrKVxuICAgICAgdFtuXS51cGRhdGVNYXRyaXhXb3JsZChlKTtcbiAgfVxuICB1cGRhdGVXb3JsZE1hdHJpeChlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMucGFyZW50O1xuICAgIGlmIChlID09PSAhMCAmJiBuICE9PSBudWxsICYmIG4udXBkYXRlV29ybGRNYXRyaXgoITAsICExKSwgdGhpcy5tYXRyaXhBdXRvVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCksIHRoaXMucGFyZW50ID09PSBudWxsID8gdGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KSA6IHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXgpLCB0ID09PSAhMCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuY2hpbGRyZW47XG4gICAgICBmb3IgKGxldCBzID0gMCwgbyA9IGkubGVuZ3RoOyBzIDwgbzsgcysrKVxuICAgICAgICBpW3NdLnVwZGF0ZVdvcmxkTWF0cml4KCExLCAhMCk7XG4gICAgfVxuICB9XG4gIHRvSlNPTihlKSB7XG4gICAgY29uc3QgdCA9IGUgPT09IHZvaWQgMCB8fCB0eXBlb2YgZSA9PSBcInN0cmluZ1wiLCBuID0ge307XG4gICAgdCAmJiAoZSA9IHtcbiAgICAgIGdlb21ldHJpZXM6IHt9LFxuICAgICAgbWF0ZXJpYWxzOiB7fSxcbiAgICAgIHRleHR1cmVzOiB7fSxcbiAgICAgIGltYWdlczoge30sXG4gICAgICBzaGFwZXM6IHt9LFxuICAgICAgc2tlbGV0b25zOiB7fSxcbiAgICAgIGFuaW1hdGlvbnM6IHt9LFxuICAgICAgbm9kZXM6IHt9XG4gICAgfSwgbi5tZXRhZGF0YSA9IHtcbiAgICAgIHZlcnNpb246IDQuNSxcbiAgICAgIHR5cGU6IFwiT2JqZWN0XCIsXG4gICAgICBnZW5lcmF0b3I6IFwiT2JqZWN0M0QudG9KU09OXCJcbiAgICB9KTtcbiAgICBjb25zdCBpID0ge307XG4gICAgaS51dWlkID0gdGhpcy51dWlkLCBpLnR5cGUgPSB0aGlzLnR5cGUsIHRoaXMubmFtZSAhPT0gXCJcIiAmJiAoaS5uYW1lID0gdGhpcy5uYW1lKSwgdGhpcy5jYXN0U2hhZG93ID09PSAhMCAmJiAoaS5jYXN0U2hhZG93ID0gITApLCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09ICEwICYmIChpLnJlY2VpdmVTaGFkb3cgPSAhMCksIHRoaXMudmlzaWJsZSA9PT0gITEgJiYgKGkudmlzaWJsZSA9ICExKSwgdGhpcy5mcnVzdHVtQ3VsbGVkID09PSAhMSAmJiAoaS5mcnVzdHVtQ3VsbGVkID0gITEpLCB0aGlzLnJlbmRlck9yZGVyICE9PSAwICYmIChpLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlciksIEpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpICE9PSBcInt9XCIgJiYgKGkudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhKSwgaS5sYXllcnMgPSB0aGlzLmxheWVycy5tYXNrLCBpLm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKSwgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSAhMSAmJiAoaS5tYXRyaXhBdXRvVXBkYXRlID0gITEpLCB0aGlzLmlzSW5zdGFuY2VkTWVzaCAmJiAoaS50eXBlID0gXCJJbnN0YW5jZWRNZXNoXCIsIGkuY291bnQgPSB0aGlzLmNvdW50LCBpLmluc3RhbmNlTWF0cml4ID0gdGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKSwgdGhpcy5pbnN0YW5jZUNvbG9yICE9PSBudWxsICYmIChpLmluc3RhbmNlQ29sb3IgPSB0aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCkpKTtcbiAgICBmdW5jdGlvbiBzKHIsIGwpIHtcbiAgICAgIHJldHVybiByW2wudXVpZF0gPT09IHZvaWQgMCAmJiAocltsLnV1aWRdID0gbC50b0pTT04oZSkpLCBsLnV1aWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2NlbmUpXG4gICAgICB0aGlzLmJhY2tncm91bmQgJiYgKHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yID8gaS5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTigpIDogdGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSAmJiAoaS5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTihlKS51dWlkKSksIHRoaXMuZW52aXJvbm1lbnQgJiYgdGhpcy5lbnZpcm9ubWVudC5pc1RleHR1cmUgJiYgdGhpcy5lbnZpcm9ubWVudC5pc1JlbmRlclRhcmdldFRleHR1cmUgIT09ICEwICYmIChpLmVudmlyb25tZW50ID0gdGhpcy5lbnZpcm9ubWVudC50b0pTT04oZSkudXVpZCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01lc2ggfHwgdGhpcy5pc0xpbmUgfHwgdGhpcy5pc1BvaW50cykge1xuICAgICAgaS5nZW9tZXRyeSA9IHMoZS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5KTtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG4gICAgICBpZiAociAhPT0gdm9pZCAwICYmIHIuc2hhcGVzICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbCA9IHIuc2hhcGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsKSlcbiAgICAgICAgICBmb3IgKGxldCBhID0gMCwgYyA9IGwubGVuZ3RoOyBhIDwgYzsgYSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gbFthXTtcbiAgICAgICAgICAgIHMoZS5zaGFwZXMsIGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHMoZS5zaGFwZXMsIGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1NraW5uZWRNZXNoICYmIChpLmJpbmRNb2RlID0gdGhpcy5iaW5kTW9kZSwgaS5iaW5kTWF0cml4ID0gdGhpcy5iaW5kTWF0cml4LnRvQXJyYXkoKSwgdGhpcy5za2VsZXRvbiAhPT0gdm9pZCAwICYmIChzKGUuc2tlbGV0b25zLCB0aGlzLnNrZWxldG9uKSwgaS5za2VsZXRvbiA9IHRoaXMuc2tlbGV0b24udXVpZCkpLCB0aGlzLm1hdGVyaWFsICE9PSB2b2lkIDApXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIGZvciAobGV0IGwgPSAwLCBhID0gdGhpcy5tYXRlcmlhbC5sZW5ndGg7IGwgPCBhOyBsKyspXG4gICAgICAgICAgci5wdXNoKHMoZS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWxbbF0pKTtcbiAgICAgICAgaS5tYXRlcmlhbCA9IHI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgaS5tYXRlcmlhbCA9IHMoZS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWwpO1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGkuY2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IHIrKylcbiAgICAgICAgaS5jaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5bcl0udG9KU09OKGUpLm9iamVjdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFuaW1hdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgaS5hbmltYXRpb25zID0gW107XG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IHIrKykge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5hbmltYXRpb25zW3JdO1xuICAgICAgICBpLmFuaW1hdGlvbnMucHVzaChzKGUuYW5pbWF0aW9ucywgbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgciA9IG8oZS5nZW9tZXRyaWVzKSwgbCA9IG8oZS5tYXRlcmlhbHMpLCBhID0gbyhlLnRleHR1cmVzKSwgYyA9IG8oZS5pbWFnZXMpLCBkID0gbyhlLnNoYXBlcyksIHUgPSBvKGUuc2tlbGV0b25zKSwgbSA9IG8oZS5hbmltYXRpb25zKSwgZyA9IG8oZS5ub2Rlcyk7XG4gICAgICByLmxlbmd0aCA+IDAgJiYgKG4uZ2VvbWV0cmllcyA9IHIpLCBsLmxlbmd0aCA+IDAgJiYgKG4ubWF0ZXJpYWxzID0gbCksIGEubGVuZ3RoID4gMCAmJiAobi50ZXh0dXJlcyA9IGEpLCBjLmxlbmd0aCA+IDAgJiYgKG4uaW1hZ2VzID0gYyksIGQubGVuZ3RoID4gMCAmJiAobi5zaGFwZXMgPSBkKSwgdS5sZW5ndGggPiAwICYmIChuLnNrZWxldG9ucyA9IHUpLCBtLmxlbmd0aCA+IDAgJiYgKG4uYW5pbWF0aW9ucyA9IG0pLCBnLmxlbmd0aCA+IDAgJiYgKG4ubm9kZXMgPSBnKTtcbiAgICB9XG4gICAgcmV0dXJuIG4ub2JqZWN0ID0gaSwgbjtcbiAgICBmdW5jdGlvbiBvKHIpIHtcbiAgICAgIGNvbnN0IGwgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYSBpbiByKSB7XG4gICAgICAgIGNvbnN0IGMgPSByW2FdO1xuICAgICAgICBkZWxldGUgYy5tZXRhZGF0YSwgbC5wdXNoKGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGw7XG4gICAgfVxuICB9XG4gIGNsb25lKGUpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMsIGUpO1xuICB9XG4gIGNvcHkoZSwgdCA9ICEwKSB7XG4gICAgaWYgKHRoaXMubmFtZSA9IGUubmFtZSwgdGhpcy51cC5jb3B5KGUudXApLCB0aGlzLnBvc2l0aW9uLmNvcHkoZS5wb3NpdGlvbiksIHRoaXMucm90YXRpb24ub3JkZXIgPSBlLnJvdGF0aW9uLm9yZGVyLCB0aGlzLnF1YXRlcm5pb24uY29weShlLnF1YXRlcm5pb24pLCB0aGlzLnNjYWxlLmNvcHkoZS5zY2FsZSksIHRoaXMubWF0cml4LmNvcHkoZS5tYXRyaXgpLCB0aGlzLm1hdHJpeFdvcmxkLmNvcHkoZS5tYXRyaXhXb3JsZCksIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGUubWF0cml4QXV0b1VwZGF0ZSwgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlLCB0aGlzLmxheWVycy5tYXNrID0gZS5sYXllcnMubWFzaywgdGhpcy52aXNpYmxlID0gZS52aXNpYmxlLCB0aGlzLmNhc3RTaGFkb3cgPSBlLmNhc3RTaGFkb3csIHRoaXMucmVjZWl2ZVNoYWRvdyA9IGUucmVjZWl2ZVNoYWRvdywgdGhpcy5mcnVzdHVtQ3VsbGVkID0gZS5mcnVzdHVtQ3VsbGVkLCB0aGlzLnJlbmRlck9yZGVyID0gZS5yZW5kZXJPcmRlciwgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLCB0ID09PSAhMClcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZS5jaGlsZHJlbi5sZW5ndGg7IG4rKykge1xuICAgICAgICBjb25zdCBpID0gZS5jaGlsZHJlbltuXTtcbiAgICAgICAgdGhpcy5hZGQoaS5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuYXQuRGVmYXVsdFVwID0gLyogQF9fUFVSRV9fICovIG5ldyBPKDAsIDEsIDApO1xuYXQuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSAhMDtcbmNvbnN0IEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIHF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIHVzID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIFh0ID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIE5uID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIE9uID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIGRzID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIGZzID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIHBzID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCk7XG5jbGFzcyBRdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSBuZXcgTygpLCB0ID0gbmV3IE8oKSwgbiA9IG5ldyBPKCkpIHtcbiAgICB0aGlzLmEgPSBlLCB0aGlzLmIgPSB0LCB0aGlzLmMgPSBuO1xuICB9XG4gIHN0YXRpYyBnZXROb3JtYWwoZSwgdCwgbiwgaSkge1xuICAgIGkuc3ViVmVjdG9ycyhuLCB0KSwgQXQuc3ViVmVjdG9ycyhlLCB0KSwgaS5jcm9zcyhBdCk7XG4gICAgY29uc3QgcyA9IGkubGVuZ3RoU3EoKTtcbiAgICByZXR1cm4gcyA+IDAgPyBpLm11bHRpcGx5U2NhbGFyKDEgLyBNYXRoLnNxcnQocykpIDogaS5zZXQoMCwgMCwgMCk7XG4gIH1cbiAgc3RhdGljIGdldEJhcnljb29yZChlLCB0LCBuLCBpLCBzKSB7XG4gICAgQXQuc3ViVmVjdG9ycyhpLCB0KSwgcXQuc3ViVmVjdG9ycyhuLCB0KSwgdXMuc3ViVmVjdG9ycyhlLCB0KTtcbiAgICBjb25zdCBvID0gQXQuZG90KEF0KSwgciA9IEF0LmRvdChxdCksIGwgPSBBdC5kb3QodXMpLCBhID0gcXQuZG90KHF0KSwgYyA9IHF0LmRvdCh1cyksIGQgPSBvICogYSAtIHIgKiByO1xuICAgIGlmIChkID09PSAwKVxuICAgICAgcmV0dXJuIHMuc2V0KC0yLCAtMSwgLTEpO1xuICAgIGNvbnN0IHUgPSAxIC8gZCwgbSA9IChhICogbCAtIHIgKiBjKSAqIHUsIGcgPSAobyAqIGMgLSByICogbCkgKiB1O1xuICAgIHJldHVybiBzLnNldCgxIC0gbSAtIGcsIGcsIG0pO1xuICB9XG4gIHN0YXRpYyBjb250YWluc1BvaW50KGUsIHQsIG4sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQoZSwgdCwgbiwgaSwgWHQpLCBYdC54ID49IDAgJiYgWHQueSA+PSAwICYmIFh0LnggKyBYdC55IDw9IDE7XG4gIH1cbiAgc3RhdGljIGdldFVWKGUsIHQsIG4sIGksIHMsIG8sIHIsIGwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQoZSwgdCwgbiwgaSwgWHQpLCBsLnNldCgwLCAwKSwgbC5hZGRTY2FsZWRWZWN0b3IocywgWHQueCksIGwuYWRkU2NhbGVkVmVjdG9yKG8sIFh0LnkpLCBsLmFkZFNjYWxlZFZlY3RvcihyLCBYdC56KSwgbDtcbiAgfVxuICBzdGF0aWMgaXNGcm9udEZhY2luZyhlLCB0LCBuLCBpKSB7XG4gICAgcmV0dXJuIEF0LnN1YlZlY3RvcnMobiwgdCksIHF0LnN1YlZlY3RvcnMoZSwgdCksIEF0LmNyb3NzKHF0KS5kb3QoaSkgPCAwO1xuICB9XG4gIHNldChlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuYS5jb3B5KGUpLCB0aGlzLmIuY29weSh0KSwgdGhpcy5jLmNvcHkobiksIHRoaXM7XG4gIH1cbiAgc2V0RnJvbVBvaW50c0FuZEluZGljZXMoZSwgdCwgbiwgaSkge1xuICAgIHJldHVybiB0aGlzLmEuY29weShlW3RdKSwgdGhpcy5iLmNvcHkoZVtuXSksIHRoaXMuYy5jb3B5KGVbaV0pLCB0aGlzO1xuICB9XG4gIHNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKGUsIHQsIG4sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5hLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSwgdCksIHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsIG4pLCB0aGlzLmMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCBpKSwgdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLmEuY29weShlLmEpLCB0aGlzLmIuY29weShlLmIpLCB0aGlzLmMuY29weShlLmMpLCB0aGlzO1xuICB9XG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIEF0LnN1YlZlY3RvcnModGhpcy5jLCB0aGlzLmIpLCBxdC5zdWJWZWN0b3JzKHRoaXMuYSwgdGhpcy5iKSwgQXQuY3Jvc3MocXQpLmxlbmd0aCgpICogMC41O1xuICB9XG4gIGdldE1pZHBvaW50KGUpIHtcbiAgICByZXR1cm4gZS5hZGRWZWN0b3JzKHRoaXMuYSwgdGhpcy5iKS5hZGQodGhpcy5jKS5tdWx0aXBseVNjYWxhcigxIC8gMyk7XG4gIH1cbiAgZ2V0Tm9ybWFsKGUpIHtcbiAgICByZXR1cm4gUXQuZ2V0Tm9ybWFsKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIGUpO1xuICB9XG4gIGdldFBsYW5lKGUpIHtcbiAgICByZXR1cm4gZS5zZXRGcm9tQ29wbGFuYXJQb2ludHModGhpcy5hLCB0aGlzLmIsIHRoaXMuYyk7XG4gIH1cbiAgZ2V0QmFyeWNvb3JkKGUsIHQpIHtcbiAgICByZXR1cm4gUXQuZ2V0QmFyeWNvb3JkKGUsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHQpO1xuICB9XG4gIGdldFVWKGUsIHQsIG4sIGksIHMpIHtcbiAgICByZXR1cm4gUXQuZ2V0VVYoZSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdCwgbiwgaSwgcyk7XG4gIH1cbiAgY29udGFpbnNQb2ludChlKSB7XG4gICAgcmV0dXJuIFF0LmNvbnRhaW5zUG9pbnQoZSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyk7XG4gIH1cbiAgaXNGcm9udEZhY2luZyhlKSB7XG4gICAgcmV0dXJuIFF0LmlzRnJvbnRGYWNpbmcodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgZSk7XG4gIH1cbiAgaW50ZXJzZWN0c0JveChlKSB7XG4gICAgcmV0dXJuIGUuaW50ZXJzZWN0c1RyaWFuZ2xlKHRoaXMpO1xuICB9XG4gIGNsb3Nlc3RQb2ludFRvUG9pbnQoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmEsIGkgPSB0aGlzLmIsIHMgPSB0aGlzLmM7XG4gICAgbGV0IG8sIHI7XG4gICAgTm4uc3ViVmVjdG9ycyhpLCBuKSwgT24uc3ViVmVjdG9ycyhzLCBuKSwgZHMuc3ViVmVjdG9ycyhlLCBuKTtcbiAgICBjb25zdCBsID0gTm4uZG90KGRzKSwgYSA9IE9uLmRvdChkcyk7XG4gICAgaWYgKGwgPD0gMCAmJiBhIDw9IDApXG4gICAgICByZXR1cm4gdC5jb3B5KG4pO1xuICAgIGZzLnN1YlZlY3RvcnMoZSwgaSk7XG4gICAgY29uc3QgYyA9IE5uLmRvdChmcyksIGQgPSBPbi5kb3QoZnMpO1xuICAgIGlmIChjID49IDAgJiYgZCA8PSBjKVxuICAgICAgcmV0dXJuIHQuY29weShpKTtcbiAgICBjb25zdCB1ID0gbCAqIGQgLSBjICogYTtcbiAgICBpZiAodSA8PSAwICYmIGwgPj0gMCAmJiBjIDw9IDApXG4gICAgICByZXR1cm4gbyA9IGwgLyAobCAtIGMpLCB0LmNvcHkobikuYWRkU2NhbGVkVmVjdG9yKE5uLCBvKTtcbiAgICBwcy5zdWJWZWN0b3JzKGUsIHMpO1xuICAgIGNvbnN0IG0gPSBObi5kb3QocHMpLCBnID0gT24uZG90KHBzKTtcbiAgICBpZiAoZyA+PSAwICYmIG0gPD0gZylcbiAgICAgIHJldHVybiB0LmNvcHkocyk7XG4gICAgY29uc3QgcCA9IG0gKiBhIC0gbCAqIGc7XG4gICAgaWYgKHAgPD0gMCAmJiBhID49IDAgJiYgZyA8PSAwKVxuICAgICAgcmV0dXJuIHIgPSBhIC8gKGEgLSBnKSwgdC5jb3B5KG4pLmFkZFNjYWxlZFZlY3RvcihPbiwgcik7XG4gICAgY29uc3QgZiA9IGMgKiBnIC0gbSAqIGQ7XG4gICAgaWYgKGYgPD0gMCAmJiBkIC0gYyA+PSAwICYmIG0gLSBnID49IDApXG4gICAgICByZXR1cm4gb3Iuc3ViVmVjdG9ycyhzLCBpKSwgciA9IChkIC0gYykgLyAoZCAtIGMgKyAobSAtIGcpKSwgdC5jb3B5KGkpLmFkZFNjYWxlZFZlY3Rvcihvciwgcik7XG4gICAgY29uc3QgdiA9IDEgLyAoZiArIHAgKyB1KTtcbiAgICByZXR1cm4gbyA9IHAgKiB2LCByID0gdSAqIHYsIHQuY29weShuKS5hZGRTY2FsZWRWZWN0b3IoTm4sIG8pLmFkZFNjYWxlZFZlY3RvcihPbiwgcik7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICByZXR1cm4gZS5hLmVxdWFscyh0aGlzLmEpICYmIGUuYi5lcXVhbHModGhpcy5iKSAmJiBlLmMuZXF1YWxzKHRoaXMuYyk7XG4gIH1cbn1cbmxldCBZbyA9IDA7XG5jbGFzcyBBbiBleHRlbmRzICRuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc01hdGVyaWFsID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHsgdmFsdWU6IFlvKysgfSksIHRoaXMudXVpZCA9IGhpKCksIHRoaXMubmFtZSA9IFwiXCIsIHRoaXMudHlwZSA9IFwiTWF0ZXJpYWxcIiwgdGhpcy5ibGVuZGluZyA9IDEsIHRoaXMuc2lkZSA9IDAsIHRoaXMudmVydGV4Q29sb3JzID0gITEsIHRoaXMub3BhY2l0eSA9IDEsIHRoaXMudHJhbnNwYXJlbnQgPSAhMSwgdGhpcy5ibGVuZFNyYyA9IDIwNCwgdGhpcy5ibGVuZERzdCA9IDIwNSwgdGhpcy5ibGVuZEVxdWF0aW9uID0gMTAwLCB0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsLCB0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsLCB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGwsIHRoaXMuZGVwdGhGdW5jID0gMywgdGhpcy5kZXB0aFRlc3QgPSAhMCwgdGhpcy5kZXB0aFdyaXRlID0gITAsIHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IDI1NSwgdGhpcy5zdGVuY2lsRnVuYyA9IDUxOSwgdGhpcy5zdGVuY2lsUmVmID0gMCwgdGhpcy5zdGVuY2lsRnVuY01hc2sgPSAyNTUsIHRoaXMuc3RlbmNpbEZhaWwgPSA3NjgwLCB0aGlzLnN0ZW5jaWxaRmFpbCA9IDc2ODAsIHRoaXMuc3RlbmNpbFpQYXNzID0gNzY4MCwgdGhpcy5zdGVuY2lsV3JpdGUgPSAhMSwgdGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGwsIHRoaXMuY2xpcEludGVyc2VjdGlvbiA9ICExLCB0aGlzLmNsaXBTaGFkb3dzID0gITEsIHRoaXMuc2hhZG93U2lkZSA9IG51bGwsIHRoaXMuY29sb3JXcml0ZSA9ICEwLCB0aGlzLnByZWNpc2lvbiA9IG51bGwsIHRoaXMucG9seWdvbk9mZnNldCA9ICExLCB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwLCB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDAsIHRoaXMuZGl0aGVyaW5nID0gITEsIHRoaXMuYWxwaGFUb0NvdmVyYWdlID0gITEsIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gITEsIHRoaXMudmlzaWJsZSA9ICEwLCB0aGlzLnRvbmVNYXBwZWQgPSAhMCwgdGhpcy51c2VyRGF0YSA9IHt9LCB0aGlzLnZlcnNpb24gPSAwLCB0aGlzLl9hbHBoYVRlc3QgPSAwO1xuICB9XG4gIGdldCBhbHBoYVRlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FscGhhVGVzdDtcbiAgfVxuICBzZXQgYWxwaGFUZXN0KGUpIHtcbiAgICB0aGlzLl9hbHBoYVRlc3QgPiAwICE9IGUgPiAwICYmIHRoaXMudmVyc2lvbisrLCB0aGlzLl9hbHBoYVRlc3QgPSBlO1xuICB9XG4gIG9uQnVpbGQoKSB7XG4gIH1cbiAgb25CZWZvcmVSZW5kZXIoKSB7XG4gIH1cbiAgb25CZWZvcmVDb21waWxlKCkge1xuICB9XG4gIGN1c3RvbVByb2dyYW1DYWNoZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKTtcbiAgfVxuICBzZXRWYWx1ZXMoZSkge1xuICAgIGlmIChlICE9PSB2b2lkIDApXG4gICAgICBmb3IgKGNvbnN0IHQgaW4gZSkge1xuICAgICAgICBjb25zdCBuID0gZVt0XTtcbiAgICAgICAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdGVyaWFsOiAnXCIgKyB0ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ID09PSBcInNoYWRpbmdcIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6IC5zaGFkaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB0aGUgYm9vbGVhbiAuZmxhdFNoYWRpbmcgaW5zdGVhZC5cIiksIHRoaXMuZmxhdFNoYWRpbmcgPSBuID09PSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzW3RdO1xuICAgICAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgKyBcIjogJ1wiICsgdCArIFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpICYmIGkuaXNDb2xvciA/IGkuc2V0KG4pIDogaSAmJiBpLmlzVmVjdG9yMyAmJiBuICYmIG4uaXNWZWN0b3IzID8gaS5jb3B5KG4pIDogdGhpc1t0XSA9IG47XG4gICAgICB9XG4gIH1cbiAgdG9KU09OKGUpIHtcbiAgICBjb25zdCB0ID0gZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwic3RyaW5nXCI7XG4gICAgdCAmJiAoZSA9IHtcbiAgICAgIHRleHR1cmVzOiB7fSxcbiAgICAgIGltYWdlczoge31cbiAgICB9KTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC41LFxuICAgICAgICB0eXBlOiBcIk1hdGVyaWFsXCIsXG4gICAgICAgIGdlbmVyYXRvcjogXCJNYXRlcmlhbC50b0pTT05cIlxuICAgICAgfVxuICAgIH07XG4gICAgbi51dWlkID0gdGhpcy51dWlkLCBuLnR5cGUgPSB0aGlzLnR5cGUsIHRoaXMubmFtZSAhPT0gXCJcIiAmJiAobi5uYW1lID0gdGhpcy5uYW1lKSwgdGhpcy5jb2xvciAmJiB0aGlzLmNvbG9yLmlzQ29sb3IgJiYgKG4uY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpKSwgdGhpcy5yb3VnaG5lc3MgIT09IHZvaWQgMCAmJiAobi5yb3VnaG5lc3MgPSB0aGlzLnJvdWdobmVzcyksIHRoaXMubWV0YWxuZXNzICE9PSB2b2lkIDAgJiYgKG4ubWV0YWxuZXNzID0gdGhpcy5tZXRhbG5lc3MpLCB0aGlzLnNoZWVuICE9PSB2b2lkIDAgJiYgKG4uc2hlZW4gPSB0aGlzLnNoZWVuKSwgdGhpcy5zaGVlbkNvbG9yICYmIHRoaXMuc2hlZW5Db2xvci5pc0NvbG9yICYmIChuLnNoZWVuQ29sb3IgPSB0aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCkpLCB0aGlzLnNoZWVuUm91Z2huZXNzICE9PSB2b2lkIDAgJiYgKG4uc2hlZW5Sb3VnaG5lc3MgPSB0aGlzLnNoZWVuUm91Z2huZXNzKSwgdGhpcy5lbWlzc2l2ZSAmJiB0aGlzLmVtaXNzaXZlLmlzQ29sb3IgJiYgKG4uZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpKSwgdGhpcy5lbWlzc2l2ZUludGVuc2l0eSAmJiB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSAxICYmIChuLmVtaXNzaXZlSW50ZW5zaXR5ID0gdGhpcy5lbWlzc2l2ZUludGVuc2l0eSksIHRoaXMuc3BlY3VsYXIgJiYgdGhpcy5zcGVjdWxhci5pc0NvbG9yICYmIChuLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKSksIHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgIT09IHZvaWQgMCAmJiAobi5zcGVjdWxhckludGVuc2l0eSA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkpLCB0aGlzLnNwZWN1bGFyQ29sb3IgJiYgdGhpcy5zcGVjdWxhckNvbG9yLmlzQ29sb3IgJiYgKG4uc3BlY3VsYXJDb2xvciA9IHRoaXMuc3BlY3VsYXJDb2xvci5nZXRIZXgoKSksIHRoaXMuc2hpbmluZXNzICE9PSB2b2lkIDAgJiYgKG4uc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3MpLCB0aGlzLmNsZWFyY29hdCAhPT0gdm9pZCAwICYmIChuLmNsZWFyY29hdCA9IHRoaXMuY2xlYXJjb2F0KSwgdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHZvaWQgMCAmJiAobi5jbGVhcmNvYXRSb3VnaG5lc3MgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzcyksIHRoaXMuY2xlYXJjb2F0TWFwICYmIHRoaXMuY2xlYXJjb2F0TWFwLmlzVGV4dHVyZSAmJiAobi5jbGVhcmNvYXRNYXAgPSB0aGlzLmNsZWFyY29hdE1hcC50b0pTT04oZSkudXVpZCksIHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwICYmIHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSAmJiAobi5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC50b0pTT04oZSkudXVpZCksIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwICYmIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwLmlzVGV4dHVyZSAmJiAobi5jbGVhcmNvYXROb3JtYWxNYXAgPSB0aGlzLmNsZWFyY29hdE5vcm1hbE1hcC50b0pTT04oZSkudXVpZCwgbi5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudG9BcnJheSgpKSwgdGhpcy5pcmlkZXNjZW5jZSAhPT0gdm9pZCAwICYmIChuLmlyaWRlc2NlbmNlID0gdGhpcy5pcmlkZXNjZW5jZSksIHRoaXMuaXJpZGVzY2VuY2VJT1IgIT09IHZvaWQgMCAmJiAobi5pcmlkZXNjZW5jZUlPUiA9IHRoaXMuaXJpZGVzY2VuY2VJT1IpLCB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgIT09IHZvaWQgMCAmJiAobi5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlKSwgdGhpcy5pcmlkZXNjZW5jZU1hcCAmJiB0aGlzLmlyaWRlc2NlbmNlTWFwLmlzVGV4dHVyZSAmJiAobi5pcmlkZXNjZW5jZU1hcCA9IHRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKGUpLnV1aWQpLCB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICYmIHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuaXNUZXh0dXJlICYmIChuLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC50b0pTT04oZSkudXVpZCksIHRoaXMubWFwICYmIHRoaXMubWFwLmlzVGV4dHVyZSAmJiAobi5tYXAgPSB0aGlzLm1hcC50b0pTT04oZSkudXVpZCksIHRoaXMubWF0Y2FwICYmIHRoaXMubWF0Y2FwLmlzVGV4dHVyZSAmJiAobi5tYXRjYXAgPSB0aGlzLm1hdGNhcC50b0pTT04oZSkudXVpZCksIHRoaXMuYWxwaGFNYXAgJiYgdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUgJiYgKG4uYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTihlKS51dWlkKSwgdGhpcy5saWdodE1hcCAmJiB0aGlzLmxpZ2h0TWFwLmlzVGV4dHVyZSAmJiAobi5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKGUpLnV1aWQsIG4ubGlnaHRNYXBJbnRlbnNpdHkgPSB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5KSwgdGhpcy5hb01hcCAmJiB0aGlzLmFvTWFwLmlzVGV4dHVyZSAmJiAobi5hb01hcCA9IHRoaXMuYW9NYXAudG9KU09OKGUpLnV1aWQsIG4uYW9NYXBJbnRlbnNpdHkgPSB0aGlzLmFvTWFwSW50ZW5zaXR5KSwgdGhpcy5idW1wTWFwICYmIHRoaXMuYnVtcE1hcC5pc1RleHR1cmUgJiYgKG4uYnVtcE1hcCA9IHRoaXMuYnVtcE1hcC50b0pTT04oZSkudXVpZCwgbi5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZSksIHRoaXMubm9ybWFsTWFwICYmIHRoaXMubm9ybWFsTWFwLmlzVGV4dHVyZSAmJiAobi5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oZSkudXVpZCwgbi5ub3JtYWxNYXBUeXBlID0gdGhpcy5ub3JtYWxNYXBUeXBlLCBuLm5vcm1hbFNjYWxlID0gdGhpcy5ub3JtYWxTY2FsZS50b0FycmF5KCkpLCB0aGlzLmRpc3BsYWNlbWVudE1hcCAmJiB0aGlzLmRpc3BsYWNlbWVudE1hcC5pc1RleHR1cmUgJiYgKG4uZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKGUpLnV1aWQsIG4uZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlLCBuLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXMpLCB0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUgJiYgKG4ucm91Z2huZXNzTWFwID0gdGhpcy5yb3VnaG5lc3NNYXAudG9KU09OKGUpLnV1aWQpLCB0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUgJiYgKG4ubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKGUpLnV1aWQpLCB0aGlzLmVtaXNzaXZlTWFwICYmIHRoaXMuZW1pc3NpdmVNYXAuaXNUZXh0dXJlICYmIChuLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oZSkudXVpZCksIHRoaXMuc3BlY3VsYXJNYXAgJiYgdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUgJiYgKG4uc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTihlKS51dWlkKSwgdGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCAmJiB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLmlzVGV4dHVyZSAmJiAobi5zcGVjdWxhckludGVuc2l0eU1hcCA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAudG9KU09OKGUpLnV1aWQpLCB0aGlzLnNwZWN1bGFyQ29sb3JNYXAgJiYgdGhpcy5zcGVjdWxhckNvbG9yTWFwLmlzVGV4dHVyZSAmJiAobi5zcGVjdWxhckNvbG9yTWFwID0gdGhpcy5zcGVjdWxhckNvbG9yTWFwLnRvSlNPTihlKS51dWlkKSwgdGhpcy5lbnZNYXAgJiYgdGhpcy5lbnZNYXAuaXNUZXh0dXJlICYmIChuLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTihlKS51dWlkLCB0aGlzLmNvbWJpbmUgIT09IHZvaWQgMCAmJiAobi5jb21iaW5lID0gdGhpcy5jb21iaW5lKSksIHRoaXMuZW52TWFwSW50ZW5zaXR5ICE9PSB2b2lkIDAgJiYgKG4uZW52TWFwSW50ZW5zaXR5ID0gdGhpcy5lbnZNYXBJbnRlbnNpdHkpLCB0aGlzLnJlZmxlY3Rpdml0eSAhPT0gdm9pZCAwICYmIChuLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5KSwgdGhpcy5yZWZyYWN0aW9uUmF0aW8gIT09IHZvaWQgMCAmJiAobi5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbyksIHRoaXMuZ3JhZGllbnRNYXAgJiYgdGhpcy5ncmFkaWVudE1hcC5pc1RleHR1cmUgJiYgKG4uZ3JhZGllbnRNYXAgPSB0aGlzLmdyYWRpZW50TWFwLnRvSlNPTihlKS51dWlkKSwgdGhpcy50cmFuc21pc3Npb24gIT09IHZvaWQgMCAmJiAobi50cmFuc21pc3Npb24gPSB0aGlzLnRyYW5zbWlzc2lvbiksIHRoaXMudHJhbnNtaXNzaW9uTWFwICYmIHRoaXMudHJhbnNtaXNzaW9uTWFwLmlzVGV4dHVyZSAmJiAobi50cmFuc21pc3Npb25NYXAgPSB0aGlzLnRyYW5zbWlzc2lvbk1hcC50b0pTT04oZSkudXVpZCksIHRoaXMudGhpY2tuZXNzICE9PSB2b2lkIDAgJiYgKG4udGhpY2tuZXNzID0gdGhpcy50aGlja25lc3MpLCB0aGlzLnRoaWNrbmVzc01hcCAmJiB0aGlzLnRoaWNrbmVzc01hcC5pc1RleHR1cmUgJiYgKG4udGhpY2tuZXNzTWFwID0gdGhpcy50aGlja25lc3NNYXAudG9KU09OKGUpLnV1aWQpLCB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHZvaWQgMCAmJiAobi5hdHRlbnVhdGlvbkRpc3RhbmNlID0gdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlKSwgdGhpcy5hdHRlbnVhdGlvbkNvbG9yICE9PSB2b2lkIDAgJiYgKG4uYXR0ZW51YXRpb25Db2xvciA9IHRoaXMuYXR0ZW51YXRpb25Db2xvci5nZXRIZXgoKSksIHRoaXMuc2l6ZSAhPT0gdm9pZCAwICYmIChuLnNpemUgPSB0aGlzLnNpemUpLCB0aGlzLnNoYWRvd1NpZGUgIT09IG51bGwgJiYgKG4uc2hhZG93U2lkZSA9IHRoaXMuc2hhZG93U2lkZSksIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB2b2lkIDAgJiYgKG4uc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb24pLCB0aGlzLmJsZW5kaW5nICE9PSAxICYmIChuLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZyksIHRoaXMuc2lkZSAhPT0gMCAmJiAobi5zaWRlID0gdGhpcy5zaWRlKSwgdGhpcy52ZXJ0ZXhDb2xvcnMgJiYgKG4udmVydGV4Q29sb3JzID0gITApLCB0aGlzLm9wYWNpdHkgPCAxICYmIChuLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHkpLCB0aGlzLnRyYW5zcGFyZW50ID09PSAhMCAmJiAobi50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQpLCBuLmRlcHRoRnVuYyA9IHRoaXMuZGVwdGhGdW5jLCBuLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0LCBuLmRlcHRoV3JpdGUgPSB0aGlzLmRlcHRoV3JpdGUsIG4uY29sb3JXcml0ZSA9IHRoaXMuY29sb3JXcml0ZSwgbi5zdGVuY2lsV3JpdGUgPSB0aGlzLnN0ZW5jaWxXcml0ZSwgbi5zdGVuY2lsV3JpdGVNYXNrID0gdGhpcy5zdGVuY2lsV3JpdGVNYXNrLCBuLnN0ZW5jaWxGdW5jID0gdGhpcy5zdGVuY2lsRnVuYywgbi5zdGVuY2lsUmVmID0gdGhpcy5zdGVuY2lsUmVmLCBuLnN0ZW5jaWxGdW5jTWFzayA9IHRoaXMuc3RlbmNpbEZ1bmNNYXNrLCBuLnN0ZW5jaWxGYWlsID0gdGhpcy5zdGVuY2lsRmFpbCwgbi5zdGVuY2lsWkZhaWwgPSB0aGlzLnN0ZW5jaWxaRmFpbCwgbi5zdGVuY2lsWlBhc3MgPSB0aGlzLnN0ZW5jaWxaUGFzcywgdGhpcy5yb3RhdGlvbiAhPT0gdm9pZCAwICYmIHRoaXMucm90YXRpb24gIT09IDAgJiYgKG4ucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSwgdGhpcy5wb2x5Z29uT2Zmc2V0ID09PSAhMCAmJiAobi5wb2x5Z29uT2Zmc2V0ID0gITApLCB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IDAgJiYgKG4ucG9seWdvbk9mZnNldEZhY3RvciA9IHRoaXMucG9seWdvbk9mZnNldEZhY3RvciksIHRoaXMucG9seWdvbk9mZnNldFVuaXRzICE9PSAwICYmIChuLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzKSwgdGhpcy5saW5ld2lkdGggIT09IHZvaWQgMCAmJiB0aGlzLmxpbmV3aWR0aCAhPT0gMSAmJiAobi5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aCksIHRoaXMuZGFzaFNpemUgIT09IHZvaWQgMCAmJiAobi5kYXNoU2l6ZSA9IHRoaXMuZGFzaFNpemUpLCB0aGlzLmdhcFNpemUgIT09IHZvaWQgMCAmJiAobi5nYXBTaXplID0gdGhpcy5nYXBTaXplKSwgdGhpcy5zY2FsZSAhPT0gdm9pZCAwICYmIChuLnNjYWxlID0gdGhpcy5zY2FsZSksIHRoaXMuZGl0aGVyaW5nID09PSAhMCAmJiAobi5kaXRoZXJpbmcgPSAhMCksIHRoaXMuYWxwaGFUZXN0ID4gMCAmJiAobi5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdCksIHRoaXMuYWxwaGFUb0NvdmVyYWdlID09PSAhMCAmJiAobi5hbHBoYVRvQ292ZXJhZ2UgPSB0aGlzLmFscGhhVG9Db3ZlcmFnZSksIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID09PSAhMCAmJiAobi5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSksIHRoaXMud2lyZWZyYW1lID09PSAhMCAmJiAobi53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZSksIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSAmJiAobi53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCksIHRoaXMud2lyZWZyYW1lTGluZWNhcCAhPT0gXCJyb3VuZFwiICYmIChuLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXApLCB0aGlzLndpcmVmcmFtZUxpbmVqb2luICE9PSBcInJvdW5kXCIgJiYgKG4ud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luKSwgdGhpcy5mbGF0U2hhZGluZyA9PT0gITAgJiYgKG4uZmxhdFNoYWRpbmcgPSB0aGlzLmZsYXRTaGFkaW5nKSwgdGhpcy52aXNpYmxlID09PSAhMSAmJiAobi52aXNpYmxlID0gITEpLCB0aGlzLnRvbmVNYXBwZWQgPT09ICExICYmIChuLnRvbmVNYXBwZWQgPSAhMSksIHRoaXMuZm9nID09PSAhMSAmJiAobi5mb2cgPSAhMSksIEpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpICE9PSBcInt9XCIgJiYgKG4udXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhKTtcbiAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgIGNvbnN0IG8gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgciBpbiBzKSB7XG4gICAgICAgIGNvbnN0IGwgPSBzW3JdO1xuICAgICAgICBkZWxldGUgbC5tZXRhZGF0YSwgby5wdXNoKGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBzID0gaShlLnRleHR1cmVzKSwgbyA9IGkoZS5pbWFnZXMpO1xuICAgICAgcy5sZW5ndGggPiAwICYmIChuLnRleHR1cmVzID0gcyksIG8ubGVuZ3RoID4gMCAmJiAobi5pbWFnZXMgPSBvKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICB0aGlzLm5hbWUgPSBlLm5hbWUsIHRoaXMuYmxlbmRpbmcgPSBlLmJsZW5kaW5nLCB0aGlzLnNpZGUgPSBlLnNpZGUsIHRoaXMudmVydGV4Q29sb3JzID0gZS52ZXJ0ZXhDb2xvcnMsIHRoaXMub3BhY2l0eSA9IGUub3BhY2l0eSwgdGhpcy50cmFuc3BhcmVudCA9IGUudHJhbnNwYXJlbnQsIHRoaXMuYmxlbmRTcmMgPSBlLmJsZW5kU3JjLCB0aGlzLmJsZW5kRHN0ID0gZS5ibGVuZERzdCwgdGhpcy5ibGVuZEVxdWF0aW9uID0gZS5ibGVuZEVxdWF0aW9uLCB0aGlzLmJsZW5kU3JjQWxwaGEgPSBlLmJsZW5kU3JjQWxwaGEsIHRoaXMuYmxlbmREc3RBbHBoYSA9IGUuYmxlbmREc3RBbHBoYSwgdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBlLmJsZW5kRXF1YXRpb25BbHBoYSwgdGhpcy5kZXB0aEZ1bmMgPSBlLmRlcHRoRnVuYywgdGhpcy5kZXB0aFRlc3QgPSBlLmRlcHRoVGVzdCwgdGhpcy5kZXB0aFdyaXRlID0gZS5kZXB0aFdyaXRlLCB0aGlzLnN0ZW5jaWxXcml0ZU1hc2sgPSBlLnN0ZW5jaWxXcml0ZU1hc2ssIHRoaXMuc3RlbmNpbEZ1bmMgPSBlLnN0ZW5jaWxGdW5jLCB0aGlzLnN0ZW5jaWxSZWYgPSBlLnN0ZW5jaWxSZWYsIHRoaXMuc3RlbmNpbEZ1bmNNYXNrID0gZS5zdGVuY2lsRnVuY01hc2ssIHRoaXMuc3RlbmNpbEZhaWwgPSBlLnN0ZW5jaWxGYWlsLCB0aGlzLnN0ZW5jaWxaRmFpbCA9IGUuc3RlbmNpbFpGYWlsLCB0aGlzLnN0ZW5jaWxaUGFzcyA9IGUuc3RlbmNpbFpQYXNzLCB0aGlzLnN0ZW5jaWxXcml0ZSA9IGUuc3RlbmNpbFdyaXRlO1xuICAgIGNvbnN0IHQgPSBlLmNsaXBwaW5nUGxhbmVzO1xuICAgIGxldCBuID0gbnVsbDtcbiAgICBpZiAodCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaSA9IHQubGVuZ3RoO1xuICAgICAgbiA9IG5ldyBBcnJheShpKTtcbiAgICAgIGZvciAobGV0IHMgPSAwOyBzICE9PSBpOyArK3MpXG4gICAgICAgIG5bc10gPSB0W3NdLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsaXBwaW5nUGxhbmVzID0gbiwgdGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gZS5jbGlwSW50ZXJzZWN0aW9uLCB0aGlzLmNsaXBTaGFkb3dzID0gZS5jbGlwU2hhZG93cywgdGhpcy5zaGFkb3dTaWRlID0gZS5zaGFkb3dTaWRlLCB0aGlzLmNvbG9yV3JpdGUgPSBlLmNvbG9yV3JpdGUsIHRoaXMucHJlY2lzaW9uID0gZS5wcmVjaXNpb24sIHRoaXMucG9seWdvbk9mZnNldCA9IGUucG9seWdvbk9mZnNldCwgdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gZS5wb2x5Z29uT2Zmc2V0RmFjdG9yLCB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IGUucG9seWdvbk9mZnNldFVuaXRzLCB0aGlzLmRpdGhlcmluZyA9IGUuZGl0aGVyaW5nLCB0aGlzLmFscGhhVGVzdCA9IGUuYWxwaGFUZXN0LCB0aGlzLmFscGhhVG9Db3ZlcmFnZSA9IGUuYWxwaGFUb0NvdmVyYWdlLCB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IGUucHJlbXVsdGlwbGllZEFscGhhLCB0aGlzLnZpc2libGUgPSBlLnZpc2libGUsIHRoaXMudG9uZU1hcHBlZCA9IGUudG9uZU1hcHBlZCwgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS51c2VyRGF0YSkpLCB0aGlzO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJkaXNwb3NlXCIgfSk7XG4gIH1cbiAgc2V0IG5lZWRzVXBkYXRlKGUpIHtcbiAgICBlID09PSAhMCAmJiB0aGlzLnZlcnNpb24rKztcbiAgfVxufVxuY2xhc3MgYW8gZXh0ZW5kcyBBbiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzTWVzaEJhc2ljTWF0ZXJpYWwgPSAhMCwgdGhpcy50eXBlID0gXCJNZXNoQmFzaWNNYXRlcmlhbFwiLCB0aGlzLmNvbG9yID0gbmV3IEFlKDE2Nzc3MjE1KSwgdGhpcy5tYXAgPSBudWxsLCB0aGlzLmxpZ2h0TWFwID0gbnVsbCwgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEsIHRoaXMuYW9NYXAgPSBudWxsLCB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMSwgdGhpcy5zcGVjdWxhck1hcCA9IG51bGwsIHRoaXMuYWxwaGFNYXAgPSBudWxsLCB0aGlzLmVudk1hcCA9IG51bGwsIHRoaXMuY29tYmluZSA9IDAsIHRoaXMucmVmbGVjdGl2aXR5ID0gMSwgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4LCB0aGlzLndpcmVmcmFtZSA9ICExLCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDEsIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IFwicm91bmRcIiwgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IFwicm91bmRcIiwgdGhpcy5mb2cgPSAhMCwgdGhpcy5zZXRWYWx1ZXMoZSk7XG4gIH1cbiAgY29weShlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSksIHRoaXMuY29sb3IuY29weShlLmNvbG9yKSwgdGhpcy5tYXAgPSBlLm1hcCwgdGhpcy5saWdodE1hcCA9IGUubGlnaHRNYXAsIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBlLmxpZ2h0TWFwSW50ZW5zaXR5LCB0aGlzLmFvTWFwID0gZS5hb01hcCwgdGhpcy5hb01hcEludGVuc2l0eSA9IGUuYW9NYXBJbnRlbnNpdHksIHRoaXMuc3BlY3VsYXJNYXAgPSBlLnNwZWN1bGFyTWFwLCB0aGlzLmFscGhhTWFwID0gZS5hbHBoYU1hcCwgdGhpcy5lbnZNYXAgPSBlLmVudk1hcCwgdGhpcy5jb21iaW5lID0gZS5jb21iaW5lLCB0aGlzLnJlZmxlY3Rpdml0eSA9IGUucmVmbGVjdGl2aXR5LCB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IGUucmVmcmFjdGlvblJhdGlvLCB0aGlzLndpcmVmcmFtZSA9IGUud2lyZWZyYW1lLCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGUud2lyZWZyYW1lTGluZXdpZHRoLCB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBlLndpcmVmcmFtZUxpbmVjYXAsIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBlLndpcmVmcmFtZUxpbmVqb2luLCB0aGlzLmZvZyA9IGUuZm9nLCB0aGlzO1xuICB9XG59XG5jb25zdCBxZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBFaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQ2UoKTtcbmNsYXNzIE90IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuXCIpO1xuICAgIHRoaXMuaXNCdWZmZXJBdHRyaWJ1dGUgPSAhMCwgdGhpcy5uYW1lID0gXCJcIiwgdGhpcy5hcnJheSA9IGUsIHRoaXMuaXRlbVNpemUgPSB0LCB0aGlzLmNvdW50ID0gZSAhPT0gdm9pZCAwID8gZS5sZW5ndGggLyB0IDogMCwgdGhpcy5ub3JtYWxpemVkID0gbiA9PT0gITAsIHRoaXMudXNhZ2UgPSAzNTA0NCwgdGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLTEgfSwgdGhpcy52ZXJzaW9uID0gMDtcbiAgfVxuICBvblVwbG9hZENhbGxiYWNrKCkge1xuICB9XG4gIHNldCBuZWVkc1VwZGF0ZShlKSB7XG4gICAgZSA9PT0gITAgJiYgdGhpcy52ZXJzaW9uKys7XG4gIH1cbiAgc2V0VXNhZ2UoZSkge1xuICAgIHJldHVybiB0aGlzLnVzYWdlID0gZSwgdGhpcztcbiAgfVxuICBjb3B5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lID0gZS5uYW1lLCB0aGlzLmFycmF5ID0gbmV3IGUuYXJyYXkuY29uc3RydWN0b3IoZS5hcnJheSksIHRoaXMuaXRlbVNpemUgPSBlLml0ZW1TaXplLCB0aGlzLmNvdW50ID0gZS5jb3VudCwgdGhpcy5ub3JtYWxpemVkID0gZS5ub3JtYWxpemVkLCB0aGlzLnVzYWdlID0gZS51c2FnZSwgdGhpcztcbiAgfVxuICBjb3B5QXQoZSwgdCwgbikge1xuICAgIGUgKj0gdGhpcy5pdGVtU2l6ZSwgbiAqPSB0Lml0ZW1TaXplO1xuICAgIGZvciAobGV0IGkgPSAwLCBzID0gdGhpcy5pdGVtU2l6ZTsgaSA8IHM7IGkrKylcbiAgICAgIHRoaXMuYXJyYXlbZSArIGldID0gdC5hcnJheVtuICsgaV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29weUFycmF5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheS5zZXQoZSksIHRoaXM7XG4gIH1cbiAgY29weUNvbG9yc0FycmF5KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5hcnJheTtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIHMgPSBlLmxlbmd0aDsgaSA8IHM7IGkrKykge1xuICAgICAgbGV0IG8gPSBlW2ldO1xuICAgICAgbyA9PT0gdm9pZCAwICYmIChjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZFwiLCBpKSwgbyA9IG5ldyBBZSgpKSwgdFtuKytdID0gby5yLCB0W24rK10gPSBvLmcsIHRbbisrXSA9IG8uYjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29weVZlY3RvcjJzQXJyYXkoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmFycmF5O1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgcyA9IGUubGVuZ3RoOyBpIDwgczsgaSsrKSB7XG4gICAgICBsZXQgbyA9IGVbaV07XG4gICAgICBvID09PSB2b2lkIDAgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkXCIsIGkpLCBvID0gbmV3IENlKCkpLCB0W24rK10gPSBvLngsIHRbbisrXSA9IG8ueTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29weVZlY3RvcjNzQXJyYXkoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmFycmF5O1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgcyA9IGUubGVuZ3RoOyBpIDwgczsgaSsrKSB7XG4gICAgICBsZXQgbyA9IGVbaV07XG4gICAgICBvID09PSB2b2lkIDAgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkXCIsIGkpLCBvID0gbmV3IE8oKSksIHRbbisrXSA9IG8ueCwgdFtuKytdID0gby55LCB0W24rK10gPSBvLno7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvcHlWZWN0b3I0c0FycmF5KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5hcnJheTtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIHMgPSBlLmxlbmd0aDsgaSA8IHM7IGkrKykge1xuICAgICAgbGV0IG8gPSBlW2ldO1xuICAgICAgbyA9PT0gdm9pZCAwICYmIChjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZFwiLCBpKSwgbyA9IG5ldyAkZSgpKSwgdFtuKytdID0gby54LCB0W24rK10gPSBvLnksIHRbbisrXSA9IG8ueiwgdFtuKytdID0gby53O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhcHBseU1hdHJpeDMoZSkge1xuICAgIGlmICh0aGlzLml0ZW1TaXplID09PSAyKVxuICAgICAgZm9yIChsZXQgdCA9IDAsIG4gPSB0aGlzLmNvdW50OyB0IDwgbjsgdCsrKVxuICAgICAgICBFaS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIHQpLCBFaS5hcHBseU1hdHJpeDMoZSksIHRoaXMuc2V0WFkodCwgRWkueCwgRWkueSk7XG4gICAgZWxzZSBpZiAodGhpcy5pdGVtU2l6ZSA9PT0gMylcbiAgICAgIGZvciAobGV0IHQgPSAwLCBuID0gdGhpcy5jb3VudDsgdCA8IG47IHQrKylcbiAgICAgICAgcWUuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLCB0KSwgcWUuYXBwbHlNYXRyaXgzKGUpLCB0aGlzLnNldFhZWih0LCBxZS54LCBxZS55LCBxZS56KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhcHBseU1hdHJpeDQoZSkge1xuICAgIGZvciAobGV0IHQgPSAwLCBuID0gdGhpcy5jb3VudDsgdCA8IG47IHQrKylcbiAgICAgIHFlLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgdCksIHFlLmFwcGx5TWF0cml4NChlKSwgdGhpcy5zZXRYWVoodCwgcWUueCwgcWUueSwgcWUueik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXBwbHlOb3JtYWxNYXRyaXgoZSkge1xuICAgIGZvciAobGV0IHQgPSAwLCBuID0gdGhpcy5jb3VudDsgdCA8IG47IHQrKylcbiAgICAgIHFlLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgdCksIHFlLmFwcGx5Tm9ybWFsTWF0cml4KGUpLCB0aGlzLnNldFhZWih0LCBxZS54LCBxZS55LCBxZS56KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2Zvcm1EaXJlY3Rpb24oZSkge1xuICAgIGZvciAobGV0IHQgPSAwLCBuID0gdGhpcy5jb3VudDsgdCA8IG47IHQrKylcbiAgICAgIHFlLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgdCksIHFlLnRyYW5zZm9ybURpcmVjdGlvbihlKSwgdGhpcy5zZXRYWVoodCwgcWUueCwgcWUueSwgcWUueik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0KGUsIHQgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXkuc2V0KGUsIHQpLCB0aGlzO1xuICB9XG4gIGdldFgoZSkge1xuICAgIHJldHVybiB0aGlzLmFycmF5W2UgKiB0aGlzLml0ZW1TaXplXTtcbiAgfVxuICBzZXRYKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheVtlICogdGhpcy5pdGVtU2l6ZV0gPSB0LCB0aGlzO1xuICB9XG4gIGdldFkoZSkge1xuICAgIHJldHVybiB0aGlzLmFycmF5W2UgKiB0aGlzLml0ZW1TaXplICsgMV07XG4gIH1cbiAgc2V0WShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbZSAqIHRoaXMuaXRlbVNpemUgKyAxXSA9IHQsIHRoaXM7XG4gIH1cbiAgZ2V0WihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbZSAqIHRoaXMuaXRlbVNpemUgKyAyXTtcbiAgfVxuICBzZXRaKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheVtlICogdGhpcy5pdGVtU2l6ZSArIDJdID0gdCwgdGhpcztcbiAgfVxuICBnZXRXKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheVtlICogdGhpcy5pdGVtU2l6ZSArIDNdO1xuICB9XG4gIHNldFcoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5W2UgKiB0aGlzLml0ZW1TaXplICsgM10gPSB0LCB0aGlzO1xuICB9XG4gIHNldFhZKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gZSAqPSB0aGlzLml0ZW1TaXplLCB0aGlzLmFycmF5W2UgKyAwXSA9IHQsIHRoaXMuYXJyYXlbZSArIDFdID0gbiwgdGhpcztcbiAgfVxuICBzZXRYWVooZSwgdCwgbiwgaSkge1xuICAgIHJldHVybiBlICo9IHRoaXMuaXRlbVNpemUsIHRoaXMuYXJyYXlbZSArIDBdID0gdCwgdGhpcy5hcnJheVtlICsgMV0gPSBuLCB0aGlzLmFycmF5W2UgKyAyXSA9IGksIHRoaXM7XG4gIH1cbiAgc2V0WFlaVyhlLCB0LCBuLCBpLCBzKSB7XG4gICAgcmV0dXJuIGUgKj0gdGhpcy5pdGVtU2l6ZSwgdGhpcy5hcnJheVtlICsgMF0gPSB0LCB0aGlzLmFycmF5W2UgKyAxXSA9IG4sIHRoaXMuYXJyYXlbZSArIDJdID0gaSwgdGhpcy5hcnJheVtlICsgM10gPSBzLCB0aGlzO1xuICB9XG4gIG9uVXBsb2FkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5vblVwbG9hZENhbGxiYWNrID0gZSwgdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSkuY29weSh0aGlzKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuICAgICAgdHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgYXJyYXk6IEFycmF5LmZyb20odGhpcy5hcnJheSksXG4gICAgICBub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLm5hbWUgIT09IFwiXCIgJiYgKGUubmFtZSA9IHRoaXMubmFtZSksIHRoaXMudXNhZ2UgIT09IDM1MDQ0ICYmIChlLnVzYWdlID0gdGhpcy51c2FnZSksICh0aGlzLnVwZGF0ZVJhbmdlLm9mZnNldCAhPT0gMCB8fCB0aGlzLnVwZGF0ZVJhbmdlLmNvdW50ICE9PSAtMSkgJiYgKGUudXBkYXRlUmFuZ2UgPSB0aGlzLnVwZGF0ZVJhbmdlKSwgZTtcbiAgfVxufVxuY2xhc3MgbG8gZXh0ZW5kcyBPdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBzdXBlcihuZXcgVWludDE2QXJyYXkoZSksIHQsIG4pO1xuICB9XG59XG5jbGFzcyBjbyBleHRlbmRzIE90IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHN1cGVyKG5ldyBVaW50MzJBcnJheShlKSwgdCwgbik7XG4gIH1cbn1cbmNsYXNzIHN0IGV4dGVuZHMgT3Qge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgc3VwZXIobmV3IEZsb2F0MzJBcnJheShlKSwgdCwgbik7XG4gIH1cbn1cbmxldCBabyA9IDA7XG5jb25zdCBidCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgS2UoKSwgbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IGF0KCksIFVuID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIHB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBkaSgpLCBuaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZGkoKSwgUWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKTtcbmNsYXNzIFV0IGV4dGVuZHMgJG4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzQnVmZmVyR2VvbWV0cnkgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgeyB2YWx1ZTogWm8rKyB9KSwgdGhpcy51dWlkID0gaGkoKSwgdGhpcy5uYW1lID0gXCJcIiwgdGhpcy50eXBlID0gXCJCdWZmZXJHZW9tZXRyeVwiLCB0aGlzLmluZGV4ID0gbnVsbCwgdGhpcy5hdHRyaWJ1dGVzID0ge30sIHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge30sIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSAhMSwgdGhpcy5ncm91cHMgPSBbXSwgdGhpcy5ib3VuZGluZ0JveCA9IG51bGwsIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsLCB0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiAxIC8gMCB9LCB0aGlzLnVzZXJEYXRhID0ge307XG4gIH1cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gIH1cbiAgc2V0SW5kZXgoZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGUpID8gdGhpcy5pbmRleCA9IG5ldyAodG8oZSkgPyBjbyA6IGxvKShlLCAxKSA6IHRoaXMuaW5kZXggPSBlLCB0aGlzO1xuICB9XG4gIGdldEF0dHJpYnV0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tlXTtcbiAgfVxuICBzZXRBdHRyaWJ1dGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbZV0gPSB0LCB0aGlzO1xuICB9XG4gIGRlbGV0ZUF0dHJpYnV0ZShlKSB7XG4gICAgcmV0dXJuIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbZV0sIHRoaXM7XG4gIH1cbiAgaGFzQXR0cmlidXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2VdICE9PSB2b2lkIDA7XG4gIH1cbiAgYWRkR3JvdXAoZSwgdCwgbiA9IDApIHtcbiAgICB0aGlzLmdyb3Vwcy5wdXNoKHtcbiAgICAgIHN0YXJ0OiBlLFxuICAgICAgY291bnQ6IHQsXG4gICAgICBtYXRlcmlhbEluZGV4OiBuXG4gICAgfSk7XG4gIH1cbiAgY2xlYXJHcm91cHMoKSB7XG4gICAgdGhpcy5ncm91cHMgPSBbXTtcbiAgfVxuICBzZXREcmF3UmFuZ2UoZSwgdCkge1xuICAgIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gZSwgdGhpcy5kcmF3UmFuZ2UuY291bnQgPSB0O1xuICB9XG4gIGFwcGx5TWF0cml4NChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICB0ICE9PSB2b2lkIDAgJiYgKHQuYXBwbHlNYXRyaXg0KGUpLCB0Lm5lZWRzVXBkYXRlID0gITApO1xuICAgIGNvbnN0IG4gPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuICAgIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHMgPSBuZXcgTXQoKS5nZXROb3JtYWxNYXRyaXgoZSk7XG4gICAgICBuLmFwcGx5Tm9ybWFsTWF0cml4KHMpLCBuLm5lZWRzVXBkYXRlID0gITA7XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtcbiAgICByZXR1cm4gaSAhPT0gdm9pZCAwICYmIChpLnRyYW5zZm9ybURpcmVjdGlvbihlKSwgaS5uZWVkc1VwZGF0ZSA9ICEwKSwgdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCAmJiB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICYmIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksIHRoaXM7XG4gIH1cbiAgYXBwbHlRdWF0ZXJuaW9uKGUpIHtcbiAgICByZXR1cm4gYnQubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oZSksIHRoaXMuYXBwbHlNYXRyaXg0KGJ0KSwgdGhpcztcbiAgfVxuICByb3RhdGVYKGUpIHtcbiAgICByZXR1cm4gYnQubWFrZVJvdGF0aW9uWChlKSwgdGhpcy5hcHBseU1hdHJpeDQoYnQpLCB0aGlzO1xuICB9XG4gIHJvdGF0ZVkoZSkge1xuICAgIHJldHVybiBidC5tYWtlUm90YXRpb25ZKGUpLCB0aGlzLmFwcGx5TWF0cml4NChidCksIHRoaXM7XG4gIH1cbiAgcm90YXRlWihlKSB7XG4gICAgcmV0dXJuIGJ0Lm1ha2VSb3RhdGlvblooZSksIHRoaXMuYXBwbHlNYXRyaXg0KGJ0KSwgdGhpcztcbiAgfVxuICB0cmFuc2xhdGUoZSwgdCwgbikge1xuICAgIHJldHVybiBidC5tYWtlVHJhbnNsYXRpb24oZSwgdCwgbiksIHRoaXMuYXBwbHlNYXRyaXg0KGJ0KSwgdGhpcztcbiAgfVxuICBzY2FsZShlLCB0LCBuKSB7XG4gICAgcmV0dXJuIGJ0Lm1ha2VTY2FsZShlLCB0LCBuKSwgdGhpcy5hcHBseU1hdHJpeDQoYnQpLCB0aGlzO1xuICB9XG4gIGxvb2tBdChlKSB7XG4gICAgcmV0dXJuIG1zLmxvb2tBdChlKSwgbXMudXBkYXRlTWF0cml4KCksIHRoaXMuYXBwbHlNYXRyaXg0KG1zLm1hdHJpeCksIHRoaXM7XG4gIH1cbiAgY2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLCB0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihVbikubmVnYXRlKCksIHRoaXMudHJhbnNsYXRlKFVuLngsIFVuLnksIFVuLnopLCB0aGlzO1xuICB9XG4gIHNldEZyb21Qb2ludHMoZSkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMCwgaSA9IGUubGVuZ3RoOyBuIDwgaTsgbisrKSB7XG4gICAgICBjb25zdCBzID0gZVtuXTtcbiAgICAgIHQucHVzaChzLngsIHMueSwgcy56IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgc3QodCwgMykpLCB0aGlzO1xuICB9XG4gIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICYmICh0aGlzLmJvdW5kaW5nQm94ID0gbmV3IGRpKCkpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sIHQgPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICBpZiAoZSAmJiBlLmlzR0xCdWZmZXJBdHRyaWJ1dGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMpLCB0aGlzLmJvdW5kaW5nQm94LnNldChcbiAgICAgICAgbmV3IE8oLTEgLyAwLCAtMSAvIDAsIC0xIC8gMCksXG4gICAgICAgIG5ldyBPKDEgLyAwLCAxIC8gMCwgMSAvIDApXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGUpLCB0KVxuICAgICAgICBmb3IgKGxldCBuID0gMCwgaSA9IHQubGVuZ3RoOyBuIDwgaTsgbisrKSB7XG4gICAgICAgICAgY29uc3QgcyA9IHRbbl07XG4gICAgICAgICAgcHQuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShzKSwgdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA/IChRZS5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWluLCBwdC5taW4pLCB0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoUWUpLCBRZS5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWF4LCBwdC5tYXgpLCB0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoUWUpKSA6ICh0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQocHQubWluKSwgdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KHB0Lm1heCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuICAgIChpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi54KSB8fCBpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi55KSB8fCBpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi56KSkgJiYgY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMpO1xuICB9XG4gIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICYmICh0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IGNpKCkpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sIHQgPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICBpZiAoZSAmJiBlLmlzR0xCdWZmZXJBdHRyaWJ1dGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMpLCB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgTygpLCAxIC8gMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG4gICAgICBpZiAocHQuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlKSwgdClcbiAgICAgICAgZm9yIChsZXQgcyA9IDAsIG8gPSB0Lmxlbmd0aDsgcyA8IG87IHMrKykge1xuICAgICAgICAgIGNvbnN0IHIgPSB0W3NdO1xuICAgICAgICAgIG5pLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUociksIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAoUWUuYWRkVmVjdG9ycyhwdC5taW4sIG5pLm1pbiksIHB0LmV4cGFuZEJ5UG9pbnQoUWUpLCBRZS5hZGRWZWN0b3JzKHB0Lm1heCwgbmkubWF4KSwgcHQuZXhwYW5kQnlQb2ludChRZSkpIDogKHB0LmV4cGFuZEJ5UG9pbnQobmkubWluKSwgcHQuZXhwYW5kQnlQb2ludChuaS5tYXgpKTtcbiAgICAgICAgfVxuICAgICAgcHQuZ2V0Q2VudGVyKG4pO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgcyA9IDAsIG8gPSBlLmNvdW50OyBzIDwgbzsgcysrKVxuICAgICAgICBRZS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsIHMpLCBpID0gTWF0aC5tYXgoaSwgbi5kaXN0YW5jZVRvU3F1YXJlZChRZSkpO1xuICAgICAgaWYgKHQpXG4gICAgICAgIGZvciAobGV0IHMgPSAwLCBvID0gdC5sZW5ndGg7IHMgPCBvOyBzKyspIHtcbiAgICAgICAgICBjb25zdCByID0gdFtzXSwgbCA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gICAgICAgICAgZm9yIChsZXQgYSA9IDAsIGMgPSByLmNvdW50OyBhIDwgYzsgYSsrKVxuICAgICAgICAgICAgUWUuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLCBhKSwgbCAmJiAoVW4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCBhKSwgUWUuYWRkKFVuKSksIGkgPSBNYXRoLm1heChpLCBuLmRpc3RhbmNlVG9TcXVhcmVkKFFlKSk7XG4gICAgICAgIH1cbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KGkpLCBpc05hTih0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cykgJiYgY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyk7XG4gICAgfVxuICB9XG4gIGNvbXB1dGVUYW5nZW50cygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5pbmRleCwgdCA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBpZiAoZSA9PT0gbnVsbCB8fCB0LnBvc2l0aW9uID09PSB2b2lkIDAgfHwgdC5ub3JtYWwgPT09IHZvaWQgMCB8fCB0LnV2ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGZhaWxlZC4gTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1dilcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBlLmFycmF5LCBpID0gdC5wb3NpdGlvbi5hcnJheSwgcyA9IHQubm9ybWFsLmFycmF5LCBvID0gdC51di5hcnJheSwgciA9IGkubGVuZ3RoIC8gMztcbiAgICB0aGlzLmhhc0F0dHJpYnV0ZShcInRhbmdlbnRcIikgPT09ICExICYmIHRoaXMuc2V0QXR0cmlidXRlKFwidGFuZ2VudFwiLCBuZXcgT3QobmV3IEZsb2F0MzJBcnJheSg0ICogciksIDQpKTtcbiAgICBjb25zdCBsID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJ0YW5nZW50XCIpLmFycmF5LCBhID0gW10sIGMgPSBbXTtcbiAgICBmb3IgKGxldCBGID0gMDsgRiA8IHI7IEYrKylcbiAgICAgIGFbRl0gPSBuZXcgTygpLCBjW0ZdID0gbmV3IE8oKTtcbiAgICBjb25zdCBkID0gbmV3IE8oKSwgdSA9IG5ldyBPKCksIG0gPSBuZXcgTygpLCBnID0gbmV3IENlKCksIHAgPSBuZXcgQ2UoKSwgZiA9IG5ldyBDZSgpLCB2ID0gbmV3IE8oKSwgXyA9IG5ldyBPKCk7XG4gICAgZnVuY3Rpb24gdyhGLCBQLCBHKSB7XG4gICAgICBkLmZyb21BcnJheShpLCBGICogMyksIHUuZnJvbUFycmF5KGksIFAgKiAzKSwgbS5mcm9tQXJyYXkoaSwgRyAqIDMpLCBnLmZyb21BcnJheShvLCBGICogMiksIHAuZnJvbUFycmF5KG8sIFAgKiAyKSwgZi5mcm9tQXJyYXkobywgRyAqIDIpLCB1LnN1YihkKSwgbS5zdWIoZCksIHAuc3ViKGcpLCBmLnN1YihnKTtcbiAgICAgIGNvbnN0IHogPSAxIC8gKHAueCAqIGYueSAtIGYueCAqIHAueSk7XG4gICAgICAhaXNGaW5pdGUoeikgfHwgKHYuY29weSh1KS5tdWx0aXBseVNjYWxhcihmLnkpLmFkZFNjYWxlZFZlY3RvcihtLCAtcC55KS5tdWx0aXBseVNjYWxhcih6KSwgXy5jb3B5KG0pLm11bHRpcGx5U2NhbGFyKHAueCkuYWRkU2NhbGVkVmVjdG9yKHUsIC1mLngpLm11bHRpcGx5U2NhbGFyKHopLCBhW0ZdLmFkZCh2KSwgYVtQXS5hZGQodiksIGFbR10uYWRkKHYpLCBjW0ZdLmFkZChfKSwgY1tQXS5hZGQoXyksIGNbR10uYWRkKF8pKTtcbiAgICB9XG4gICAgbGV0IHggPSB0aGlzLmdyb3VwcztcbiAgICB4Lmxlbmd0aCA9PT0gMCAmJiAoeCA9IFt7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGNvdW50OiBuLmxlbmd0aFxuICAgIH1dKTtcbiAgICBmb3IgKGxldCBGID0gMCwgUCA9IHgubGVuZ3RoOyBGIDwgUDsgKytGKSB7XG4gICAgICBjb25zdCBHID0geFtGXSwgeiA9IEcuc3RhcnQsIEwgPSBHLmNvdW50O1xuICAgICAgZm9yIChsZXQgSSA9IHosIEQgPSB6ICsgTDsgSSA8IEQ7IEkgKz0gMylcbiAgICAgICAgdyhcbiAgICAgICAgICBuW0kgKyAwXSxcbiAgICAgICAgICBuW0kgKyAxXSxcbiAgICAgICAgICBuW0kgKyAyXVxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zdCBNID0gbmV3IE8oKSwgRSA9IG5ldyBPKCksIFIgPSBuZXcgTygpLCB5ID0gbmV3IE8oKTtcbiAgICBmdW5jdGlvbiBBKEYpIHtcbiAgICAgIFIuZnJvbUFycmF5KHMsIEYgKiAzKSwgeS5jb3B5KFIpO1xuICAgICAgY29uc3QgUCA9IGFbRl07XG4gICAgICBNLmNvcHkoUCksIE0uc3ViKFIubXVsdGlwbHlTY2FsYXIoUi5kb3QoUCkpKS5ub3JtYWxpemUoKSwgRS5jcm9zc1ZlY3RvcnMoeSwgUCk7XG4gICAgICBjb25zdCB6ID0gRS5kb3QoY1tGXSkgPCAwID8gLTEgOiAxO1xuICAgICAgbFtGICogNF0gPSBNLngsIGxbRiAqIDQgKyAxXSA9IE0ueSwgbFtGICogNCArIDJdID0gTS56LCBsW0YgKiA0ICsgM10gPSB6O1xuICAgIH1cbiAgICBmb3IgKGxldCBGID0gMCwgUCA9IHgubGVuZ3RoOyBGIDwgUDsgKytGKSB7XG4gICAgICBjb25zdCBHID0geFtGXSwgeiA9IEcuc3RhcnQsIEwgPSBHLmNvdW50O1xuICAgICAgZm9yIChsZXQgSSA9IHosIEQgPSB6ICsgTDsgSSA8IEQ7IEkgKz0gMylcbiAgICAgICAgQShuW0kgKyAwXSksIEEobltJICsgMV0pLCBBKG5bSSArIDJdKTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZVZlcnRleE5vcm1hbHMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaW5kZXgsIHQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgIGlmICh0ICE9PSB2b2lkIDApIHtcbiAgICAgIGxldCBuID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJub3JtYWxcIik7XG4gICAgICBpZiAobiA9PT0gdm9pZCAwKVxuICAgICAgICBuID0gbmV3IE90KG5ldyBGbG9hdDMyQXJyYXkodC5jb3VudCAqIDMpLCAzKSwgdGhpcy5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbik7XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAobGV0IHUgPSAwLCBtID0gbi5jb3VudDsgdSA8IG07IHUrKylcbiAgICAgICAgICBuLnNldFhZWih1LCAwLCAwLCAwKTtcbiAgICAgIGNvbnN0IGkgPSBuZXcgTygpLCBzID0gbmV3IE8oKSwgbyA9IG5ldyBPKCksIHIgPSBuZXcgTygpLCBsID0gbmV3IE8oKSwgYSA9IG5ldyBPKCksIGMgPSBuZXcgTygpLCBkID0gbmV3IE8oKTtcbiAgICAgIGlmIChlKVxuICAgICAgICBmb3IgKGxldCB1ID0gMCwgbSA9IGUuY291bnQ7IHUgPCBtOyB1ICs9IDMpIHtcbiAgICAgICAgICBjb25zdCBnID0gZS5nZXRYKHUgKyAwKSwgcCA9IGUuZ2V0WCh1ICsgMSksIGYgPSBlLmdldFgodSArIDIpO1xuICAgICAgICAgIGkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBnKSwgcy5mcm9tQnVmZmVyQXR0cmlidXRlKHQsIHApLCBvLmZyb21CdWZmZXJBdHRyaWJ1dGUodCwgZiksIGMuc3ViVmVjdG9ycyhvLCBzKSwgZC5zdWJWZWN0b3JzKGksIHMpLCBjLmNyb3NzKGQpLCByLmZyb21CdWZmZXJBdHRyaWJ1dGUobiwgZyksIGwuZnJvbUJ1ZmZlckF0dHJpYnV0ZShuLCBwKSwgYS5mcm9tQnVmZmVyQXR0cmlidXRlKG4sIGYpLCByLmFkZChjKSwgbC5hZGQoYyksIGEuYWRkKGMpLCBuLnNldFhZWihnLCByLngsIHIueSwgci56KSwgbi5zZXRYWVoocCwgbC54LCBsLnksIGwueiksIG4uc2V0WFlaKGYsIGEueCwgYS55LCBhLnopO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAobGV0IHUgPSAwLCBtID0gdC5jb3VudDsgdSA8IG07IHUgKz0gMylcbiAgICAgICAgICBpLmZyb21CdWZmZXJBdHRyaWJ1dGUodCwgdSArIDApLCBzLmZyb21CdWZmZXJBdHRyaWJ1dGUodCwgdSArIDEpLCBvLmZyb21CdWZmZXJBdHRyaWJ1dGUodCwgdSArIDIpLCBjLnN1YlZlY3RvcnMobywgcyksIGQuc3ViVmVjdG9ycyhpLCBzKSwgYy5jcm9zcyhkKSwgbi5zZXRYWVoodSArIDAsIGMueCwgYy55LCBjLnopLCBuLnNldFhZWih1ICsgMSwgYy54LCBjLnksIGMueiksIG4uc2V0WFlaKHUgKyAyLCBjLngsIGMueSwgYy56KTtcbiAgICAgIHRoaXMubm9ybWFsaXplTm9ybWFscygpLCBuLm5lZWRzVXBkYXRlID0gITA7XG4gICAgfVxuICB9XG4gIG1lcmdlKGUsIHQpIHtcbiAgICBpZiAoIShlICYmIGUuaXNCdWZmZXJHZW9tZXRyeSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkuXCIsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ID09PSB2b2lkIDAgJiYgKHQgPSAwLCBjb25zb2xlLndhcm4oXG4gICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IE92ZXJ3cml0aW5nIG9yaWdpbmFsIGdlb21ldHJ5LCBzdGFydGluZyBhdCBvZmZzZXQ9MC4gVXNlIEJ1ZmZlckdlb21ldHJ5VXRpbHMubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZm9yIGxvc3NsZXNzIG1lcmdlLlwiXG4gICAgKSk7XG4gICAgY29uc3QgbiA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBmb3IgKGNvbnN0IGkgaW4gbikge1xuICAgICAgaWYgKGUuYXR0cmlidXRlc1tpXSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IG8gPSBuW2ldLmFycmF5LCByID0gZS5hdHRyaWJ1dGVzW2ldLCBsID0gci5hcnJheSwgYSA9IHIuaXRlbVNpemUgKiB0LCBjID0gTWF0aC5taW4obC5sZW5ndGgsIG8ubGVuZ3RoIC0gYSk7XG4gICAgICBmb3IgKGxldCBkID0gMCwgdSA9IGE7IGQgPCBjOyBkKyssIHUrKylcbiAgICAgICAgb1t1XSA9IGxbZF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5vcm1hbGl6ZU5vcm1hbHMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgZm9yIChsZXQgdCA9IDAsIG4gPSBlLmNvdW50OyB0IDwgbjsgdCsrKVxuICAgICAgUWUuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCB0KSwgUWUubm9ybWFsaXplKCksIGUuc2V0WFlaKHQsIFFlLngsIFFlLnksIFFlLnopO1xuICB9XG4gIHRvTm9uSW5kZXhlZCgpIHtcbiAgICBmdW5jdGlvbiBlKHIsIGwpIHtcbiAgICAgIGNvbnN0IGEgPSByLmFycmF5LCBjID0gci5pdGVtU2l6ZSwgZCA9IHIubm9ybWFsaXplZCwgdSA9IG5ldyBhLmNvbnN0cnVjdG9yKGwubGVuZ3RoICogYyk7XG4gICAgICBsZXQgbSA9IDAsIGcgPSAwO1xuICAgICAgZm9yIChsZXQgcCA9IDAsIGYgPSBsLmxlbmd0aDsgcCA8IGY7IHArKykge1xuICAgICAgICByLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPyBtID0gbFtwXSAqIHIuZGF0YS5zdHJpZGUgKyByLm9mZnNldCA6IG0gPSBsW3BdICogYztcbiAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCBjOyB2KyspXG4gICAgICAgICAgdVtnKytdID0gYVttKytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBPdCh1LCBjLCBkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5kZXggPT09IG51bGwpXG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEJ1ZmZlckdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuXCIpLCB0aGlzO1xuICAgIGNvbnN0IHQgPSBuZXcgVXQoKSwgbiA9IHRoaXMuaW5kZXguYXJyYXksIGkgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgZm9yIChjb25zdCByIGluIGkpIHtcbiAgICAgIGNvbnN0IGwgPSBpW3JdLCBhID0gZShsLCBuKTtcbiAgICAgIHQuc2V0QXR0cmlidXRlKHIsIGEpO1xuICAgIH1cbiAgICBjb25zdCBzID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXM7XG4gICAgZm9yIChjb25zdCByIGluIHMpIHtcbiAgICAgIGNvbnN0IGwgPSBbXSwgYSA9IHNbcl07XG4gICAgICBmb3IgKGxldCBjID0gMCwgZCA9IGEubGVuZ3RoOyBjIDwgZDsgYysrKSB7XG4gICAgICAgIGNvbnN0IHUgPSBhW2NdLCBtID0gZSh1LCBuKTtcbiAgICAgICAgbC5wdXNoKG0pO1xuICAgICAgfVxuICAgICAgdC5tb3JwaEF0dHJpYnV0ZXNbcl0gPSBsO1xuICAgIH1cbiAgICB0Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgICBjb25zdCBvID0gdGhpcy5ncm91cHM7XG4gICAgZm9yIChsZXQgciA9IDAsIGwgPSBvLmxlbmd0aDsgciA8IGw7IHIrKykge1xuICAgICAgY29uc3QgYSA9IG9bcl07XG4gICAgICB0LmFkZEdyb3VwKGEuc3RhcnQsIGEuY291bnQsIGEubWF0ZXJpYWxJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC41LFxuICAgICAgICB0eXBlOiBcIkJ1ZmZlckdlb21ldHJ5XCIsXG4gICAgICAgIGdlbmVyYXRvcjogXCJCdWZmZXJHZW9tZXRyeS50b0pTT05cIlxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGUudXVpZCA9IHRoaXMudXVpZCwgZS50eXBlID0gdGhpcy50eXBlLCB0aGlzLm5hbWUgIT09IFwiXCIgJiYgKGUubmFtZSA9IHRoaXMubmFtZSksIE9iamVjdC5rZXlzKHRoaXMudXNlckRhdGEpLmxlbmd0aCA+IDAgJiYgKGUudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhKSwgdGhpcy5wYXJhbWV0ZXJzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLnBhcmFtZXRlcnM7XG4gICAgICBmb3IgKGNvbnN0IGEgaW4gbClcbiAgICAgICAgbFthXSAhPT0gdm9pZCAwICYmIChlW2FdID0gbFthXSk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZS5kYXRhID0geyBhdHRyaWJ1dGVzOiB7fSB9O1xuICAgIGNvbnN0IHQgPSB0aGlzLmluZGV4O1xuICAgIHQgIT09IG51bGwgJiYgKGUuZGF0YS5pbmRleCA9IHtcbiAgICAgIHR5cGU6IHQuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcbiAgICAgIGFycmF5OiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LmFycmF5KVxuICAgIH0pO1xuICAgIGNvbnN0IG4gPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgZm9yIChjb25zdCBsIGluIG4pIHtcbiAgICAgIGNvbnN0IGEgPSBuW2xdO1xuICAgICAgZS5kYXRhLmF0dHJpYnV0ZXNbbF0gPSBhLnRvSlNPTihlLmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBpID0ge307XG4gICAgbGV0IHMgPSAhMTtcbiAgICBmb3IgKGNvbnN0IGwgaW4gdGhpcy5tb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLm1vcnBoQXR0cmlidXRlc1tsXSwgYyA9IFtdO1xuICAgICAgZm9yIChsZXQgZCA9IDAsIHUgPSBhLmxlbmd0aDsgZCA8IHU7IGQrKykge1xuICAgICAgICBjb25zdCBtID0gYVtkXTtcbiAgICAgICAgYy5wdXNoKG0udG9KU09OKGUuZGF0YSkpO1xuICAgICAgfVxuICAgICAgYy5sZW5ndGggPiAwICYmIChpW2xdID0gYywgcyA9ICEwKTtcbiAgICB9XG4gICAgcyAmJiAoZS5kYXRhLm1vcnBoQXR0cmlidXRlcyA9IGksIGUuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUpO1xuICAgIGNvbnN0IG8gPSB0aGlzLmdyb3VwcztcbiAgICBvLmxlbmd0aCA+IDAgJiYgKGUuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKSk7XG4gICAgY29uc3QgciA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG4gICAgcmV0dXJuIHIgIT09IG51bGwgJiYgKGUuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcbiAgICAgIGNlbnRlcjogci5jZW50ZXIudG9BcnJheSgpLFxuICAgICAgcmFkaXVzOiByLnJhZGl1c1xuICAgIH0pLCBlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gIH1cbiAgY29weShlKSB7XG4gICAgdGhpcy5pbmRleCA9IG51bGwsIHRoaXMuYXR0cmlidXRlcyA9IHt9LCB0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9LCB0aGlzLmdyb3VwcyA9IFtdLCB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbCwgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG4gICAgY29uc3QgdCA9IHt9O1xuICAgIHRoaXMubmFtZSA9IGUubmFtZTtcbiAgICBjb25zdCBuID0gZS5pbmRleDtcbiAgICBuICE9PSBudWxsICYmIHRoaXMuc2V0SW5kZXgobi5jbG9uZSh0KSk7XG4gICAgY29uc3QgaSA9IGUuYXR0cmlidXRlcztcbiAgICBmb3IgKGNvbnN0IGEgaW4gaSkge1xuICAgICAgY29uc3QgYyA9IGlbYV07XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShhLCBjLmNsb25lKHQpKTtcbiAgICB9XG4gICAgY29uc3QgcyA9IGUubW9ycGhBdHRyaWJ1dGVzO1xuICAgIGZvciAoY29uc3QgYSBpbiBzKSB7XG4gICAgICBjb25zdCBjID0gW10sIGQgPSBzW2FdO1xuICAgICAgZm9yIChsZXQgdSA9IDAsIG0gPSBkLmxlbmd0aDsgdSA8IG07IHUrKylcbiAgICAgICAgYy5wdXNoKGRbdV0uY2xvbmUodCkpO1xuICAgICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXNbYV0gPSBjO1xuICAgIH1cbiAgICB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgICBjb25zdCBvID0gZS5ncm91cHM7XG4gICAgZm9yIChsZXQgYSA9IDAsIGMgPSBvLmxlbmd0aDsgYSA8IGM7IGErKykge1xuICAgICAgY29uc3QgZCA9IG9bYV07XG4gICAgICB0aGlzLmFkZEdyb3VwKGQuc3RhcnQsIGQuY291bnQsIGQubWF0ZXJpYWxJbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSBlLmJvdW5kaW5nQm94O1xuICAgIHIgIT09IG51bGwgJiYgKHRoaXMuYm91bmRpbmdCb3ggPSByLmNsb25lKCkpO1xuICAgIGNvbnN0IGwgPSBlLmJvdW5kaW5nU3BoZXJlO1xuICAgIHJldHVybiBsICE9PSBudWxsICYmICh0aGlzLmJvdW5kaW5nU3BoZXJlID0gbC5jbG9uZSgpKSwgdGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBlLmRyYXdSYW5nZS5zdGFydCwgdGhpcy5kcmF3UmFuZ2UuY291bnQgPSBlLmRyYXdSYW5nZS5jb3VudCwgdGhpcy51c2VyRGF0YSA9IGUudXNlckRhdGEsIGUucGFyYW1ldGVycyAhPT0gdm9pZCAwICYmICh0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBlLnBhcmFtZXRlcnMpKSwgdGhpcztcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiZGlzcG9zZVwiIH0pO1xuICB9XG59XG5jb25zdCBhciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgS2UoKSwgR24gPSAvKiBAX19QVVJFX18gKi8gbmV3IGtvKCksIGdzID0gLyogQF9fUFVSRV9fICovIG5ldyBjaSgpLCBhbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBsbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBjbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBfcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCB2cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCB4cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBUaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBBaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBDaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBMaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQ2UoKSwgUmkgPSAvKiBAX19QVVJFX18gKi8gbmV3IENlKCksIEZpID0gLyogQF9fUFVSRV9fICovIG5ldyBDZSgpLCB5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpLCBEaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTygpO1xuY2xhc3MgTnQgZXh0ZW5kcyBhdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSBuZXcgVXQoKSwgdCA9IG5ldyBhbygpKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc01lc2ggPSAhMCwgdGhpcy50eXBlID0gXCJNZXNoXCIsIHRoaXMuZ2VvbWV0cnkgPSBlLCB0aGlzLm1hdGVyaWFsID0gdCwgdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcbiAgfVxuICBjb3B5KGUsIHQpIHtcbiAgICByZXR1cm4gc3VwZXIuY29weShlLCB0KSwgZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IHZvaWQgMCAmJiAodGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpKSwgZS5tb3JwaFRhcmdldERpY3Rpb25hcnkgIT09IHZvaWQgMCAmJiAodGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSBPYmplY3QuYXNzaWduKHt9LCBlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSkpLCB0aGlzLm1hdGVyaWFsID0gZS5tYXRlcmlhbCwgdGhpcy5nZW9tZXRyeSA9IGUuZ2VvbWV0cnksIHRoaXM7XG4gIH1cbiAgdXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcywgbiA9IE9iamVjdC5rZXlzKHQpO1xuICAgIGlmIChuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGkgPSB0W25bMF1dO1xuICAgICAgaWYgKGkgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdLCB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBzID0gMCwgbyA9IGkubGVuZ3RoOyBzIDwgbzsgcysrKSB7XG4gICAgICAgICAgY29uc3QgciA9IGlbc10ubmFtZSB8fCBTdHJpbmcocyk7XG4gICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSwgdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbcl0gPSBzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJheWNhc3QoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdlb21ldHJ5LCBpID0gdGhpcy5tYXRlcmlhbCwgcyA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgaWYgKGkgPT09IHZvaWQgMCB8fCAobi5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCAmJiBuLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLCBncy5jb3B5KG4uYm91bmRpbmdTcGhlcmUpLCBncy5hcHBseU1hdHJpeDQocyksIGUucmF5LmludGVyc2VjdHNTcGhlcmUoZ3MpID09PSAhMSkgfHwgKGFyLmNvcHkocykuaW52ZXJ0KCksIEduLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChhciksIG4uYm91bmRpbmdCb3ggIT09IG51bGwgJiYgR24uaW50ZXJzZWN0c0JveChuLmJvdW5kaW5nQm94KSA9PT0gITEpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBvO1xuICAgIGNvbnN0IHIgPSBuLmluZGV4LCBsID0gbi5hdHRyaWJ1dGVzLnBvc2l0aW9uLCBhID0gbi5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24sIGMgPSBuLm1vcnBoVGFyZ2V0c1JlbGF0aXZlLCBkID0gbi5hdHRyaWJ1dGVzLnV2LCB1ID0gbi5hdHRyaWJ1dGVzLnV2MiwgbSA9IG4uZ3JvdXBzLCBnID0gbi5kcmF3UmFuZ2U7XG4gICAgaWYgKHIgIT09IG51bGwpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSlcbiAgICAgICAgZm9yIChsZXQgcCA9IDAsIGYgPSBtLmxlbmd0aDsgcCA8IGY7IHArKykge1xuICAgICAgICAgIGNvbnN0IHYgPSBtW3BdLCBfID0gaVt2Lm1hdGVyaWFsSW5kZXhdLCB3ID0gTWF0aC5tYXgodi5zdGFydCwgZy5zdGFydCksIHggPSBNYXRoLm1pbihyLmNvdW50LCBNYXRoLm1pbih2LnN0YXJ0ICsgdi5jb3VudCwgZy5zdGFydCArIGcuY291bnQpKTtcbiAgICAgICAgICBmb3IgKGxldCBNID0gdywgRSA9IHg7IE0gPCBFOyBNICs9IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IFIgPSByLmdldFgoTSksIHkgPSByLmdldFgoTSArIDEpLCBBID0gci5nZXRYKE0gKyAyKTtcbiAgICAgICAgICAgIG8gPSBQaSh0aGlzLCBfLCBlLCBHbiwgbCwgYSwgYywgZCwgdSwgUiwgeSwgQSksIG8gJiYgKG8uZmFjZUluZGV4ID0gTWF0aC5mbG9vcihNIC8gMyksIG8uZmFjZS5tYXRlcmlhbEluZGV4ID0gdi5tYXRlcmlhbEluZGV4LCB0LnB1c2gobykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHAgPSBNYXRoLm1heCgwLCBnLnN0YXJ0KSwgZiA9IE1hdGgubWluKHIuY291bnQsIGcuc3RhcnQgKyBnLmNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgdiA9IHAsIF8gPSBmOyB2IDwgXzsgdiArPSAzKSB7XG4gICAgICAgICAgY29uc3QgdyA9IHIuZ2V0WCh2KSwgeCA9IHIuZ2V0WCh2ICsgMSksIE0gPSByLmdldFgodiArIDIpO1xuICAgICAgICAgIG8gPSBQaSh0aGlzLCBpLCBlLCBHbiwgbCwgYSwgYywgZCwgdSwgdywgeCwgTSksIG8gJiYgKG8uZmFjZUluZGV4ID0gTWF0aC5mbG9vcih2IC8gMyksIHQucHVzaChvKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlIGlmIChsICE9PSB2b2lkIDApXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSlcbiAgICAgICAgZm9yIChsZXQgcCA9IDAsIGYgPSBtLmxlbmd0aDsgcCA8IGY7IHArKykge1xuICAgICAgICAgIGNvbnN0IHYgPSBtW3BdLCBfID0gaVt2Lm1hdGVyaWFsSW5kZXhdLCB3ID0gTWF0aC5tYXgodi5zdGFydCwgZy5zdGFydCksIHggPSBNYXRoLm1pbihsLmNvdW50LCBNYXRoLm1pbih2LnN0YXJ0ICsgdi5jb3VudCwgZy5zdGFydCArIGcuY291bnQpKTtcbiAgICAgICAgICBmb3IgKGxldCBNID0gdywgRSA9IHg7IE0gPCBFOyBNICs9IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IFIgPSBNLCB5ID0gTSArIDEsIEEgPSBNICsgMjtcbiAgICAgICAgICAgIG8gPSBQaSh0aGlzLCBfLCBlLCBHbiwgbCwgYSwgYywgZCwgdSwgUiwgeSwgQSksIG8gJiYgKG8uZmFjZUluZGV4ID0gTWF0aC5mbG9vcihNIC8gMyksIG8uZmFjZS5tYXRlcmlhbEluZGV4ID0gdi5tYXRlcmlhbEluZGV4LCB0LnB1c2gobykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHAgPSBNYXRoLm1heCgwLCBnLnN0YXJ0KSwgZiA9IE1hdGgubWluKGwuY291bnQsIGcuc3RhcnQgKyBnLmNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgdiA9IHAsIF8gPSBmOyB2IDwgXzsgdiArPSAzKSB7XG4gICAgICAgICAgY29uc3QgdyA9IHYsIHggPSB2ICsgMSwgTSA9IHYgKyAyO1xuICAgICAgICAgIG8gPSBQaSh0aGlzLCBpLCBlLCBHbiwgbCwgYSwgYywgZCwgdSwgdywgeCwgTSksIG8gJiYgKG8uZmFjZUluZGV4ID0gTWF0aC5mbG9vcih2IC8gMyksIHQucHVzaChvKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJG8oaCwgZSwgdCwgbiwgaSwgcywgbywgcikge1xuICBsZXQgbDtcbiAgaWYgKGUuc2lkZSA9PT0gMSA/IGwgPSBuLmludGVyc2VjdFRyaWFuZ2xlKG8sIHMsIGksICEwLCByKSA6IGwgPSBuLmludGVyc2VjdFRyaWFuZ2xlKGksIHMsIG8sIGUuc2lkZSAhPT0gMiwgciksIGwgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIERpLmNvcHkociksIERpLmFwcGx5TWF0cml4NChoLm1hdHJpeFdvcmxkKTtcbiAgY29uc3QgYSA9IHQucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKERpKTtcbiAgcmV0dXJuIGEgPCB0Lm5lYXIgfHwgYSA+IHQuZmFyID8gbnVsbCA6IHtcbiAgICBkaXN0YW5jZTogYSxcbiAgICBwb2ludDogRGkuY2xvbmUoKSxcbiAgICBvYmplY3Q6IGhcbiAgfTtcbn1cbmZ1bmN0aW9uIFBpKGgsIGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEsIGMsIGQpIHtcbiAgYW4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLCBhKSwgbG4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLCBjKSwgY24uZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLCBkKTtcbiAgY29uc3QgdSA9IGgubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuICBpZiAocyAmJiB1KSB7XG4gICAgVGkuc2V0KDAsIDAsIDApLCBBaS5zZXQoMCwgMCwgMCksIENpLnNldCgwLCAwLCAwKTtcbiAgICBmb3IgKGxldCBnID0gMCwgcCA9IHMubGVuZ3RoOyBnIDwgcDsgZysrKSB7XG4gICAgICBjb25zdCBmID0gdVtnXSwgdiA9IHNbZ107XG4gICAgICBmICE9PSAwICYmIChfcy5mcm9tQnVmZmVyQXR0cmlidXRlKHYsIGEpLCB2cy5mcm9tQnVmZmVyQXR0cmlidXRlKHYsIGMpLCB4cy5mcm9tQnVmZmVyQXR0cmlidXRlKHYsIGQpLCBvID8gKFRpLmFkZFNjYWxlZFZlY3RvcihfcywgZiksIEFpLmFkZFNjYWxlZFZlY3Rvcih2cywgZiksIENpLmFkZFNjYWxlZFZlY3Rvcih4cywgZikpIDogKFRpLmFkZFNjYWxlZFZlY3Rvcihfcy5zdWIoYW4pLCBmKSwgQWkuYWRkU2NhbGVkVmVjdG9yKHZzLnN1YihsbiksIGYpLCBDaS5hZGRTY2FsZWRWZWN0b3IoeHMuc3ViKGNuKSwgZikpKTtcbiAgICB9XG4gICAgYW4uYWRkKFRpKSwgbG4uYWRkKEFpKSwgY24uYWRkKENpKTtcbiAgfVxuICBoLmlzU2tpbm5lZE1lc2ggJiYgKGguYm9uZVRyYW5zZm9ybShhLCBhbiksIGguYm9uZVRyYW5zZm9ybShjLCBsbiksIGguYm9uZVRyYW5zZm9ybShkLCBjbikpO1xuICBjb25zdCBtID0gJG8oaCwgZSwgdCwgbiwgYW4sIGxuLCBjbiwgeXMpO1xuICBpZiAobSkge1xuICAgIHIgJiYgKExpLmZyb21CdWZmZXJBdHRyaWJ1dGUociwgYSksIFJpLmZyb21CdWZmZXJBdHRyaWJ1dGUociwgYyksIEZpLmZyb21CdWZmZXJBdHRyaWJ1dGUociwgZCksIG0udXYgPSBRdC5nZXRVVih5cywgYW4sIGxuLCBjbiwgTGksIFJpLCBGaSwgbmV3IENlKCkpKSwgbCAmJiAoTGkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShsLCBhKSwgUmkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShsLCBjKSwgRmkuZnJvbUJ1ZmZlckF0dHJpYnV0ZShsLCBkKSwgbS51djIgPSBRdC5nZXRVVih5cywgYW4sIGxuLCBjbiwgTGksIFJpLCBGaSwgbmV3IENlKCkpKTtcbiAgICBjb25zdCBnID0ge1xuICAgICAgYSxcbiAgICAgIGI6IGMsXG4gICAgICBjOiBkLFxuICAgICAgbm9ybWFsOiBuZXcgTygpLFxuICAgICAgbWF0ZXJpYWxJbmRleDogMFxuICAgIH07XG4gICAgUXQuZ2V0Tm9ybWFsKGFuLCBsbiwgY24sIGcubm9ybWFsKSwgbS5mYWNlID0gZztcbiAgfVxuICByZXR1cm4gbTtcbn1cbmNsYXNzIHBpIGV4dGVuZHMgVXQge1xuICBjb25zdHJ1Y3RvcihlID0gMSwgdCA9IDEsIG4gPSAxLCBpID0gMSwgcyA9IDEsIG8gPSAxKSB7XG4gICAgc3VwZXIoKSwgdGhpcy50eXBlID0gXCJCb3hHZW9tZXRyeVwiLCB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICB3aWR0aDogZSxcbiAgICAgIGhlaWdodDogdCxcbiAgICAgIGRlcHRoOiBuLFxuICAgICAgd2lkdGhTZWdtZW50czogaSxcbiAgICAgIGhlaWdodFNlZ21lbnRzOiBzLFxuICAgICAgZGVwdGhTZWdtZW50czogb1xuICAgIH07XG4gICAgY29uc3QgciA9IHRoaXM7XG4gICAgaSA9IE1hdGguZmxvb3IoaSksIHMgPSBNYXRoLmZsb29yKHMpLCBvID0gTWF0aC5mbG9vcihvKTtcbiAgICBjb25zdCBsID0gW10sIGEgPSBbXSwgYyA9IFtdLCBkID0gW107XG4gICAgbGV0IHUgPSAwLCBtID0gMDtcbiAgICBnKFwielwiLCBcInlcIiwgXCJ4XCIsIC0xLCAtMSwgbiwgdCwgZSwgbywgcywgMCksIGcoXCJ6XCIsIFwieVwiLCBcInhcIiwgMSwgLTEsIG4sIHQsIC1lLCBvLCBzLCAxKSwgZyhcInhcIiwgXCJ6XCIsIFwieVwiLCAxLCAxLCBlLCBuLCB0LCBpLCBvLCAyKSwgZyhcInhcIiwgXCJ6XCIsIFwieVwiLCAxLCAtMSwgZSwgbiwgLXQsIGksIG8sIDMpLCBnKFwieFwiLCBcInlcIiwgXCJ6XCIsIDEsIC0xLCBlLCB0LCBuLCBpLCBzLCA0KSwgZyhcInhcIiwgXCJ5XCIsIFwielwiLCAtMSwgLTEsIGUsIHQsIC1uLCBpLCBzLCA1KSwgdGhpcy5zZXRJbmRleChsKSwgdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgc3QoYSwgMykpLCB0aGlzLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgc3QoYywgMykpLCB0aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBzdChkLCAyKSk7XG4gICAgZnVuY3Rpb24gZyhwLCBmLCB2LCBfLCB3LCB4LCBNLCBFLCBSLCB5LCBBKSB7XG4gICAgICBjb25zdCBGID0geCAvIFIsIFAgPSBNIC8geSwgRyA9IHggLyAyLCB6ID0gTSAvIDIsIEwgPSBFIC8gMiwgSSA9IFIgKyAxLCBEID0geSArIDE7XG4gICAgICBsZXQgcSA9IDAsIGsgPSAwO1xuICAgICAgY29uc3QgTiA9IG5ldyBPKCk7XG4gICAgICBmb3IgKGxldCBIID0gMDsgSCA8IEQ7IEgrKykge1xuICAgICAgICBjb25zdCBKID0gSCAqIFAgLSB6O1xuICAgICAgICBmb3IgKGxldCBWID0gMDsgViA8IEk7IFYrKykge1xuICAgICAgICAgIGNvbnN0IGVlID0gViAqIEYgLSBHO1xuICAgICAgICAgIE5bcF0gPSBlZSAqIF8sIE5bZl0gPSBKICogdywgTlt2XSA9IEwsIGEucHVzaChOLngsIE4ueSwgTi56KSwgTltwXSA9IDAsIE5bZl0gPSAwLCBOW3ZdID0gRSA+IDAgPyAxIDogLTEsIGMucHVzaChOLngsIE4ueSwgTi56KSwgZC5wdXNoKFYgLyBSKSwgZC5wdXNoKDEgLSBIIC8geSksIHEgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgSCA9IDA7IEggPCB5OyBIKyspXG4gICAgICAgIGZvciAobGV0IEogPSAwOyBKIDwgUjsgSisrKSB7XG4gICAgICAgICAgY29uc3QgViA9IHUgKyBKICsgSSAqIEgsIGVlID0gdSArIEogKyBJICogKEggKyAxKSwgY2UgPSB1ICsgKEogKyAxKSArIEkgKiAoSCArIDEpLCBnZSA9IHUgKyAoSiArIDEpICsgSSAqIEg7XG4gICAgICAgICAgbC5wdXNoKFYsIGVlLCBnZSksIGwucHVzaChlZSwgY2UsIGdlKSwgayArPSA2O1xuICAgICAgICB9XG4gICAgICByLmFkZEdyb3VwKG0sIGssIEEpLCBtICs9IGssIHUgKz0gcTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21KU09OKGUpIHtcbiAgICByZXR1cm4gbmV3IHBpKGUud2lkdGgsIGUuaGVpZ2h0LCBlLmRlcHRoLCBlLndpZHRoU2VnbWVudHMsIGUuaGVpZ2h0U2VnbWVudHMsIGUuZGVwdGhTZWdtZW50cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFpuKGgpIHtcbiAgY29uc3QgZSA9IHt9O1xuICBmb3IgKGNvbnN0IHQgaW4gaCkge1xuICAgIGVbdF0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IG4gaW4gaFt0XSkge1xuICAgICAgY29uc3QgaSA9IGhbdF1bbl07XG4gICAgICBpICYmIChpLmlzQ29sb3IgfHwgaS5pc01hdHJpeDMgfHwgaS5pc01hdHJpeDQgfHwgaS5pc1ZlY3RvcjIgfHwgaS5pc1ZlY3RvcjMgfHwgaS5pc1ZlY3RvcjQgfHwgaS5pc1RleHR1cmUgfHwgaS5pc1F1YXRlcm5pb24pID8gZVt0XVtuXSA9IGkuY2xvbmUoKSA6IEFycmF5LmlzQXJyYXkoaSkgPyBlW3RdW25dID0gaS5zbGljZSgpIDogZVt0XVtuXSA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gaXQoaCkge1xuICBjb25zdCBlID0ge307XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaC5sZW5ndGg7IHQrKykge1xuICAgIGNvbnN0IG4gPSBabihoW3RdKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gbilcbiAgICAgIGVbaV0gPSBuW2ldO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gS28oaCkge1xuICBjb25zdCBlID0gW107XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaC5sZW5ndGg7IHQrKylcbiAgICBlLnB1c2goaFt0XS5jbG9uZSgpKTtcbiAgcmV0dXJuIGU7XG59XG5jb25zdCBKbyA9IHsgY2xvbmU6IFpuLCBtZXJnZTogaXQgfTtcbnZhciBRbyA9IGB2b2lkIG1haW4oKSB7XG5cdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbn1gLCBlYSA9IGB2b2lkIG1haW4oKSB7XG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xufWA7XG5jbGFzcyBUbiBleHRlbmRzIEFuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMuaXNTaGFkZXJNYXRlcmlhbCA9ICEwLCB0aGlzLnR5cGUgPSBcIlNoYWRlck1hdGVyaWFsXCIsIHRoaXMuZGVmaW5lcyA9IHt9LCB0aGlzLnVuaWZvcm1zID0ge30sIHRoaXMudW5pZm9ybXNHcm91cHMgPSBbXSwgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBRbywgdGhpcy5mcmFnbWVudFNoYWRlciA9IGVhLCB0aGlzLmxpbmV3aWR0aCA9IDEsIHRoaXMud2lyZWZyYW1lID0gITEsIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMSwgdGhpcy5mb2cgPSAhMSwgdGhpcy5saWdodHMgPSAhMSwgdGhpcy5jbGlwcGluZyA9ICExLCB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBkZXJpdmF0aXZlczogITEsXG4gICAgICBmcmFnRGVwdGg6ICExLFxuICAgICAgZHJhd0J1ZmZlcnM6ICExLFxuICAgICAgc2hhZGVyVGV4dHVyZUxPRDogITFcbiAgICB9LCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSB7XG4gICAgICBjb2xvcjogWzEsIDEsIDFdLFxuICAgICAgdXY6IFswLCAwXSxcbiAgICAgIHV2MjogWzAsIDBdXG4gICAgfSwgdGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdm9pZCAwLCB0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9ICExLCB0aGlzLmdsc2xWZXJzaW9uID0gbnVsbCwgZSAhPT0gdm9pZCAwICYmIChlLmF0dHJpYnV0ZXMgIT09IHZvaWQgMCAmJiBjb25zb2xlLmVycm9yKFwiVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBkZWZpbmVkIGluIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuXCIpLCB0aGlzLnNldFZhbHVlcyhlKSk7XG4gIH1cbiAgY29weShlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSksIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBlLmZyYWdtZW50U2hhZGVyLCB0aGlzLnZlcnRleFNoYWRlciA9IGUudmVydGV4U2hhZGVyLCB0aGlzLnVuaWZvcm1zID0gWm4oZS51bmlmb3JtcyksIHRoaXMudW5pZm9ybXNHcm91cHMgPSBLbyhlLnVuaWZvcm1zR3JvdXBzKSwgdGhpcy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgZS5kZWZpbmVzKSwgdGhpcy53aXJlZnJhbWUgPSBlLndpcmVmcmFtZSwgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBlLndpcmVmcmFtZUxpbmV3aWR0aCwgdGhpcy5mb2cgPSBlLmZvZywgdGhpcy5saWdodHMgPSBlLmxpZ2h0cywgdGhpcy5jbGlwcGluZyA9IGUuY2xpcHBpbmcsIHRoaXMuZXh0ZW5zaW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGUuZXh0ZW5zaW9ucyksIHRoaXMuZ2xzbFZlcnNpb24gPSBlLmdsc2xWZXJzaW9uLCB0aGlzO1xuICB9XG4gIHRvSlNPTihlKSB7XG4gICAgY29uc3QgdCA9IHN1cGVyLnRvSlNPTihlKTtcbiAgICB0Lmdsc2xWZXJzaW9uID0gdGhpcy5nbHNsVmVyc2lvbiwgdC51bmlmb3JtcyA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnVuaWZvcm1zKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy51bmlmb3Jtc1tpXS52YWx1ZTtcbiAgICAgIG8gJiYgby5pc1RleHR1cmUgPyB0LnVuaWZvcm1zW2ldID0ge1xuICAgICAgICB0eXBlOiBcInRcIixcbiAgICAgICAgdmFsdWU6IG8udG9KU09OKGUpLnV1aWRcbiAgICAgIH0gOiBvICYmIG8uaXNDb2xvciA/IHQudW5pZm9ybXNbaV0gPSB7XG4gICAgICAgIHR5cGU6IFwiY1wiLFxuICAgICAgICB2YWx1ZTogby5nZXRIZXgoKVxuICAgICAgfSA6IG8gJiYgby5pc1ZlY3RvcjIgPyB0LnVuaWZvcm1zW2ldID0ge1xuICAgICAgICB0eXBlOiBcInYyXCIsXG4gICAgICAgIHZhbHVlOiBvLnRvQXJyYXkoKVxuICAgICAgfSA6IG8gJiYgby5pc1ZlY3RvcjMgPyB0LnVuaWZvcm1zW2ldID0ge1xuICAgICAgICB0eXBlOiBcInYzXCIsXG4gICAgICAgIHZhbHVlOiBvLnRvQXJyYXkoKVxuICAgICAgfSA6IG8gJiYgby5pc1ZlY3RvcjQgPyB0LnVuaWZvcm1zW2ldID0ge1xuICAgICAgICB0eXBlOiBcInY0XCIsXG4gICAgICAgIHZhbHVlOiBvLnRvQXJyYXkoKVxuICAgICAgfSA6IG8gJiYgby5pc01hdHJpeDMgPyB0LnVuaWZvcm1zW2ldID0ge1xuICAgICAgICB0eXBlOiBcIm0zXCIsXG4gICAgICAgIHZhbHVlOiBvLnRvQXJyYXkoKVxuICAgICAgfSA6IG8gJiYgby5pc01hdHJpeDQgPyB0LnVuaWZvcm1zW2ldID0ge1xuICAgICAgICB0eXBlOiBcIm00XCIsXG4gICAgICAgIHZhbHVlOiBvLnRvQXJyYXkoKVxuICAgICAgfSA6IHQudW5pZm9ybXNbaV0gPSB7XG4gICAgICAgIHZhbHVlOiBvXG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLmRlZmluZXMpLmxlbmd0aCA+IDAgJiYgKHQuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcyksIHQudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXIsIHQuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuICAgIGNvbnN0IG4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5leHRlbnNpb25zKVxuICAgICAgdGhpcy5leHRlbnNpb25zW2ldID09PSAhMCAmJiAobltpXSA9ICEwKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobikubGVuZ3RoID4gMCAmJiAodC5leHRlbnNpb25zID0gbiksIHQ7XG4gIH1cbn1cbmNsYXNzIGhvIGV4dGVuZHMgYXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzQ2FtZXJhID0gITAsIHRoaXMudHlwZSA9IFwiQ2FtZXJhXCIsIHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IEtlKCksIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBLZSgpLCB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IEtlKCk7XG4gIH1cbiAgY29weShlLCB0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSwgdCksIHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoZS5tYXRyaXhXb3JsZEludmVyc2UpLCB0aGlzLnByb2plY3Rpb25NYXRyaXguY29weShlLnByb2plY3Rpb25NYXRyaXgpLCB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoZS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSksIHRoaXM7XG4gIH1cbiAgZ2V0V29ybGREaXJlY3Rpb24oZSkge1xuICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsICExKTtcbiAgICBjb25zdCB0ID0gdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50cztcbiAgICByZXR1cm4gZS5zZXQoLXRbOF0sIC10WzldLCAtdFsxMF0pLm5vcm1hbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZU1hdHJpeFdvcmxkKGUpIHtcbiAgICBzdXBlci51cGRhdGVNYXRyaXhXb3JsZChlKSwgdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgfVxuICB1cGRhdGVXb3JsZE1hdHJpeChlLCB0KSB7XG4gICAgc3VwZXIudXBkYXRlV29ybGRNYXRyaXgoZSwgdCksIHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgfVxufVxuY2xhc3MgZ3QgZXh0ZW5kcyBobyB7XG4gIGNvbnN0cnVjdG9yKGUgPSA1MCwgdCA9IDEsIG4gPSAwLjEsIGkgPSAyZTMpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzUGVyc3BlY3RpdmVDYW1lcmEgPSAhMCwgdGhpcy50eXBlID0gXCJQZXJzcGVjdGl2ZUNhbWVyYVwiLCB0aGlzLmZvdiA9IGUsIHRoaXMuem9vbSA9IDEsIHRoaXMubmVhciA9IG4sIHRoaXMuZmFyID0gaSwgdGhpcy5mb2N1cyA9IDEwLCB0aGlzLmFzcGVjdCA9IHQsIHRoaXMudmlldyA9IG51bGwsIHRoaXMuZmlsbUdhdWdlID0gMzUsIHRoaXMuZmlsbU9mZnNldCA9IDAsIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICB9XG4gIGNvcHkoZSwgdCkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KGUsIHQpLCB0aGlzLmZvdiA9IGUuZm92LCB0aGlzLnpvb20gPSBlLnpvb20sIHRoaXMubmVhciA9IGUubmVhciwgdGhpcy5mYXIgPSBlLmZhciwgdGhpcy5mb2N1cyA9IGUuZm9jdXMsIHRoaXMuYXNwZWN0ID0gZS5hc3BlY3QsIHRoaXMudmlldyA9IGUudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKHt9LCBlLnZpZXcpLCB0aGlzLmZpbG1HYXVnZSA9IGUuZmlsbUdhdWdlLCB0aGlzLmZpbG1PZmZzZXQgPSBlLmZpbG1PZmZzZXQsIHRoaXM7XG4gIH1cbiAgc2V0Rm9jYWxMZW5ndGgoZSkge1xuICAgIGNvbnN0IHQgPSAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIGU7XG4gICAgdGhpcy5mb3YgPSB6cyAqIDIgKiBNYXRoLmF0YW4odCksIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICB9XG4gIGdldEZvY2FsTGVuZ3RoKCkge1xuICAgIGNvbnN0IGUgPSBNYXRoLnRhbihRaSAqIDAuNSAqIHRoaXMuZm92KTtcbiAgICByZXR1cm4gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBlO1xuICB9XG4gIGdldEVmZmVjdGl2ZUZPVigpIHtcbiAgICByZXR1cm4genMgKiAyICogTWF0aC5hdGFuKFxuICAgICAgTWF0aC50YW4oUWkgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb21cbiAgICApO1xuICB9XG4gIGdldEZpbG1XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbih0aGlzLmFzcGVjdCwgMSk7XG4gIH1cbiAgZ2V0RmlsbUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCh0aGlzLmFzcGVjdCwgMSk7XG4gIH1cbiAgc2V0Vmlld09mZnNldChlLCB0LCBuLCBpLCBzLCBvKSB7XG4gICAgdGhpcy5hc3BlY3QgPSBlIC8gdCwgdGhpcy52aWV3ID09PSBudWxsICYmICh0aGlzLnZpZXcgPSB7XG4gICAgICBlbmFibGVkOiAhMCxcbiAgICAgIGZ1bGxXaWR0aDogMSxcbiAgICAgIGZ1bGxIZWlnaHQ6IDEsXG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMCxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAxXG4gICAgfSksIHRoaXMudmlldy5lbmFibGVkID0gITAsIHRoaXMudmlldy5mdWxsV2lkdGggPSBlLCB0aGlzLnZpZXcuZnVsbEhlaWdodCA9IHQsIHRoaXMudmlldy5vZmZzZXRYID0gbiwgdGhpcy52aWV3Lm9mZnNldFkgPSBpLCB0aGlzLnZpZXcud2lkdGggPSBzLCB0aGlzLnZpZXcuaGVpZ2h0ID0gbywgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cbiAgY2xlYXJWaWV3T2Zmc2V0KCkge1xuICAgIHRoaXMudmlldyAhPT0gbnVsbCAmJiAodGhpcy52aWV3LmVuYWJsZWQgPSAhMSksIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICB9XG4gIHVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubmVhcjtcbiAgICBsZXQgdCA9IGUgKiBNYXRoLnRhbihRaSAqIDAuNSAqIHRoaXMuZm92KSAvIHRoaXMuem9vbSwgbiA9IDIgKiB0LCBpID0gdGhpcy5hc3BlY3QgKiBuLCBzID0gLTAuNSAqIGk7XG4gICAgY29uc3QgbyA9IHRoaXMudmlldztcbiAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkKSB7XG4gICAgICBjb25zdCBsID0gby5mdWxsV2lkdGgsIGEgPSBvLmZ1bGxIZWlnaHQ7XG4gICAgICBzICs9IG8ub2Zmc2V0WCAqIGkgLyBsLCB0IC09IG8ub2Zmc2V0WSAqIG4gLyBhLCBpICo9IG8ud2lkdGggLyBsLCBuICo9IG8uaGVpZ2h0IC8gYTtcbiAgICB9XG4gICAgY29uc3QgciA9IHRoaXMuZmlsbU9mZnNldDtcbiAgICByICE9PSAwICYmIChzICs9IGUgKiByIC8gdGhpcy5nZXRGaWxtV2lkdGgoKSksIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUocywgcyArIGksIHQsIHQgLSBuLCBlLCB0aGlzLmZhciksIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpO1xuICB9XG4gIHRvSlNPTihlKSB7XG4gICAgY29uc3QgdCA9IHN1cGVyLnRvSlNPTihlKTtcbiAgICByZXR1cm4gdC5vYmplY3QuZm92ID0gdGhpcy5mb3YsIHQub2JqZWN0Lnpvb20gPSB0aGlzLnpvb20sIHQub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXIsIHQub2JqZWN0LmZhciA9IHRoaXMuZmFyLCB0Lm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXMsIHQub2JqZWN0LmFzcGVjdCA9IHRoaXMuYXNwZWN0LCB0aGlzLnZpZXcgIT09IG51bGwgJiYgKHQub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcpKSwgdC5vYmplY3QuZmlsbUdhdWdlID0gdGhpcy5maWxtR2F1Z2UsIHQub2JqZWN0LmZpbG1PZmZzZXQgPSB0aGlzLmZpbG1PZmZzZXQsIHQ7XG4gIH1cbn1cbmNvbnN0IGtuID0gOTAsIFduID0gMTtcbmNsYXNzIHRhIGV4dGVuZHMgYXQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgaWYgKHN1cGVyKCksIHRoaXMudHlwZSA9IFwiQ3ViZUNhbWVyYVwiLCBuLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICE9PSAhMCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkN1YmVDYW1lcmE6IFRoZSBjb25zdHJ1Y3RvciBub3cgZXhwZWN0cyBhbiBpbnN0YW5jZSBvZiBXZWJHTEN1YmVSZW5kZXJUYXJnZXQgYXMgdGhpcmQgcGFyYW1ldGVyLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuO1xuICAgIGNvbnN0IGkgPSBuZXcgZ3Qoa24sIFduLCBlLCB0KTtcbiAgICBpLmxheWVycyA9IHRoaXMubGF5ZXJzLCBpLnVwLnNldCgwLCAtMSwgMCksIGkubG9va0F0KG5ldyBPKDEsIDAsIDApKSwgdGhpcy5hZGQoaSk7XG4gICAgY29uc3QgcyA9IG5ldyBndChrbiwgV24sIGUsIHQpO1xuICAgIHMubGF5ZXJzID0gdGhpcy5sYXllcnMsIHMudXAuc2V0KDAsIC0xLCAwKSwgcy5sb29rQXQobmV3IE8oLTEsIDAsIDApKSwgdGhpcy5hZGQocyk7XG4gICAgY29uc3QgbyA9IG5ldyBndChrbiwgV24sIGUsIHQpO1xuICAgIG8ubGF5ZXJzID0gdGhpcy5sYXllcnMsIG8udXAuc2V0KDAsIDAsIDEpLCBvLmxvb2tBdChuZXcgTygwLCAxLCAwKSksIHRoaXMuYWRkKG8pO1xuICAgIGNvbnN0IHIgPSBuZXcgZ3Qoa24sIFduLCBlLCB0KTtcbiAgICByLmxheWVycyA9IHRoaXMubGF5ZXJzLCByLnVwLnNldCgwLCAwLCAtMSksIHIubG9va0F0KG5ldyBPKDAsIC0xLCAwKSksIHRoaXMuYWRkKHIpO1xuICAgIGNvbnN0IGwgPSBuZXcgZ3Qoa24sIFduLCBlLCB0KTtcbiAgICBsLmxheWVycyA9IHRoaXMubGF5ZXJzLCBsLnVwLnNldCgwLCAtMSwgMCksIGwubG9va0F0KG5ldyBPKDAsIDAsIDEpKSwgdGhpcy5hZGQobCk7XG4gICAgY29uc3QgYSA9IG5ldyBndChrbiwgV24sIGUsIHQpO1xuICAgIGEubGF5ZXJzID0gdGhpcy5sYXllcnMsIGEudXAuc2V0KDAsIC0xLCAwKSwgYS5sb29rQXQobmV3IE8oMCwgMCwgLTEpKSwgdGhpcy5hZGQoYSk7XG4gIH1cbiAgdXBkYXRlKGUsIHQpIHtcbiAgICB0aGlzLnBhcmVudCA9PT0gbnVsbCAmJiB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgY29uc3QgbiA9IHRoaXMucmVuZGVyVGFyZ2V0LCBbaSwgcywgbywgciwgbCwgYV0gPSB0aGlzLmNoaWxkcmVuLCBjID0gZS5nZXRSZW5kZXJUYXJnZXQoKSwgZCA9IGUudG9uZU1hcHBpbmcsIHUgPSBlLnhyLmVuYWJsZWQ7XG4gICAgZS50b25lTWFwcGluZyA9IDAsIGUueHIuZW5hYmxlZCA9ICExO1xuICAgIGNvbnN0IG0gPSBuLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuICAgIG4udGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSAhMSwgZS5zZXRSZW5kZXJUYXJnZXQobiwgMCksIGUucmVuZGVyKHQsIGkpLCBlLnNldFJlbmRlclRhcmdldChuLCAxKSwgZS5yZW5kZXIodCwgcyksIGUuc2V0UmVuZGVyVGFyZ2V0KG4sIDIpLCBlLnJlbmRlcih0LCBvKSwgZS5zZXRSZW5kZXJUYXJnZXQobiwgMyksIGUucmVuZGVyKHQsIHIpLCBlLnNldFJlbmRlclRhcmdldChuLCA0KSwgZS5yZW5kZXIodCwgbCksIG4udGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBtLCBlLnNldFJlbmRlclRhcmdldChuLCA1KSwgZS5yZW5kZXIodCwgYSksIGUuc2V0UmVuZGVyVGFyZ2V0KGMpLCBlLnRvbmVNYXBwaW5nID0gZCwgZS54ci5lbmFibGVkID0gdSwgbi50ZXh0dXJlLm5lZWRzUE1SRU1VcGRhdGUgPSAhMDtcbiAgfVxufVxuY2xhc3MgdW8gZXh0ZW5kcyBfdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEsIGMpIHtcbiAgICBlID0gZSAhPT0gdm9pZCAwID8gZSA6IFtdLCB0ID0gdCAhPT0gdm9pZCAwID8gdCA6IDMwMSwgc3VwZXIoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYyksIHRoaXMuaXNDdWJlVGV4dHVyZSA9ICEwLCB0aGlzLmZsaXBZID0gITE7XG4gIH1cbiAgZ2V0IGltYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZTtcbiAgfVxuICBzZXQgaW1hZ2VzKGUpIHtcbiAgICB0aGlzLmltYWdlID0gZTtcbiAgfVxufVxuY2xhc3MgbmEgZXh0ZW5kcyBFbiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQgPSB7fSkge1xuICAgIHN1cGVyKGUsIGUsIHQpLCB0aGlzLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID0gITA7XG4gICAgY29uc3QgbiA9IHsgd2lkdGg6IGUsIGhlaWdodDogZSwgZGVwdGg6IDEgfSwgaSA9IFtuLCBuLCBuLCBuLCBuLCBuXTtcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgdW8oaSwgdC5tYXBwaW5nLCB0LndyYXBTLCB0LndyYXBULCB0Lm1hZ0ZpbHRlciwgdC5taW5GaWx0ZXIsIHQuZm9ybWF0LCB0LnR5cGUsIHQuYW5pc290cm9weSwgdC5lbmNvZGluZyksIHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSAhMCwgdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHQuZ2VuZXJhdGVNaXBtYXBzICE9PSB2b2lkIDAgPyB0LmdlbmVyYXRlTWlwbWFwcyA6ICExLCB0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdC5taW5GaWx0ZXIgIT09IHZvaWQgMCA/IHQubWluRmlsdGVyIDogMTAwNjtcbiAgfVxuICBmcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZShlLCB0KSB7XG4gICAgdGhpcy50ZXh0dXJlLnR5cGUgPSB0LnR5cGUsIHRoaXMudGV4dHVyZS5lbmNvZGluZyA9IHQuZW5jb2RpbmcsIHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0LmdlbmVyYXRlTWlwbWFwcywgdGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHQubWluRmlsdGVyLCB0aGlzLnRleHR1cmUubWFnRmlsdGVyID0gdC5tYWdGaWx0ZXI7XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9XG4gICAgICB9LFxuICAgICAgdmVydGV4U2hhZGVyOiBgXG5cblx0XHRcdFx0dmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcblxuXHRcdFx0XHR2ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XG5cblx0XHRcdFx0XHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHRcdFx0XHRcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cblxuXHRcdFx0XHR9XG5cdFx0XHRgLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcblxuXHRcdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XG5cblx0XHRcdFx0dmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcblxuXHRcdFx0XHQjaW5jbHVkZSA8Y29tbW9uPlxuXG5cdFx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRcdHZlYzIgc2FtcGxlVVYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xuXG5cdFx0XHRcdH1cblx0XHRcdGBcbiAgICB9LCBpID0gbmV3IHBpKDUsIDUsIDUpLCBzID0gbmV3IFRuKHtcbiAgICAgIG5hbWU6IFwiQ3ViZW1hcEZyb21FcXVpcmVjdFwiLFxuICAgICAgdW5pZm9ybXM6IFpuKG4udW5pZm9ybXMpLFxuICAgICAgdmVydGV4U2hhZGVyOiBuLnZlcnRleFNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBuLmZyYWdtZW50U2hhZGVyLFxuICAgICAgc2lkZTogMSxcbiAgICAgIGJsZW5kaW5nOiAwXG4gICAgfSk7XG4gICAgcy51bmlmb3Jtcy50RXF1aXJlY3QudmFsdWUgPSB0O1xuICAgIGNvbnN0IG8gPSBuZXcgTnQoaSwgcyksIHIgPSB0Lm1pbkZpbHRlcjtcbiAgICByZXR1cm4gdC5taW5GaWx0ZXIgPT09IDEwMDggJiYgKHQubWluRmlsdGVyID0gMTAwNiksIG5ldyB0YSgxLCAxMCwgdGhpcykudXBkYXRlKGUsIG8pLCB0Lm1pbkZpbHRlciA9IHIsIG8uZ2VvbWV0cnkuZGlzcG9zZSgpLCBvLm1hdGVyaWFsLmRpc3Bvc2UoKSwgdGhpcztcbiAgfVxuICBjbGVhcihlLCB0LCBuLCBpKSB7XG4gICAgY29uc3QgcyA9IGUuZ2V0UmVuZGVyVGFyZ2V0KCk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCA2OyBvKyspXG4gICAgICBlLnNldFJlbmRlclRhcmdldCh0aGlzLCBvKSwgZS5jbGVhcih0LCBuLCBpKTtcbiAgICBlLnNldFJlbmRlclRhcmdldChzKTtcbiAgfVxufVxuY29uc3QgYnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgaWEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSwgc2EgPSAvKiBAX19QVVJFX18gKi8gbmV3IE10KCk7XG5jbGFzcyBnbiB7XG4gIGNvbnN0cnVjdG9yKGUgPSBuZXcgTygxLCAwLCAwKSwgdCA9IDApIHtcbiAgICB0aGlzLmlzUGxhbmUgPSAhMCwgdGhpcy5ub3JtYWwgPSBlLCB0aGlzLmNvbnN0YW50ID0gdDtcbiAgfVxuICBzZXQoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbC5jb3B5KGUpLCB0aGlzLmNvbnN0YW50ID0gdCwgdGhpcztcbiAgfVxuICBzZXRDb21wb25lbnRzKGUsIHQsIG4sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWwuc2V0KGUsIHQsIG4pLCB0aGlzLmNvbnN0YW50ID0gaSwgdGhpcztcbiAgfVxuICBzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLmNvcHkoZSksIHRoaXMuY29uc3RhbnQgPSAtdC5kb3QodGhpcy5ub3JtYWwpLCB0aGlzO1xuICB9XG4gIHNldEZyb21Db3BsYW5hclBvaW50cyhlLCB0LCBuKSB7XG4gICAgY29uc3QgaSA9IGJzLnN1YlZlY3RvcnMobiwgdCkuY3Jvc3MoaWEuc3ViVmVjdG9ycyhlLCB0KSkubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoaSwgZSksIHRoaXM7XG4gIH1cbiAgY29weShlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLmNvcHkoZS5ub3JtYWwpLCB0aGlzLmNvbnN0YW50ID0gZS5jb25zdGFudCwgdGhpcztcbiAgfVxuICBub3JtYWxpemUoKSB7XG4gICAgY29uc3QgZSA9IDEgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoZSksIHRoaXMuY29uc3RhbnQgKj0gZSwgdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RhbnQgKj0gLTEsIHRoaXMubm9ybWFsLm5lZ2F0ZSgpLCB0aGlzO1xuICB9XG4gIGRpc3RhbmNlVG9Qb2ludChlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLmRvdChlKSArIHRoaXMuY29uc3RhbnQ7XG4gIH1cbiAgZGlzdGFuY2VUb1NwaGVyZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGUuY2VudGVyKSAtIGUucmFkaXVzO1xuICB9XG4gIHByb2plY3RQb2ludChlLCB0KSB7XG4gICAgcmV0dXJuIHQuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoLXRoaXMuZGlzdGFuY2VUb1BvaW50KGUpKS5hZGQoZSk7XG4gIH1cbiAgaW50ZXJzZWN0TGluZShlLCB0KSB7XG4gICAgY29uc3QgbiA9IGUuZGVsdGEoYnMpLCBpID0gdGhpcy5ub3JtYWwuZG90KG4pO1xuICAgIGlmIChpID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGUuc3RhcnQpID09PSAwID8gdC5jb3B5KGUuc3RhcnQpIDogbnVsbDtcbiAgICBjb25zdCBzID0gLShlLnN0YXJ0LmRvdCh0aGlzLm5vcm1hbCkgKyB0aGlzLmNvbnN0YW50KSAvIGk7XG4gICAgcmV0dXJuIHMgPCAwIHx8IHMgPiAxID8gbnVsbCA6IHQuY29weShuKS5tdWx0aXBseVNjYWxhcihzKS5hZGQoZS5zdGFydCk7XG4gIH1cbiAgaW50ZXJzZWN0c0xpbmUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmRpc3RhbmNlVG9Qb2ludChlLnN0YXJ0KSwgbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KGUuZW5kKTtcbiAgICByZXR1cm4gdCA8IDAgJiYgbiA+IDAgfHwgbiA8IDAgJiYgdCA+IDA7XG4gIH1cbiAgaW50ZXJzZWN0c0JveChlKSB7XG4gICAgcmV0dXJuIGUuaW50ZXJzZWN0c1BsYW5lKHRoaXMpO1xuICB9XG4gIGludGVyc2VjdHNTcGhlcmUoZSkge1xuICAgIHJldHVybiBlLmludGVyc2VjdHNQbGFuZSh0aGlzKTtcbiAgfVxuICBjb3BsYW5hclBvaW50KGUpIHtcbiAgICByZXR1cm4gZS5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5jb25zdGFudCk7XG4gIH1cbiAgYXBwbHlNYXRyaXg0KGUsIHQpIHtcbiAgICBjb25zdCBuID0gdCB8fCBzYS5nZXROb3JtYWxNYXRyaXgoZSksIGkgPSB0aGlzLmNvcGxhbmFyUG9pbnQoYnMpLmFwcGx5TWF0cml4NChlKSwgcyA9IHRoaXMubm9ybWFsLmFwcGx5TWF0cml4MyhuKS5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gdGhpcy5jb25zdGFudCA9IC1pLmRvdChzKSwgdGhpcztcbiAgfVxuICB0cmFuc2xhdGUoZSkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0YW50IC09IGUuZG90KHRoaXMubm9ybWFsKSwgdGhpcztcbiAgfVxuICBlcXVhbHMoZSkge1xuICAgIHJldHVybiBlLm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpICYmIGUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQ7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgfVxufVxuY29uc3QgVm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IGNpKCksIElpID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCk7XG5jbGFzcyBVcyB7XG4gIGNvbnN0cnVjdG9yKGUgPSBuZXcgZ24oKSwgdCA9IG5ldyBnbigpLCBuID0gbmV3IGduKCksIGkgPSBuZXcgZ24oKSwgcyA9IG5ldyBnbigpLCBvID0gbmV3IGduKCkpIHtcbiAgICB0aGlzLnBsYW5lcyA9IFtlLCB0LCBuLCBpLCBzLCBvXTtcbiAgfVxuICBzZXQoZSwgdCwgbiwgaSwgcywgbykge1xuICAgIGNvbnN0IHIgPSB0aGlzLnBsYW5lcztcbiAgICByZXR1cm4gclswXS5jb3B5KGUpLCByWzFdLmNvcHkodCksIHJbMl0uY29weShuKSwgclszXS5jb3B5KGkpLCByWzRdLmNvcHkocyksIHJbNV0uY29weShvKSwgdGhpcztcbiAgfVxuICBjb3B5KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5wbGFuZXM7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCA2OyBuKyspXG4gICAgICB0W25dLmNvcHkoZS5wbGFuZXNbbl0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEZyb21Qcm9qZWN0aW9uTWF0cml4KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5wbGFuZXMsIG4gPSBlLmVsZW1lbnRzLCBpID0gblswXSwgcyA9IG5bMV0sIG8gPSBuWzJdLCByID0gblszXSwgbCA9IG5bNF0sIGEgPSBuWzVdLCBjID0gbls2XSwgZCA9IG5bN10sIHUgPSBuWzhdLCBtID0gbls5XSwgZyA9IG5bMTBdLCBwID0gblsxMV0sIGYgPSBuWzEyXSwgdiA9IG5bMTNdLCBfID0gblsxNF0sIHcgPSBuWzE1XTtcbiAgICByZXR1cm4gdFswXS5zZXRDb21wb25lbnRzKHIgLSBpLCBkIC0gbCwgcCAtIHUsIHcgLSBmKS5ub3JtYWxpemUoKSwgdFsxXS5zZXRDb21wb25lbnRzKHIgKyBpLCBkICsgbCwgcCArIHUsIHcgKyBmKS5ub3JtYWxpemUoKSwgdFsyXS5zZXRDb21wb25lbnRzKHIgKyBzLCBkICsgYSwgcCArIG0sIHcgKyB2KS5ub3JtYWxpemUoKSwgdFszXS5zZXRDb21wb25lbnRzKHIgLSBzLCBkIC0gYSwgcCAtIG0sIHcgLSB2KS5ub3JtYWxpemUoKSwgdFs0XS5zZXRDb21wb25lbnRzKHIgLSBvLCBkIC0gYywgcCAtIGcsIHcgLSBfKS5ub3JtYWxpemUoKSwgdFs1XS5zZXRDb21wb25lbnRzKHIgKyBvLCBkICsgYywgcCArIGcsIHcgKyBfKS5ub3JtYWxpemUoKSwgdGhpcztcbiAgfVxuICBpbnRlcnNlY3RzT2JqZWN0KGUpIHtcbiAgICBjb25zdCB0ID0gZS5nZW9tZXRyeTtcbiAgICByZXR1cm4gdC5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCAmJiB0LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLCBWbi5jb3B5KHQuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKSwgdGhpcy5pbnRlcnNlY3RzU3BoZXJlKFZuKTtcbiAgfVxuICBpbnRlcnNlY3RzU3ByaXRlKGUpIHtcbiAgICByZXR1cm4gVm4uY2VudGVyLnNldCgwLCAwLCAwKSwgVm4ucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2LCBWbi5hcHBseU1hdHJpeDQoZS5tYXRyaXhXb3JsZCksIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShWbik7XG4gIH1cbiAgaW50ZXJzZWN0c1NwaGVyZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucGxhbmVzLCBuID0gZS5jZW50ZXIsIGkgPSAtZS5yYWRpdXM7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCA2OyBzKyspXG4gICAgICBpZiAodFtzXS5kaXN0YW5jZVRvUG9pbnQobikgPCBpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGludGVyc2VjdHNCb3goZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnBsYW5lcztcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgICAgY29uc3QgaSA9IHRbbl07XG4gICAgICBpZiAoSWkueCA9IGkubm9ybWFsLnggPiAwID8gZS5tYXgueCA6IGUubWluLngsIElpLnkgPSBpLm5vcm1hbC55ID4gMCA/IGUubWF4LnkgOiBlLm1pbi55LCBJaS56ID0gaS5ub3JtYWwueiA+IDAgPyBlLm1heC56IDogZS5taW4ueiwgaS5kaXN0YW5jZVRvUG9pbnQoSWkpIDwgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgY29udGFpbnNQb2ludChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucGxhbmVzO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgNjsgbisrKVxuICAgICAgaWYgKHRbbl0uZGlzdGFuY2VUb1BvaW50KGUpIDwgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICB9XG59XG5mdW5jdGlvbiBmbygpIHtcbiAgbGV0IGggPSBudWxsLCBlID0gITEsIHQgPSBudWxsLCBuID0gbnVsbDtcbiAgZnVuY3Rpb24gaShzLCBvKSB7XG4gICAgdChzLCBvKSwgbiA9IGgucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZSAhPT0gITAgJiYgdCAhPT0gbnVsbCAmJiAobiA9IGgucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGkpLCBlID0gITApO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBoLmNhbmNlbEFuaW1hdGlvbkZyYW1lKG4pLCBlID0gITE7XG4gICAgfSxcbiAgICBzZXRBbmltYXRpb25Mb29wOiBmdW5jdGlvbihzKSB7XG4gICAgICB0ID0gcztcbiAgICB9LFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGggPSBzO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJhKGgsIGUpIHtcbiAgY29uc3QgdCA9IGUuaXNXZWJHTDIsIG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gaShhLCBjKSB7XG4gICAgY29uc3QgZCA9IGEuYXJyYXksIHUgPSBhLnVzYWdlLCBtID0gaC5jcmVhdGVCdWZmZXIoKTtcbiAgICBoLmJpbmRCdWZmZXIoYywgbSksIGguYnVmZmVyRGF0YShjLCBkLCB1KSwgYS5vblVwbG9hZENhbGxiYWNrKCk7XG4gICAgbGV0IGc7XG4gICAgaWYgKGQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpXG4gICAgICBnID0gNTEyNjtcbiAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgVWludDE2QXJyYXkpXG4gICAgICBpZiAoYS5pc0Zsb2F0MTZCdWZmZXJBdHRyaWJ1dGUpXG4gICAgICAgIGlmICh0KVxuICAgICAgICAgIGcgPSA1MTMxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVc2FnZSBvZiBGbG9hdDE2QnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIFdlYkdMMi5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIGcgPSA1MTIzO1xuICAgIGVsc2UgaWYgKGQgaW5zdGFuY2VvZiBJbnQxNkFycmF5KVxuICAgICAgZyA9IDUxMjI7XG4gICAgZWxzZSBpZiAoZCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KVxuICAgICAgZyA9IDUxMjU7XG4gICAgZWxzZSBpZiAoZCBpbnN0YW5jZW9mIEludDMyQXJyYXkpXG4gICAgICBnID0gNTEyNDtcbiAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgSW50OEFycmF5KVxuICAgICAgZyA9IDUxMjA7XG4gICAgZWxzZSBpZiAoZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICBnID0gNTEyMTtcbiAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpXG4gICAgICBnID0gNTEyMTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFVuc3VwcG9ydGVkIGJ1ZmZlciBkYXRhIGZvcm1hdDogXCIgKyBkKTtcbiAgICByZXR1cm4ge1xuICAgICAgYnVmZmVyOiBtLFxuICAgICAgdHlwZTogZyxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogZC5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgIHZlcnNpb246IGEudmVyc2lvblxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcyhhLCBjLCBkKSB7XG4gICAgY29uc3QgdSA9IGMuYXJyYXksIG0gPSBjLnVwZGF0ZVJhbmdlO1xuICAgIGguYmluZEJ1ZmZlcihkLCBhKSwgbS5jb3VudCA9PT0gLTEgPyBoLmJ1ZmZlclN1YkRhdGEoZCwgMCwgdSkgOiAodCA/IGguYnVmZmVyU3ViRGF0YShcbiAgICAgIGQsXG4gICAgICBtLm9mZnNldCAqIHUuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICB1LFxuICAgICAgbS5vZmZzZXQsXG4gICAgICBtLmNvdW50XG4gICAgKSA6IGguYnVmZmVyU3ViRGF0YShcbiAgICAgIGQsXG4gICAgICBtLm9mZnNldCAqIHUuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICB1LnN1YmFycmF5KG0ub2Zmc2V0LCBtLm9mZnNldCArIG0uY291bnQpXG4gICAgKSwgbS5jb3VudCA9IC0xKTtcbiAgfVxuICBmdW5jdGlvbiBvKGEpIHtcbiAgICByZXR1cm4gYS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICYmIChhID0gYS5kYXRhKSwgbi5nZXQoYSk7XG4gIH1cbiAgZnVuY3Rpb24gcihhKSB7XG4gICAgYS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICYmIChhID0gYS5kYXRhKTtcbiAgICBjb25zdCBjID0gbi5nZXQoYSk7XG4gICAgYyAmJiAoaC5kZWxldGVCdWZmZXIoYy5idWZmZXIpLCBuLmRlbGV0ZShhKSk7XG4gIH1cbiAgZnVuY3Rpb24gbChhLCBjKSB7XG4gICAgaWYgKGEuaXNHTEJ1ZmZlckF0dHJpYnV0ZSkge1xuICAgICAgY29uc3QgdSA9IG4uZ2V0KGEpO1xuICAgICAgKCF1IHx8IHUudmVyc2lvbiA8IGEudmVyc2lvbikgJiYgbi5zZXQoYSwge1xuICAgICAgICBidWZmZXI6IGEuYnVmZmVyLFxuICAgICAgICB0eXBlOiBhLnR5cGUsXG4gICAgICAgIGJ5dGVzUGVyRWxlbWVudDogYS5lbGVtZW50U2l6ZSxcbiAgICAgICAgdmVyc2lvbjogYS52ZXJzaW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICYmIChhID0gYS5kYXRhKTtcbiAgICBjb25zdCBkID0gbi5nZXQoYSk7XG4gICAgZCA9PT0gdm9pZCAwID8gbi5zZXQoYSwgaShhLCBjKSkgOiBkLnZlcnNpb24gPCBhLnZlcnNpb24gJiYgKHMoZC5idWZmZXIsIGEsIGMpLCBkLnZlcnNpb24gPSBhLnZlcnNpb24pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiBvLFxuICAgIHJlbW92ZTogcixcbiAgICB1cGRhdGU6IGxcbiAgfTtcbn1cbmNsYXNzIGppIGV4dGVuZHMgVXQge1xuICBjb25zdHJ1Y3RvcihlID0gMSwgdCA9IDEsIG4gPSAxLCBpID0gMSkge1xuICAgIHN1cGVyKCksIHRoaXMudHlwZSA9IFwiUGxhbmVHZW9tZXRyeVwiLCB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICB3aWR0aDogZSxcbiAgICAgIGhlaWdodDogdCxcbiAgICAgIHdpZHRoU2VnbWVudHM6IG4sXG4gICAgICBoZWlnaHRTZWdtZW50czogaVxuICAgIH07XG4gICAgY29uc3QgcyA9IGUgLyAyLCBvID0gdCAvIDIsIHIgPSBNYXRoLmZsb29yKG4pLCBsID0gTWF0aC5mbG9vcihpKSwgYSA9IHIgKyAxLCBjID0gbCArIDEsIGQgPSBlIC8gciwgdSA9IHQgLyBsLCBtID0gW10sIGcgPSBbXSwgcCA9IFtdLCBmID0gW107XG4gICAgZm9yIChsZXQgdiA9IDA7IHYgPCBjOyB2KyspIHtcbiAgICAgIGNvbnN0IF8gPSB2ICogdSAtIG87XG4gICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IGE7IHcrKykge1xuICAgICAgICBjb25zdCB4ID0gdyAqIGQgLSBzO1xuICAgICAgICBnLnB1c2goeCwgLV8sIDApLCBwLnB1c2goMCwgMCwgMSksIGYucHVzaCh3IC8gciksIGYucHVzaCgxIC0gdiAvIGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB2ID0gMDsgdiA8IGw7IHYrKylcbiAgICAgIGZvciAobGV0IF8gPSAwOyBfIDwgcjsgXysrKSB7XG4gICAgICAgIGNvbnN0IHcgPSBfICsgYSAqIHYsIHggPSBfICsgYSAqICh2ICsgMSksIE0gPSBfICsgMSArIGEgKiAodiArIDEpLCBFID0gXyArIDEgKyBhICogdjtcbiAgICAgICAgbS5wdXNoKHcsIHgsIEUpLCBtLnB1c2goeCwgTSwgRSk7XG4gICAgICB9XG4gICAgdGhpcy5zZXRJbmRleChtKSwgdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgc3QoZywgMykpLCB0aGlzLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgc3QocCwgMykpLCB0aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBzdChmLCAyKSk7XG4gIH1cbiAgc3RhdGljIGZyb21KU09OKGUpIHtcbiAgICByZXR1cm4gbmV3IGppKGUud2lkdGgsIGUuaGVpZ2h0LCBlLndpZHRoU2VnbWVudHMsIGUuaGVpZ2h0U2VnbWVudHMpO1xuICB9XG59XG52YXIgb2EgPSBgI2lmZGVmIFVTRV9BTFBIQU1BUFxuXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xuI2VuZGlmYCwgYWEgPSBgI2lmZGVmIFVTRV9BTFBIQU1BUFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcbiNlbmRpZmAsIGxhID0gYCNpZmRlZiBVU0VfQUxQSEFURVNUXG5cdGlmICggZGlmZnVzZUNvbG9yLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkO1xuI2VuZGlmYCwgY2EgPSBgI2lmZGVmIFVTRV9BTFBIQVRFU1Rcblx0dW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7XG4jZW5kaWZgLCBoYSA9IGAjaWZkZWYgVVNFX0FPTUFQXG5cdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGFtYmllbnRPY2NsdXNpb247XG5cdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKVxuXHRcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICo9IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggZG90TlYsIGFtYmllbnRPY2NsdXNpb24sIG1hdGVyaWFsLnJvdWdobmVzcyApO1xuXHQjZW5kaWZcbiNlbmRpZmAsIHVhID0gYCNpZmRlZiBVU0VfQU9NQVBcblx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XG5cdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XG4jZW5kaWZgLCBkYSA9IFwidmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XCIsIGZhID0gYHZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XG4jaWZkZWYgVVNFX1RBTkdFTlRcblx0dmVjMyBvYmplY3RUYW5nZW50ID0gdmVjMyggdGFuZ2VudC54eXogKTtcbiNlbmRpZmAsIHBhID0gYHZlYzMgQlJERl9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHtcblx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XG59XG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcblx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApO1xuXHRyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApO1xufVxuZmxvYXQgRl9TY2hsaWNrKCBjb25zdCBpbiBmbG9hdCBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcblx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApO1xuXHRyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApO1xufVxudmVjMyBTY2hsaWNrX3RvX0YwKCBjb25zdCBpbiB2ZWMzIGYsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7XG4gICAgZmxvYXQgeCA9IGNsYW1wKCAxLjAgLSBkb3RWSCwgMC4wLCAxLjAgKTtcbiAgICBmbG9hdCB4MiA9IHggKiB4O1xuICAgIGZsb2F0IHg1ID0gY2xhbXAoIHggKiB4MiAqIHgyLCAwLjAsIDAuOTk5OSApO1xuICAgIHJldHVybiAoIGYgLSB2ZWMzKCBmOTAgKSAqIHg1ICkgLyAoIDEuMCAtIHg1ICk7XG59XG5mbG9hdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XG5cdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcblx0ZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xuXHRmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XG5cdHJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTtcbn1cbmZsb2F0IERfR0dYKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XG5cdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcblx0ZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wO1xuXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gcG93MiggZGVub20gKTtcbn1cbnZlYzMgQlJERl9HR1goIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xuXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xuXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xuXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xuXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XG5cdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcblx0ZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTtcblx0dmVjMyBGID0gRl9TY2hsaWNrKCBmMCwgZjkwLCBkb3RWSCApO1xuXHRmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XG5cdGZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7XG5cdHJldHVybiBGICogKCBWICogRCApO1xufVxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxuXHR2ZWMzIEJSREZfR0dYX0lyaWRlc2NlbmNlKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGlyaWRlc2NlbmNlLCBjb25zdCBpbiB2ZWMzIGlyaWRlc2NlbmNlRnJlc25lbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xuXHRcdGZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7XG5cdFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcblx0XHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xuXHRcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcblx0XHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XG5cdFx0ZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTtcblx0XHR2ZWMzIEYgPSBtaXgoIEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKSwgaXJpZGVzY2VuY2VGcmVzbmVsLCBpcmlkZXNjZW5jZSApO1xuXHRcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcblx0XHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xuXHRcdHJldHVybiBGICogKCBWICogRCApO1xuXHR9XG4jZW5kaWZcbnZlYzIgTFRDX1V2KCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xuXHRjb25zdCBmbG9hdCBMVVRfU0laRSA9IDY0LjA7XG5cdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xuXHRjb25zdCBmbG9hdCBMVVRfQklBUyA9IDAuNSAvIExVVF9TSVpFO1xuXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIE4sIFYgKSApO1xuXHR2ZWMyIHV2ID0gdmVjMiggcm91Z2huZXNzLCBzcXJ0KCAxLjAgLSBkb3ROViApICk7XG5cdHV2ID0gdXYgKiBMVVRfU0NBTEUgKyBMVVRfQklBUztcblx0cmV0dXJuIHV2O1xufVxuZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7XG5cdGZsb2F0IGwgPSBsZW5ndGgoIGYgKTtcblx0cmV0dXJuIG1heCggKCBsICogbCArIGYueiApIC8gKCBsICsgMS4wICksIDAuMCApO1xufVxudmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7XG5cdGZsb2F0IHggPSBkb3QoIHYxLCB2MiApO1xuXHRmbG9hdCB5ID0gYWJzKCB4ICk7XG5cdGZsb2F0IGEgPSAwLjg1NDM5ODUgKyAoIDAuNDk2NTE1NSArIDAuMDE0NTIwNiAqIHkgKSAqIHk7XG5cdGZsb2F0IGIgPSAzLjQxNzU5NDAgKyAoIDQuMTYxNjcyNCArIHkgKSAqIHk7XG5cdGZsb2F0IHYgPSBhIC8gYjtcblx0ZmxvYXQgdGhldGFfc2ludGhldGEgPSAoIHggPiAwLjAgKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggbWF4KCAxLjAgLSB4ICogeCwgMWUtNyApICkgLSB2O1xuXHRyZXR1cm4gY3Jvc3MoIHYxLCB2MiApICogdGhldGFfc2ludGhldGE7XG59XG52ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHtcblx0dmVjMyB2MSA9IHJlY3RDb29yZHNbIDEgXSAtIHJlY3RDb29yZHNbIDAgXTtcblx0dmVjMyB2MiA9IHJlY3RDb29yZHNbIDMgXSAtIHJlY3RDb29yZHNbIDAgXTtcblx0dmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTtcblx0aWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTtcblx0dmVjMyBUMSwgVDI7XG5cdFQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7XG5cdFQyID0gLSBjcm9zcyggTiwgVDEgKTtcblx0bWF0MyBtYXQgPSBtSW52ICogdHJhbnNwb3NlTWF0MyggbWF0MyggVDEsIFQyLCBOICkgKTtcblx0dmVjMyBjb29yZHNbIDQgXTtcblx0Y29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTtcblx0Y29vcmRzWyAxIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDEgXSAtIFAgKTtcblx0Y29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTtcblx0Y29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTtcblx0Y29vcmRzWyAwIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMCBdICk7XG5cdGNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApO1xuXHRjb29yZHNbIDIgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAyIF0gKTtcblx0Y29vcmRzWyAzIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMyBdICk7XG5cdHZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApO1xuXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7XG5cdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDEgXSwgY29vcmRzWyAyIF0gKTtcblx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApO1xuXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7XG5cdGZsb2F0IHJlc3VsdCA9IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggdmVjdG9yRm9ybUZhY3RvciApO1xuXHRyZXR1cm4gdmVjMyggcmVzdWx0ICk7XG59XG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICkge1xuXHRyZXR1cm4gMC4yNTtcbn1cbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcblx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XG59XG52ZWMzIEJSREZfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7XG5cdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XG5cdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcblx0ZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTtcblx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCAxLjAsIGRvdFZIICk7XG5cdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XG5cdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcblx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XG59XG4jaWYgZGVmaW5lZCggVVNFX1NIRUVOIClcbmZsb2F0IERfQ2hhcmxpZSggZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBkb3ROSCApIHtcblx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcblx0ZmxvYXQgaW52QWxwaGEgPSAxLjAgLyBhbHBoYTtcblx0ZmxvYXQgY29zMmggPSBkb3ROSCAqIGRvdE5IO1xuXHRmbG9hdCBzaW4yaCA9IG1heCggMS4wIC0gY29zMmgsIDAuMDA3ODEyNSApO1xuXHRyZXR1cm4gKCAyLjAgKyBpbnZBbHBoYSApICogcG93KCBzaW4yaCwgaW52QWxwaGEgKiAwLjUgKSAvICggMi4wICogUEkgKTtcbn1cbmZsb2F0IFZfTmV1YmVsdCggZmxvYXQgZG90TlYsIGZsb2F0IGRvdE5MICkge1xuXHRyZXR1cm4gc2F0dXJhdGUoIDEuMCAvICggNC4wICogKCBkb3ROTCArIGRvdE5WIC0gZG90TkwgKiBkb3ROViApICkgKTtcbn1cbnZlYzMgQlJERl9TaGVlbiggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgdmVjMyBzaGVlbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGVlblJvdWdobmVzcyApIHtcblx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcblx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcblx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xuXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XG5cdGZsb2F0IEQgPSBEX0NoYXJsaWUoIHNoZWVuUm91Z2huZXNzLCBkb3ROSCApO1xuXHRmbG9hdCBWID0gVl9OZXViZWx0KCBkb3ROViwgZG90TkwgKTtcblx0cmV0dXJuIHNoZWVuQ29sb3IgKiAoIEQgKiBWICk7XG59XG4jZW5kaWZgLCBtYSA9IGAjaWZkZWYgVVNFX0lSSURFU0NFTkNFXG5cdGNvbnN0IG1hdDMgWFlaX1RPX1JFQzcwOSA9IG1hdDMoXG5cdFx0IDMuMjQwNDU0MiwgLTAuOTY5MjY2MCwgIDAuMDU1NjQzNCxcblx0XHQtMS41MzcxMzg1LCAgMS44NzYwMTA4LCAtMC4yMDQwMjU5LFxuXHRcdC0wLjQ5ODUzMTQsICAwLjA0MTU1NjAsICAxLjA1NzIyNTJcblx0KTtcblx0dmVjMyBGcmVzbmVsMFRvSW9yKCB2ZWMzIGZyZXNuZWwwICkge1xuXHRcdHZlYzMgc3FydEYwID0gc3FydCggZnJlc25lbDAgKTtcblx0XHRyZXR1cm4gKCB2ZWMzKCAxLjAgKSArIHNxcnRGMCApIC8gKCB2ZWMzKCAxLjAgKSAtIHNxcnRGMCApO1xuXHR9XG5cdHZlYzMgSW9yVG9GcmVzbmVsMCggdmVjMyB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7XG5cdFx0cmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSB2ZWMzKCBpbmNpZGVudElvciApICkgLyAoIHRyYW5zbWl0dGVkSW9yICsgdmVjMyggaW5jaWRlbnRJb3IgKSApICk7XG5cdH1cblx0ZmxvYXQgSW9yVG9GcmVzbmVsMCggZmxvYXQgdHJhbnNtaXR0ZWRJb3IsIGZsb2F0IGluY2lkZW50SW9yICkge1xuXHRcdHJldHVybiBwb3cyKCAoIHRyYW5zbWl0dGVkSW9yIC0gaW5jaWRlbnRJb3IgKSAvICggdHJhbnNtaXR0ZWRJb3IgKyBpbmNpZGVudElvciApKTtcblx0fVxuXHR2ZWMzIGV2YWxTZW5zaXRpdml0eSggZmxvYXQgT1BELCB2ZWMzIHNoaWZ0ICkge1xuXHRcdGZsb2F0IHBoYXNlID0gMi4wICogUEkgKiBPUEQgKiAxLjBlLTk7XG5cdFx0dmVjMyB2YWwgPSB2ZWMzKCA1LjQ4NTZlLTEzLCA0LjQyMDFlLTEzLCA1LjI0ODFlLTEzICk7XG5cdFx0dmVjMyBwb3MgPSB2ZWMzKCAxLjY4MTBlKzA2LCAxLjc5NTNlKzA2LCAyLjIwODRlKzA2ICk7XG5cdFx0dmVjMyB2YXIgPSB2ZWMzKCA0LjMyNzhlKzA5LCA5LjMwNDZlKzA5LCA2LjYxMjFlKzA5ICk7XG5cdFx0dmVjMyB4eXogPSB2YWwgKiBzcXJ0KCAyLjAgKiBQSSAqIHZhciApICogY29zKCBwb3MgKiBwaGFzZSArIHNoaWZ0ICkgKiBleHAoIC0gcG93MiggcGhhc2UgKSAqIHZhciApO1xuXHRcdHh5ei54ICs9IDkuNzQ3MGUtMTQgKiBzcXJ0KCAyLjAgKiBQSSAqIDQuNTI4MmUrMDkgKSAqIGNvcyggMi4yMzk5ZSswNiAqIHBoYXNlICsgc2hpZnRbIDAgXSApICogZXhwKCAtIDQuNTI4MmUrMDkgKiBwb3cyKCBwaGFzZSApICk7XG5cdFx0eHl6IC89IDEuMDY4NWUtNztcblx0XHR2ZWMzIHJnYiA9IFhZWl9UT19SRUM3MDkgKiB4eXo7XG5cdFx0cmV0dXJuIHJnYjtcblx0fVxuXHR2ZWMzIGV2YWxJcmlkZXNjZW5jZSggZmxvYXQgb3V0c2lkZUlPUiwgZmxvYXQgZXRhMiwgZmxvYXQgY29zVGhldGExLCBmbG9hdCB0aGluRmlsbVRoaWNrbmVzcywgdmVjMyBiYXNlRjAgKSB7XG5cdFx0dmVjMyBJO1xuXHRcdGZsb2F0IGlyaWRlc2NlbmNlSU9SID0gbWl4KCBvdXRzaWRlSU9SLCBldGEyLCBzbW9vdGhzdGVwKCAwLjAsIDAuMDMsIHRoaW5GaWxtVGhpY2tuZXNzICkgKTtcblx0XHRmbG9hdCBzaW5UaGV0YTJTcSA9IHBvdzIoIG91dHNpZGVJT1IgLyBpcmlkZXNjZW5jZUlPUiApICogKCAxLjAgLSBwb3cyKCBjb3NUaGV0YTEgKSApO1xuXHRcdGZsb2F0IGNvc1RoZXRhMlNxID0gMS4wIC0gc2luVGhldGEyU3E7XG5cdFx0aWYgKCBjb3NUaGV0YTJTcSA8IDAuMCApIHtcblx0XHRcdCByZXR1cm4gdmVjMyggMS4wICk7XG5cdFx0fVxuXHRcdGZsb2F0IGNvc1RoZXRhMiA9IHNxcnQoIGNvc1RoZXRhMlNxICk7XG5cdFx0ZmxvYXQgUjAgPSBJb3JUb0ZyZXNuZWwwKCBpcmlkZXNjZW5jZUlPUiwgb3V0c2lkZUlPUiApO1xuXHRcdGZsb2F0IFIxMiA9IEZfU2NobGljayggUjAsIDEuMCwgY29zVGhldGExICk7XG5cdFx0ZmxvYXQgUjIxID0gUjEyO1xuXHRcdGZsb2F0IFQxMjEgPSAxLjAgLSBSMTI7XG5cdFx0ZmxvYXQgcGhpMTIgPSAwLjA7XG5cdFx0aWYgKCBpcmlkZXNjZW5jZUlPUiA8IG91dHNpZGVJT1IgKSBwaGkxMiA9IFBJO1xuXHRcdGZsb2F0IHBoaTIxID0gUEkgLSBwaGkxMjtcblx0XHR2ZWMzIGJhc2VJT1IgPSBGcmVzbmVsMFRvSW9yKCBjbGFtcCggYmFzZUYwLCAwLjAsIDAuOTk5OSApICk7XHRcdHZlYzMgUjEgPSBJb3JUb0ZyZXNuZWwwKCBiYXNlSU9SLCBpcmlkZXNjZW5jZUlPUiApO1xuXHRcdHZlYzMgUjIzID0gRl9TY2hsaWNrKCBSMSwgMS4wLCBjb3NUaGV0YTIgKTtcblx0XHR2ZWMzIHBoaTIzID0gdmVjMyggMC4wICk7XG5cdFx0aWYgKCBiYXNlSU9SWyAwIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAwIF0gPSBQSTtcblx0XHRpZiAoIGJhc2VJT1JbIDEgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDEgXSA9IFBJO1xuXHRcdGlmICggYmFzZUlPUlsgMiBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMiBdID0gUEk7XG5cdFx0ZmxvYXQgT1BEID0gMi4wICogaXJpZGVzY2VuY2VJT1IgKiB0aGluRmlsbVRoaWNrbmVzcyAqIGNvc1RoZXRhMjtcblx0XHR2ZWMzIHBoaSA9IHZlYzMoIHBoaTIxICkgKyBwaGkyMztcblx0XHR2ZWMzIFIxMjMgPSBjbGFtcCggUjEyICogUjIzLCAxZS01LCAwLjk5OTkgKTtcblx0XHR2ZWMzIHIxMjMgPSBzcXJ0KCBSMTIzICk7XG5cdFx0dmVjMyBScyA9IHBvdzIoIFQxMjEgKSAqIFIyMyAvICggdmVjMyggMS4wICkgLSBSMTIzICk7XG5cdFx0dmVjMyBDMCA9IFIxMiArIFJzO1xuXHRcdEkgPSBDMDtcblx0XHR2ZWMzIENtID0gUnMgLSBUMTIxO1xuXHRcdGZvciAoIGludCBtID0gMTsgbSA8PSAyOyArKyBtICkge1xuXHRcdFx0Q20gKj0gcjEyMztcblx0XHRcdHZlYzMgU20gPSAyLjAgKiBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0KCBtICkgKiBPUEQsIGZsb2F0KCBtICkgKiBwaGkgKTtcblx0XHRcdEkgKz0gQ20gKiBTbTtcblx0XHR9XG5cdFx0cmV0dXJuIG1heCggSSwgdmVjMyggMC4wICkgKTtcblx0fVxuI2VuZGlmYCwgZ2EgPSBgI2lmZGVmIFVTRV9CVU1QTUFQXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XG5cdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xuXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcblx0XHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XG5cdFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcblx0XHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcblx0XHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcblx0XHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcblx0fVxuXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5LCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xuXHRcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zLnh5eiApO1xuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zLnh5eiApO1xuXHRcdHZlYzMgdk4gPSBzdXJmX25vcm07XG5cdFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xuXHRcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcblx0XHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApICogZmFjZURpcmVjdGlvbjtcblx0XHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcblx0XHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XG5cdH1cbiNlbmRpZmAsIF9hID0gYCNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxuXHR2ZWM0IHBsYW5lO1xuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdGZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcblx0XHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XG5cdFx0aWYgKCBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApIGRpc2NhcmQ7XG5cdH1cblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcblx0I2lmIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyA8IE5VTV9DTElQUElOR19QTEFORVNcblx0XHRib29sIGNsaXBwZWQgPSB0cnVlO1xuXHRcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcblx0XHRmb3IgKCBpbnQgaSA9IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSA8IE5VTV9DTElQUElOR19QTEFORVM7IGkgKysgKSB7XG5cdFx0XHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XG5cdFx0XHRjbGlwcGVkID0gKCBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApICYmIGNsaXBwZWQ7XG5cdFx0fVxuXHRcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXG5cdFx0aWYgKCBjbGlwcGVkICkgZGlzY2FyZDtcblx0I2VuZGlmXG4jZW5kaWZgLCB2YSA9IGAjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcblx0dmFyeWluZyB2ZWMzIHZDbGlwUG9zaXRpb247XG5cdHVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdO1xuI2VuZGlmYCwgeGEgPSBgI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXG5cdHZhcnlpbmcgdmVjMyB2Q2xpcFBvc2l0aW9uO1xuI2VuZGlmYCwgeWEgPSBgI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXG5cdHZDbGlwUG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xuI2VuZGlmYCwgYmEgPSBgI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXG5cdGRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7XG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKVxuXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcbiNlbmRpZmAsIHdhID0gYCNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxuXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcbiNlbmRpZmAsIE1hID0gYCNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxuXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0lOU1RBTkNJTkdfQ09MT1IgKVxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xuI2VuZGlmYCwgU2EgPSBgI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXG5cdHZDb2xvciA9IHZlYzQoIDEuMCApO1xuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0lOU1RBTkNJTkdfQ09MT1IgKVxuXHR2Q29sb3IgPSB2ZWMzKCAxLjAgKTtcbiNlbmRpZlxuI2lmZGVmIFVTRV9DT0xPUlxuXHR2Q29sb3IgKj0gY29sb3I7XG4jZW5kaWZcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUlxuXHR2Q29sb3IueHl6ICo9IGluc3RhbmNlQ29sb3IueHl6O1xuI2VuZGlmYCwgRWEgPSBgI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5M1xuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxNzk1ODZcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjZcbiNkZWZpbmUgUkVDSVBST0NBTF9QSSAwLjMxODMwOTg4NjE4Mzc5MDdcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NDMwOTE4OTUzNVxuI2RlZmluZSBFUFNJTE9OIDFlLTZcbiNpZm5kZWYgc2F0dXJhdGVcbiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxuI2VuZGlmXG4jZGVmaW5lIHdoaXRlQ29tcGxlbWVudCggYSApICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XG52ZWMzIHBvdzIoIGNvbnN0IGluIHZlYzMgeCApIHsgcmV0dXJuIHgqeDsgfVxuZmxvYXQgcG93MyggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeCp4OyB9XG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XG5mbG9hdCBtYXgzKCBjb25zdCBpbiB2ZWMzIHYgKSB7IHJldHVybiBtYXgoIG1heCggdi54LCB2LnkgKSwgdi56ICk7IH1cbmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgdiApIHsgcmV0dXJuIGRvdCggdiwgdmVjMyggMC4zMzMzMzMzICkgKTsgfVxuaGlnaHAgZmxvYXQgcmFuZCggY29uc3QgaW4gdmVjMiB1diApIHtcblx0Y29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xuXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcblx0cmV0dXJuIGZyYWN0KCBzaW4oIHNuICkgKiBjICk7XG59XG4jaWZkZWYgSElHSF9QUkVDSVNJT05cblx0ZmxvYXQgcHJlY2lzaW9uU2FmZUxlbmd0aCggdmVjMyB2ICkgeyByZXR1cm4gbGVuZ3RoKCB2ICk7IH1cbiNlbHNlXG5cdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHtcblx0XHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgzKCBhYnMoIHYgKSApO1xuXHRcdHJldHVybiBsZW5ndGgoIHYgLyBtYXhDb21wb25lbnQgKSAqIG1heENvbXBvbmVudDtcblx0fVxuI2VuZGlmXG5zdHJ1Y3QgSW5jaWRlbnRMaWdodCB7XG5cdHZlYzMgY29sb3I7XG5cdHZlYzMgZGlyZWN0aW9uO1xuXHRib29sIHZpc2libGU7XG59O1xuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcblx0dmVjMyBkaXJlY3REaWZmdXNlO1xuXHR2ZWMzIGRpcmVjdFNwZWN1bGFyO1xuXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcblx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xufTtcbnN0cnVjdCBHZW9tZXRyaWNDb250ZXh0IHtcblx0dmVjMyBwb3NpdGlvbjtcblx0dmVjMyBub3JtYWw7XG5cdHZlYzMgdmlld0RpcjtcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUXG5cdHZlYzMgY2xlYXJjb2F0Tm9ybWFsO1xuI2VuZGlmXG59O1xudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcblx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XG59XG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcblx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7XG59XG5tYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHtcblx0bWF0MyB0bXA7XG5cdHRtcFsgMCBdID0gdmVjMyggbVsgMCBdLngsIG1bIDEgXS54LCBtWyAyIF0ueCApO1xuXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcblx0dG1wWyAyIF0gPSB2ZWMzKCBtWyAwIF0ueiwgbVsgMSBdLnosIG1bIDIgXS56ICk7XG5cdHJldHVybiB0bXA7XG59XG5mbG9hdCBsdW1pbmFuY2UoIGNvbnN0IGluIHZlYzMgcmdiICkge1xuXHRjb25zdCB2ZWMzIHdlaWdodHMgPSB2ZWMzKCAwLjIxMjY3MjksIDAuNzE1MTUyMiwgMC4wNzIxNzUwICk7XG5cdHJldHVybiBkb3QoIHdlaWdodHMsIHJnYiApO1xufVxuYm9vbCBpc1BlcnNwZWN0aXZlTWF0cml4KCBtYXQ0IG0gKSB7XG5cdHJldHVybiBtWyAyIF1bIDMgXSA9PSAtIDEuMDtcbn1cbnZlYzIgZXF1aXJlY3RVdiggaW4gdmVjMyBkaXIgKSB7XG5cdGZsb2F0IHUgPSBhdGFuKCBkaXIueiwgZGlyLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xuXHRmbG9hdCB2ID0gYXNpbiggY2xhbXAoIGRpci55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7XG5cdHJldHVybiB2ZWMyKCB1LCB2ICk7XG59YCwgVGEgPSBgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcblx0I2RlZmluZSBjdWJlVVZfbWluTWlwTGV2ZWwgNC4wXG5cdCNkZWZpbmUgY3ViZVVWX21pblRpbGVTaXplIDE2LjBcblx0ZmxvYXQgZ2V0RmFjZSggdmVjMyBkaXJlY3Rpb24gKSB7XG5cdFx0dmVjMyBhYnNEaXJlY3Rpb24gPSBhYnMoIGRpcmVjdGlvbiApO1xuXHRcdGZsb2F0IGZhY2UgPSAtIDEuMDtcblx0XHRpZiAoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnogKSB7XG5cdFx0XHRpZiAoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnkgKVxuXHRcdFx0XHRmYWNlID0gZGlyZWN0aW9uLnggPiAwLjAgPyAwLjAgOiAzLjA7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEuMCA6IDQuMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBhYnNEaXJlY3Rpb24ueiA+IGFic0RpcmVjdGlvbi55IClcblx0XHRcdFx0ZmFjZSA9IGRpcmVjdGlvbi56ID4gMC4wID8gMi4wIDogNS4wO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7XG5cdFx0fVxuXHRcdHJldHVybiBmYWNlO1xuXHR9XG5cdHZlYzIgZ2V0VVYoIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBmYWNlICkge1xuXHRcdHZlYzIgdXY7XG5cdFx0aWYgKCBmYWNlID09IDAuMCApIHtcblx0XHRcdHV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7XG5cdFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XG5cdFx0XHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIC0gZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTtcblx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHtcblx0XHRcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTtcblx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcblx0XHRcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTtcblx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcblx0XHRcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dXYgPSB2ZWMyKCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICggdXYgKyAxLjAgKTtcblx0fVxuXHR2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkge1xuXHRcdGZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTtcblx0XHRmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7XG5cdFx0bWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApO1xuXHRcdGZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7XG5cdFx0dmVjMiB1diA9IGdldFVWKCBkaXJlY3Rpb24sIGZhY2UgKSAqICggZmFjZVNpemUgLSAyLjAgKSArIDEuMDtcblx0XHRpZiAoIGZhY2UgPiAyLjAgKSB7XG5cdFx0XHR1di55ICs9IGZhY2VTaXplO1xuXHRcdFx0ZmFjZSAtPSAzLjA7XG5cdFx0fVxuXHRcdHV2LnggKz0gZmFjZSAqIGZhY2VTaXplO1xuXHRcdHV2LnggKz0gZmlsdGVySW50ICogMy4wICogY3ViZVVWX21pblRpbGVTaXplO1xuXHRcdHV2LnkgKz0gNC4wICogKCBleHAyKCBDVUJFVVZfTUFYX01JUCApIC0gZmFjZVNpemUgKTtcblx0XHR1di54ICo9IENVQkVVVl9URVhFTF9XSURUSDtcblx0XHR1di55ICo9IENVQkVVVl9URVhFTF9IRUlHSFQ7XG5cdFx0I2lmZGVmIHRleHR1cmUyREdyYWRFWFRcblx0XHRcdHJldHVybiB0ZXh0dXJlMkRHcmFkRVhUKCBlbnZNYXAsIHV2LCB2ZWMyKCAwLjAgKSwgdmVjMiggMC4wICkgKS5yZ2I7XG5cdFx0I2Vsc2Vcblx0XHRcdHJldHVybiB0ZXh0dXJlMkQoIGVudk1hcCwgdXYgKS5yZ2I7XG5cdFx0I2VuZGlmXG5cdH1cblx0I2RlZmluZSByMCAxLjBcblx0I2RlZmluZSB2MCAwLjMzOVxuXHQjZGVmaW5lIG0wIC0gMi4wXG5cdCNkZWZpbmUgcjEgMC44XG5cdCNkZWZpbmUgdjEgMC4yNzZcblx0I2RlZmluZSBtMSAtIDEuMFxuXHQjZGVmaW5lIHI0IDAuNFxuXHQjZGVmaW5lIHY0IDAuMDQ2XG5cdCNkZWZpbmUgbTQgMi4wXG5cdCNkZWZpbmUgcjUgMC4zMDVcblx0I2RlZmluZSB2NSAwLjAxNlxuXHQjZGVmaW5lIG01IDMuMFxuXHQjZGVmaW5lIHI2IDAuMjFcblx0I2RlZmluZSB2NiAwLjAwMzhcblx0I2RlZmluZSBtNiA0LjBcblx0ZmxvYXQgcm91Z2huZXNzVG9NaXAoIGZsb2F0IHJvdWdobmVzcyApIHtcblx0XHRmbG9hdCBtaXAgPSAwLjA7XG5cdFx0aWYgKCByb3VnaG5lc3MgPj0gcjEgKSB7XG5cdFx0XHRtaXAgPSAoIHIwIC0gcm91Z2huZXNzICkgKiAoIG0xIC0gbTAgKSAvICggcjAgLSByMSApICsgbTA7XG5cdFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IHI0ICkge1xuXHRcdFx0bWlwID0gKCByMSAtIHJvdWdobmVzcyApICogKCBtNCAtIG0xICkgLyAoIHIxIC0gcjQgKSArIG0xO1xuXHRcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSByNSApIHtcblx0XHRcdG1pcCA9ICggcjQgLSByb3VnaG5lc3MgKSAqICggbTUgLSBtNCApIC8gKCByNCAtIHI1ICkgKyBtNDtcblx0XHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gcjYgKSB7XG5cdFx0XHRtaXAgPSAoIHI1IC0gcm91Z2huZXNzICkgKiAoIG02IC0gbTUgKSAvICggcjUgLSByNiApICsgbTU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pcCA9IC0gMi4wICogbG9nMiggMS4xNiAqIHJvdWdobmVzcyApO1x0XHR9XG5cdFx0cmV0dXJuIG1pcDtcblx0fVxuXHR2ZWM0IHRleHR1cmVDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgc2FtcGxlRGlyLCBmbG9hdCByb3VnaG5lc3MgKSB7XG5cdFx0ZmxvYXQgbWlwID0gY2xhbXAoIHJvdWdobmVzc1RvTWlwKCByb3VnaG5lc3MgKSwgbTAsIENVQkVVVl9NQVhfTUlQICk7XG5cdFx0ZmxvYXQgbWlwRiA9IGZyYWN0KCBtaXAgKTtcblx0XHRmbG9hdCBtaXBJbnQgPSBmbG9vciggbWlwICk7XG5cdFx0dmVjMyBjb2xvcjAgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCApO1xuXHRcdGlmICggbWlwRiA9PSAwLjAgKSB7XG5cdFx0XHRyZXR1cm4gdmVjNCggY29sb3IwLCAxLjAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmVjMyBjb2xvcjEgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCArIDEuMCApO1xuXHRcdFx0cmV0dXJuIHZlYzQoIG1peCggY29sb3IwLCBjb2xvcjEsIG1pcEYgKSwgMS4wICk7XG5cdFx0fVxuXHR9XG4jZW5kaWZgLCBBYSA9IGB2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gb2JqZWN0Tm9ybWFsO1xuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXG5cdG1hdDMgbSA9IG1hdDMoIGluc3RhbmNlTWF0cml4ICk7XG5cdHRyYW5zZm9ybWVkTm9ybWFsIC89IHZlYzMoIGRvdCggbVsgMCBdLCBtWyAwIF0gKSwgZG90KCBtWyAxIF0sIG1bIDEgXSApLCBkb3QoIG1bIDIgXSwgbVsgMiBdICkgKTtcblx0dHJhbnNmb3JtZWROb3JtYWwgPSBtICogdHJhbnNmb3JtZWROb3JtYWw7XG4jZW5kaWZcbnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogdHJhbnNmb3JtZWROb3JtYWw7XG4jaWZkZWYgRkxJUF9TSURFRFxuXHR0cmFuc2Zvcm1lZE5vcm1hbCA9IC0gdHJhbnNmb3JtZWROb3JtYWw7XG4jZW5kaWZcbiNpZmRlZiBVU0VfVEFOR0VOVFxuXHR2ZWMzIHRyYW5zZm9ybWVkVGFuZ2VudCA9ICggbW9kZWxWaWV3TWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7XG5cdCNpZmRlZiBGTElQX1NJREVEXG5cdFx0dHJhbnNmb3JtZWRUYW5nZW50ID0gLSB0cmFuc2Zvcm1lZFRhbmdlbnQ7XG5cdCNlbmRpZlxuI2VuZGlmYCwgQ2EgPSBgI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcblx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XG4jZW5kaWZgLCBMYSA9IGAjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxuXHR0cmFuc2Zvcm1lZCArPSBub3JtYWxpemUoIG9iamVjdE5vcm1hbCApICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdlV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xuI2VuZGlmYCwgUmEgPSBgI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxuXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcblx0dG90YWxFbWlzc2l2ZVJhZGlhbmNlICo9IGVtaXNzaXZlQ29sb3IucmdiO1xuI2VuZGlmYCwgRmEgPSBgI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcbiNlbmRpZmAsIERhID0gXCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcIiwgUGEgPSBgdmVjNCBMaW5lYXJUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcblx0cmV0dXJuIHZhbHVlO1xufVxudmVjNCBMaW5lYXJUb3NSR0IoIGluIHZlYzQgdmFsdWUgKSB7XG5cdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLmEgKTtcbn1gLCBJYSA9IGAjaWZkZWYgVVNFX0VOVk1BUFxuXHQjaWZkZWYgRU5WX1dPUkxEUE9TXG5cdFx0dmVjMyBjYW1lcmFUb0ZyYWc7XG5cdFx0aWYgKCBpc09ydGhvZ3JhcGhpYyApIHtcblx0XHRcdGNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xuXHRcdH1cblx0XHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XG5cdFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwgKTtcblx0XHQjZWxzZVxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XG5cdFx0I2VuZGlmXG5cdCNlbHNlXG5cdFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XG5cdCNlbmRpZlxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgcmVmbGVjdFZlYywgMC4wICk7XG5cdCNlbHNlXG5cdFx0dmVjNCBlbnZDb2xvciA9IHZlYzQoIDAuMCApO1xuXHQjZW5kaWZcblx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXG5cdFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxuXHRcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcblx0I2VuZGlmXG4jZW5kaWZgLCB6YSA9IGAjaWZkZWYgVVNFX0VOVk1BUFxuXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuXHRcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xuXHQjZWxzZVxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcblx0I2VuZGlmXG5cdFxuI2VuZGlmYCwgQmEgPSBgI2lmZGVmIFVTRV9FTlZNQVBcblx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXG5cdFx0I2RlZmluZSBFTlZfV09STERQT1Ncblx0I2VuZGlmXG5cdCNpZmRlZiBFTlZfV09STERQT1Ncblx0XHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG5cdFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XG5cdCNlbHNlXG5cdFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xuXHQjZW5kaWZcbiNlbmRpZmAsIE5hID0gYCNpZmRlZiBVU0VfRU5WTUFQXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fGRlZmluZWQoIFBIT05HIClcblx0XHQjZGVmaW5lIEVOVl9XT1JMRFBPU1xuXHQjZW5kaWZcblx0I2lmZGVmIEVOVl9XT1JMRFBPU1xuXHRcdFxuXHRcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcblx0I2Vsc2Vcblx0XHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XG5cdFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XG5cdCNlbmRpZlxuI2VuZGlmYCwgT2EgPSBgI2lmZGVmIFVTRV9FTlZNQVBcblx0I2lmZGVmIEVOVl9XT1JMRFBPU1xuXHRcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XG5cdCNlbHNlXG5cdFx0dmVjMyBjYW1lcmFUb1ZlcnRleDtcblx0XHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xuXHRcdFx0Y2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xuXHRcdH1cblx0XHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcblx0XHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxuXHRcdFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcblx0XHQjZWxzZVxuXHRcdFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xuXHRcdCNlbmRpZlxuXHQjZW5kaWZcbiNlbmRpZmAsIFVhID0gYCNpZmRlZiBVU0VfRk9HXG5cdHZGb2dEZXB0aCA9IC0gbXZQb3NpdGlvbi56O1xuI2VuZGlmYCwgR2EgPSBgI2lmZGVmIFVTRV9GT0dcblx0dmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7XG4jZW5kaWZgLCBrYSA9IGAjaWZkZWYgVVNFX0ZPR1xuXHQjaWZkZWYgRk9HX0VYUDJcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSAxLjAgLSBleHAoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiB2Rm9nRGVwdGggKiB2Rm9nRGVwdGggKTtcblx0I2Vsc2Vcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIHZGb2dEZXB0aCApO1xuXHQjZW5kaWZcblx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xuI2VuZGlmYCwgV2EgPSBgI2lmZGVmIFVTRV9GT0dcblx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xuXHR2YXJ5aW5nIGZsb2F0IHZGb2dEZXB0aDtcblx0I2lmZGVmIEZPR19FWFAyXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xuXHQjZWxzZVxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0Zhcjtcblx0I2VuZGlmXG4jZW5kaWZgLCBWYSA9IGAjaWZkZWYgVVNFX0dSQURJRU5UTUFQXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGdyYWRpZW50TWFwO1xuI2VuZGlmXG52ZWMzIGdldEdyYWRpZW50SXJyYWRpYW5jZSggdmVjMyBub3JtYWwsIHZlYzMgbGlnaHREaXJlY3Rpb24gKSB7XG5cdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7XG5cdHZlYzIgY29vcmQgPSB2ZWMyKCBkb3ROTCAqIDAuNSArIDAuNSwgMC4wICk7XG5cdCNpZmRlZiBVU0VfR1JBRElFTlRNQVBcblx0XHRyZXR1cm4gdmVjMyggdGV4dHVyZTJEKCBncmFkaWVudE1hcCwgY29vcmQgKS5yICk7XG5cdCNlbHNlXG5cdFx0cmV0dXJuICggY29vcmQueCA8IDAuNyApID8gdmVjMyggMC43ICkgOiB2ZWMzKCAxLjAgKTtcblx0I2VuZGlmXG59YCwgSGEgPSBgI2lmZGVmIFVTRV9MSUdIVE1BUFxuXHR2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XG5cdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gbGlnaHRNYXBUZXhlbC5yZ2IgKiBsaWdodE1hcEludGVuc2l0eTtcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTtcbiNlbmRpZmAsIHFhID0gYCNpZmRlZiBVU0VfTElHSFRNQVBcblx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XG5cdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XG4jZW5kaWZgLCBYYSA9IGB2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcbkdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnk7XG5nZW9tZXRyeS5wb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xuZ2VvbWV0cnkudmlld0RpciA9ICggaXNPcnRob2dyYXBoaWMgKSA/IHZlYzMoIDAsIDAsIDEgKSA6IG5vcm1hbGl6ZSggLW12UG9zaXRpb24ueHl6ICk7XG5HZW9tZXRyaWNDb250ZXh0IGJhY2tHZW9tZXRyeTtcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xuYmFja0dlb21ldHJ5Lm5vcm1hbCA9IC1nZW9tZXRyeS5ub3JtYWw7XG5iYWNrR2VvbWV0cnkudmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xudkluZGlyZWN0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcbiNpZmRlZiBET1VCTEVfU0lERURcblx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xuXHR2SW5kaXJlY3RCYWNrID0gdmVjMyggMC4wICk7XG4jZW5kaWZcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XG5mbG9hdCBkb3ROTDtcbnZlYzMgZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xudkluZGlyZWN0RnJvbnQgKz0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcbnZJbmRpcmVjdEZyb250ICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBnZW9tZXRyeS5ub3JtYWwgKTtcbiNpZmRlZiBET1VCTEVfU0lERURcblx0dkluZGlyZWN0QmFjayArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xuXHR2SW5kaXJlY3RCYWNrICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBiYWNrR2VvbWV0cnkubm9ybWFsICk7XG4jZW5kaWZcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XG5cdFx0Z2V0UG9pbnRMaWdodEluZm8oIHBvaW50TGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xuXHRcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xuXHRcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IGRpcmVjdExpZ2h0LmNvbG9yO1xuXHRcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcblx0XHRcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC0gZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcblx0XHQjZW5kaWZcblx0fVxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuI2VuZGlmXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcblx0XHRnZXRTcG90TGlnaHRJbmZvKCBzcG90TGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xuXHRcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xuXHRcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IGRpcmVjdExpZ2h0LmNvbG9yO1xuXHRcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcblx0XHRcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC0gZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcblx0XHQjZW5kaWZcblx0fVxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuI2VuZGlmXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XG5cdFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xuXHRcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xuXHRcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IGRpcmVjdExpZ2h0LmNvbG9yO1xuXHRcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcblx0XHRcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC0gZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcblx0XHQjZW5kaWZcblx0fVxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuI2VuZGlmXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcblx0XHR2SW5kaXJlY3RGcm9udCArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Lm5vcm1hbCApO1xuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcblx0XHRcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBiYWNrR2VvbWV0cnkubm9ybWFsICk7XG5cdFx0I2VuZGlmXG5cdH1cblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcbiNlbmRpZmAsIGphID0gYHVuaWZvcm0gYm9vbCByZWNlaXZlU2hhZG93O1xudW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xudW5pZm9ybSB2ZWMzIGxpZ2h0UHJvYmVbIDkgXTtcbnZlYzMgc2hHZXRJcnJhZGlhbmNlQXQoIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWMzIHNoQ29lZmZpY2llbnRzWyA5IF0gKSB7XG5cdGZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XG5cdHZlYzMgcmVzdWx0ID0gc2hDb2VmZmljaWVudHNbIDAgXSAqIDAuODg2MjI3O1xuXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDEgXSAqIDIuMCAqIDAuNTExNjY0ICogeTtcblx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAyIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHo7XG5cdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMyBdICogMi4wICogMC41MTE2NjQgKiB4O1xuXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDQgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHk7XG5cdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejtcblx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA2IF0gKiAoIDAuNzQzMTI1ICogeiAqIHogLSAwLjI0NzcwOCApO1xuXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDcgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHo7XG5cdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cbnZlYzMgZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbGlnaHRQcm9iZVsgOSBdLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcblx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xuXHR2ZWMzIGlycmFkaWFuY2UgPSBzaEdldElycmFkaWFuY2VBdCggd29ybGROb3JtYWwsIGxpZ2h0UHJvYmUgKTtcblx0cmV0dXJuIGlycmFkaWFuY2U7XG59XG52ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7XG5cdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xuXHRyZXR1cm4gaXJyYWRpYW5jZTtcbn1cbmZsb2F0IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xuXHQjaWYgZGVmaW5lZCAoIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMgKVxuXHRcdGZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTtcblx0XHRpZiAoIGN1dG9mZkRpc3RhbmNlID4gMC4wICkge1xuXHRcdFx0ZGlzdGFuY2VGYWxsb2ZmICo9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7XG5cdFx0fVxuXHRcdHJldHVybiBkaXN0YW5jZUZhbGxvZmY7XG5cdCNlbHNlXG5cdFx0aWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCAmJiBkZWNheUV4cG9uZW50ID4gMC4wICkge1xuXHRcdFx0cmV0dXJuIHBvdyggc2F0dXJhdGUoIC0gbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIDEuMDtcblx0I2VuZGlmXG59XG5mbG9hdCBnZXRTcG90QXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGNvbmVDb3NpbmUsIGNvbnN0IGluIGZsb2F0IHBlbnVtYnJhQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBhbmdsZUNvc2luZSApIHtcblx0cmV0dXJuIHNtb290aHN0ZXAoIGNvbmVDb3NpbmUsIHBlbnVtYnJhQ29zaW5lLCBhbmdsZUNvc2luZSApO1xufVxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxuXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XG5cdFx0dmVjMyBkaXJlY3Rpb247XG5cdFx0dmVjMyBjb2xvcjtcblx0fTtcblx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdO1xuXHR2b2lkIGdldERpcmVjdGlvbmFsTGlnaHRJbmZvKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xuXHRcdGxpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcblx0XHRsaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcblx0XHRsaWdodC52aXNpYmxlID0gdHJ1ZTtcblx0fVxuI2VuZGlmXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcblx0c3RydWN0IFBvaW50TGlnaHQge1xuXHRcdHZlYzMgcG9zaXRpb247XG5cdFx0dmVjMyBjb2xvcjtcblx0XHRmbG9hdCBkaXN0YW5jZTtcblx0XHRmbG9hdCBkZWNheTtcblx0fTtcblx0dW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07XG5cdHZvaWQgZ2V0UG9pbnRMaWdodEluZm8oIGNvbnN0IGluIFBvaW50TGlnaHQgcG9pbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7XG5cdFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xuXHRcdGxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xuXHRcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcblx0XHRsaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7XG5cdFx0bGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xuXHRcdGxpZ2h0LnZpc2libGUgPSAoIGxpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7XG5cdH1cbiNlbmRpZlxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcblx0c3RydWN0IFNwb3RMaWdodCB7XG5cdFx0dmVjMyBwb3NpdGlvbjtcblx0XHR2ZWMzIGRpcmVjdGlvbjtcblx0XHR2ZWMzIGNvbG9yO1xuXHRcdGZsb2F0IGRpc3RhbmNlO1xuXHRcdGZsb2F0IGRlY2F5O1xuXHRcdGZsb2F0IGNvbmVDb3M7XG5cdFx0ZmxvYXQgcGVudW1icmFDb3M7XG5cdH07XG5cdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xuXHR2b2lkIGdldFNwb3RMaWdodEluZm8oIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xuXHRcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xuXHRcdGxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xuXHRcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBsaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcblx0XHRmbG9hdCBzcG90QXR0ZW51YXRpb24gPSBnZXRTcG90QXR0ZW51YXRpb24oIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XG5cdFx0aWYgKCBzcG90QXR0ZW51YXRpb24gPiAwLjAgKSB7XG5cdFx0XHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XG5cdFx0XHRsaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvciAqIHNwb3RBdHRlbnVhdGlvbjtcblx0XHRcdGxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7XG5cdFx0XHRsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xuXHRcdFx0bGlnaHQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuI2VuZGlmXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXG5cdHN0cnVjdCBSZWN0QXJlYUxpZ2h0IHtcblx0XHR2ZWMzIGNvbG9yO1xuXHRcdHZlYzMgcG9zaXRpb247XG5cdFx0dmVjMyBoYWxmV2lkdGg7XG5cdFx0dmVjMyBoYWxmSGVpZ2h0O1xuXHR9O1xuXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMTtcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y18yO1xuXHR1bmlmb3JtIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodHNbIE5VTV9SRUNUX0FSRUFfTElHSFRTIF07XG4jZW5kaWZcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXG5cdHN0cnVjdCBIZW1pc3BoZXJlTGlnaHQge1xuXHRcdHZlYzMgZGlyZWN0aW9uO1xuXHRcdHZlYzMgc2t5Q29sb3I7XG5cdFx0dmVjMyBncm91bmRDb2xvcjtcblx0fTtcblx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XG5cdHZlYzMgZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gSGVtaXNwaGVyZUxpZ2h0IGhlbWlMaWdodCwgY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XG5cdFx0ZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApO1xuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XG5cdFx0dmVjMyBpcnJhZGlhbmNlID0gbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcblx0XHRyZXR1cm4gaXJyYWRpYW5jZTtcblx0fVxuI2VuZGlmYCwgWWEgPSBgI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKVxuXHR2ZWMzIGdldElCTElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xuXHRcdCNpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcblx0XHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcblx0XHRcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIHdvcmxkTm9ybWFsLCAxLjAgKTtcblx0XHRcdHJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcblx0XHQjZWxzZVxuXHRcdFx0cmV0dXJuIHZlYzMoIDAuMCApO1xuXHRcdCNlbmRpZlxuXHR9XG5cdHZlYzMgZ2V0SUJMUmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcblx0XHQjaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCAtIHZpZXdEaXIsIG5vcm1hbCApO1xuXHRcdFx0cmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggbWl4KCByZWZsZWN0VmVjLCBub3JtYWwsIHJvdWdobmVzcyAqIHJvdWdobmVzcykgKTtcblx0XHRcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XG5cdFx0XHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCByZWZsZWN0VmVjLCByb3VnaG5lc3MgKTtcblx0XHRcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XG5cdFx0I2Vsc2Vcblx0XHRcdHJldHVybiB2ZWMzKCAwLjAgKTtcblx0XHQjZW5kaWZcblx0fVxuI2VuZGlmYCwgWmEgPSBgVG9vbk1hdGVyaWFsIG1hdGVyaWFsO1xubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtgLCAkYSA9IGB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcbnN0cnVjdCBUb29uTWF0ZXJpYWwge1xuXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcbn07XG52b2lkIFJFX0RpcmVjdF9Ub29uKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xuXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcblx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcbn1cbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1Rvb24oIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xufVxuI2RlZmluZSBSRV9EaXJlY3RcdFx0XHRcdFJFX0RpcmVjdF9Ub29uXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVx0XHRSRV9JbmRpcmVjdERpZmZ1c2VfVG9vblxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXHQoMClgLCBLYSA9IGBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7XG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xubWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7XG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtgLCBKYSA9IGB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcbnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwge1xuXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcblx0dmVjMyBzcGVjdWxhckNvbG9yO1xuXHRmbG9hdCBzcGVjdWxhclNoaW5pbmVzcztcblx0ZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcbn07XG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xuXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcblx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcblx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcblx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xufVxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XG59XG4jZGVmaW5lIFJFX0RpcmVjdFx0XHRcdFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXHRcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcdCgwKWAsIFFhID0gYFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLjAgLSBtZXRhbG5lc3NGYWN0b3IgKTtcbnZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIGdlb21ldHJ5Tm9ybWFsICkgKSwgYWJzKCBkRmR5KCBnZW9tZXRyeU5vcm1hbCApICkgKTtcbmZsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApO1xubWF0ZXJpYWwucm91Z2huZXNzID0gbWF4KCByb3VnaG5lc3NGYWN0b3IsIDAuMDUyNSApO21hdGVyaWFsLnJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcbm1hdGVyaWFsLnJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwucm91Z2huZXNzLCAxLjAgKTtcbiNpZmRlZiBJT1Jcblx0I2lmZGVmIFNQRUNVTEFSXG5cdFx0ZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSBzcGVjdWxhckludGVuc2l0eTtcblx0XHR2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSBzcGVjdWxhckNvbG9yO1xuXHRcdCNpZmRlZiBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJJbnRlbnNpdHlNYXAsIHZVdiApLmE7XG5cdFx0I2VuZGlmXG5cdFx0I2lmZGVmIFVTRV9TUEVDVUxBUkNPTE9STUFQXG5cdFx0XHRzcGVjdWxhckNvbG9yRmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJDb2xvck1hcCwgdlV2ICkucmdiO1xuXHRcdCNlbmRpZlxuXHRcdG1hdGVyaWFsLnNwZWN1bGFyRjkwID0gbWl4KCBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgMS4wLCBtZXRhbG5lc3NGYWN0b3IgKTtcblx0I2Vsc2Vcblx0XHRmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IDEuMDtcblx0XHR2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSB2ZWMzKCAxLjAgKTtcblx0XHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcblx0I2VuZGlmXG5cdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIG1pbiggcG93MiggKCBpb3IgLSAxLjAgKSAvICggaW9yICsgMS4wICkgKSAqIHNwZWN1bGFyQ29sb3JGYWN0b3IsIHZlYzMoIDEuMCApICkgKiBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XG4jZWxzZVxuXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCAwLjA0ICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xuXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcbiNlbmRpZlxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcblx0bWF0ZXJpYWwuY2xlYXJjb2F0ID0gY2xlYXJjb2F0O1xuXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBjbGVhcmNvYXRSb3VnaG5lc3M7XG5cdG1hdGVyaWFsLmNsZWFyY29hdEYwID0gdmVjMyggMC4wNCApO1xuXHRtYXRlcmlhbC5jbGVhcmNvYXRGOTAgPSAxLjA7XG5cdCNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXG5cdFx0bWF0ZXJpYWwuY2xlYXJjb2F0ICo9IHRleHR1cmUyRCggY2xlYXJjb2F0TWFwLCB2VXYgKS54O1xuXHQjZW5kaWZcblx0I2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQXG5cdFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICo9IHRleHR1cmUyRCggY2xlYXJjb2F0Um91Z2huZXNzTWFwLCB2VXYgKS55O1xuXHQjZW5kaWZcblx0bWF0ZXJpYWwuY2xlYXJjb2F0ID0gc2F0dXJhdGUoIG1hdGVyaWFsLmNsZWFyY29hdCApO1x0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWF4KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDAuMDUyNSApO1xuXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7XG5cdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAxLjAgKTtcbiNlbmRpZlxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxuXHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IGlyaWRlc2NlbmNlO1xuXHRtYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiA9IGlyaWRlc2NlbmNlSU9SO1xuXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQXG5cdFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgKj0gdGV4dHVyZTJEKCBpcmlkZXNjZW5jZU1hcCwgdlV2ICkucjtcblx0I2VuZGlmXG5cdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQXG5cdFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPSAoaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIC0gaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtKSAqIHRleHR1cmUyRCggaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsIHZVdiApLmcgKyBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XG5cdCNlbHNlXG5cdFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPSBpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW07XG5cdCNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgVVNFX1NIRUVOXG5cdG1hdGVyaWFsLnNoZWVuQ29sb3IgPSBzaGVlbkNvbG9yO1xuXHQjaWZkZWYgVVNFX1NIRUVOQ09MT1JNQVBcblx0XHRtYXRlcmlhbC5zaGVlbkNvbG9yICo9IHRleHR1cmUyRCggc2hlZW5Db2xvck1hcCwgdlV2ICkucmdiO1xuXHQjZW5kaWZcblx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgPSBjbGFtcCggc2hlZW5Sb3VnaG5lc3MsIDAuMDcsIDEuMCApO1xuXHQjaWZkZWYgVVNFX1NIRUVOUk9VR0hORVNTTUFQXG5cdFx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBzaGVlblJvdWdobmVzc01hcCwgdlV2ICkuYTtcblx0I2VuZGlmXG4jZW5kaWZgLCBlbCA9IGBzdHJ1Y3QgUGh5c2ljYWxNYXRlcmlhbCB7XG5cdHZlYzMgZGlmZnVzZUNvbG9yO1xuXHRmbG9hdCByb3VnaG5lc3M7XG5cdHZlYzMgc3BlY3VsYXJDb2xvcjtcblx0ZmxvYXQgc3BlY3VsYXJGOTA7XG5cdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXG5cdFx0ZmxvYXQgY2xlYXJjb2F0O1xuXHRcdGZsb2F0IGNsZWFyY29hdFJvdWdobmVzcztcblx0XHR2ZWMzIGNsZWFyY29hdEYwO1xuXHRcdGZsb2F0IGNsZWFyY29hdEY5MDtcblx0I2VuZGlmXG5cdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0Vcblx0XHRmbG9hdCBpcmlkZXNjZW5jZTtcblx0XHRmbG9hdCBpcmlkZXNjZW5jZUlPUjtcblx0XHRmbG9hdCBpcmlkZXNjZW5jZVRoaWNrbmVzcztcblx0XHR2ZWMzIGlyaWRlc2NlbmNlRnJlc25lbDtcblx0XHR2ZWMzIGlyaWRlc2NlbmNlRjA7XG5cdCNlbmRpZlxuXHQjaWZkZWYgVVNFX1NIRUVOXG5cdFx0dmVjMyBzaGVlbkNvbG9yO1xuXHRcdGZsb2F0IHNoZWVuUm91Z2huZXNzO1xuXHQjZW5kaWZcbn07XG52ZWMzIGNsZWFyY29hdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XG52ZWMzIHNoZWVuU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcbmZsb2F0IElCTFNoZWVuQlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzKSB7XG5cdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcblx0ZmxvYXQgcjIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XG5cdGZsb2F0IGEgPSByb3VnaG5lc3MgPCAwLjI1ID8gLTMzOS4yICogcjIgKyAxNjEuNCAqIHJvdWdobmVzcyAtIDI1LjkgOiAtOC40OCAqIHIyICsgMTQuMyAqIHJvdWdobmVzcyAtIDkuOTU7XG5cdGZsb2F0IGIgPSByb3VnaG5lc3MgPCAwLjI1ID8gNDQuMCAqIHIyIC0gMjMuNyAqIHJvdWdobmVzcyArIDMuMjYgOiAxLjk3ICogcjIgLSAzLjI3ICogcm91Z2huZXNzICsgMC43Mjtcblx0ZmxvYXQgREcgPSBleHAoIGEgKiBkb3ROViArIGIgKSArICggcm91Z2huZXNzIDwgMC4yNSA/IDAuMCA6IDAuMSAqICggcm91Z2huZXNzIC0gMC4yNSApICk7XG5cdHJldHVybiBzYXR1cmF0ZSggREcgKiBSRUNJUFJPQ0FMX1BJICk7XG59XG52ZWMyIERGR0FwcHJveCggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xuXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XG5cdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xuXHRjb25zdCB2ZWM0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcblx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcblx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XG5cdHZlYzIgZmFiID0gdmVjMiggLSAxLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcblx0cmV0dXJuIGZhYjtcbn1cbnZlYzMgRW52aXJvbm1lbnRCUkRGKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XG5cdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xuXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcbn1cbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcbnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZ0lyaWRlc2NlbmNlKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCBpcmlkZXNjZW5jZSwgY29uc3QgaW4gdmVjMyBpcmlkZXNjZW5jZUYwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7XG4jZWxzZVxudm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7XG4jZW5kaWZcblx0dmVjMiBmYWIgPSBERkdBcHByb3goIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XG5cdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0Vcblx0XHR2ZWMzIEZyID0gbWl4KCBzcGVjdWxhckNvbG9yLCBpcmlkZXNjZW5jZUYwLCBpcmlkZXNjZW5jZSApO1xuXHQjZWxzZVxuXHRcdHZlYzMgRnIgPSBzcGVjdWxhckNvbG9yO1xuXHQjZW5kaWZcblx0dmVjMyBGc3NFc3MgPSBGciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcblx0ZmxvYXQgRXNzID0gZmFiLnggKyBmYWIueTtcblx0ZmxvYXQgRW1zID0gMS4wIC0gRXNzO1xuXHR2ZWMzIEZhdmcgPSBGciArICggMS4wIC0gRnIgKSAqIDAuMDQ3NjE5O1x0dmVjMyBGbXMgPSBGc3NFc3MgKiBGYXZnIC8gKCAxLjAgLSBFbXMgKiBGYXZnICk7XG5cdHNpbmdsZVNjYXR0ZXIgKz0gRnNzRXNzO1xuXHRtdWx0aVNjYXR0ZXIgKz0gRm1zICogRW1zO1xufVxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxuXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcblx0XHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Lm5vcm1hbDtcblx0XHR2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xuXHRcdHZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcblx0XHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcblx0XHR2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoO1xuXHRcdHZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDtcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xuXHRcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzcztcblx0XHR2ZWMzIHJlY3RDb29yZHNbIDQgXTtcblx0XHRyZWN0Q29vcmRzWyAwIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XHRcdHJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcblx0XHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XG5cdFx0cmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xuXHRcdHZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XG5cdFx0dmVjNCB0MSA9IHRleHR1cmUyRCggbHRjXzEsIHV2ICk7XG5cdFx0dmVjNCB0MiA9IHRleHR1cmUyRCggbHRjXzIsIHV2ICk7XG5cdFx0bWF0MyBtSW52ID0gbWF0Myhcblx0XHRcdHZlYzMoIHQxLngsIDAsIHQxLnkgKSxcblx0XHRcdHZlYzMoICAgIDAsIDEsICAgIDAgKSxcblx0XHRcdHZlYzMoIHQxLnosIDAsIHQxLncgKVxuXHRcdCk7XG5cdFx0dmVjMyBmcmVzbmVsID0gKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogdDIueCArICggdmVjMyggMS4wICkgLSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICkgKiB0Mi55ICk7XG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIGZyZXNuZWwgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTtcblx0XHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEuMCApLCByZWN0Q29vcmRzICk7XG5cdH1cbiNlbmRpZlxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xuXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcblx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcblx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcblx0XHRmbG9hdCBkb3ROTGNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xuXHRcdHZlYzMgY2NJcnJhZGlhbmNlID0gZG90TkxjYyAqIGRpcmVjdExpZ2h0LmNvbG9yO1xuXHRcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNjSXJyYWRpYW5jZSAqIEJSREZfR0dYKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XG5cdCNlbmRpZlxuXHQjaWZkZWYgVVNFX1NIRUVOXG5cdFx0c2hlZW5TcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TaGVlbiggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnNoZWVuQ29sb3IsIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICk7XG5cdCNlbmRpZlxuXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFXG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfR0dYX0lyaWRlc2NlbmNlKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLnJvdWdobmVzcyApO1xuXHQjZWxzZVxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX0dHWCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTtcblx0I2VuZGlmXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XG59XG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xufVxudm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgY2xlYXJjb2F0UmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0KSB7XG5cdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXG5cdFx0Y2xlYXJjb2F0U3BlY3VsYXIgKz0gY2xlYXJjb2F0UmFkaWFuY2UgKiBFbnZpcm9ubWVudEJSREYoIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciwgbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XG5cdCNlbmRpZlxuXHQjaWZkZWYgVVNFX1NIRUVOXG5cdFx0c2hlZW5TcGVjdWxhciArPSBpcnJhZGlhbmNlICogbWF0ZXJpYWwuc2hlZW5Db2xvciAqIElCTFNoZWVuQlJERiggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApO1xuXHQjZW5kaWZcblx0dmVjMyBzaW5nbGVTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XG5cdHZlYzMgbXVsdGlTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XG5cdHZlYzMgY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlID0gaXJyYWRpYW5jZSAqIFJFQ0lQUk9DQUxfUEk7XG5cdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0Vcblx0XHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLnJvdWdobmVzcywgc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nICk7XG5cdCNlbHNlXG5cdFx0Y29tcHV0ZU11bHRpc2NhdHRlcmluZyggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwucm91Z2huZXNzLCBzaW5nbGVTY2F0dGVyaW5nLCBtdWx0aVNjYXR0ZXJpbmcgKTtcblx0I2VuZGlmXG5cdHZlYzMgdG90YWxTY2F0dGVyaW5nID0gc2luZ2xlU2NhdHRlcmluZyArIG11bHRpU2NhdHRlcmluZztcblx0dmVjMyBkaWZmdXNlID0gbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICogKCAxLjAgLSBtYXgoIG1heCggdG90YWxTY2F0dGVyaW5nLnIsIHRvdGFsU2NhdHRlcmluZy5nICksIHRvdGFsU2NhdHRlcmluZy5iICkgKTtcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSByYWRpYW5jZSAqIHNpbmdsZVNjYXR0ZXJpbmc7XG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gbXVsdGlTY2F0dGVyaW5nICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gZGlmZnVzZSAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcbn1cbiNkZWZpbmUgUkVfRGlyZWN0XHRcdFx0XHRSRV9EaXJlY3RfUGh5c2ljYWxcbiNkZWZpbmUgUkVfRGlyZWN0X1JlY3RBcmVhXHRcdFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcdFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcdFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxuZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xuXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xufWAsIHRsID0gYFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsO1xuZ2VvbWV0cnkudmlld0RpciA9ICggaXNPcnRob2dyYXBoaWMgKSA/IHZlYzMoIDAsIDAsIDEgKSA6IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xuI2lmZGVmIFVTRV9DTEVBUkNPQVRcblx0Z2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsID0gY2xlYXJjb2F0Tm9ybWFsO1xuI2VuZGlmXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXG5cdGZsb2F0IGRvdE5WaSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XG5cdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPT0gMC4wICkge1xuXHRcdG1hdGVyaWFsLmlyaWRlc2NlbmNlID0gMC4wO1xuXHR9IGVsc2Uge1xuXHRcdG1hdGVyaWFsLmlyaWRlc2NlbmNlID0gc2F0dXJhdGUoIG1hdGVyaWFsLmlyaWRlc2NlbmNlICk7XG5cdH1cblx0aWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDAuMCApIHtcblx0XHRtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwgPSBldmFsSXJpZGVzY2VuY2UoIDEuMCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IsIGRvdE5WaSwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKTtcblx0XHRtYXRlcmlhbC5pcmlkZXNjZW5jZUYwID0gU2NobGlja190b19GMCggbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsLCAxLjAsIGRvdE5WaSApO1xuXHR9XG4jZW5kaWZcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XG4jaWYgKCBOVU1fUE9JTlRfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXG5cdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcblx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcblx0UG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93O1xuXHQjZW5kaWZcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xuXHRcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xuXHRcdGdldFBvaW50TGlnaHRJbmZvKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcblx0XHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIClcblx0XHRwb2ludExpZ2h0U2hhZG93ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTtcblx0XHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBkaXJlY3RMaWdodC52aXNpYmxlLCByZWNlaXZlU2hhZG93ICkgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcblx0XHQjZW5kaWZcblx0XHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XG5cdH1cblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcbiNlbmRpZlxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXG5cdFNwb3RMaWdodCBzcG90TGlnaHQ7XG5cdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcblx0U3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvdztcblx0I2VuZGlmXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xuXHRcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcblx0XHRnZXRTcG90TGlnaHRJbmZvKCBzcG90TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xuXHRcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXG5cdFx0c3BvdExpZ2h0U2hhZG93ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xuXHRcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdExpZ2h0LnZpc2libGUsIHJlY2VpdmVTaGFkb3cgKSApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93Qmlhcywgc3BvdExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XG5cdFx0I2VuZGlmXG5cdFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xuXHR9XG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXG4jZW5kaWZcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXG5cdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcblx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXG5cdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvdztcblx0I2VuZGlmXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XG5cdFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XG5cdFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xuXHRcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTIClcblx0XHRkaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcblx0XHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBkaXJlY3RMaWdodC52aXNpYmxlLCByZWNlaXZlU2hhZG93ICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XG5cdFx0I2VuZGlmXG5cdFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xuXHR9XG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXG4jZW5kaWZcbiNpZiAoIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdF9SZWN0QXJlYSApXG5cdFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodDtcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcblx0XHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcblx0XHRSRV9EaXJlY3RfUmVjdEFyZWEoIHJlY3RBcmVhTGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcblx0fVxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuI2VuZGlmXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcblx0dmVjMyBpYmxJcnJhZGlhbmNlID0gdmVjMyggMC4wICk7XG5cdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XG5cdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGdlb21ldHJ5Lm5vcm1hbCApO1xuXHQjaWYgKCBOVU1fSEVNSV9MSUdIVFMgPiAwIClcblx0XHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xuXHRcdFx0aXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Lm5vcm1hbCApO1xuXHRcdH1cblx0XHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuXHQjZW5kaWZcbiNlbmRpZlxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxuXHR2ZWMzIHJhZGlhbmNlID0gdmVjMyggMC4wICk7XG5cdHZlYzMgY2xlYXJjb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcbiNlbmRpZmAsIG5sID0gYCNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxuXHQjaWZkZWYgVVNFX0xJR0hUTUFQXG5cdFx0dmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1xuXHRcdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gbGlnaHRNYXBUZXhlbC5yZ2IgKiBsaWdodE1hcEludGVuc2l0eTtcblx0XHRpcnJhZGlhbmNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTtcblx0I2VuZGlmXG5cdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcblx0XHRpYmxJcnJhZGlhbmNlICs9IGdldElCTElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCApO1xuXHQjZW5kaWZcbiNlbmRpZlxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcblx0cmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XG5cdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXG5cdFx0Y2xlYXJjb2F0UmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XG5cdCNlbmRpZlxuI2VuZGlmYCwgaWwgPSBgI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXG5cdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xuI2VuZGlmXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXG5cdFJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBpYmxJcnJhZGlhbmNlLCBjbGVhcmNvYXRSYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xuI2VuZGlmYCwgc2wgPSBgI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApICYmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRl9FWFQgKVxuXHRnbF9GcmFnRGVwdGhFWFQgPSB2SXNQZXJzcGVjdGl2ZSA9PSAwLjAgPyBnbF9GcmFnQ29vcmQueiA6IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XG4jZW5kaWZgLCBybCA9IGAjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGICkgJiYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGX0VYVCApXG5cdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcblx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xuXHR2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlO1xuI2VuZGlmYCwgb2wgPSBgI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcblx0XHR2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlO1xuXHQjZWxzZVxuXHRcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcblx0I2VuZGlmXG4jZW5kaWZgLCBhbCA9IGAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXG5cdFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XG5cdFx0dklzUGVyc3BlY3RpdmUgPSBmbG9hdCggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICk7XG5cdCNlbHNlXG5cdFx0aWYgKCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKSB7XG5cdFx0XHRnbF9Qb3NpdGlvbi56ID0gbG9nMiggbWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkgKSAqIGxvZ0RlcHRoQnVmRkMgLSAxLjA7XG5cdFx0XHRnbF9Qb3NpdGlvbi56ICo9IGdsX1Bvc2l0aW9uLnc7XG5cdFx0fVxuXHQjZW5kaWZcbiNlbmRpZmAsIGxsID0gYCNpZmRlZiBVU0VfTUFQXG5cdHZlYzQgc2FtcGxlZERpZmZ1c2VDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcblx0I2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFXG5cdFx0c2FtcGxlZERpZmZ1c2VDb2xvciA9IHZlYzQoIG1peCggcG93KCBzYW1wbGVkRGlmZnVzZUNvbG9yLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCBzYW1wbGVkRGlmZnVzZUNvbG9yLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggc2FtcGxlZERpZmZ1c2VDb2xvci5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgc2FtcGxlZERpZmZ1c2VDb2xvci53ICk7XG5cdCNlbmRpZlxuXHRkaWZmdXNlQ29sb3IgKj0gc2FtcGxlZERpZmZ1c2VDb2xvcjtcbiNlbmRpZmAsIGNsID0gYCNpZmRlZiBVU0VfTUFQXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcbiNlbmRpZmAsIGhsID0gYCNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcblx0dmVjMiB1diA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSwgMSApICkueHk7XG4jZW5kaWZcbiNpZmRlZiBVU0VfTUFQXG5cdGRpZmZ1c2VDb2xvciAqPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKTtcbiNlbmRpZlxuI2lmZGVmIFVTRV9BTFBIQU1BUFxuXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB1diApLmc7XG4jZW5kaWZgLCB1bCA9IGAjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXG5cdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcbiNlbmRpZlxuI2lmZGVmIFVTRV9NQVBcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xuI2VuZGlmXG4jaWZkZWYgVVNFX0FMUEhBTUFQXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xuI2VuZGlmYCwgZGwgPSBgZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xuI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcblx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2VXYgKTtcblx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLmI7XG4jZW5kaWZgLCBmbCA9IGAjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XG4jZW5kaWZgLCBwbCA9IGAjaWYgZGVmaW5lZCggVVNFX01PUlBIQ09MT1JTICkgJiYgZGVmaW5lZCggTU9SUEhUQVJHRVRTX1RFWFRVUkUgKVxuXHR2Q29sb3IgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XG5cdFx0I2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHZDb2xvciArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDIgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xuXHRcdCNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHZDb2xvciArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDIgKS5yZ2IgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcblx0XHQjZW5kaWZcblx0fVxuI2VuZGlmYCwgbWwgPSBgI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcblx0b2JqZWN0Tm9ybWFsICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcblx0I2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXG5cdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xuXHRcdFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSBvYmplY3ROb3JtYWwgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAxICkueHl6ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XG5cdFx0fVxuXHQjZWxzZVxuXHRcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDAgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcblx0XHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwxICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XG5cdFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xuXHRcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDMgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcblx0I2VuZGlmXG4jZW5kaWZgLCBnbCA9IGAjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcblx0I2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXG5cdFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIE1PUlBIVEFSR0VUU19DT1VOVCBdO1xuXHRcdHVuaWZvcm0gc2FtcGxlcjJEQXJyYXkgbW9ycGhUYXJnZXRzVGV4dHVyZTtcblx0XHR1bmlmb3JtIGl2ZWMyIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplO1xuXHRcdHZlYzQgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQgKSB7XG5cdFx0XHRpbnQgdGV4ZWxJbmRleCA9IHZlcnRleEluZGV4ICogTU9SUEhUQVJHRVRTX1RFWFRVUkVfU1RSSURFICsgb2Zmc2V0O1xuXHRcdFx0aW50IHkgPSB0ZXhlbEluZGV4IC8gbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueDtcblx0XHRcdGludCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xuXHRcdFx0aXZlYzMgbW9ycGhVViA9IGl2ZWMzKCB4LCB5LCBtb3JwaFRhcmdldEluZGV4ICk7XG5cdFx0XHRyZXR1cm4gdGV4ZWxGZXRjaCggbW9ycGhUYXJnZXRzVGV4dHVyZSwgbW9ycGhVViwgMCApO1xuXHRcdH1cblx0I2Vsc2Vcblx0XHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcblx0XHRcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XG5cdFx0I2Vsc2Vcblx0XHRcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XG5cdFx0I2VuZGlmXG5cdCNlbmRpZlxuI2VuZGlmYCwgX2wgPSBgI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcblx0dHJhbnNmb3JtZWQgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xuXHQjaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkVcblx0XHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHRyYW5zZm9ybWVkICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMCApLnh5eiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xuXHRcdH1cblx0I2Vsc2Vcblx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDAgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcblx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDEgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcblx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDIgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcblx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDMgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcblx0XHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcblx0XHRcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xuXHRcdFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQ1ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XG5cdFx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDYgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcblx0XHRcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xuXHRcdCNlbmRpZlxuXHQjZW5kaWZcbiNlbmRpZmAsIHZsID0gYGZsb2F0IGZhY2VEaXJlY3Rpb24gPSBnbF9Gcm9udEZhY2luZyA/IDEuMCA6IC0gMS4wO1xuI2lmZGVmIEZMQVRfU0hBREVEXG5cdHZlYzMgZmR4ID0gdmVjMyggZEZkeCggdlZpZXdQb3NpdGlvbi54ICksIGRGZHgoIHZWaWV3UG9zaXRpb24ueSApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnogKSApO1xuXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcblx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBmZHgsIGZkeSApICk7XG4jZWxzZVxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xuXHQjaWZkZWYgRE9VQkxFX1NJREVEXG5cdFx0bm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjtcblx0I2VuZGlmXG5cdCNpZmRlZiBVU0VfVEFOR0VOVFxuXHRcdHZlYzMgdGFuZ2VudCA9IG5vcm1hbGl6ZSggdlRhbmdlbnQgKTtcblx0XHR2ZWMzIGJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApO1xuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcblx0XHRcdHRhbmdlbnQgPSB0YW5nZW50ICogZmFjZURpcmVjdGlvbjtcblx0XHRcdGJpdGFuZ2VudCA9IGJpdGFuZ2VudCAqIGZhY2VEaXJlY3Rpb247XG5cdFx0I2VuZGlmXG5cdFx0I2lmIGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApXG5cdFx0XHRtYXQzIHZUQk4gPSBtYXQzKCB0YW5nZW50LCBiaXRhbmdlbnQsIG5vcm1hbCApO1xuXHRcdCNlbmRpZlxuXHQjZW5kaWZcbiNlbmRpZlxudmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDtgLCB4bCA9IGAjaWZkZWYgT0JKRUNUU1BBQ0VfTk9STUFMTUFQXG5cdG5vcm1hbCA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XG5cdCNpZmRlZiBGTElQX1NJREVEXG5cdFx0bm9ybWFsID0gLSBub3JtYWw7XG5cdCNlbmRpZlxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXG5cdFx0bm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjtcblx0I2VuZGlmXG5cdG5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XG4jZWxpZiBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcblx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcblx0bWFwTi54eSAqPSBub3JtYWxTY2FsZTtcblx0I2lmZGVmIFVTRV9UQU5HRU5UXG5cdFx0bm9ybWFsID0gbm9ybWFsaXplKCB2VEJOICogbWFwTiApO1xuXHQjZWxzZVxuXHRcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCwgbWFwTiwgZmFjZURpcmVjdGlvbiApO1xuXHQjZW5kaWZcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpLCBmYWNlRGlyZWN0aW9uICk7XG4jZW5kaWZgLCB5bCA9IGAjaWZuZGVmIEZMQVRfU0hBREVEXG5cdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xuXHQjaWZkZWYgVVNFX1RBTkdFTlRcblx0XHR2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XG5cdFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XG5cdCNlbmRpZlxuI2VuZGlmYCwgYmwgPSBgI2lmbmRlZiBGTEFUX1NIQURFRFxuXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcblx0I2lmZGVmIFVTRV9UQU5HRU5UXG5cdFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xuXHRcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xuXHQjZW5kaWZcbiNlbmRpZmAsIHdsID0gYCNpZm5kZWYgRkxBVF9TSEFERURcblx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcblx0I2lmZGVmIFVTRV9UQU5HRU5UXG5cdFx0dlRhbmdlbnQgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkVGFuZ2VudCApO1xuXHRcdHZCaXRhbmdlbnQgPSBub3JtYWxpemUoIGNyb3NzKCB2Tm9ybWFsLCB2VGFuZ2VudCApICogdGFuZ2VudC53ICk7XG5cdCNlbmRpZlxuI2VuZGlmYCwgTWwgPSBgI2lmZGVmIFVTRV9OT1JNQUxNQVBcblx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XG4jZW5kaWZcbiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcblx0dW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcbiNlbmRpZlxuI2lmICEgZGVmaW5lZCAoIFVTRV9UQU5HRU5UICkgJiYgKCBkZWZpbmVkICggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQgKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApIClcblx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMyBtYXBOLCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xuXHRcdHZlYzMgcTAgPSBkRmR4KCBleWVfcG9zLnh5eiApO1xuXHRcdHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XG5cdFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcblx0XHR2ZWMzIE4gPSBzdXJmX25vcm07XG5cdFx0dmVjMyBxMXBlcnAgPSBjcm9zcyggcTEsIE4gKTtcblx0XHR2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApO1xuXHRcdHZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7XG5cdFx0dmVjMyBCID0gcTFwZXJwICogc3QwLnkgKyBxMHBlcnAgKiBzdDEueTtcblx0XHRmbG9hdCBkZXQgPSBtYXgoIGRvdCggVCwgVCApLCBkb3QoIEIsIEIgKSApO1xuXHRcdGZsb2F0IHNjYWxlID0gKCBkZXQgPT0gMC4wICkgPyAwLjAgOiBmYWNlRGlyZWN0aW9uICogaW52ZXJzZXNxcnQoIGRldCApO1xuXHRcdHJldHVybiBub3JtYWxpemUoIFQgKiAoIG1hcE4ueCAqIHNjYWxlICkgKyBCICogKCBtYXBOLnkgKiBzY2FsZSApICsgTiAqIG1hcE4ueiApO1xuXHR9XG4jZW5kaWZgLCBTbCA9IGAjaWZkZWYgVVNFX0NMRUFSQ09BVFxuXHR2ZWMzIGNsZWFyY29hdE5vcm1hbCA9IGdlb21ldHJ5Tm9ybWFsO1xuI2VuZGlmYCwgRWwgPSBgI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXG5cdHZlYzMgY2xlYXJjb2F0TWFwTiA9IHRleHR1cmUyRCggY2xlYXJjb2F0Tm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XG5cdGNsZWFyY29hdE1hcE4ueHkgKj0gY2xlYXJjb2F0Tm9ybWFsU2NhbGU7XG5cdCNpZmRlZiBVU0VfVEFOR0VOVFxuXHRcdGNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdlRCTiAqIGNsZWFyY29hdE1hcE4gKTtcblx0I2Vsc2Vcblx0XHRjbGVhcmNvYXROb3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLSB2Vmlld1Bvc2l0aW9uLCBjbGVhcmNvYXROb3JtYWwsIGNsZWFyY29hdE1hcE4sIGZhY2VEaXJlY3Rpb24gKTtcblx0I2VuZGlmXG4jZW5kaWZgLCBUbCA9IGAjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXRNYXA7XG4jZW5kaWZcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXRSb3VnaG5lc3NNYXA7XG4jZW5kaWZcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7XG5cdHVuaWZvcm0gdmVjMiBjbGVhcmNvYXROb3JtYWxTY2FsZTtcbiNlbmRpZmAsIEFsID0gYCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcblx0dW5pZm9ybSBzYW1wbGVyMkQgaXJpZGVzY2VuY2VNYXA7XG4jZW5kaWZcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xuI2VuZGlmYCwgQ2wgPSBgI2lmZGVmIE9QQVFVRVxuZGlmZnVzZUNvbG9yLmEgPSAxLjA7XG4jZW5kaWZcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXG5kaWZmdXNlQ29sb3IuYSAqPSB0cmFuc21pc3Npb25BbHBoYSArIDAuMTtcbiNlbmRpZlxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtgLCBMbCA9IGB2ZWMzIHBhY2tOb3JtYWxUb1JHQiggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XG5cdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xufVxudmVjMyB1bnBhY2tSR0JUb05vcm1hbCggY29uc3QgaW4gdmVjMyByZ2IgKSB7XG5cdHJldHVybiAyLjAgKiByZ2IueHl6IC0gMS4wO1xufVxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2LjtcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAyNTYuICk7XG5jb25zdCB2ZWM0IFVucGFja0ZhY3RvcnMgPSBVbnBhY2tEb3duc2NhbGUgLyB2ZWM0KCBQYWNrRmFjdG9ycywgMS4gKTtcbmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuO1xudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XG5cdHZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApO1xuXHRyLnl6dyAtPSByLnh5eiAqIFNoaWZ0UmlnaHQ4O1x0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcbn1cbmZsb2F0IHVucGFja1JHQkFUb0RlcHRoKCBjb25zdCBpbiB2ZWM0IHYgKSB7XG5cdHJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnMgKTtcbn1cbnZlYzQgcGFjazJIYWxmVG9SR0JBKCB2ZWMyIHYgKSB7XG5cdHZlYzQgciA9IHZlYzQoIHYueCwgZnJhY3QoIHYueCAqIDI1NS4wICksIHYueSwgZnJhY3QoIHYueSAqIDI1NS4wICkgKTtcblx0cmV0dXJuIHZlYzQoIHIueCAtIHIueSAvIDI1NS4wLCByLnksIHIueiAtIHIudyAvIDI1NS4wLCByLncgKTtcbn1cbnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIHZlYzQgdiApIHtcblx0cmV0dXJuIHZlYzIoIHYueCArICggdi55IC8gMjU1LjAgKSwgdi56ICsgKCB2LncgLyAyNTUuMCApICk7XG59XG5mbG9hdCB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XG5cdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XG59XG5mbG9hdCBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGxpbmVhckNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XG5cdHJldHVybiBsaW5lYXJDbGlwWiAqICggbmVhciAtIGZhciApIC0gbmVhcjtcbn1cbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xuXHRyZXR1cm4gKCAoIG5lYXIgKyB2aWV3WiApICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogdmlld1ogKTtcbn1cbmZsb2F0IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBpbnZDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xuXHRyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogaW52Q2xpcFogLSBmYXIgKTtcbn1gLCBSbCA9IGAjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQVxuXHRnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xuI2VuZGlmYCwgRmwgPSBgdmVjNCBtdlBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXG5cdG12UG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIG12UG9zaXRpb247XG4jZW5kaWZcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBtdlBvc2l0aW9uO1xuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtgLCBEbCA9IGAjaWZkZWYgRElUSEVSSU5HXG5cdGdsX0ZyYWdDb2xvci5yZ2IgPSBkaXRoZXJpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcbiNlbmRpZmAsIFBsID0gYCNpZmRlZiBESVRIRVJJTkdcblx0dmVjMyBkaXRoZXJpbmcoIHZlYzMgY29sb3IgKSB7XG5cdFx0ZmxvYXQgZ3JpZF9wb3NpdGlvbiA9IHJhbmQoIGdsX0ZyYWdDb29yZC54eSApO1xuXHRcdHZlYzMgZGl0aGVyX3NoaWZ0X1JHQiA9IHZlYzMoIDAuMjUgLyAyNTUuMCwgLTAuMjUgLyAyNTUuMCwgMC4yNSAvIDI1NS4wICk7XG5cdFx0ZGl0aGVyX3NoaWZ0X1JHQiA9IG1peCggMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgLTIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIGdyaWRfcG9zaXRpb24gKTtcblx0XHRyZXR1cm4gY29sb3IgKyBkaXRoZXJfc2hpZnRfUkdCO1xuXHR9XG4jZW5kaWZgLCBJbCA9IGBmbG9hdCByb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3M7XG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxuXHR2ZWM0IHRleGVsUm91Z2huZXNzID0gdGV4dHVyZTJEKCByb3VnaG5lc3NNYXAsIHZVdiApO1xuXHRyb3VnaG5lc3NGYWN0b3IgKj0gdGV4ZWxSb3VnaG5lc3MuZztcbiNlbmRpZmAsIHpsID0gYCNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcbiNlbmRpZmAsIEJsID0gYCNpZmRlZiBVU0VfU0hBRE9XTUFQXG5cdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xuXHRcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XG5cdFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xuXHRcdFx0ZmxvYXQgc2hhZG93Qmlhcztcblx0XHRcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XG5cdFx0XHRmbG9hdCBzaGFkb3dSYWRpdXM7XG5cdFx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XG5cdFx0fTtcblx0XHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xuXHQjZW5kaWZcblx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xuXHRcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XG5cdFx0c3RydWN0IFNwb3RMaWdodFNoYWRvdyB7XG5cdFx0XHRmbG9hdCBzaGFkb3dCaWFzO1xuXHRcdFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcblx0XHRcdGZsb2F0IHNoYWRvd1JhZGl1cztcblx0XHRcdHZlYzIgc2hhZG93TWFwU2l6ZTtcblx0XHR9O1xuXHRcdHVuaWZvcm0gU3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvd3NbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcblx0I2VuZGlmXG5cdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcblx0XHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XG5cdFx0c3RydWN0IFBvaW50TGlnaHRTaGFkb3cge1xuXHRcdFx0ZmxvYXQgc2hhZG93Qmlhcztcblx0XHRcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XG5cdFx0XHRmbG9hdCBzaGFkb3dSYWRpdXM7XG5cdFx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XG5cdFx0XHRmbG9hdCBzaGFkb3dDYW1lcmFOZWFyO1xuXHRcdFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xuXHRcdH07XG5cdFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xuXHQjZW5kaWZcblx0ZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcblx0XHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcblx0fVxuXHR2ZWMyIHRleHR1cmUyRERpc3RyaWJ1dGlvbiggc2FtcGxlcjJEIHNoYWRvdywgdmVjMiB1diApIHtcblx0XHRyZXR1cm4gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93LCB1diApICk7XG5cdH1cblx0ZmxvYXQgVlNNU2hhZG93IChzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICl7XG5cdFx0ZmxvYXQgb2NjbHVzaW9uID0gMS4wO1xuXHRcdHZlYzIgZGlzdHJpYnV0aW9uID0gdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzaGFkb3csIHV2ICk7XG5cdFx0ZmxvYXQgaGFyZF9zaGFkb3cgPSBzdGVwKCBjb21wYXJlICwgZGlzdHJpYnV0aW9uLnggKTtcblx0XHRpZiAoaGFyZF9zaGFkb3cgIT0gMS4wICkge1xuXHRcdFx0ZmxvYXQgZGlzdGFuY2UgPSBjb21wYXJlIC0gZGlzdHJpYnV0aW9uLnggO1xuXHRcdFx0ZmxvYXQgdmFyaWFuY2UgPSBtYXgoIDAuMDAwMDAsIGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKTtcblx0XHRcdGZsb2F0IHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkaXN0YW5jZSAqIGRpc3RhbmNlICk7XHRcdFx0c29mdG5lc3NfcHJvYmFiaWxpdHkgPSBjbGFtcCggKCBzb2Z0bmVzc19wcm9iYWJpbGl0eSAtIDAuMyApIC8gKCAwLjk1IC0gMC4zICksIDAuMCwgMS4wICk7XHRcdFx0b2NjbHVzaW9uID0gY2xhbXAoIG1heCggaGFyZF9zaGFkb3csIHNvZnRuZXNzX3Byb2JhYmlsaXR5ICksIDAuMCwgMS4wICk7XG5cdFx0fVxuXHRcdHJldHVybiBvY2NsdXNpb247XG5cdH1cblx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCApIHtcblx0XHRmbG9hdCBzaGFkb3cgPSAxLjA7XG5cdFx0c2hhZG93Q29vcmQueHl6IC89IHNoYWRvd0Nvb3JkLnc7XG5cdFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xuXHRcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcblx0XHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XG5cdFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xuXHRcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XG5cdFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcblx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcblx0XHRcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xuXHRcdFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcblx0XHRcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XG5cdFx0XHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xuXHRcdFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcblx0XHRcdGZsb2F0IGR4MiA9IGR4MCAvIDIuMDtcblx0XHRcdGZsb2F0IGR5MiA9IGR5MCAvIDIuMDtcblx0XHRcdGZsb2F0IGR4MyA9IGR4MSAvIDIuMDtcblx0XHRcdGZsb2F0IGR5MyA9IGR5MSAvIDIuMDtcblx0XHRcdHNoYWRvdyA9IChcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxuXHRcdFx0KSAqICggMS4wIC8gMTcuMCApO1xuXHRcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcblx0XHRcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xuXHRcdFx0ZmxvYXQgZHggPSB0ZXhlbFNpemUueDtcblx0XHRcdGZsb2F0IGR5ID0gdGV4ZWxTaXplLnk7XG5cdFx0XHR2ZWMyIHV2ID0gc2hhZG93Q29vcmQueHk7XG5cdFx0XHR2ZWMyIGYgPSBmcmFjdCggdXYgKiBzaGFkb3dNYXBTaXplICsgMC41ICk7XG5cdFx0XHR1diAtPSBmICogdGV4ZWxTaXplO1xuXHRcdFx0c2hhZG93ID0gKFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2LCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCBkeSApLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdGV4ZWxTaXplLCBzaGFkb3dDb29yZC56ICkgK1xuXHRcdFx0XHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksIFxuXHRcdFx0XHRcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0XHRcdFx0IGYueCApICtcblx0XHRcdFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksIFxuXHRcdFx0XHRcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRcdFx0XHQgZi54ICkgK1xuXHRcdFx0XHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIC1keSApLCBzaGFkb3dDb29yZC56ICksIFxuXHRcdFx0XHRcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0XHRcdFx0IGYueSApICtcblx0XHRcdFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksIFxuXHRcdFx0XHRcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRcdFx0XHQgZi55ICkgK1xuXHRcdFx0XHRtaXgoIG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXG5cdFx0XHRcdFx0XHQgIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRcdFx0XHRcdCAgZi54ICksXG5cdFx0XHRcdFx0IG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLCBcblx0XHRcdFx0XHRcdCAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0XHRcdFx0XHQgIGYueCApLFxuXHRcdFx0XHRcdCBmLnkgKVxuXHRcdFx0KSAqICggMS4wIC8gOS4wICk7XG5cdFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNIClcblx0XHRcdHNoYWRvdyA9IFZTTVNoYWRvdyggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xuXHRcdCNlbHNlXG5cdFx0XHRzaGFkb3cgPSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XG5cdFx0I2VuZGlmXG5cdFx0fVxuXHRcdHJldHVybiBzaGFkb3c7XG5cdH1cblx0dmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkge1xuXHRcdHZlYzMgYWJzViA9IGFicyggdiApO1xuXHRcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xuXHRcdGFic1YgKj0gc2NhbGVUb0N1YmU7XG5cdFx0diAqPSBzY2FsZVRvQ3ViZSAqICggMS4wIC0gMi4wICogdGV4ZWxTaXplWSApO1xuXHRcdHZlYzIgcGxhbmFyID0gdi54eTtcblx0XHRmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZO1xuXHRcdGZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDtcblx0XHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XG5cdFx0XHRpZiAoIHYueiA+IDAuMCApXG5cdFx0XHRcdHBsYW5hci54ID0gNC4wIC0gdi54O1xuXHRcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XG5cdFx0XHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xuXHRcdFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xuXHRcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XG5cdFx0XHRmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApO1xuXHRcdFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcblx0XHRcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XG5cdFx0fVxuXHRcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcblx0fVxuXHRmbG9hdCBnZXRQb2ludFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQsIGZsb2F0IHNoYWRvd0NhbWVyYU5lYXIsIGZsb2F0IHNoYWRvd0NhbWVyYUZhciApIHtcblx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gKCBzaGFkb3dNYXBTaXplICogdmVjMiggNC4wLCAyLjAgKSApO1xuXHRcdHZlYzMgbGlnaHRUb1Bvc2l0aW9uID0gc2hhZG93Q29vcmQueHl6O1xuXHRcdGZsb2F0IGRwID0gKCBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7XHRcdGRwICs9IHNoYWRvd0JpYXM7XG5cdFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcblx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9WU00gKVxuXHRcdFx0dmVjMiBvZmZzZXQgPSB2ZWMyKCAtIDEsIDEgKSAqIHNoYWRvd1JhZGl1cyAqIHRleGVsU2l6ZS55O1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwIClcblx0XHRcdCkgKiAoIDEuMCAvIDkuMCApO1xuXHRcdCNlbHNlXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcblx0XHQjZW5kaWZcblx0fVxuI2VuZGlmYCwgTmwgPSBgI2lmZGVmIFVTRV9TSEFET1dNQVBcblx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcblx0XHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xuXHRcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XG5cdFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xuXHRcdFx0ZmxvYXQgc2hhZG93Qmlhcztcblx0XHRcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XG5cdFx0XHRmbG9hdCBzaGFkb3dSYWRpdXM7XG5cdFx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XG5cdFx0fTtcblx0XHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xuXHQjZW5kaWZcblx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXG5cdFx0dW5pZm9ybSBtYXQ0IHNwb3RTaGFkb3dNYXRyaXhbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcblx0XHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xuXHRcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xuXHRcdFx0ZmxvYXQgc2hhZG93Qmlhcztcblx0XHRcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XG5cdFx0XHRmbG9hdCBzaGFkb3dSYWRpdXM7XG5cdFx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XG5cdFx0fTtcblx0XHR1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XG5cdCNlbmRpZlxuXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXG5cdFx0dW5pZm9ybSBtYXQ0IHBvaW50U2hhZG93TWF0cml4WyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xuXHRcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcblx0XHRzdHJ1Y3QgUG9pbnRMaWdodFNoYWRvdyB7XG5cdFx0XHRmbG9hdCBzaGFkb3dCaWFzO1xuXHRcdFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcblx0XHRcdGZsb2F0IHNoYWRvd1JhZGl1cztcblx0XHRcdHZlYzIgc2hhZG93TWFwU2l6ZTtcblx0XHRcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XG5cdFx0XHRmbG9hdCBzaGFkb3dDYW1lcmFGYXI7XG5cdFx0fTtcblx0XHR1bmlmb3JtIFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvd3NbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XG5cdCNlbmRpZlxuI2VuZGlmYCwgT2wgPSBgI2lmZGVmIFVTRV9TSEFET1dNQVBcblx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXG5cdFx0dmVjMyBzaGFkb3dXb3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XG5cdFx0dmVjNCBzaGFkb3dXb3JsZFBvc2l0aW9uO1xuXHQjZW5kaWZcblx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XG5cdFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xuXHRcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcblx0fVxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuXHQjZW5kaWZcblx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcblx0XHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogc3BvdExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcblx0XHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uO1xuXHR9XG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXG5cdCNlbmRpZlxuXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XG5cdFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIHBvaW50TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xuXHRcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcblx0fVxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuXHQjZW5kaWZcbiNlbmRpZmAsIFVsID0gYGZsb2F0IGdldFNoYWRvd01hc2soKSB7XG5cdGZsb2F0IHNoYWRvdyA9IDEuMDtcblx0I2lmZGVmIFVTRV9TSEFET1dNQVBcblx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcblx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0O1xuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcblx0XHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcblx0XHRzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XG5cdH1cblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcblx0I2VuZGlmXG5cdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxuXHRTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0O1xuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XG5cdFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xuXHRcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XG5cdH1cblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcblx0I2VuZGlmXG5cdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcblx0UG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0O1xuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xuXHRcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xuXHRcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xuXHR9XG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXG5cdCNlbmRpZlxuXHQjZW5kaWZcblx0cmV0dXJuIHNoYWRvdztcbn1gLCBHbCA9IGAjaWZkZWYgVVNFX1NLSU5OSU5HXG5cdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xuXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcblx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XG5cdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xuI2VuZGlmYCwga2wgPSBgI2lmZGVmIFVTRV9TS0lOTklOR1xuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xuXHR1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcblx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVTaXplO1xuXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XG5cdFx0ZmxvYXQgaiA9IGkgKiA0LjA7XG5cdFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XG5cdFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XG5cdFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XG5cdFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XG5cdFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XG5cdFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xuXHRcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcblx0XHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XG5cdFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xuXHRcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XG5cdFx0cmV0dXJuIGJvbmU7XG5cdH1cbiNlbmRpZmAsIFdsID0gYCNpZmRlZiBVU0VfU0tJTk5JTkdcblx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcblx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XG5cdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xuXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcblx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XG5cdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xuXHR0cmFuc2Zvcm1lZCA9ICggYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkICkueHl6O1xuI2VuZGlmYCwgVmwgPSBgI2lmZGVmIFVTRV9TS0lOTklOR1xuXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0Wjtcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0Vztcblx0c2tpbk1hdHJpeCA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XG5cdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xuXHQjaWZkZWYgVVNFX1RBTkdFTlRcblx0XHRvYmplY3RUYW5nZW50ID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6O1xuXHQjZW5kaWZcbiNlbmRpZmAsIEhsID0gYGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXG5cdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xuXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xuI2Vsc2Vcblx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcbiNlbmRpZmAsIHFsID0gYCNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcblx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XG4jZW5kaWZgLCBYbCA9IGAjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcblx0Z2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XG4jZW5kaWZgLCBqbCA9IGAjaWZuZGVmIHNhdHVyYXRlXG4jZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wIClcbiNlbmRpZlxudW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ0V4cG9zdXJlO1xudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcblx0cmV0dXJuIHRvbmVNYXBwaW5nRXhwb3N1cmUgKiBjb2xvcjtcbn1cbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcblx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcblx0cmV0dXJuIHNhdHVyYXRlKCBjb2xvciAvICggdmVjMyggMS4wICkgKyBjb2xvciApICk7XG59XG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xuXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xuXHRjb2xvciA9IG1heCggdmVjMyggMC4wICksIGNvbG9yIC0gMC4wMDQgKTtcblx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcbn1cbnZlYzMgUlJUQW5kT0RURml0KCB2ZWMzIHYgKSB7XG5cdHZlYzMgYSA9IHYgKiAoIHYgKyAwLjAyNDU3ODYgKSAtIDAuMDAwMDkwNTM3O1xuXHR2ZWMzIGIgPSB2ICogKCAwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTAgKSArIDAuMjM4MDgxO1xuXHRyZXR1cm4gYSAvIGI7XG59XG52ZWMzIEFDRVNGaWxtaWNUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcblx0Y29uc3QgbWF0MyBBQ0VTSW5wdXRNYXQgPSBtYXQzKFxuXHRcdHZlYzMoIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAgKSxcdFx0dmVjMyggMC4zNTQ1OCwgMC45MDgzNCwgMC4xMzM4MyApLFxuXHRcdHZlYzMoIDAuMDQ4MjMsIDAuMDE1NjYsIDAuODM3NzcgKVxuXHQpO1xuXHRjb25zdCBtYXQzIEFDRVNPdXRwdXRNYXQgPSBtYXQzKFxuXHRcdHZlYzMoICAxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcgKSxcdFx0dmVjMyggLTAuNTMxMDgsICAxLjEwODEzLCAtMC4wNzI3NiApLFxuXHRcdHZlYzMoIC0wLjA3MzY3LCAtMC4wMDYwNSwgIDEuMDc2MDIgKVxuXHQpO1xuXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlIC8gMC42O1xuXHRjb2xvciA9IEFDRVNJbnB1dE1hdCAqIGNvbG9yO1xuXHRjb2xvciA9IFJSVEFuZE9EVEZpdCggY29sb3IgKTtcblx0Y29sb3IgPSBBQ0VTT3V0cHV0TWF0ICogY29sb3I7XG5cdHJldHVybiBzYXR1cmF0ZSggY29sb3IgKTtcbn1cbnZlYzMgQ3VzdG9tVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7IHJldHVybiBjb2xvcjsgfWAsIFlsID0gYCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXG5cdGZsb2F0IHRyYW5zbWlzc2lvbkFscGhhID0gMS4wO1xuXHRmbG9hdCB0cmFuc21pc3Npb25GYWN0b3IgPSB0cmFuc21pc3Npb247XG5cdGZsb2F0IHRoaWNrbmVzc0ZhY3RvciA9IHRoaWNrbmVzcztcblx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcblx0XHR0cmFuc21pc3Npb25GYWN0b3IgKj0gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25NYXAsIHZVdiApLnI7XG5cdCNlbmRpZlxuXHQjaWZkZWYgVVNFX1RISUNLTkVTU01BUFxuXHRcdHRoaWNrbmVzc0ZhY3RvciAqPSB0ZXh0dXJlMkQoIHRoaWNrbmVzc01hcCwgdlV2ICkuZztcblx0I2VuZGlmXG5cdHZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247XG5cdHZlYzMgdiA9IG5vcm1hbGl6ZSggY2FtZXJhUG9zaXRpb24gLSBwb3MgKTtcblx0dmVjMyBuID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XG5cdHZlYzQgdHJhbnNtaXNzaW9uID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcblx0XHRuLCB2LCByb3VnaG5lc3NGYWN0b3IsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXG5cdFx0cG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgaW9yLCB0aGlja25lc3NGYWN0b3IsXG5cdFx0YXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApO1xuXHR0b3RhbERpZmZ1c2UgPSBtaXgoIHRvdGFsRGlmZnVzZSwgdHJhbnNtaXNzaW9uLnJnYiwgdHJhbnNtaXNzaW9uRmFjdG9yICk7XG5cdHRyYW5zbWlzc2lvbkFscGhhID0gbWl4KCB0cmFuc21pc3Npb25BbHBoYSwgdHJhbnNtaXNzaW9uLmEsIHRyYW5zbWlzc2lvbkZhY3RvciApO1xuI2VuZGlmYCwgWmwgPSBgI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cblx0dW5pZm9ybSBmbG9hdCB0cmFuc21pc3Npb247XG5cdHVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzO1xuXHR1bmlmb3JtIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdHVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvbkNvbG9yO1xuXHQjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvbk1hcDtcblx0I2VuZGlmXG5cdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGhpY2tuZXNzTWFwO1xuXHQjZW5kaWZcblx0dW5pZm9ybSB2ZWMyIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplO1xuXHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwO1xuXHR1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XG5cdHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG5cdHZlYzMgZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXggKSB7XG5cdFx0dmVjMyByZWZyYWN0aW9uVmVjdG9yID0gcmVmcmFjdCggLSB2LCBub3JtYWxpemUoIG4gKSwgMS4wIC8gaW9yICk7XG5cdFx0dmVjMyBtb2RlbFNjYWxlO1xuXHRcdG1vZGVsU2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54eXogKSApO1xuXHRcdG1vZGVsU2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54eXogKSApO1xuXHRcdG1vZGVsU2NhbGUueiA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDIgXS54eXogKSApO1xuXHRcdHJldHVybiBub3JtYWxpemUoIHJlZnJhY3Rpb25WZWN0b3IgKSAqIHRoaWNrbmVzcyAqIG1vZGVsU2NhbGU7XG5cdH1cblx0ZmxvYXQgYXBwbHlJb3JUb1JvdWdobmVzcyggY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IgKSB7XG5cdFx0cmV0dXJuIHJvdWdobmVzcyAqIGNsYW1wKCBpb3IgKiAyLjAgLSAyLjAsIDAuMCwgMS4wICk7XG5cdH1cblx0dmVjNCBnZXRUcmFuc21pc3Npb25TYW1wbGUoIGNvbnN0IGluIHZlYzIgZnJhZ0Nvb3JkLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcblx0XHRmbG9hdCBmcmFtZWJ1ZmZlckxvZCA9IGxvZzIoIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnggKSAqIGFwcGx5SW9yVG9Sb3VnaG5lc3MoIHJvdWdobmVzcywgaW9yICk7XG5cdFx0I2lmZGVmIHRleHR1cmUyRExvZEVYVFxuXHRcdFx0cmV0dXJuIHRleHR1cmUyRExvZEVYVCggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBmcmFtZWJ1ZmZlckxvZCApO1xuXHRcdCNlbHNlXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGZyYW1lYnVmZmVyTG9kICk7XG5cdFx0I2VuZGlmXG5cdH1cblx0dmVjMyBhcHBseVZvbHVtZUF0dGVudWF0aW9uKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiBmbG9hdCB0cmFuc21pc3Npb25EaXN0YW5jZSwgY29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xuXHRcdGlmICggYXR0ZW51YXRpb25EaXN0YW5jZSA9PSAwLjAgKSB7XG5cdFx0XHRyZXR1cm4gcmFkaWFuY2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZlYzMgYXR0ZW51YXRpb25Db2VmZmljaWVudCA9IC1sb2coIGF0dGVudWF0aW9uQ29sb3IgKSAvIGF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHR2ZWMzIHRyYW5zbWl0dGFuY2UgPSBleHAoIC0gYXR0ZW51YXRpb25Db2VmZmljaWVudCAqIHRyYW5zbWlzc2lvbkRpc3RhbmNlICk7XHRcdFx0cmV0dXJuIHRyYW5zbWl0dGFuY2UgKiByYWRpYW5jZTtcblx0XHR9XG5cdH1cblx0dmVjNCBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvcixcblx0XHRjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiB2ZWMzIHBvc2l0aW9uLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4LFxuXHRcdGNvbnN0IGluIG1hdDQgdmlld01hdHJpeCwgY29uc3QgaW4gbWF0NCBwcm9qTWF0cml4LCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcyxcblx0XHRjb25zdCBpbiB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGNvbnN0IGluIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7XG5cdFx0dmVjMyB0cmFuc21pc3Npb25SYXkgPSBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIG4sIHYsIHRoaWNrbmVzcywgaW9yLCBtb2RlbE1hdHJpeCApO1xuXHRcdHZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5O1xuXHRcdHZlYzQgbmRjUG9zID0gcHJvak1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZyYWN0ZWRSYXlFeGl0LCAxLjAgKTtcblx0XHR2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3Mudztcblx0XHRyZWZyYWN0aW9uQ29vcmRzICs9IDEuMDtcblx0XHRyZWZyYWN0aW9uQ29vcmRzIC89IDIuMDtcblx0XHR2ZWM0IHRyYW5zbWl0dGVkTGlnaHQgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUoIHJlZnJhY3Rpb25Db29yZHMsIHJvdWdobmVzcywgaW9yICk7XG5cdFx0dmVjMyBhdHRlbnVhdGVkQ29sb3IgPSBhcHBseVZvbHVtZUF0dGVudWF0aW9uKCB0cmFuc21pdHRlZExpZ2h0LnJnYiwgbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApO1xuXHRcdHZlYzMgRiA9IEVudmlyb25tZW50QlJERiggbiwgdiwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHJvdWdobmVzcyApO1xuXHRcdHJldHVybiB2ZWM0KCAoIDEuMCAtIEYgKSAqIGF0dGVudWF0ZWRDb2xvciAqIGRpZmZ1c2VDb2xvciwgdHJhbnNtaXR0ZWRMaWdodC5hICk7XG5cdH1cbiNlbmRpZmAsICRsID0gYCNpZiAoIGRlZmluZWQoIFVTRV9VViApICYmICEgZGVmaW5lZCggVVZTX1ZFUlRFWF9PTkxZICkgKVxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xuI2VuZGlmYCwgS2wgPSBgI2lmZGVmIFVTRV9VVlxuXHQjaWZkZWYgVVZTX1ZFUlRFWF9PTkxZXG5cdFx0dmVjMiB2VXY7XG5cdCNlbHNlXG5cdFx0dmFyeWluZyB2ZWMyIHZVdjtcblx0I2VuZGlmXG5cdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcbiNlbmRpZmAsIEpsID0gYCNpZmRlZiBVU0VfVVZcblx0dlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTtcbiNlbmRpZmAsIFFsID0gYCNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcbiNlbmRpZmAsIGVjID0gYCNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxuXHRhdHRyaWJ1dGUgdmVjMiB1djI7XG5cdHZhcnlpbmcgdmVjMiB2VXYyO1xuXHR1bmlmb3JtIG1hdDMgdXYyVHJhbnNmb3JtO1xuI2VuZGlmYCwgdGMgPSBgI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXG5cdHZVdjIgPSAoIHV2MlRyYW5zZm9ybSAqIHZlYzMoIHV2MiwgMSApICkueHk7XG4jZW5kaWZgLCBuYyA9IGAjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIERJU1RBTkNFICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKSB8fCBkZWZpbmVkICggVVNFX1RSQU5TTUlTU0lPTiApXG5cdHZlYzQgd29ybGRQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcblx0I2lmZGVmIFVTRV9JTlNUQU5DSU5HXG5cdFx0d29ybGRQb3NpdGlvbiA9IGluc3RhbmNlTWF0cml4ICogd29ybGRQb3NpdGlvbjtcblx0I2VuZGlmXG5cdHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHdvcmxkUG9zaXRpb247XG4jZW5kaWZgO1xuY29uc3QgaWMgPSBgdmFyeWluZyB2ZWMyIHZVdjtcbnVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcbnZvaWQgbWFpbigpIHtcblx0dlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTtcblx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbi54eSwgMS4wLCAxLjAgKTtcbn1gLCBzYyA9IGB1bmlmb3JtIHNhbXBsZXIyRCB0MkQ7XG52YXJ5aW5nIHZlYzIgdlV2O1xudm9pZCBtYWluKCkge1xuXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHQyRCwgdlV2ICk7XG5cdCNpZmRlZiBERUNPREVfVklERU9fVEVYVFVSRVxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG1peCggcG93KCBnbF9GcmFnQ29sb3IucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIGdsX0ZyYWdDb2xvci5yZ2IgKiAwLjA3NzM5OTM4MDgsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIGdsX0ZyYWdDb2xvci5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgZ2xfRnJhZ0NvbG9yLncgKTtcblx0I2VuZGlmXG5cdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cblx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cbn1gLCByYyA9IGB2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xuI2luY2x1ZGUgPGNvbW1vbj5cbnZvaWQgbWFpbigpIHtcblx0dldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcblx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXHRnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udztcbn1gLCBvYyA9IGAjaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG52b2lkIG1haW4oKSB7XG5cdHZlYzMgdlJlZmxlY3QgPSB2V29ybGREaXJlY3Rpb247XG5cdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XG5cdGdsX0ZyYWdDb2xvciA9IGVudkNvbG9yO1xuXHRnbF9GcmFnQ29sb3IuYSAqPSBvcGFjaXR5O1xuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XG59YCwgYWMgPSBgI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XG52b2lkIG1haW4oKSB7XG5cdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XG5cdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXG5cdFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cblx0XHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxuXHRcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cblx0I2VuZGlmXG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxuXHR2SGlnaFByZWNpc2lvblpXID0gZ2xfUG9zaXRpb24uenc7XG59YCwgbGMgPSBgI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxuXHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG4jZW5kaWZcbiNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8cGFja2luZz5cbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cbnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXO1xudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xuXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXG5cdFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xuXHQjZW5kaWZcblx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XG5cdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTtcblx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCAtIGZyYWdDb29yZFogKSwgb3BhY2l0eSApO1xuXHQjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcblx0XHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGZyYWdDb29yZFogKTtcblx0I2VuZGlmXG59YCwgY2MgPSBgI2RlZmluZSBESVNUQU5DRVxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Plxudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxuXHQjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxuXHRcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XG5cdFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cblx0XHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XG5cdCNlbmRpZlxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbn1gLCBoYyA9IGAjZGVmaW5lIERJU1RBTkNFXG51bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247XG51bmlmb3JtIGZsb2F0IG5lYXJEaXN0YW5jZTtcbnVuaWZvcm0gZmxvYXQgZmFyRGlzdGFuY2U7XG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG4jaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHBhY2tpbmc+XG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Plxudm9pZCBtYWluICgpIHtcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcblx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxuXHRmbG9hdCBkaXN0ID0gbGVuZ3RoKCB2V29ybGRQb3NpdGlvbiAtIHJlZmVyZW5jZVBvc2l0aW9uICk7XG5cdGRpc3QgPSAoIGRpc3QgLSBuZWFyRGlzdGFuY2UgKSAvICggZmFyRGlzdGFuY2UgLSBuZWFyRGlzdGFuY2UgKTtcblx0ZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7XG5cdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZGlzdCApO1xufWAsIHVjID0gYHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XG4jaW5jbHVkZSA8Y29tbW9uPlxudm9pZCBtYWluKCkge1xuXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG59YCwgZGMgPSBgdW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcbiNpbmNsdWRlIDxjb21tb24+XG52b2lkIG1haW4oKSB7XG5cdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTtcblx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xuXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxufWAsIGZjID0gYHVuaWZvcm0gZmxvYXQgc2NhbGU7XG5hdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1xudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Plxudm9pZCBtYWluKCkge1xuXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cblx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XG59YCwgcGMgPSBgdW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xudW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XG4jaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XG5cdFx0ZGlzY2FyZDtcblx0fVxuXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxuXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcblx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cbn1gLCBtYyA9IGAjaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cblx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cblx0I2lmIGRlZmluZWQgKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9TS0lOTklORyApXG5cdFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cblx0XHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxuXHRcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XG5cdFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxuXHRcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cblx0I2VuZGlmXG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cbn1gLCBnYyA9IGB1bmlmb3JtIHZlYzMgZGlmZnVzZTtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbiNpZm5kZWYgRkxBVF9TSEFERURcblx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XG4jZW5kaWZcbiNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Plxudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxuXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xuXHQjaWZkZWYgVVNFX0xJR0hUTUFQXG5cdFx0dmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1xuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5ICogUkVDSVBST0NBTF9QSTtcblx0I2Vsc2Vcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdmVjMyggMS4wICk7XG5cdCNlbmRpZlxuXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiO1xuXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XG5cdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cblx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cblx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cblx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XG59YCwgX2MgPSBgI2RlZmluZSBMQU1CRVJUXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XG52YXJ5aW5nIHZlYzMgdkluZGlyZWN0RnJvbnQ7XG4jaWZkZWYgRE9VQkxFX1NJREVEXG5cdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xuXHR2YXJ5aW5nIHZlYzMgdkluZGlyZWN0QmFjaztcbiNlbmRpZlxuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGJzZGZzPlxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Plxudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxuXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cblx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxuXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cblx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cbn1gLCB2YyA9IGB1bmlmb3JtIHZlYzMgZGlmZnVzZTtcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcbnZhcnlpbmcgdmVjMyB2SW5kaXJlY3RGcm9udDtcbiNpZmRlZiBET1VCTEVfU0lERURcblx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XG5cdHZhcnlpbmcgdmVjMyB2SW5kaXJlY3RCYWNrO1xuI2VuZGlmXG4jaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHBhY2tpbmc+XG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cbiNpbmNsdWRlIDxic2Rmcz5cbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Plxudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcblx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcblx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XG5cdCNpZmRlZiBET1VCTEVfU0lERURcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gKCBnbF9Gcm9udEZhY2luZyApID8gdkluZGlyZWN0RnJvbnQgOiB2SW5kaXJlY3RCYWNrO1xuXHQjZWxzZVxuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB2SW5kaXJlY3RGcm9udDtcblx0I2VuZGlmXG5cdCNpbmNsdWRlIDxsaWdodG1hcF9mcmFnbWVudD5cblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IEJSREZfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApO1xuXHQjaWZkZWYgRE9VQkxFX1NJREVEXG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcblx0I2Vsc2Vcblx0XHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gdkxpZ2h0RnJvbnQ7XG5cdCNlbmRpZlxuXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApICogZ2V0U2hhZG93TWFzaygpO1xuXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XG5cdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XG5cdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cblx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cblx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cblx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XG59YCwgeGMgPSBgI2RlZmluZSBNQVRDQVBcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XG52b2lkIG1haW4oKSB7XG5cdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cblx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XG5cdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xufWAsIHljID0gYCNkZWZpbmUgTUFUQ0FQXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDtcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cblx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cblx0dmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XG5cdHZlYzMgeCA9IG5vcm1hbGl6ZSggdmVjMyggdmlld0Rpci56LCAwLjAsIC0gdmlld0Rpci54ICkgKTtcblx0dmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTtcblx0dmVjMiB1diA9IHZlYzIoIGRvdCggeCwgbm9ybWFsICksIGRvdCggeSwgbm9ybWFsICkgKSAqIDAuNDk1ICsgMC41O1xuXHQjaWZkZWYgVVNFX01BVENBUFxuXHRcdHZlYzQgbWF0Y2FwQ29sb3IgPSB0ZXh0dXJlMkQoIG1hdGNhcCwgdXYgKTtcblx0I2Vsc2Vcblx0XHR2ZWM0IG1hdGNhcENvbG9yID0gdmVjNCggdmVjMyggbWl4KCAwLjIsIDAuOCwgdXYueSApICksIDEuMCApO1xuXHQjZW5kaWZcblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYiAqIG1hdGNhcENvbG9yLnJnYjtcblx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cbn1gLCBiYyA9IGAjZGVmaW5lIE5PUk1BTFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcblx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XG4jZW5kaWZcbiNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XG52b2lkIG1haW4oKSB7XG5cdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cblx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxuXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcbiNlbmRpZlxufWAsIHdjID0gYCNkZWZpbmUgTk9STUFMXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxuXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcbiNlbmRpZlxuI2luY2x1ZGUgPHBhY2tpbmc+XG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxuXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIG9wYWNpdHkgKTtcblx0I2lmZGVmIE9QQVFVRVxuXHRcdGdsX0ZyYWdDb2xvci5hID0gMS4wO1xuXHQjZW5kaWZcbn1gLCBNYyA9IGAjZGVmaW5lIFBIT05HXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcbiNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Plxudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxuXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cblx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxuXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxuXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcblx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cblx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cbn1gLCBTYyA9IGAjZGVmaW5lIFBIT05HXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxwYWNraW5nPlxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YnNkZnM+XG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XG5cdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XG5cdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cblx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cblx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxuXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+XG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cblx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XG5cdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcblx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cbn1gLCBFYyA9IGAjZGVmaW5lIFNUQU5EQVJEXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcbiNlbmRpZlxuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cblx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cblx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXG5cdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XG4jZW5kaWZcbn1gLCBUYyA9IGAjZGVmaW5lIFNUQU5EQVJEXG4jaWZkZWYgUEhZU0lDQUxcblx0I2RlZmluZSBJT1Jcblx0I2RlZmluZSBTUEVDVUxBUlxuI2VuZGlmXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xudW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG4jaWZkZWYgSU9SXG5cdHVuaWZvcm0gZmxvYXQgaW9yO1xuI2VuZGlmXG4jaWZkZWYgU1BFQ1VMQVJcblx0dW5pZm9ybSBmbG9hdCBzcGVjdWxhckludGVuc2l0eTtcblx0dW5pZm9ybSB2ZWMzIHNwZWN1bGFyQ29sb3I7XG5cdCNpZmRlZiBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckludGVuc2l0eU1hcDtcblx0I2VuZGlmXG5cdCNpZmRlZiBVU0VfU1BFQ1VMQVJDT0xPUk1BUFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyQ29sb3JNYXA7XG5cdCNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxuXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdDtcblx0dW5pZm9ybSBmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7XG4jZW5kaWZcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0Vcblx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZTtcblx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZUlPUjtcblx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XG5cdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xuI2VuZGlmXG4jaWZkZWYgVVNFX1NIRUVOXG5cdHVuaWZvcm0gdmVjMyBzaGVlbkNvbG9yO1xuXHR1bmlmb3JtIGZsb2F0IHNoZWVuUm91Z2huZXNzO1xuXHQjaWZkZWYgVVNFX1NIRUVOQ09MT1JNQVBcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBzaGVlbkNvbG9yTWFwO1xuXHQjZW5kaWZcblx0I2lmZGVmIFVTRV9TSEVFTlJPVUdITkVTU01BUFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuUm91Z2huZXNzTWFwO1xuXHQjZW5kaWZcbiNlbmRpZlxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XG4jaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHBhY2tpbmc+XG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YnNkZnM+XG4jaW5jbHVkZSA8aXJpZGVzY2VuY2VfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Y2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8aXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Plxudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcblx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcblx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cblx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxuXHQjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbj5cblx0I2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcz5cblx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfZW5kPlxuXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XG5cdHZlYzMgdG90YWxEaWZmdXNlID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcblx0dmVjMyB0b3RhbFNwZWN1bGFyID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyO1xuXHQjaW5jbHVkZSA8dHJhbnNtaXNzaW9uX2ZyYWdtZW50PlxuXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB0b3RhbERpZmZ1c2UgKyB0b3RhbFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xuXHQjaWZkZWYgVVNFX1NIRUVOXG5cdFx0ZmxvYXQgc2hlZW5FbmVyZ3lDb21wID0gMS4wIC0gMC4xNTcgKiBtYXgzKCBtYXRlcmlhbC5zaGVlbkNvbG9yICk7XG5cdFx0b3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiBzaGVlbkVuZXJneUNvbXAgKyBzaGVlblNwZWN1bGFyO1xuXHQjZW5kaWZcblx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcblx0XHRmbG9hdCBkb3ROVmNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcblx0XHR2ZWMzIEZjYyA9IEZfU2NobGljayggbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgZG90TlZjYyApO1xuXHRcdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogKCAxLjAgLSBtYXRlcmlhbC5jbGVhcmNvYXQgKiBGY2MgKSArIGNsZWFyY29hdFNwZWN1bGFyICogbWF0ZXJpYWwuY2xlYXJjb2F0O1xuXHQjZW5kaWZcblx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cbn1gLCBBYyA9IGAjZGVmaW5lIFRPT05cbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cblx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cblx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cbn1gLCBDYyA9IGAjZGVmaW5lIFRPT05cbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxwYWNraW5nPlxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YnNkZnM+XG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XG5cdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XG5cdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cblx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cblx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bGlnaHRzX3Rvb25fZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+XG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cblx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XG5cdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcblx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cblx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cbn1gLCBMYyA9IGB1bmlmb3JtIGZsb2F0IHNpemU7XG51bmlmb3JtIGZsb2F0IHNjYWxlO1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Plxudm9pZCBtYWluKCkge1xuXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cblx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcblx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cblx0XHRib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0aWYgKCBpc1BlcnNwZWN0aXZlICkgZ2xfUG9pbnRTaXplICo9ICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1xuXHQjZW5kaWZcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxufWAsIFJjID0gYHVuaWZvcm0gdmVjMyBkaWZmdXNlO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XG52b2lkIG1haW4oKSB7XG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XG5cdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XG5cdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xuXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxufWAsIEZjID0gYCNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cbnZvaWQgbWFpbigpIHtcblx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cblx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cblx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxufWAsIERjID0gYHVuaWZvcm0gdmVjMyBjb2xvcjtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbiNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8cGFja2luZz5cbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxic2Rmcz5cbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XG52b2lkIG1haW4oKSB7XG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XG59YCwgUGMgPSBgdW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcbnVuaWZvcm0gdmVjMiBjZW50ZXI7XG4jaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XG52b2lkIG1haW4oKSB7XG5cdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xuXHR2ZWMyIHNjYWxlO1xuXHRzY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLngsIG1vZGVsTWF0cml4WyAwIF0ueSwgbW9kZWxNYXRyaXhbIDAgXS56ICkgKTtcblx0c2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54LCBtb2RlbE1hdHJpeFsgMSBdLnksIG1vZGVsTWF0cml4WyAxIF0ueiApICk7XG5cdCNpZm5kZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxuXHRcdGJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTtcblx0XHRpZiAoIGlzUGVyc3BlY3RpdmUgKSBzY2FsZSAqPSAtIG12UG9zaXRpb24uejtcblx0I2VuZGlmXG5cdHZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGU7XG5cdHZlYzIgcm90YXRlZFBvc2l0aW9uO1xuXHRyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XG5cdHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcblx0bXZQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247XG5cdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cbn1gLCBJYyA9IGB1bmlmb3JtIHZlYzMgZGlmZnVzZTtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbiNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XG52b2lkIG1haW4oKSB7XG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XG5cdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XG5cdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xuXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XG5cdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XG59YCwgVGUgPSB7XG4gIGFscGhhbWFwX2ZyYWdtZW50OiBvYSxcbiAgYWxwaGFtYXBfcGFyc19mcmFnbWVudDogYWEsXG4gIGFscGhhdGVzdF9mcmFnbWVudDogbGEsXG4gIGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50OiBjYSxcbiAgYW9tYXBfZnJhZ21lbnQ6IGhhLFxuICBhb21hcF9wYXJzX2ZyYWdtZW50OiB1YSxcbiAgYmVnaW5fdmVydGV4OiBkYSxcbiAgYmVnaW5ub3JtYWxfdmVydGV4OiBmYSxcbiAgYnNkZnM6IHBhLFxuICBpcmlkZXNjZW5jZV9mcmFnbWVudDogbWEsXG4gIGJ1bXBtYXBfcGFyc19mcmFnbWVudDogZ2EsXG4gIGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudDogX2EsXG4gIGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiB2YSxcbiAgY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4OiB4YSxcbiAgY2xpcHBpbmdfcGxhbmVzX3ZlcnRleDogeWEsXG4gIGNvbG9yX2ZyYWdtZW50OiBiYSxcbiAgY29sb3JfcGFyc19mcmFnbWVudDogd2EsXG4gIGNvbG9yX3BhcnNfdmVydGV4OiBNYSxcbiAgY29sb3JfdmVydGV4OiBTYSxcbiAgY29tbW9uOiBFYSxcbiAgY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50OiBUYSxcbiAgZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6IEFhLFxuICBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IENhLFxuICBkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBMYSxcbiAgZW1pc3NpdmVtYXBfZnJhZ21lbnQ6IFJhLFxuICBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBGYSxcbiAgZW5jb2RpbmdzX2ZyYWdtZW50OiBEYSxcbiAgZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQ6IFBhLFxuICBlbnZtYXBfZnJhZ21lbnQ6IElhLFxuICBlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ6IHphLFxuICBlbnZtYXBfcGFyc19mcmFnbWVudDogQmEsXG4gIGVudm1hcF9wYXJzX3ZlcnRleDogTmEsXG4gIGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBZYSxcbiAgZW52bWFwX3ZlcnRleDogT2EsXG4gIGZvZ192ZXJ0ZXg6IFVhLFxuICBmb2dfcGFyc192ZXJ0ZXg6IEdhLFxuICBmb2dfZnJhZ21lbnQ6IGthLFxuICBmb2dfcGFyc19mcmFnbWVudDogV2EsXG4gIGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ6IFZhLFxuICBsaWdodG1hcF9mcmFnbWVudDogSGEsXG4gIGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6IHFhLFxuICBsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IFhhLFxuICBsaWdodHNfcGFyc19iZWdpbjogamEsXG4gIGxpZ2h0c190b29uX2ZyYWdtZW50OiBaYSxcbiAgbGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudDogJGEsXG4gIGxpZ2h0c19waG9uZ19mcmFnbWVudDogS2EsXG4gIGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OiBKYSxcbiAgbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50OiBRYSxcbiAgbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGVsLFxuICBsaWdodHNfZnJhZ21lbnRfYmVnaW46IHRsLFxuICBsaWdodHNfZnJhZ21lbnRfbWFwczogbmwsXG4gIGxpZ2h0c19mcmFnbWVudF9lbmQ6IGlsLFxuICBsb2dkZXB0aGJ1Zl9mcmFnbWVudDogc2wsXG4gIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IHJsLFxuICBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogb2wsXG4gIGxvZ2RlcHRoYnVmX3ZlcnRleDogYWwsXG4gIG1hcF9mcmFnbWVudDogbGwsXG4gIG1hcF9wYXJzX2ZyYWdtZW50OiBjbCxcbiAgbWFwX3BhcnRpY2xlX2ZyYWdtZW50OiBobCxcbiAgbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ6IHVsLFxuICBtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IGRsLFxuICBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogZmwsXG4gIG1vcnBoY29sb3JfdmVydGV4OiBwbCxcbiAgbW9ycGhub3JtYWxfdmVydGV4OiBtbCxcbiAgbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IGdsLFxuICBtb3JwaHRhcmdldF92ZXJ0ZXg6IF9sLFxuICBub3JtYWxfZnJhZ21lbnRfYmVnaW46IHZsLFxuICBub3JtYWxfZnJhZ21lbnRfbWFwczogeGwsXG4gIG5vcm1hbF9wYXJzX2ZyYWdtZW50OiB5bCxcbiAgbm9ybWFsX3BhcnNfdmVydGV4OiBibCxcbiAgbm9ybWFsX3ZlcnRleDogd2wsXG4gIG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OiBNbCxcbiAgY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjogU2wsXG4gIGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwczogRWwsXG4gIGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50OiBUbCxcbiAgaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudDogQWwsXG4gIG91dHB1dF9mcmFnbWVudDogQ2wsXG4gIHBhY2tpbmc6IExsLFxuICBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OiBSbCxcbiAgcHJvamVjdF92ZXJ0ZXg6IEZsLFxuICBkaXRoZXJpbmdfZnJhZ21lbnQ6IERsLFxuICBkaXRoZXJpbmdfcGFyc19mcmFnbWVudDogUGwsXG4gIHJvdWdobmVzc21hcF9mcmFnbWVudDogSWwsXG4gIHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50OiB6bCxcbiAgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IEJsLFxuICBzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IE5sLFxuICBzaGFkb3dtYXBfdmVydGV4OiBPbCxcbiAgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50OiBVbCxcbiAgc2tpbmJhc2VfdmVydGV4OiBHbCxcbiAgc2tpbm5pbmdfcGFyc192ZXJ0ZXg6IGtsLFxuICBza2lubmluZ192ZXJ0ZXg6IFdsLFxuICBza2lubm9ybWFsX3ZlcnRleDogVmwsXG4gIHNwZWN1bGFybWFwX2ZyYWdtZW50OiBIbCxcbiAgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDogcWwsXG4gIHRvbmVtYXBwaW5nX2ZyYWdtZW50OiBYbCxcbiAgdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDogamwsXG4gIHRyYW5zbWlzc2lvbl9mcmFnbWVudDogWWwsXG4gIHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50OiBabCxcbiAgdXZfcGFyc19mcmFnbWVudDogJGwsXG4gIHV2X3BhcnNfdmVydGV4OiBLbCxcbiAgdXZfdmVydGV4OiBKbCxcbiAgdXYyX3BhcnNfZnJhZ21lbnQ6IFFsLFxuICB1djJfcGFyc192ZXJ0ZXg6IGVjLFxuICB1djJfdmVydGV4OiB0YyxcbiAgd29ybGRwb3NfdmVydGV4OiBuYyxcbiAgYmFja2dyb3VuZF92ZXJ0OiBpYyxcbiAgYmFja2dyb3VuZF9mcmFnOiBzYyxcbiAgY3ViZV92ZXJ0OiByYyxcbiAgY3ViZV9mcmFnOiBvYyxcbiAgZGVwdGhfdmVydDogYWMsXG4gIGRlcHRoX2ZyYWc6IGxjLFxuICBkaXN0YW5jZVJHQkFfdmVydDogY2MsXG4gIGRpc3RhbmNlUkdCQV9mcmFnOiBoYyxcbiAgZXF1aXJlY3RfdmVydDogdWMsXG4gIGVxdWlyZWN0X2ZyYWc6IGRjLFxuICBsaW5lZGFzaGVkX3ZlcnQ6IGZjLFxuICBsaW5lZGFzaGVkX2ZyYWc6IHBjLFxuICBtZXNoYmFzaWNfdmVydDogbWMsXG4gIG1lc2hiYXNpY19mcmFnOiBnYyxcbiAgbWVzaGxhbWJlcnRfdmVydDogX2MsXG4gIG1lc2hsYW1iZXJ0X2ZyYWc6IHZjLFxuICBtZXNobWF0Y2FwX3ZlcnQ6IHhjLFxuICBtZXNobWF0Y2FwX2ZyYWc6IHljLFxuICBtZXNobm9ybWFsX3ZlcnQ6IGJjLFxuICBtZXNobm9ybWFsX2ZyYWc6IHdjLFxuICBtZXNocGhvbmdfdmVydDogTWMsXG4gIG1lc2hwaG9uZ19mcmFnOiBTYyxcbiAgbWVzaHBoeXNpY2FsX3ZlcnQ6IEVjLFxuICBtZXNocGh5c2ljYWxfZnJhZzogVGMsXG4gIG1lc2h0b29uX3ZlcnQ6IEFjLFxuICBtZXNodG9vbl9mcmFnOiBDYyxcbiAgcG9pbnRzX3ZlcnQ6IExjLFxuICBwb2ludHNfZnJhZzogUmMsXG4gIHNoYWRvd192ZXJ0OiBGYyxcbiAgc2hhZG93X2ZyYWc6IERjLFxuICBzcHJpdGVfdmVydDogUGMsXG4gIHNwcml0ZV9mcmFnOiBJY1xufSwgbmUgPSB7XG4gIGNvbW1vbjoge1xuICAgIGRpZmZ1c2U6IHsgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgQWUoMTY3NzcyMTUpIH0sXG4gICAgb3BhY2l0eTogeyB2YWx1ZTogMSB9LFxuICAgIG1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IE10KCkgfSxcbiAgICB1djJUcmFuc2Zvcm06IHsgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXQoKSB9LFxuICAgIGFscGhhTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgYWxwaGFUZXN0OiB7IHZhbHVlOiAwIH1cbiAgfSxcbiAgc3BlY3VsYXJtYXA6IHtcbiAgICBzcGVjdWxhck1hcDogeyB2YWx1ZTogbnVsbCB9XG4gIH0sXG4gIGVudm1hcDoge1xuICAgIGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIGZsaXBFbnZNYXA6IHsgdmFsdWU6IC0xIH0sXG4gICAgcmVmbGVjdGl2aXR5OiB7IHZhbHVlOiAxIH0sXG4gICAgaW9yOiB7IHZhbHVlOiAxLjUgfSxcbiAgICByZWZyYWN0aW9uUmF0aW86IHsgdmFsdWU6IDAuOTggfVxuICB9LFxuICBhb21hcDoge1xuICAgIGFvTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgYW9NYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxuICB9LFxuICBsaWdodG1hcDoge1xuICAgIGxpZ2h0TWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgbGlnaHRNYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxuICB9LFxuICBlbWlzc2l2ZW1hcDoge1xuICAgIGVtaXNzaXZlTWFwOiB7IHZhbHVlOiBudWxsIH1cbiAgfSxcbiAgYnVtcG1hcDoge1xuICAgIGJ1bXBNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBidW1wU2NhbGU6IHsgdmFsdWU6IDEgfVxuICB9LFxuICBub3JtYWxtYXA6IHtcbiAgICBub3JtYWxNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBub3JtYWxTY2FsZTogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBDZSgxLCAxKSB9XG4gIH0sXG4gIGRpc3BsYWNlbWVudG1hcDoge1xuICAgIGRpc3BsYWNlbWVudE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIGRpc3BsYWNlbWVudFNjYWxlOiB7IHZhbHVlOiAxIH0sXG4gICAgZGlzcGxhY2VtZW50QmlhczogeyB2YWx1ZTogMCB9XG4gIH0sXG4gIHJvdWdobmVzc21hcDoge1xuICAgIHJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XG4gIH0sXG4gIG1ldGFsbmVzc21hcDoge1xuICAgIG1ldGFsbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XG4gIH0sXG4gIGdyYWRpZW50bWFwOiB7XG4gICAgZ3JhZGllbnRNYXA6IHsgdmFsdWU6IG51bGwgfVxuICB9LFxuICBmb2c6IHtcbiAgICBmb2dEZW5zaXR5OiB7IHZhbHVlOiAyNWUtNSB9LFxuICAgIGZvZ05lYXI6IHsgdmFsdWU6IDEgfSxcbiAgICBmb2dGYXI6IHsgdmFsdWU6IDJlMyB9LFxuICAgIGZvZ0NvbG9yOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDE2Nzc3MjE1KSB9XG4gIH0sXG4gIGxpZ2h0czoge1xuICAgIGFtYmllbnRMaWdodENvbG9yOiB7IHZhbHVlOiBbXSB9LFxuICAgIGxpZ2h0UHJvYmU6IHsgdmFsdWU6IFtdIH0sXG4gICAgZGlyZWN0aW9uYWxMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG4gICAgICBkaXJlY3Rpb246IHt9LFxuICAgICAgY29sb3I6IHt9XG4gICAgfSB9LFxuICAgIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuICAgICAgc2hhZG93Qmlhczoge30sXG4gICAgICBzaGFkb3dOb3JtYWxCaWFzOiB7fSxcbiAgICAgIHNoYWRvd1JhZGl1czoge30sXG4gICAgICBzaGFkb3dNYXBTaXplOiB7fVxuICAgIH0gfSxcbiAgICBkaXJlY3Rpb25hbFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcbiAgICBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcbiAgICBzcG90TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuICAgICAgY29sb3I6IHt9LFxuICAgICAgcG9zaXRpb246IHt9LFxuICAgICAgZGlyZWN0aW9uOiB7fSxcbiAgICAgIGRpc3RhbmNlOiB7fSxcbiAgICAgIGNvbmVDb3M6IHt9LFxuICAgICAgcGVudW1icmFDb3M6IHt9LFxuICAgICAgZGVjYXk6IHt9XG4gICAgfSB9LFxuICAgIHNwb3RMaWdodFNoYWRvd3M6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG4gICAgICBzaGFkb3dCaWFzOiB7fSxcbiAgICAgIHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuICAgICAgc2hhZG93UmFkaXVzOiB7fSxcbiAgICAgIHNoYWRvd01hcFNpemU6IHt9XG4gICAgfSB9LFxuICAgIHNwb3RTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG4gICAgc3BvdFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcbiAgICBwb2ludExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcbiAgICAgIGNvbG9yOiB7fSxcbiAgICAgIHBvc2l0aW9uOiB7fSxcbiAgICAgIGRlY2F5OiB7fSxcbiAgICAgIGRpc3RhbmNlOiB7fVxuICAgIH0gfSxcbiAgICBwb2ludExpZ2h0U2hhZG93czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcbiAgICAgIHNoYWRvd0JpYXM6IHt9LFxuICAgICAgc2hhZG93Tm9ybWFsQmlhczoge30sXG4gICAgICBzaGFkb3dSYWRpdXM6IHt9LFxuICAgICAgc2hhZG93TWFwU2l6ZToge30sXG4gICAgICBzaGFkb3dDYW1lcmFOZWFyOiB7fSxcbiAgICAgIHNoYWRvd0NhbWVyYUZhcjoge31cbiAgICB9IH0sXG4gICAgcG9pbnRTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG4gICAgcG9pbnRTaGFkb3dNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXG4gICAgaGVtaXNwaGVyZUxpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcbiAgICAgIGRpcmVjdGlvbjoge30sXG4gICAgICBza3lDb2xvcjoge30sXG4gICAgICBncm91bmRDb2xvcjoge31cbiAgICB9IH0sXG4gICAgcmVjdEFyZWFMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG4gICAgICBjb2xvcjoge30sXG4gICAgICBwb3NpdGlvbjoge30sXG4gICAgICB3aWR0aDoge30sXG4gICAgICBoZWlnaHQ6IHt9XG4gICAgfSB9LFxuICAgIGx0Y18xOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgbHRjXzI6IHsgdmFsdWU6IG51bGwgfVxuICB9LFxuICBwb2ludHM6IHtcbiAgICBkaWZmdXNlOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDE2Nzc3MjE1KSB9LFxuICAgIG9wYWNpdHk6IHsgdmFsdWU6IDEgfSxcbiAgICBzaXplOiB7IHZhbHVlOiAxIH0sXG4gICAgc2NhbGU6IHsgdmFsdWU6IDEgfSxcbiAgICBtYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBhbHBoYU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIGFscGhhVGVzdDogeyB2YWx1ZTogMCB9LFxuICAgIHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IE10KCkgfVxuICB9LFxuICBzcHJpdGU6IHtcbiAgICBkaWZmdXNlOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDE2Nzc3MjE1KSB9LFxuICAgIG9wYWNpdHk6IHsgdmFsdWU6IDEgfSxcbiAgICBjZW50ZXI6IHsgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgQ2UoMC41LCAwLjUpIH0sXG4gICAgcm90YXRpb246IHsgdmFsdWU6IDAgfSxcbiAgICBtYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBhbHBoYU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIGFscGhhVGVzdDogeyB2YWx1ZTogMCB9LFxuICAgIHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IE10KCkgfVxuICB9XG59LCBCdCA9IHtcbiAgYmFzaWM6IHtcbiAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIGl0KFtcbiAgICAgIG5lLmNvbW1vbixcbiAgICAgIG5lLnNwZWN1bGFybWFwLFxuICAgICAgbmUuZW52bWFwLFxuICAgICAgbmUuYW9tYXAsXG4gICAgICBuZS5saWdodG1hcCxcbiAgICAgIG5lLmZvZ1xuICAgIF0pLFxuICAgIHZlcnRleFNoYWRlcjogVGUubWVzaGJhc2ljX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFRlLm1lc2hiYXNpY19mcmFnXG4gIH0sXG4gIGxhbWJlcnQ6IHtcbiAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIGl0KFtcbiAgICAgIG5lLmNvbW1vbixcbiAgICAgIG5lLnNwZWN1bGFybWFwLFxuICAgICAgbmUuZW52bWFwLFxuICAgICAgbmUuYW9tYXAsXG4gICAgICBuZS5saWdodG1hcCxcbiAgICAgIG5lLmVtaXNzaXZlbWFwLFxuICAgICAgbmUuZm9nLFxuICAgICAgbmUubGlnaHRzLFxuICAgICAge1xuICAgICAgICBlbWlzc2l2ZTogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBBZSgwKSB9XG4gICAgICB9XG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5tZXNobGFtYmVydF92ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBUZS5tZXNobGFtYmVydF9mcmFnXG4gIH0sXG4gIHBob25nOiB7XG4gICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBpdChbXG4gICAgICBuZS5jb21tb24sXG4gICAgICBuZS5zcGVjdWxhcm1hcCxcbiAgICAgIG5lLmVudm1hcCxcbiAgICAgIG5lLmFvbWFwLFxuICAgICAgbmUubGlnaHRtYXAsXG4gICAgICBuZS5lbWlzc2l2ZW1hcCxcbiAgICAgIG5lLmJ1bXBtYXAsXG4gICAgICBuZS5ub3JtYWxtYXAsXG4gICAgICBuZS5kaXNwbGFjZW1lbnRtYXAsXG4gICAgICBuZS5mb2csXG4gICAgICBuZS5saWdodHMsXG4gICAgICB7XG4gICAgICAgIGVtaXNzaXZlOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDApIH0sXG4gICAgICAgIHNwZWN1bGFyOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDExMTg0ODEpIH0sXG4gICAgICAgIHNoaW5pbmVzczogeyB2YWx1ZTogMzAgfVxuICAgICAgfVxuICAgIF0pLFxuICAgIHZlcnRleFNoYWRlcjogVGUubWVzaHBob25nX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFRlLm1lc2hwaG9uZ19mcmFnXG4gIH0sXG4gIHN0YW5kYXJkOiB7XG4gICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBpdChbXG4gICAgICBuZS5jb21tb24sXG4gICAgICBuZS5lbnZtYXAsXG4gICAgICBuZS5hb21hcCxcbiAgICAgIG5lLmxpZ2h0bWFwLFxuICAgICAgbmUuZW1pc3NpdmVtYXAsXG4gICAgICBuZS5idW1wbWFwLFxuICAgICAgbmUubm9ybWFsbWFwLFxuICAgICAgbmUuZGlzcGxhY2VtZW50bWFwLFxuICAgICAgbmUucm91Z2huZXNzbWFwLFxuICAgICAgbmUubWV0YWxuZXNzbWFwLFxuICAgICAgbmUuZm9nLFxuICAgICAgbmUubGlnaHRzLFxuICAgICAge1xuICAgICAgICBlbWlzc2l2ZTogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBBZSgwKSB9LFxuICAgICAgICByb3VnaG5lc3M6IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgbWV0YWxuZXNzOiB7IHZhbHVlOiAwIH0sXG4gICAgICAgIGVudk1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9XG4gICAgICB9XG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5tZXNocGh5c2ljYWxfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogVGUubWVzaHBoeXNpY2FsX2ZyYWdcbiAgfSxcbiAgdG9vbjoge1xuICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gaXQoW1xuICAgICAgbmUuY29tbW9uLFxuICAgICAgbmUuYW9tYXAsXG4gICAgICBuZS5saWdodG1hcCxcbiAgICAgIG5lLmVtaXNzaXZlbWFwLFxuICAgICAgbmUuYnVtcG1hcCxcbiAgICAgIG5lLm5vcm1hbG1hcCxcbiAgICAgIG5lLmRpc3BsYWNlbWVudG1hcCxcbiAgICAgIG5lLmdyYWRpZW50bWFwLFxuICAgICAgbmUuZm9nLFxuICAgICAgbmUubGlnaHRzLFxuICAgICAge1xuICAgICAgICBlbWlzc2l2ZTogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBBZSgwKSB9XG4gICAgICB9XG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5tZXNodG9vbl92ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBUZS5tZXNodG9vbl9mcmFnXG4gIH0sXG4gIG1hdGNhcDoge1xuICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gaXQoW1xuICAgICAgbmUuY29tbW9uLFxuICAgICAgbmUuYnVtcG1hcCxcbiAgICAgIG5lLm5vcm1hbG1hcCxcbiAgICAgIG5lLmRpc3BsYWNlbWVudG1hcCxcbiAgICAgIG5lLmZvZyxcbiAgICAgIHtcbiAgICAgICAgbWF0Y2FwOiB7IHZhbHVlOiBudWxsIH1cbiAgICAgIH1cbiAgICBdKSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IFRlLm1lc2htYXRjYXBfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogVGUubWVzaG1hdGNhcF9mcmFnXG4gIH0sXG4gIHBvaW50czoge1xuICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gaXQoW1xuICAgICAgbmUucG9pbnRzLFxuICAgICAgbmUuZm9nXG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5wb2ludHNfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogVGUucG9pbnRzX2ZyYWdcbiAgfSxcbiAgZGFzaGVkOiB7XG4gICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBpdChbXG4gICAgICBuZS5jb21tb24sXG4gICAgICBuZS5mb2csXG4gICAgICB7XG4gICAgICAgIHNjYWxlOiB7IHZhbHVlOiAxIH0sXG4gICAgICAgIGRhc2hTaXplOiB7IHZhbHVlOiAxIH0sXG4gICAgICAgIHRvdGFsU2l6ZTogeyB2YWx1ZTogMiB9XG4gICAgICB9XG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5saW5lZGFzaGVkX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFRlLmxpbmVkYXNoZWRfZnJhZ1xuICB9LFxuICBkZXB0aDoge1xuICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gaXQoW1xuICAgICAgbmUuY29tbW9uLFxuICAgICAgbmUuZGlzcGxhY2VtZW50bWFwXG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5kZXB0aF92ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBUZS5kZXB0aF9mcmFnXG4gIH0sXG4gIG5vcm1hbDoge1xuICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gaXQoW1xuICAgICAgbmUuY29tbW9uLFxuICAgICAgbmUuYnVtcG1hcCxcbiAgICAgIG5lLm5vcm1hbG1hcCxcbiAgICAgIG5lLmRpc3BsYWNlbWVudG1hcCxcbiAgICAgIHtcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogMSB9XG4gICAgICB9XG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5tZXNobm9ybWFsX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFRlLm1lc2hub3JtYWxfZnJhZ1xuICB9LFxuICBzcHJpdGU6IHtcbiAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIGl0KFtcbiAgICAgIG5lLnNwcml0ZSxcbiAgICAgIG5lLmZvZ1xuICAgIF0pLFxuICAgIHZlcnRleFNoYWRlcjogVGUuc3ByaXRlX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFRlLnNwcml0ZV9mcmFnXG4gIH0sXG4gIGJhY2tncm91bmQ6IHtcbiAgICB1bmlmb3Jtczoge1xuICAgICAgdXZUcmFuc2Zvcm06IHsgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXQoKSB9LFxuICAgICAgdDJEOiB7IHZhbHVlOiBudWxsIH1cbiAgICB9LFxuICAgIHZlcnRleFNoYWRlcjogVGUuYmFja2dyb3VuZF92ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBUZS5iYWNrZ3JvdW5kX2ZyYWdcbiAgfSxcbiAgY3ViZToge1xuICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gaXQoW1xuICAgICAgbmUuZW52bWFwLFxuICAgICAge1xuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiAxIH1cbiAgICAgIH1cbiAgICBdKSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IFRlLmN1YmVfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogVGUuY3ViZV9mcmFnXG4gIH0sXG4gIGVxdWlyZWN0OiB7XG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9XG4gICAgfSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IFRlLmVxdWlyZWN0X3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFRlLmVxdWlyZWN0X2ZyYWdcbiAgfSxcbiAgZGlzdGFuY2VSR0JBOiB7XG4gICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBpdChbXG4gICAgICBuZS5jb21tb24sXG4gICAgICBuZS5kaXNwbGFjZW1lbnRtYXAsXG4gICAgICB7XG4gICAgICAgIHJlZmVyZW5jZVBvc2l0aW9uOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IE8oKSB9LFxuICAgICAgICBuZWFyRGlzdGFuY2U6IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgZmFyRGlzdGFuY2U6IHsgdmFsdWU6IDFlMyB9XG4gICAgICB9XG4gICAgXSksXG4gICAgdmVydGV4U2hhZGVyOiBUZS5kaXN0YW5jZVJHQkFfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogVGUuZGlzdGFuY2VSR0JBX2ZyYWdcbiAgfSxcbiAgc2hhZG93OiB7XG4gICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBpdChbXG4gICAgICBuZS5saWdodHMsXG4gICAgICBuZS5mb2csXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDApIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgdmFsdWU6IDEgfVxuICAgICAgfVxuICAgIF0pLFxuICAgIHZlcnRleFNoYWRlcjogVGUuc2hhZG93X3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFRlLnNoYWRvd19mcmFnXG4gIH1cbn07XG5CdC5waHlzaWNhbCA9IHtcbiAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBpdChbXG4gICAgQnQuc3RhbmRhcmQudW5pZm9ybXMsXG4gICAge1xuICAgICAgY2xlYXJjb2F0OiB7IHZhbHVlOiAwIH0sXG4gICAgICBjbGVhcmNvYXRNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgIGNsZWFyY29hdFJvdWdobmVzczogeyB2YWx1ZTogMCB9LFxuICAgICAgY2xlYXJjb2F0Um91Z2huZXNzTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICBjbGVhcmNvYXROb3JtYWxTY2FsZTogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBDZSgxLCAxKSB9LFxuICAgICAgY2xlYXJjb2F0Tm9ybWFsTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICBpcmlkZXNjZW5jZTogeyB2YWx1ZTogMCB9LFxuICAgICAgaXJpZGVzY2VuY2VNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgIGlyaWRlc2NlbmNlSU9SOiB7IHZhbHVlOiAxLjMgfSxcbiAgICAgIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTogeyB2YWx1ZTogMTAwIH0sXG4gICAgICBpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW06IHsgdmFsdWU6IDQwMCB9LFxuICAgICAgaXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgIHNoZWVuOiB7IHZhbHVlOiAwIH0sXG4gICAgICBzaGVlbkNvbG9yOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDApIH0sXG4gICAgICBzaGVlbkNvbG9yTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICBzaGVlblJvdWdobmVzczogeyB2YWx1ZTogMSB9LFxuICAgICAgc2hlZW5Sb3VnaG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgIHRyYW5zbWlzc2lvbjogeyB2YWx1ZTogMCB9LFxuICAgICAgdHJhbnNtaXNzaW9uTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBDZSgpIH0sXG4gICAgICB0cmFuc21pc3Npb25TYW1wbGVyTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICB0aGlja25lc3M6IHsgdmFsdWU6IDAgfSxcbiAgICAgIHRoaWNrbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgYXR0ZW51YXRpb25EaXN0YW5jZTogeyB2YWx1ZTogMCB9LFxuICAgICAgYXR0ZW51YXRpb25Db2xvcjogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBBZSgwKSB9LFxuICAgICAgc3BlY3VsYXJJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfSxcbiAgICAgIHNwZWN1bGFySW50ZW5zaXR5TWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICBzcGVjdWxhckNvbG9yOiB7IHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3IEFlKDEsIDEsIDEpIH0sXG4gICAgICBzcGVjdWxhckNvbG9yTWFwOiB7IHZhbHVlOiBudWxsIH1cbiAgICB9XG4gIF0pLFxuICB2ZXJ0ZXhTaGFkZXI6IFRlLm1lc2hwaHlzaWNhbF92ZXJ0LFxuICBmcmFnbWVudFNoYWRlcjogVGUubWVzaHBoeXNpY2FsX2ZyYWdcbn07XG5mdW5jdGlvbiB6YyhoLCBlLCB0LCBuLCBpLCBzKSB7XG4gIGNvbnN0IG8gPSBuZXcgQWUoMCk7XG4gIGxldCByID0gaSA9PT0gITAgPyAwIDogMSwgbCwgYSwgYyA9IG51bGwsIGQgPSAwLCB1ID0gbnVsbDtcbiAgZnVuY3Rpb24gbShwLCBmKSB7XG4gICAgbGV0IHYgPSAhMSwgXyA9IGYuaXNTY2VuZSA9PT0gITAgPyBmLmJhY2tncm91bmQgOiBudWxsO1xuICAgIF8gJiYgXy5pc1RleHR1cmUgJiYgKF8gPSBlLmdldChfKSk7XG4gICAgY29uc3QgdyA9IGgueHIsIHggPSB3LmdldFNlc3Npb24gJiYgdy5nZXRTZXNzaW9uKCk7XG4gICAgeCAmJiB4LmVudmlyb25tZW50QmxlbmRNb2RlID09PSBcImFkZGl0aXZlXCIgJiYgKF8gPSBudWxsKSwgXyA9PT0gbnVsbCA/IGcobywgcikgOiBfICYmIF8uaXNDb2xvciAmJiAoZyhfLCAxKSwgdiA9ICEwKSwgKGguYXV0b0NsZWFyIHx8IHYpICYmIGguY2xlYXIoaC5hdXRvQ2xlYXJDb2xvciwgaC5hdXRvQ2xlYXJEZXB0aCwgaC5hdXRvQ2xlYXJTdGVuY2lsKSwgXyAmJiAoXy5pc0N1YmVUZXh0dXJlIHx8IF8ubWFwcGluZyA9PT0gMzA2KSA/IChhID09PSB2b2lkIDAgJiYgKGEgPSBuZXcgTnQoXG4gICAgICBuZXcgcGkoMSwgMSwgMSksXG4gICAgICBuZXcgVG4oe1xuICAgICAgICBuYW1lOiBcIkJhY2tncm91bmRDdWJlTWF0ZXJpYWxcIixcbiAgICAgICAgdW5pZm9ybXM6IFpuKEJ0LmN1YmUudW5pZm9ybXMpLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IEJ0LmN1YmUudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogQnQuY3ViZS5mcmFnbWVudFNoYWRlcixcbiAgICAgICAgc2lkZTogMSxcbiAgICAgICAgZGVwdGhUZXN0OiAhMSxcbiAgICAgICAgZGVwdGhXcml0ZTogITEsXG4gICAgICAgIGZvZzogITFcbiAgICAgIH0pXG4gICAgKSwgYS5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoXCJub3JtYWxcIiksIGEuZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKFwidXZcIiksIGEub25CZWZvcmVSZW5kZXIgPSBmdW5jdGlvbihNLCBFLCBSKSB7XG4gICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHlQb3NpdGlvbihSLm1hdHJpeFdvcmxkKTtcbiAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5tYXRlcmlhbCwgXCJlbnZNYXBcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZW52TWFwLnZhbHVlO1xuICAgICAgfVxuICAgIH0pLCBuLnVwZGF0ZShhKSksIGEubWF0ZXJpYWwudW5pZm9ybXMuZW52TWFwLnZhbHVlID0gXywgYS5tYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gXy5pc0N1YmVUZXh0dXJlICYmIF8uaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSAhMSA/IC0xIDogMSwgKGMgIT09IF8gfHwgZCAhPT0gXy52ZXJzaW9uIHx8IHUgIT09IGgudG9uZU1hcHBpbmcpICYmIChhLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gITAsIGMgPSBfLCBkID0gXy52ZXJzaW9uLCB1ID0gaC50b25lTWFwcGluZyksIGEubGF5ZXJzLmVuYWJsZUFsbCgpLCBwLnVuc2hpZnQoYSwgYS5nZW9tZXRyeSwgYS5tYXRlcmlhbCwgMCwgMCwgbnVsbCkpIDogXyAmJiBfLmlzVGV4dHVyZSAmJiAobCA9PT0gdm9pZCAwICYmIChsID0gbmV3IE50KFxuICAgICAgbmV3IGppKDIsIDIpLFxuICAgICAgbmV3IFRuKHtcbiAgICAgICAgbmFtZTogXCJCYWNrZ3JvdW5kTWF0ZXJpYWxcIixcbiAgICAgICAgdW5pZm9ybXM6IFpuKEJ0LmJhY2tncm91bmQudW5pZm9ybXMpLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IEJ0LmJhY2tncm91bmQudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogQnQuYmFja2dyb3VuZC5mcmFnbWVudFNoYWRlcixcbiAgICAgICAgc2lkZTogMCxcbiAgICAgICAgZGVwdGhUZXN0OiAhMSxcbiAgICAgICAgZGVwdGhXcml0ZTogITEsXG4gICAgICAgIGZvZzogITFcbiAgICAgIH0pXG4gICAgKSwgbC5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoXCJub3JtYWxcIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLm1hdGVyaWFsLCBcIm1hcFwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50MkQudmFsdWU7XG4gICAgICB9XG4gICAgfSksIG4udXBkYXRlKGwpKSwgbC5tYXRlcmlhbC51bmlmb3Jtcy50MkQudmFsdWUgPSBfLCBfLm1hdHJpeEF1dG9VcGRhdGUgPT09ICEwICYmIF8udXBkYXRlTWF0cml4KCksIGwubWF0ZXJpYWwudW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weShfLm1hdHJpeCksIChjICE9PSBfIHx8IGQgIT09IF8udmVyc2lvbiB8fCB1ICE9PSBoLnRvbmVNYXBwaW5nKSAmJiAobC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9ICEwLCBjID0gXywgZCA9IF8udmVyc2lvbiwgdSA9IGgudG9uZU1hcHBpbmcpLCBsLmxheWVycy5lbmFibGVBbGwoKSwgcC51bnNoaWZ0KGwsIGwuZ2VvbWV0cnksIGwubWF0ZXJpYWwsIDAsIDAsIG51bGwpKTtcbiAgfVxuICBmdW5jdGlvbiBnKHAsIGYpIHtcbiAgICB0LmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIocC5yLCBwLmcsIHAuYiwgZiwgcyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRDbGVhckNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG4gICAgc2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24ocCwgZiA9IDEpIHtcbiAgICAgIG8uc2V0KHApLCByID0gZiwgZyhvLCByKTtcbiAgICB9LFxuICAgIGdldENsZWFyQWxwaGE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICBzZXRDbGVhckFscGhhOiBmdW5jdGlvbihwKSB7XG4gICAgICByID0gcCwgZyhvLCByKTtcbiAgICB9LFxuICAgIHJlbmRlcjogbVxuICB9O1xufVxuZnVuY3Rpb24gQmMoaCwgZSwgdCwgbikge1xuICBjb25zdCBpID0gaC5nZXRQYXJhbWV0ZXIoMzQ5MjEpLCBzID0gbi5pc1dlYkdMMiA/IG51bGwgOiBlLmdldChcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpLCBvID0gbi5pc1dlYkdMMiB8fCBzICE9PSBudWxsLCByID0ge30sIGwgPSBmKG51bGwpO1xuICBsZXQgYSA9IGwsIGMgPSAhMTtcbiAgZnVuY3Rpb24gZChMLCBJLCBELCBxLCBrKSB7XG4gICAgbGV0IE4gPSAhMTtcbiAgICBpZiAobykge1xuICAgICAgY29uc3QgSCA9IHAocSwgRCwgSSk7XG4gICAgICBhICE9PSBIICYmIChhID0gSCwgbShhLm9iamVjdCkpLCBOID0gdihMLCBxLCBELCBrKSwgTiAmJiBfKEwsIHEsIEQsIGspO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBIID0gSS53aXJlZnJhbWUgPT09ICEwO1xuICAgICAgKGEuZ2VvbWV0cnkgIT09IHEuaWQgfHwgYS5wcm9ncmFtICE9PSBELmlkIHx8IGEud2lyZWZyYW1lICE9PSBIKSAmJiAoYS5nZW9tZXRyeSA9IHEuaWQsIGEucHJvZ3JhbSA9IEQuaWQsIGEud2lyZWZyYW1lID0gSCwgTiA9ICEwKTtcbiAgICB9XG4gICAgayAhPT0gbnVsbCAmJiB0LnVwZGF0ZShrLCAzNDk2MyksIChOIHx8IGMpICYmIChjID0gITEsIHkoTCwgSSwgRCwgcSksIGsgIT09IG51bGwgJiYgaC5iaW5kQnVmZmVyKDM0OTYzLCB0LmdldChrKS5idWZmZXIpKTtcbiAgfVxuICBmdW5jdGlvbiB1KCkge1xuICAgIHJldHVybiBuLmlzV2ViR0wyID8gaC5jcmVhdGVWZXJ0ZXhBcnJheSgpIDogcy5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuICB9XG4gIGZ1bmN0aW9uIG0oTCkge1xuICAgIHJldHVybiBuLmlzV2ViR0wyID8gaC5iaW5kVmVydGV4QXJyYXkoTCkgOiBzLmJpbmRWZXJ0ZXhBcnJheU9FUyhMKTtcbiAgfVxuICBmdW5jdGlvbiBnKEwpIHtcbiAgICByZXR1cm4gbi5pc1dlYkdMMiA/IGguZGVsZXRlVmVydGV4QXJyYXkoTCkgOiBzLmRlbGV0ZVZlcnRleEFycmF5T0VTKEwpO1xuICB9XG4gIGZ1bmN0aW9uIHAoTCwgSSwgRCkge1xuICAgIGNvbnN0IHEgPSBELndpcmVmcmFtZSA9PT0gITA7XG4gICAgbGV0IGsgPSByW0wuaWRdO1xuICAgIGsgPT09IHZvaWQgMCAmJiAoayA9IHt9LCByW0wuaWRdID0gayk7XG4gICAgbGV0IE4gPSBrW0kuaWRdO1xuICAgIE4gPT09IHZvaWQgMCAmJiAoTiA9IHt9LCBrW0kuaWRdID0gTik7XG4gICAgbGV0IEggPSBOW3FdO1xuICAgIHJldHVybiBIID09PSB2b2lkIDAgJiYgKEggPSBmKHUoKSksIE5bcV0gPSBIKSwgSDtcbiAgfVxuICBmdW5jdGlvbiBmKEwpIHtcbiAgICBjb25zdCBJID0gW10sIEQgPSBbXSwgcSA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaTsgaysrKVxuICAgICAgSVtrXSA9IDAsIERba10gPSAwLCBxW2tdID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgZ2VvbWV0cnk6IG51bGwsXG4gICAgICBwcm9ncmFtOiBudWxsLFxuICAgICAgd2lyZWZyYW1lOiAhMSxcbiAgICAgIG5ld0F0dHJpYnV0ZXM6IEksXG4gICAgICBlbmFibGVkQXR0cmlidXRlczogRCxcbiAgICAgIGF0dHJpYnV0ZURpdmlzb3JzOiBxLFxuICAgICAgb2JqZWN0OiBMLFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBpbmRleDogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdihMLCBJLCBELCBxKSB7XG4gICAgY29uc3QgayA9IGEuYXR0cmlidXRlcywgTiA9IEkuYXR0cmlidXRlcztcbiAgICBsZXQgSCA9IDA7XG4gICAgY29uc3QgSiA9IEQuZ2V0QXR0cmlidXRlcygpO1xuICAgIGZvciAoY29uc3QgViBpbiBKKVxuICAgICAgaWYgKEpbVl0ubG9jYXRpb24gPj0gMCkge1xuICAgICAgICBjb25zdCBjZSA9IGtbVl07XG4gICAgICAgIGxldCBnZSA9IE5bVl07XG4gICAgICAgIGlmIChnZSA9PT0gdm9pZCAwICYmIChWID09PSBcImluc3RhbmNlTWF0cml4XCIgJiYgTC5pbnN0YW5jZU1hdHJpeCAmJiAoZ2UgPSBMLmluc3RhbmNlTWF0cml4KSwgViA9PT0gXCJpbnN0YW5jZUNvbG9yXCIgJiYgTC5pbnN0YW5jZUNvbG9yICYmIChnZSA9IEwuaW5zdGFuY2VDb2xvcikpLCBjZSA9PT0gdm9pZCAwIHx8IGNlLmF0dHJpYnV0ZSAhPT0gZ2UgfHwgZ2UgJiYgY2UuZGF0YSAhPT0gZ2UuZGF0YSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIEgrKztcbiAgICAgIH1cbiAgICByZXR1cm4gYS5hdHRyaWJ1dGVzTnVtICE9PSBIIHx8IGEuaW5kZXggIT09IHE7XG4gIH1cbiAgZnVuY3Rpb24gXyhMLCBJLCBELCBxKSB7XG4gICAgY29uc3QgayA9IHt9LCBOID0gSS5hdHRyaWJ1dGVzO1xuICAgIGxldCBIID0gMDtcbiAgICBjb25zdCBKID0gRC5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgZm9yIChjb25zdCBWIGluIEopXG4gICAgICBpZiAoSltWXS5sb2NhdGlvbiA+PSAwKSB7XG4gICAgICAgIGxldCBjZSA9IE5bVl07XG4gICAgICAgIGNlID09PSB2b2lkIDAgJiYgKFYgPT09IFwiaW5zdGFuY2VNYXRyaXhcIiAmJiBMLmluc3RhbmNlTWF0cml4ICYmIChjZSA9IEwuaW5zdGFuY2VNYXRyaXgpLCBWID09PSBcImluc3RhbmNlQ29sb3JcIiAmJiBMLmluc3RhbmNlQ29sb3IgJiYgKGNlID0gTC5pbnN0YW5jZUNvbG9yKSk7XG4gICAgICAgIGNvbnN0IGdlID0ge307XG4gICAgICAgIGdlLmF0dHJpYnV0ZSA9IGNlLCBjZSAmJiBjZS5kYXRhICYmIChnZS5kYXRhID0gY2UuZGF0YSksIGtbVl0gPSBnZSwgSCsrO1xuICAgICAgfVxuICAgIGEuYXR0cmlidXRlcyA9IGssIGEuYXR0cmlidXRlc051bSA9IEgsIGEuaW5kZXggPSBxO1xuICB9XG4gIGZ1bmN0aW9uIHcoKSB7XG4gICAgY29uc3QgTCA9IGEubmV3QXR0cmlidXRlcztcbiAgICBmb3IgKGxldCBJID0gMCwgRCA9IEwubGVuZ3RoOyBJIDwgRDsgSSsrKVxuICAgICAgTFtJXSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24geChMKSB7XG4gICAgTShMLCAwKTtcbiAgfVxuICBmdW5jdGlvbiBNKEwsIEkpIHtcbiAgICBjb25zdCBEID0gYS5uZXdBdHRyaWJ1dGVzLCBxID0gYS5lbmFibGVkQXR0cmlidXRlcywgayA9IGEuYXR0cmlidXRlRGl2aXNvcnM7XG4gICAgRFtMXSA9IDEsIHFbTF0gPT09IDAgJiYgKGguZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoTCksIHFbTF0gPSAxKSwga1tMXSAhPT0gSSAmJiAoKG4uaXNXZWJHTDIgPyBoIDogZS5nZXQoXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpKVtuLmlzV2ViR0wyID8gXCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yXCIgOiBcInZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRVwiXShMLCBJKSwga1tMXSA9IEkpO1xuICB9XG4gIGZ1bmN0aW9uIEUoKSB7XG4gICAgY29uc3QgTCA9IGEubmV3QXR0cmlidXRlcywgSSA9IGEuZW5hYmxlZEF0dHJpYnV0ZXM7XG4gICAgZm9yIChsZXQgRCA9IDAsIHEgPSBJLmxlbmd0aDsgRCA8IHE7IEQrKylcbiAgICAgIElbRF0gIT09IExbRF0gJiYgKGguZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KEQpLCBJW0RdID0gMCk7XG4gIH1cbiAgZnVuY3Rpb24gUihMLCBJLCBELCBxLCBrLCBOKSB7XG4gICAgbi5pc1dlYkdMMiA9PT0gITAgJiYgKEQgPT09IDUxMjQgfHwgRCA9PT0gNTEyNSkgPyBoLnZlcnRleEF0dHJpYklQb2ludGVyKEwsIEksIEQsIGssIE4pIDogaC52ZXJ0ZXhBdHRyaWJQb2ludGVyKEwsIEksIEQsIHEsIGssIE4pO1xuICB9XG4gIGZ1bmN0aW9uIHkoTCwgSSwgRCwgcSkge1xuICAgIGlmIChuLmlzV2ViR0wyID09PSAhMSAmJiAoTC5pc0luc3RhbmNlZE1lc2ggfHwgcS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSAmJiBlLmdldChcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIikgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgdygpO1xuICAgIGNvbnN0IGsgPSBxLmF0dHJpYnV0ZXMsIE4gPSBELmdldEF0dHJpYnV0ZXMoKSwgSCA9IEkuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcbiAgICBmb3IgKGNvbnN0IEogaW4gTikge1xuICAgICAgY29uc3QgViA9IE5bSl07XG4gICAgICBpZiAoVi5sb2NhdGlvbiA+PSAwKSB7XG4gICAgICAgIGxldCBlZSA9IGtbSl07XG4gICAgICAgIGlmIChlZSA9PT0gdm9pZCAwICYmIChKID09PSBcImluc3RhbmNlTWF0cml4XCIgJiYgTC5pbnN0YW5jZU1hdHJpeCAmJiAoZWUgPSBMLmluc3RhbmNlTWF0cml4KSwgSiA9PT0gXCJpbnN0YW5jZUNvbG9yXCIgJiYgTC5pbnN0YW5jZUNvbG9yICYmIChlZSA9IEwuaW5zdGFuY2VDb2xvcikpLCBlZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgY2UgPSBlZS5ub3JtYWxpemVkLCBnZSA9IGVlLml0ZW1TaXplLCAkID0gdC5nZXQoZWUpO1xuICAgICAgICAgIGlmICgkID09PSB2b2lkIDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBEZSA9ICQuYnVmZmVyLCB2ZSA9ICQudHlwZSwgeGUgPSAkLmJ5dGVzUGVyRWxlbWVudDtcbiAgICAgICAgICBpZiAoZWUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgY29uc3QgdWUgPSBlZS5kYXRhLCBPZSA9IHVlLnN0cmlkZSwgRWUgPSBlZS5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAodWUuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcikge1xuICAgICAgICAgICAgICBmb3IgKGxldCBtZSA9IDA7IG1lIDwgVi5sb2NhdGlvblNpemU7IG1lKyspXG4gICAgICAgICAgICAgICAgTShWLmxvY2F0aW9uICsgbWUsIHVlLm1lc2hQZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICBMLmlzSW5zdGFuY2VkTWVzaCAhPT0gITAgJiYgcS5fbWF4SW5zdGFuY2VDb3VudCA9PT0gdm9pZCAwICYmIChxLl9tYXhJbnN0YW5jZUNvdW50ID0gdWUubWVzaFBlckF0dHJpYnV0ZSAqIHVlLmNvdW50KTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBmb3IgKGxldCBtZSA9IDA7IG1lIDwgVi5sb2NhdGlvblNpemU7IG1lKyspXG4gICAgICAgICAgICAgICAgeChWLmxvY2F0aW9uICsgbWUpO1xuICAgICAgICAgICAgaC5iaW5kQnVmZmVyKDM0OTYyLCBEZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBtZSA9IDA7IG1lIDwgVi5sb2NhdGlvblNpemU7IG1lKyspXG4gICAgICAgICAgICAgIFIoXG4gICAgICAgICAgICAgICAgVi5sb2NhdGlvbiArIG1lLFxuICAgICAgICAgICAgICAgIGdlIC8gVi5sb2NhdGlvblNpemUsXG4gICAgICAgICAgICAgICAgdmUsXG4gICAgICAgICAgICAgICAgY2UsXG4gICAgICAgICAgICAgICAgT2UgKiB4ZSxcbiAgICAgICAgICAgICAgICAoRWUgKyBnZSAvIFYubG9jYXRpb25TaXplICogbWUpICogeGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHVlID0gMDsgdWUgPCBWLmxvY2F0aW9uU2l6ZTsgdWUrKylcbiAgICAgICAgICAgICAgICBNKFYubG9jYXRpb24gKyB1ZSwgZWUubWVzaFBlckF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgIEwuaXNJbnN0YW5jZWRNZXNoICE9PSAhMCAmJiBxLl9tYXhJbnN0YW5jZUNvdW50ID09PSB2b2lkIDAgJiYgKHEuX21heEluc3RhbmNlQ291bnQgPSBlZS5tZXNoUGVyQXR0cmlidXRlICogZWUuY291bnQpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGZvciAobGV0IHVlID0gMDsgdWUgPCBWLmxvY2F0aW9uU2l6ZTsgdWUrKylcbiAgICAgICAgICAgICAgICB4KFYubG9jYXRpb24gKyB1ZSk7XG4gICAgICAgICAgICBoLmJpbmRCdWZmZXIoMzQ5NjIsIERlKTtcbiAgICAgICAgICAgIGZvciAobGV0IHVlID0gMDsgdWUgPCBWLmxvY2F0aW9uU2l6ZTsgdWUrKylcbiAgICAgICAgICAgICAgUihcbiAgICAgICAgICAgICAgICBWLmxvY2F0aW9uICsgdWUsXG4gICAgICAgICAgICAgICAgZ2UgLyBWLmxvY2F0aW9uU2l6ZSxcbiAgICAgICAgICAgICAgICB2ZSxcbiAgICAgICAgICAgICAgICBjZSxcbiAgICAgICAgICAgICAgICBnZSAqIHhlLFxuICAgICAgICAgICAgICAgIGdlIC8gVi5sb2NhdGlvblNpemUgKiB1ZSAqIHhlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEggIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IGNlID0gSFtKXTtcbiAgICAgICAgICBpZiAoY2UgIT09IHZvaWQgMClcbiAgICAgICAgICAgIHN3aXRjaCAoY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBoLnZlcnRleEF0dHJpYjJmdihWLmxvY2F0aW9uLCBjZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBoLnZlcnRleEF0dHJpYjNmdihWLmxvY2F0aW9uLCBjZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBoLnZlcnRleEF0dHJpYjRmdihWLmxvY2F0aW9uLCBjZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaC52ZXJ0ZXhBdHRyaWIxZnYoVi5sb2NhdGlvbiwgY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEUoKTtcbiAgfVxuICBmdW5jdGlvbiBBKCkge1xuICAgIEcoKTtcbiAgICBmb3IgKGNvbnN0IEwgaW4gcikge1xuICAgICAgY29uc3QgSSA9IHJbTF07XG4gICAgICBmb3IgKGNvbnN0IEQgaW4gSSkge1xuICAgICAgICBjb25zdCBxID0gSVtEXTtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHEpXG4gICAgICAgICAgZyhxW2tdLm9iamVjdCksIGRlbGV0ZSBxW2tdO1xuICAgICAgICBkZWxldGUgSVtEXTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSByW0xdO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBGKEwpIHtcbiAgICBpZiAocltMLmlkXSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IEkgPSByW0wuaWRdO1xuICAgIGZvciAoY29uc3QgRCBpbiBJKSB7XG4gICAgICBjb25zdCBxID0gSVtEXTtcbiAgICAgIGZvciAoY29uc3QgayBpbiBxKVxuICAgICAgICBnKHFba10ub2JqZWN0KSwgZGVsZXRlIHFba107XG4gICAgICBkZWxldGUgSVtEXTtcbiAgICB9XG4gICAgZGVsZXRlIHJbTC5pZF07XG4gIH1cbiAgZnVuY3Rpb24gUChMKSB7XG4gICAgZm9yIChjb25zdCBJIGluIHIpIHtcbiAgICAgIGNvbnN0IEQgPSByW0ldO1xuICAgICAgaWYgKERbTC5pZF0gPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBxID0gRFtMLmlkXTtcbiAgICAgIGZvciAoY29uc3QgayBpbiBxKVxuICAgICAgICBnKHFba10ub2JqZWN0KSwgZGVsZXRlIHFba107XG4gICAgICBkZWxldGUgRFtMLmlkXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRygpIHtcbiAgICB6KCksIGMgPSAhMCwgYSAhPT0gbCAmJiAoYSA9IGwsIG0oYS5vYmplY3QpKTtcbiAgfVxuICBmdW5jdGlvbiB6KCkge1xuICAgIGwuZ2VvbWV0cnkgPSBudWxsLCBsLnByb2dyYW0gPSBudWxsLCBsLndpcmVmcmFtZSA9ICExO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2V0dXA6IGQsXG4gICAgcmVzZXQ6IEcsXG4gICAgcmVzZXREZWZhdWx0U3RhdGU6IHosXG4gICAgZGlzcG9zZTogQSxcbiAgICByZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeTogRixcbiAgICByZWxlYXNlU3RhdGVzT2ZQcm9ncmFtOiBQLFxuICAgIGluaXRBdHRyaWJ1dGVzOiB3LFxuICAgIGVuYWJsZUF0dHJpYnV0ZTogeCxcbiAgICBkaXNhYmxlVW51c2VkQXR0cmlidXRlczogRVxuICB9O1xufVxuZnVuY3Rpb24gTmMoaCwgZSwgdCwgbikge1xuICBjb25zdCBpID0gbi5pc1dlYkdMMjtcbiAgbGV0IHM7XG4gIGZ1bmN0aW9uIG8oYSkge1xuICAgIHMgPSBhO1xuICB9XG4gIGZ1bmN0aW9uIHIoYSwgYykge1xuICAgIGguZHJhd0FycmF5cyhzLCBhLCBjKSwgdC51cGRhdGUoYywgcywgMSk7XG4gIH1cbiAgZnVuY3Rpb24gbChhLCBjLCBkKSB7XG4gICAgaWYgKGQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IHUsIG07XG4gICAgaWYgKGkpXG4gICAgICB1ID0gaCwgbSA9IFwiZHJhd0FycmF5c0luc3RhbmNlZFwiO1xuICAgIGVsc2UgaWYgKHUgPSBlLmdldChcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIiksIG0gPSBcImRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRVwiLCB1ID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1W21dKHMsIGEsIGMsIGQpLCB0LnVwZGF0ZShjLCBzLCBkKTtcbiAgfVxuICB0aGlzLnNldE1vZGUgPSBvLCB0aGlzLnJlbmRlciA9IHIsIHRoaXMucmVuZGVySW5zdGFuY2VzID0gbDtcbn1cbmZ1bmN0aW9uIE9jKGgsIGUsIHQpIHtcbiAgbGV0IG47XG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgaWYgKG4gIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBuO1xuICAgIGlmIChlLmhhcyhcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSA9PT0gITApIHtcbiAgICAgIGNvbnN0IFIgPSBlLmdldChcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKTtcbiAgICAgIG4gPSBoLmdldFBhcmFtZXRlcihSLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7XG4gICAgfSBlbHNlXG4gICAgICBuID0gMDtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiBzKFIpIHtcbiAgICBpZiAoUiA9PT0gXCJoaWdocFwiKSB7XG4gICAgICBpZiAoaC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoMzU2MzMsIDM2MzM4KS5wcmVjaXNpb24gPiAwICYmIGguZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KDM1NjMyLCAzNjMzOCkucHJlY2lzaW9uID4gMClcbiAgICAgICAgcmV0dXJuIFwiaGlnaHBcIjtcbiAgICAgIFIgPSBcIm1lZGl1bXBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFIgPT09IFwibWVkaXVtcFwiICYmIGguZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KDM1NjMzLCAzNjMzNykucHJlY2lzaW9uID4gMCAmJiBoLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCgzNTYzMiwgMzYzMzcpLnByZWNpc2lvbiA+IDAgPyBcIm1lZGl1bXBcIiA6IFwibG93cFwiO1xuICB9XG4gIGNvbnN0IG8gPSB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA8IFwidVwiICYmIGggaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHx8IHR5cGVvZiBXZWJHTDJDb21wdXRlUmVuZGVyaW5nQ29udGV4dCA8IFwidVwiICYmIGggaW5zdGFuY2VvZiBXZWJHTDJDb21wdXRlUmVuZGVyaW5nQ29udGV4dDtcbiAgbGV0IHIgPSB0LnByZWNpc2lvbiAhPT0gdm9pZCAwID8gdC5wcmVjaXNpb24gOiBcImhpZ2hwXCI7XG4gIGNvbnN0IGwgPSBzKHIpO1xuICBsICE9PSByICYmIChjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOlwiLCByLCBcIm5vdCBzdXBwb3J0ZWQsIHVzaW5nXCIsIGwsIFwiaW5zdGVhZC5cIiksIHIgPSBsKTtcbiAgY29uc3QgYSA9IG8gfHwgZS5oYXMoXCJXRUJHTF9kcmF3X2J1ZmZlcnNcIiksIGMgPSB0LmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPT09ICEwLCBkID0gaC5nZXRQYXJhbWV0ZXIoMzQ5MzApLCB1ID0gaC5nZXRQYXJhbWV0ZXIoMzU2NjApLCBtID0gaC5nZXRQYXJhbWV0ZXIoMzM3OSksIGcgPSBoLmdldFBhcmFtZXRlcigzNDA3NiksIHAgPSBoLmdldFBhcmFtZXRlcigzNDkyMSksIGYgPSBoLmdldFBhcmFtZXRlcigzNjM0NyksIHYgPSBoLmdldFBhcmFtZXRlcigzNjM0OCksIF8gPSBoLmdldFBhcmFtZXRlcigzNjM0OSksIHcgPSB1ID4gMCwgeCA9IG8gfHwgZS5oYXMoXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSwgTSA9IHcgJiYgeCwgRSA9IG8gPyBoLmdldFBhcmFtZXRlcigzNjE4MykgOiAwO1xuICByZXR1cm4ge1xuICAgIGlzV2ViR0wyOiBvLFxuICAgIGRyYXdCdWZmZXJzOiBhLFxuICAgIGdldE1heEFuaXNvdHJvcHk6IGksXG4gICAgZ2V0TWF4UHJlY2lzaW9uOiBzLFxuICAgIHByZWNpc2lvbjogcixcbiAgICBsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjLFxuICAgIG1heFRleHR1cmVzOiBkLFxuICAgIG1heFZlcnRleFRleHR1cmVzOiB1LFxuICAgIG1heFRleHR1cmVTaXplOiBtLFxuICAgIG1heEN1YmVtYXBTaXplOiBnLFxuICAgIG1heEF0dHJpYnV0ZXM6IHAsXG4gICAgbWF4VmVydGV4VW5pZm9ybXM6IGYsXG4gICAgbWF4VmFyeWluZ3M6IHYsXG4gICAgbWF4RnJhZ21lbnRVbmlmb3JtczogXyxcbiAgICB2ZXJ0ZXhUZXh0dXJlczogdyxcbiAgICBmbG9hdEZyYWdtZW50VGV4dHVyZXM6IHgsXG4gICAgZmxvYXRWZXJ0ZXhUZXh0dXJlczogTSxcbiAgICBtYXhTYW1wbGVzOiBFXG4gIH07XG59XG5mdW5jdGlvbiBVYyhoKSB7XG4gIGNvbnN0IGUgPSB0aGlzO1xuICBsZXQgdCA9IG51bGwsIG4gPSAwLCBpID0gITEsIHMgPSAhMTtcbiAgY29uc3QgbyA9IG5ldyBnbigpLCByID0gbmV3IE10KCksIGwgPSB7IHZhbHVlOiBudWxsLCBuZWVkc1VwZGF0ZTogITEgfTtcbiAgdGhpcy51bmlmb3JtID0gbCwgdGhpcy5udW1QbGFuZXMgPSAwLCB0aGlzLm51bUludGVyc2VjdGlvbiA9IDAsIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGQsIHUsIG0pIHtcbiAgICBjb25zdCBnID0gZC5sZW5ndGggIT09IDAgfHwgdSB8fCBuICE9PSAwIHx8IGk7XG4gICAgcmV0dXJuIGkgPSB1LCB0ID0gYyhkLCBtLCAwKSwgbiA9IGQubGVuZ3RoLCBnO1xuICB9LCB0aGlzLmJlZ2luU2hhZG93cyA9IGZ1bmN0aW9uKCkge1xuICAgIHMgPSAhMCwgYyhudWxsKTtcbiAgfSwgdGhpcy5lbmRTaGFkb3dzID0gZnVuY3Rpb24oKSB7XG4gICAgcyA9ICExLCBhKCk7XG4gIH0sIHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbihkLCB1LCBtKSB7XG4gICAgY29uc3QgZyA9IGQuY2xpcHBpbmdQbGFuZXMsIHAgPSBkLmNsaXBJbnRlcnNlY3Rpb24sIGYgPSBkLmNsaXBTaGFkb3dzLCB2ID0gaC5nZXQoZCk7XG4gICAgaWYgKCFpIHx8IGcgPT09IG51bGwgfHwgZy5sZW5ndGggPT09IDAgfHwgcyAmJiAhZilcbiAgICAgIHMgPyBjKG51bGwpIDogYSgpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgXyA9IHMgPyAwIDogbiwgdyA9IF8gKiA0O1xuICAgICAgbGV0IHggPSB2LmNsaXBwaW5nU3RhdGUgfHwgbnVsbDtcbiAgICAgIGwudmFsdWUgPSB4LCB4ID0gYyhnLCB1LCB3LCBtKTtcbiAgICAgIGZvciAobGV0IE0gPSAwOyBNICE9PSB3OyArK00pXG4gICAgICAgIHhbTV0gPSB0W01dO1xuICAgICAgdi5jbGlwcGluZ1N0YXRlID0geCwgdGhpcy5udW1JbnRlcnNlY3Rpb24gPSBwID8gdGhpcy5udW1QbGFuZXMgOiAwLCB0aGlzLm51bVBsYW5lcyArPSBfO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gYSgpIHtcbiAgICBsLnZhbHVlICE9PSB0ICYmIChsLnZhbHVlID0gdCwgbC5uZWVkc1VwZGF0ZSA9IG4gPiAwKSwgZS5udW1QbGFuZXMgPSBuLCBlLm51bUludGVyc2VjdGlvbiA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYyhkLCB1LCBtLCBnKSB7XG4gICAgY29uc3QgcCA9IGQgIT09IG51bGwgPyBkLmxlbmd0aCA6IDA7XG4gICAgbGV0IGYgPSBudWxsO1xuICAgIGlmIChwICE9PSAwKSB7XG4gICAgICBpZiAoZiA9IGwudmFsdWUsIGcgIT09ICEwIHx8IGYgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdiA9IG0gKyBwICogNCwgXyA9IHUubWF0cml4V29ybGRJbnZlcnNlO1xuICAgICAgICByLmdldE5vcm1hbE1hdHJpeChfKSwgKGYgPT09IG51bGwgfHwgZi5sZW5ndGggPCB2KSAmJiAoZiA9IG5ldyBGbG9hdDMyQXJyYXkodikpO1xuICAgICAgICBmb3IgKGxldCB3ID0gMCwgeCA9IG07IHcgIT09IHA7ICsrdywgeCArPSA0KVxuICAgICAgICAgIG8uY29weShkW3ddKS5hcHBseU1hdHJpeDQoXywgciksIG8ubm9ybWFsLnRvQXJyYXkoZiwgeCksIGZbeCArIDNdID0gby5jb25zdGFudDtcbiAgICAgIH1cbiAgICAgIGwudmFsdWUgPSBmLCBsLm5lZWRzVXBkYXRlID0gITA7XG4gICAgfVxuICAgIHJldHVybiBlLm51bVBsYW5lcyA9IHAsIGUubnVtSW50ZXJzZWN0aW9uID0gMCwgZjtcbiAgfVxufVxuZnVuY3Rpb24gR2MoaCkge1xuICBsZXQgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBmdW5jdGlvbiB0KG8sIHIpIHtcbiAgICByZXR1cm4gciA9PT0gMzAzID8gby5tYXBwaW5nID0gMzAxIDogciA9PT0gMzA0ICYmIChvLm1hcHBpbmcgPSAzMDIpLCBvO1xuICB9XG4gIGZ1bmN0aW9uIG4obykge1xuICAgIGlmIChvICYmIG8uaXNUZXh0dXJlICYmIG8uaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSAhMSkge1xuICAgICAgY29uc3QgciA9IG8ubWFwcGluZztcbiAgICAgIGlmIChyID09PSAzMDMgfHwgciA9PT0gMzA0KVxuICAgICAgICBpZiAoZS5oYXMobykpIHtcbiAgICAgICAgICBjb25zdCBsID0gZS5nZXQobykudGV4dHVyZTtcbiAgICAgICAgICByZXR1cm4gdChsLCBvLm1hcHBpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGwgPSBvLmltYWdlO1xuICAgICAgICAgIGlmIChsICYmIGwuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IG5ldyBuYShsLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGEuZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUoaCwgbyksIGUuc2V0KG8sIGEpLCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIGkpLCB0KGEudGV4dHVyZSwgby5tYXBwaW5nKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIGNvbnN0IHIgPSBvLnRhcmdldDtcbiAgICByLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIGkpO1xuICAgIGNvbnN0IGwgPSBlLmdldChyKTtcbiAgICBsICE9PSB2b2lkIDAgJiYgKGUuZGVsZXRlKHIpLCBsLmRpc3Bvc2UoKSk7XG4gIH1cbiAgZnVuY3Rpb24gcygpIHtcbiAgICBlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IG4sXG4gICAgZGlzcG9zZTogc1xuICB9O1xufVxuY2xhc3Mga2MgZXh0ZW5kcyBobyB7XG4gIGNvbnN0cnVjdG9yKGUgPSAtMSwgdCA9IDEsIG4gPSAxLCBpID0gLTEsIHMgPSAwLjEsIG8gPSAyZTMpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzT3J0aG9ncmFwaGljQ2FtZXJhID0gITAsIHRoaXMudHlwZSA9IFwiT3J0aG9ncmFwaGljQ2FtZXJhXCIsIHRoaXMuem9vbSA9IDEsIHRoaXMudmlldyA9IG51bGwsIHRoaXMubGVmdCA9IGUsIHRoaXMucmlnaHQgPSB0LCB0aGlzLnRvcCA9IG4sIHRoaXMuYm90dG9tID0gaSwgdGhpcy5uZWFyID0gcywgdGhpcy5mYXIgPSBvLCB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxuICBjb3B5KGUsIHQpIHtcbiAgICByZXR1cm4gc3VwZXIuY29weShlLCB0KSwgdGhpcy5sZWZ0ID0gZS5sZWZ0LCB0aGlzLnJpZ2h0ID0gZS5yaWdodCwgdGhpcy50b3AgPSBlLnRvcCwgdGhpcy5ib3R0b20gPSBlLmJvdHRvbSwgdGhpcy5uZWFyID0gZS5uZWFyLCB0aGlzLmZhciA9IGUuZmFyLCB0aGlzLnpvb20gPSBlLnpvb20sIHRoaXMudmlldyA9IGUudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKHt9LCBlLnZpZXcpLCB0aGlzO1xuICB9XG4gIHNldFZpZXdPZmZzZXQoZSwgdCwgbiwgaSwgcywgbykge1xuICAgIHRoaXMudmlldyA9PT0gbnVsbCAmJiAodGhpcy52aWV3ID0ge1xuICAgICAgZW5hYmxlZDogITAsXG4gICAgICBmdWxsV2lkdGg6IDEsXG4gICAgICBmdWxsSGVpZ2h0OiAxLFxuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDAsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMVxuICAgIH0pLCB0aGlzLnZpZXcuZW5hYmxlZCA9ICEwLCB0aGlzLnZpZXcuZnVsbFdpZHRoID0gZSwgdGhpcy52aWV3LmZ1bGxIZWlnaHQgPSB0LCB0aGlzLnZpZXcub2Zmc2V0WCA9IG4sIHRoaXMudmlldy5vZmZzZXRZID0gaSwgdGhpcy52aWV3LndpZHRoID0gcywgdGhpcy52aWV3LmhlaWdodCA9IG8sIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICB9XG4gIGNsZWFyVmlld09mZnNldCgpIHtcbiAgICB0aGlzLnZpZXcgIT09IG51bGwgJiYgKHRoaXMudmlldy5lbmFibGVkID0gITEpLCB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxuICB1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuICAgIGNvbnN0IGUgPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyAoMiAqIHRoaXMuem9vbSksIHQgPSAodGhpcy50b3AgLSB0aGlzLmJvdHRvbSkgLyAoMiAqIHRoaXMuem9vbSksIG4gPSAodGhpcy5yaWdodCArIHRoaXMubGVmdCkgLyAyLCBpID0gKHRoaXMudG9wICsgdGhpcy5ib3R0b20pIC8gMjtcbiAgICBsZXQgcyA9IG4gLSBlLCBvID0gbiArIGUsIHIgPSBpICsgdCwgbCA9IGkgLSB0O1xuICAgIGlmICh0aGlzLnZpZXcgIT09IG51bGwgJiYgdGhpcy52aWV3LmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGEgPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyB0aGlzLnZpZXcuZnVsbFdpZHRoIC8gdGhpcy56b29tLCBjID0gKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pIC8gdGhpcy52aWV3LmZ1bGxIZWlnaHQgLyB0aGlzLnpvb207XG4gICAgICBzICs9IGEgKiB0aGlzLnZpZXcub2Zmc2V0WCwgbyA9IHMgKyBhICogdGhpcy52aWV3LndpZHRoLCByIC09IGMgKiB0aGlzLnZpZXcub2Zmc2V0WSwgbCA9IHIgLSBjICogdGhpcy52aWV3LmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMocywgbywgciwgbCwgdGhpcy5uZWFyLCB0aGlzLmZhciksIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpO1xuICB9XG4gIHRvSlNPTihlKSB7XG4gICAgY29uc3QgdCA9IHN1cGVyLnRvSlNPTihlKTtcbiAgICByZXR1cm4gdC5vYmplY3Quem9vbSA9IHRoaXMuem9vbSwgdC5vYmplY3QubGVmdCA9IHRoaXMubGVmdCwgdC5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0LCB0Lm9iamVjdC50b3AgPSB0aGlzLnRvcCwgdC5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b20sIHQub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXIsIHQub2JqZWN0LmZhciA9IHRoaXMuZmFyLCB0aGlzLnZpZXcgIT09IG51bGwgJiYgKHQub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcpKSwgdDtcbiAgfVxufVxuY29uc3Qgam4gPSA0LCBsciA9IFswLjEyNSwgMC4yMTUsIDAuMzUsIDAuNDQ2LCAwLjUyNiwgMC41ODJdLCB2biA9IDIwLCB3cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcga2MoKSwgY3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IEFlKCk7XG5sZXQgTXMgPSBudWxsO1xuY29uc3QgX24gPSAoMSArIE1hdGguc3FydCg1KSkgLyAyLCBIbiA9IDEgLyBfbiwgaHIgPSBbXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTygxLCAxLCAxKSxcbiAgLyogQF9fUFVSRV9fICovIG5ldyBPKC0xLCAxLCAxKSxcbiAgLyogQF9fUFVSRV9fICovIG5ldyBPKDEsIDEsIC0xKSxcbiAgLyogQF9fUFVSRV9fICovIG5ldyBPKC0xLCAxLCAtMSksXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTygwLCBfbiwgSG4pLFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE8oMCwgX24sIC1IbiksXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTyhIbiwgMCwgX24pLFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE8oLUhuLCAwLCBfbiksXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTyhfbiwgSG4sIDApLFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE8oLV9uLCBIbiwgMClcbl07XG5jbGFzcyB1ciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IGUsIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gbnVsbCwgdGhpcy5fbG9kTWF4ID0gMCwgdGhpcy5fY3ViZVNpemUgPSAwLCB0aGlzLl9sb2RQbGFuZXMgPSBbXSwgdGhpcy5fc2l6ZUxvZHMgPSBbXSwgdGhpcy5fc2lnbWFzID0gW10sIHRoaXMuX2JsdXJNYXRlcmlhbCA9IG51bGwsIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IG51bGwsIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBudWxsLCB0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fYmx1ck1hdGVyaWFsKTtcbiAgfVxuICBmcm9tU2NlbmUoZSwgdCA9IDAsIG4gPSAwLjEsIGkgPSAxMDApIHtcbiAgICBNcyA9IHRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpLCB0aGlzLl9zZXRTaXplKDI1Nik7XG4gICAgY29uc3QgcyA9IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xuICAgIHJldHVybiBzLmRlcHRoQnVmZmVyID0gITAsIHRoaXMuX3NjZW5lVG9DdWJlVVYoZSwgbiwgaSwgcyksIHQgPiAwICYmIHRoaXMuX2JsdXIocywgMCwgMCwgdCksIHRoaXMuX2FwcGx5UE1SRU0ocyksIHRoaXMuX2NsZWFudXAocyksIHM7XG4gIH1cbiAgZnJvbUVxdWlyZWN0YW5ndWxhcihlLCB0ID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9mcm9tVGV4dHVyZShlLCB0KTtcbiAgfVxuICBmcm9tQ3ViZW1hcChlLCB0ID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9mcm9tVGV4dHVyZShlLCB0KTtcbiAgfVxuICBjb21waWxlQ3ViZW1hcFNoYWRlcigpIHtcbiAgICB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPT09IG51bGwgJiYgKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IHByKCksIHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9jdWJlbWFwTWF0ZXJpYWwpKTtcbiAgfVxuICBjb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyKCkge1xuICAgIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPT09IG51bGwgJiYgKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBmcigpLCB0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fZXF1aXJlY3RNYXRlcmlhbCkpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZGlzcG9zZSgpLCB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgIT09IG51bGwgJiYgdGhpcy5fY3ViZW1hcE1hdGVyaWFsLmRpc3Bvc2UoKSwgdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCAhPT0gbnVsbCAmJiB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgfVxuICBfc2V0U2l6ZShlKSB7XG4gICAgdGhpcy5fbG9kTWF4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoZSkpLCB0aGlzLl9jdWJlU2l6ZSA9IE1hdGgucG93KDIsIHRoaXMuX2xvZE1heCk7XG4gIH1cbiAgX2Rpc3Bvc2UoKSB7XG4gICAgdGhpcy5fYmx1ck1hdGVyaWFsICE9PSBudWxsICYmIHRoaXMuX2JsdXJNYXRlcmlhbC5kaXNwb3NlKCksIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ICE9PSBudWxsICYmIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7IGUrKylcbiAgICAgIHRoaXMuX2xvZFBsYW5lc1tlXS5kaXNwb3NlKCk7XG4gIH1cbiAgX2NsZWFudXAoZSkge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChNcyksIGUuc2Npc3NvclRlc3QgPSAhMSwgemkoZSwgMCwgMCwgZS53aWR0aCwgZS5oZWlnaHQpO1xuICB9XG4gIF9mcm9tVGV4dHVyZShlLCB0KSB7XG4gICAgZS5tYXBwaW5nID09PSAzMDEgfHwgZS5tYXBwaW5nID09PSAzMDIgPyB0aGlzLl9zZXRTaXplKGUuaW1hZ2UubGVuZ3RoID09PSAwID8gMTYgOiBlLmltYWdlWzBdLndpZHRoIHx8IGUuaW1hZ2VbMF0uaW1hZ2Uud2lkdGgpIDogdGhpcy5fc2V0U2l6ZShlLmltYWdlLndpZHRoIC8gNCksIE1zID0gdGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG4gICAgY29uc3QgbiA9IHQgfHwgdGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVUb0N1YmVVVihlLCBuKSwgdGhpcy5fYXBwbHlQTVJFTShuKSwgdGhpcy5fY2xlYW51cChuKSwgbjtcbiAgfVxuICBfYWxsb2NhdGVUYXJnZXRzKCkge1xuICAgIGNvbnN0IGUgPSAzICogTWF0aC5tYXgodGhpcy5fY3ViZVNpemUsIDExMiksIHQgPSA0ICogdGhpcy5fY3ViZVNpemUsIG4gPSB7XG4gICAgICBtYWdGaWx0ZXI6IDEwMDYsXG4gICAgICBtaW5GaWx0ZXI6IDEwMDYsXG4gICAgICBnZW5lcmF0ZU1pcG1hcHM6ICExLFxuICAgICAgdHlwZTogMTAxNixcbiAgICAgIGZvcm1hdDogMTAyMyxcbiAgICAgIGVuY29kaW5nOiAzZTMsXG4gICAgICBkZXB0aEJ1ZmZlcjogITFcbiAgICB9LCBpID0gZHIoZSwgdCwgbik7XG4gICAgaWYgKHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID09PSBudWxsIHx8IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LndpZHRoICE9PSBlKSB7XG4gICAgICB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCAhPT0gbnVsbCAmJiB0aGlzLl9kaXNwb3NlKCksIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gZHIoZSwgdCwgbik7XG4gICAgICBjb25zdCB7IF9sb2RNYXg6IHMgfSA9IHRoaXM7XG4gICAgICAoeyBzaXplTG9kczogdGhpcy5fc2l6ZUxvZHMsIGxvZFBsYW5lczogdGhpcy5fbG9kUGxhbmVzLCBzaWdtYXM6IHRoaXMuX3NpZ21hcyB9ID0gV2MocykpLCB0aGlzLl9ibHVyTWF0ZXJpYWwgPSBWYyhzLCBlLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgX2NvbXBpbGVNYXRlcmlhbChlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBOdCh0aGlzLl9sb2RQbGFuZXNbMF0sIGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmNvbXBpbGUodCwgd3MpO1xuICB9XG4gIF9zY2VuZVRvQ3ViZVVWKGUsIHQsIG4sIGkpIHtcbiAgICBjb25zdCByID0gbmV3IGd0KDkwLCAxLCB0LCBuKSwgbCA9IFsxLCAtMSwgMSwgMSwgMSwgMV0sIGEgPSBbMSwgMSwgMSwgLTEsIC0xLCAtMV0sIGMgPSB0aGlzLl9yZW5kZXJlciwgZCA9IGMuYXV0b0NsZWFyLCB1ID0gYy50b25lTWFwcGluZztcbiAgICBjLmdldENsZWFyQ29sb3IoY3IpLCBjLnRvbmVNYXBwaW5nID0gMCwgYy5hdXRvQ2xlYXIgPSAhMTtcbiAgICBjb25zdCBtID0gbmV3IGFvKHtcbiAgICAgIG5hbWU6IFwiUE1SRU0uQmFja2dyb3VuZFwiLFxuICAgICAgc2lkZTogMSxcbiAgICAgIGRlcHRoV3JpdGU6ICExLFxuICAgICAgZGVwdGhUZXN0OiAhMVxuICAgIH0pLCBnID0gbmV3IE50KG5ldyBwaSgpLCBtKTtcbiAgICBsZXQgcCA9ICExO1xuICAgIGNvbnN0IGYgPSBlLmJhY2tncm91bmQ7XG4gICAgZiA/IGYuaXNDb2xvciAmJiAobS5jb2xvci5jb3B5KGYpLCBlLmJhY2tncm91bmQgPSBudWxsLCBwID0gITApIDogKG0uY29sb3IuY29weShjciksIHAgPSAhMCk7XG4gICAgZm9yIChsZXQgdiA9IDA7IHYgPCA2OyB2KyspIHtcbiAgICAgIGNvbnN0IF8gPSB2ICUgMztcbiAgICAgIF8gPT09IDAgPyAoci51cC5zZXQoMCwgbFt2XSwgMCksIHIubG9va0F0KGFbdl0sIDAsIDApKSA6IF8gPT09IDEgPyAoci51cC5zZXQoMCwgMCwgbFt2XSksIHIubG9va0F0KDAsIGFbdl0sIDApKSA6IChyLnVwLnNldCgwLCBsW3ZdLCAwKSwgci5sb29rQXQoMCwgMCwgYVt2XSkpO1xuICAgICAgY29uc3QgdyA9IHRoaXMuX2N1YmVTaXplO1xuICAgICAgemkoaSwgXyAqIHcsIHYgPiAyID8gdyA6IDAsIHcsIHcpLCBjLnNldFJlbmRlclRhcmdldChpKSwgcCAmJiBjLnJlbmRlcihnLCByKSwgYy5yZW5kZXIoZSwgcik7XG4gICAgfVxuICAgIGcuZ2VvbWV0cnkuZGlzcG9zZSgpLCBnLm1hdGVyaWFsLmRpc3Bvc2UoKSwgYy50b25lTWFwcGluZyA9IHUsIGMuYXV0b0NsZWFyID0gZCwgZS5iYWNrZ3JvdW5kID0gZjtcbiAgfVxuICBfdGV4dHVyZVRvQ3ViZVVWKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fcmVuZGVyZXIsIGkgPSBlLm1hcHBpbmcgPT09IDMwMSB8fCBlLm1hcHBpbmcgPT09IDMwMjtcbiAgICBpID8gKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9PT0gbnVsbCAmJiAodGhpcy5fY3ViZW1hcE1hdGVyaWFsID0gcHIoKSksIHRoaXMuX2N1YmVtYXBNYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09ICExID8gLTEgOiAxKSA6IHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPT09IG51bGwgJiYgKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBmcigpKTtcbiAgICBjb25zdCBzID0gaSA/IHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA6IHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwsIG8gPSBuZXcgTnQodGhpcy5fbG9kUGxhbmVzWzBdLCBzKSwgciA9IHMudW5pZm9ybXM7XG4gICAgci5lbnZNYXAudmFsdWUgPSBlO1xuICAgIGNvbnN0IGwgPSB0aGlzLl9jdWJlU2l6ZTtcbiAgICB6aSh0LCAwLCAwLCAzICogbCwgMiAqIGwpLCBuLnNldFJlbmRlclRhcmdldCh0KSwgbi5yZW5kZXIobywgd3MpO1xuICB9XG4gIF9hcHBseVBNUkVNKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fcmVuZGVyZXIsIG4gPSB0LmF1dG9DbGVhcjtcbiAgICB0LmF1dG9DbGVhciA9ICExO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fbG9kUGxhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzID0gTWF0aC5zcXJ0KHRoaXMuX3NpZ21hc1tpXSAqIHRoaXMuX3NpZ21hc1tpXSAtIHRoaXMuX3NpZ21hc1tpIC0gMV0gKiB0aGlzLl9zaWdtYXNbaSAtIDFdKSwgbyA9IGhyWyhpIC0gMSkgJSBoci5sZW5ndGhdO1xuICAgICAgdGhpcy5fYmx1cihlLCBpIC0gMSwgaSwgcywgbyk7XG4gICAgfVxuICAgIHQuYXV0b0NsZWFyID0gbjtcbiAgfVxuICBfYmx1cihlLCB0LCBuLCBpLCBzKSB7XG4gICAgY29uc3QgbyA9IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0O1xuICAgIHRoaXMuX2hhbGZCbHVyKFxuICAgICAgZSxcbiAgICAgIG8sXG4gICAgICB0LFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICBcImxhdGl0dWRpbmFsXCIsXG4gICAgICBzXG4gICAgKSwgdGhpcy5faGFsZkJsdXIoXG4gICAgICBvLFxuICAgICAgZSxcbiAgICAgIG4sXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIFwibG9uZ2l0dWRpbmFsXCIsXG4gICAgICBzXG4gICAgKTtcbiAgfVxuICBfaGFsZkJsdXIoZSwgdCwgbiwgaSwgcywgbywgcikge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9yZW5kZXJlciwgYSA9IHRoaXMuX2JsdXJNYXRlcmlhbDtcbiAgICBvICE9PSBcImxhdGl0dWRpbmFsXCIgJiYgbyAhPT0gXCJsb25naXR1ZGluYWxcIiAmJiBjb25zb2xlLmVycm9yKFxuICAgICAgXCJibHVyIGRpcmVjdGlvbiBtdXN0IGJlIGVpdGhlciBsYXRpdHVkaW5hbCBvciBsb25naXR1ZGluYWwhXCJcbiAgICApO1xuICAgIGNvbnN0IGMgPSAzLCBkID0gbmV3IE50KHRoaXMuX2xvZFBsYW5lc1tpXSwgYSksIHUgPSBhLnVuaWZvcm1zLCBtID0gdGhpcy5fc2l6ZUxvZHNbbl0gLSAxLCBnID0gaXNGaW5pdGUocykgPyBNYXRoLlBJIC8gKDIgKiBtKSA6IDIgKiBNYXRoLlBJIC8gKDIgKiB2biAtIDEpLCBwID0gcyAvIGcsIGYgPSBpc0Zpbml0ZShzKSA/IDEgKyBNYXRoLmZsb29yKGMgKiBwKSA6IHZuO1xuICAgIGYgPiB2biAmJiBjb25zb2xlLndhcm4oYHNpZ21hUmFkaWFucywgJHtzfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke2Z9IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHt2bn1gKTtcbiAgICBjb25zdCB2ID0gW107XG4gICAgbGV0IF8gPSAwO1xuICAgIGZvciAobGV0IFIgPSAwOyBSIDwgdm47ICsrUikge1xuICAgICAgY29uc3QgeSA9IFIgLyBwLCBBID0gTWF0aC5leHAoLXkgKiB5IC8gMik7XG4gICAgICB2LnB1c2goQSksIFIgPT09IDAgPyBfICs9IEEgOiBSIDwgZiAmJiAoXyArPSAyICogQSk7XG4gICAgfVxuICAgIGZvciAobGV0IFIgPSAwOyBSIDwgdi5sZW5ndGg7IFIrKylcbiAgICAgIHZbUl0gPSB2W1JdIC8gXztcbiAgICB1LmVudk1hcC52YWx1ZSA9IGUudGV4dHVyZSwgdS5zYW1wbGVzLnZhbHVlID0gZiwgdS53ZWlnaHRzLnZhbHVlID0gdiwgdS5sYXRpdHVkaW5hbC52YWx1ZSA9IG8gPT09IFwibGF0aXR1ZGluYWxcIiwgciAmJiAodS5wb2xlQXhpcy52YWx1ZSA9IHIpO1xuICAgIGNvbnN0IHsgX2xvZE1heDogdyB9ID0gdGhpcztcbiAgICB1LmRUaGV0YS52YWx1ZSA9IGcsIHUubWlwSW50LnZhbHVlID0gdyAtIG47XG4gICAgY29uc3QgeCA9IHRoaXMuX3NpemVMb2RzW2ldLCBNID0gMyAqIHggKiAoaSA+IHcgLSBqbiA/IGkgLSB3ICsgam4gOiAwKSwgRSA9IDQgKiAodGhpcy5fY3ViZVNpemUgLSB4KTtcbiAgICB6aSh0LCBNLCBFLCAzICogeCwgMiAqIHgpLCBsLnNldFJlbmRlclRhcmdldCh0KSwgbC5yZW5kZXIoZCwgd3MpO1xuICB9XG59XG5mdW5jdGlvbiBXYyhoKSB7XG4gIGNvbnN0IGUgPSBbXSwgdCA9IFtdLCBuID0gW107XG4gIGxldCBpID0gaDtcbiAgY29uc3QgcyA9IGggLSBqbiArIDEgKyBsci5sZW5ndGg7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgczsgbysrKSB7XG4gICAgY29uc3QgciA9IE1hdGgucG93KDIsIGkpO1xuICAgIHQucHVzaChyKTtcbiAgICBsZXQgbCA9IDEgLyByO1xuICAgIG8gPiBoIC0gam4gPyBsID0gbHJbbyAtIGggKyBqbiAtIDFdIDogbyA9PT0gMCAmJiAobCA9IDApLCBuLnB1c2gobCk7XG4gICAgY29uc3QgYSA9IDEgLyAociAtIDIpLCBjID0gLWEsIGQgPSAxICsgYSwgdSA9IFtjLCBjLCBkLCBjLCBkLCBkLCBjLCBjLCBkLCBkLCBjLCBkXSwgbSA9IDYsIGcgPSA2LCBwID0gMywgZiA9IDIsIHYgPSAxLCBfID0gbmV3IEZsb2F0MzJBcnJheShwICogZyAqIG0pLCB3ID0gbmV3IEZsb2F0MzJBcnJheShmICogZyAqIG0pLCB4ID0gbmV3IEZsb2F0MzJBcnJheSh2ICogZyAqIG0pO1xuICAgIGZvciAobGV0IEUgPSAwOyBFIDwgbTsgRSsrKSB7XG4gICAgICBjb25zdCBSID0gRSAlIDMgKiAyIC8gMyAtIDEsIHkgPSBFID4gMiA/IDAgOiAtMSwgQSA9IFtcbiAgICAgICAgUixcbiAgICAgICAgeSxcbiAgICAgICAgMCxcbiAgICAgICAgUiArIDIgLyAzLFxuICAgICAgICB5LFxuICAgICAgICAwLFxuICAgICAgICBSICsgMiAvIDMsXG4gICAgICAgIHkgKyAxLFxuICAgICAgICAwLFxuICAgICAgICBSLFxuICAgICAgICB5LFxuICAgICAgICAwLFxuICAgICAgICBSICsgMiAvIDMsXG4gICAgICAgIHkgKyAxLFxuICAgICAgICAwLFxuICAgICAgICBSLFxuICAgICAgICB5ICsgMSxcbiAgICAgICAgMFxuICAgICAgXTtcbiAgICAgIF8uc2V0KEEsIHAgKiBnICogRSksIHcuc2V0KHUsIGYgKiBnICogRSk7XG4gICAgICBjb25zdCBGID0gW0UsIEUsIEUsIEUsIEUsIEVdO1xuICAgICAgeC5zZXQoRiwgdiAqIGcgKiBFKTtcbiAgICB9XG4gICAgY29uc3QgTSA9IG5ldyBVdCgpO1xuICAgIE0uc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IE90KF8sIHApKSwgTS5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgT3QodywgZikpLCBNLnNldEF0dHJpYnV0ZShcImZhY2VJbmRleFwiLCBuZXcgT3QoeCwgdikpLCBlLnB1c2goTSksIGkgPiBqbiAmJiBpLS07XG4gIH1cbiAgcmV0dXJuIHsgbG9kUGxhbmVzOiBlLCBzaXplTG9kczogdCwgc2lnbWFzOiBuIH07XG59XG5mdW5jdGlvbiBkcihoLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSBuZXcgRW4oaCwgZSwgdCk7XG4gIHJldHVybiBuLnRleHR1cmUubWFwcGluZyA9IDMwNiwgbi50ZXh0dXJlLm5hbWUgPSBcIlBNUkVNLmN1YmVVdlwiLCBuLnNjaXNzb3JUZXN0ID0gITAsIG47XG59XG5mdW5jdGlvbiB6aShoLCBlLCB0LCBuLCBpKSB7XG4gIGgudmlld3BvcnQuc2V0KGUsIHQsIG4sIGkpLCBoLnNjaXNzb3Iuc2V0KGUsIHQsIG4sIGkpO1xufVxuZnVuY3Rpb24gVmMoaCwgZSwgdCkge1xuICBjb25zdCBuID0gbmV3IEZsb2F0MzJBcnJheSh2biksIGkgPSBuZXcgTygwLCAxLCAwKTtcbiAgcmV0dXJuIG5ldyBUbih7XG4gICAgbmFtZTogXCJTcGhlcmljYWxHYXVzc2lhbkJsdXJcIixcbiAgICBkZWZpbmVzOiB7XG4gICAgICBuOiB2bixcbiAgICAgIENVQkVVVl9URVhFTF9XSURUSDogMSAvIGUsXG4gICAgICBDVUJFVVZfVEVYRUxfSEVJR0hUOiAxIC8gdCxcbiAgICAgIENVQkVVVl9NQVhfTUlQOiBgJHtofS4wYFxuICAgIH0sXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgc2FtcGxlczogeyB2YWx1ZTogMSB9LFxuICAgICAgd2VpZ2h0czogeyB2YWx1ZTogbiB9LFxuICAgICAgbGF0aXR1ZGluYWw6IHsgdmFsdWU6ICExIH0sXG4gICAgICBkVGhldGE6IHsgdmFsdWU6IDAgfSxcbiAgICAgIG1pcEludDogeyB2YWx1ZTogMCB9LFxuICAgICAgcG9sZUF4aXM6IHsgdmFsdWU6IGkgfVxuICAgIH0sXG4gICAgdmVydGV4U2hhZGVyOiBHcygpLFxuICAgIGZyYWdtZW50U2hhZGVyOiBgXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcblxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xuXHRcdFx0dW5pZm9ybSBpbnQgc2FtcGxlcztcblx0XHRcdHVuaWZvcm0gZmxvYXQgd2VpZ2h0c1sgbiBdO1xuXHRcdFx0dW5pZm9ybSBib29sIGxhdGl0dWRpbmFsO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCBkVGhldGE7XG5cdFx0XHR1bmlmb3JtIGZsb2F0IG1pcEludDtcblx0XHRcdHVuaWZvcm0gdmVjMyBwb2xlQXhpcztcblxuXHRcdFx0I2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXG5cdFx0XHQjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxuXG5cdFx0XHR2ZWMzIGdldFNhbXBsZSggZmxvYXQgdGhldGEsIHZlYzMgYXhpcyApIHtcblxuXHRcdFx0XHRmbG9hdCBjb3NUaGV0YSA9IGNvcyggdGhldGEgKTtcblx0XHRcdFx0Ly8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uXG5cdFx0XHRcdHZlYzMgc2FtcGxlRGlyZWN0aW9uID0gdk91dHB1dERpcmVjdGlvbiAqIGNvc1RoZXRhXG5cdFx0XHRcdFx0KyBjcm9zcyggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogc2luKCB0aGV0YSApXG5cdFx0XHRcdFx0KyBheGlzICogZG90KCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiAoIDEuMCAtIGNvc1RoZXRhICk7XG5cblx0XHRcdFx0cmV0dXJuIGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpcmVjdGlvbiwgbWlwSW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdHZlYzMgYXhpcyA9IGxhdGl0dWRpbmFsID8gcG9sZUF4aXMgOiBjcm9zcyggcG9sZUF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRpZiAoIGFsbCggZXF1YWwoIGF4aXMsIHZlYzMoIDAuMCApICkgKSApIHtcblxuXHRcdFx0XHRcdGF4aXMgPSB2ZWMzKCB2T3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgLSB2T3V0cHV0RGlyZWN0aW9uLnggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXhpcyA9IG5vcm1hbGl6ZSggYXhpcyApO1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xuXHRcdFx0XHRnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIDAgXSAqIGdldFNhbXBsZSggMC4wLCBheGlzICk7XG5cblx0XHRcdFx0Zm9yICggaW50IGkgPSAxOyBpIDwgbjsgaSsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpID49IHNhbXBsZXMgKSB7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmxvYXQgdGhldGEgPSBkVGhldGEgKiBmbG9hdCggaSApO1xuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCAtMS4wICogdGhldGEsIGF4aXMgKTtcblx0XHRcdFx0XHRnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggdGhldGEsIGF4aXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRgLFxuICAgIGJsZW5kaW5nOiAwLFxuICAgIGRlcHRoVGVzdDogITEsXG4gICAgZGVwdGhXcml0ZTogITFcbiAgfSk7XG59XG5mdW5jdGlvbiBmcigpIHtcbiAgcmV0dXJuIG5ldyBUbih7XG4gICAgbmFtZTogXCJFcXVpcmVjdGFuZ3VsYXJUb0N1YmVVVlwiLFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICBlbnZNYXA6IHsgdmFsdWU6IG51bGwgfVxuICAgIH0sXG4gICAgdmVydGV4U2hhZGVyOiBHcygpLFxuICAgIGZyYWdtZW50U2hhZGVyOiBgXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcblxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xuXG5cdFx0XHQjaW5jbHVkZSA8Y29tbW9uPlxuXG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0dmVjMyBvdXRwdXREaXJlY3Rpb24gPSBub3JtYWxpemUoIHZPdXRwdXREaXJlY3Rpb24gKTtcblx0XHRcdFx0dmVjMiB1diA9IGVxdWlyZWN0VXYoIG91dHB1dERpcmVjdGlvbiApO1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCAoIGVudk1hcCwgdXYgKS5yZ2IsIDEuMCApO1xuXG5cdFx0XHR9XG5cdFx0YCxcbiAgICBibGVuZGluZzogMCxcbiAgICBkZXB0aFRlc3Q6ICExLFxuICAgIGRlcHRoV3JpdGU6ICExXG4gIH0pO1xufVxuZnVuY3Rpb24gcHIoKSB7XG4gIHJldHVybiBuZXcgVG4oe1xuICAgIG5hbWU6IFwiQ3ViZW1hcFRvQ3ViZVVWXCIsXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgZmxpcEVudk1hcDogeyB2YWx1ZTogLTEgfVxuICAgIH0sXG4gICAgdmVydGV4U2hhZGVyOiBHcygpLFxuICAgIGZyYWdtZW50U2hhZGVyOiBgXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcblxuXHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiB2T3V0cHV0RGlyZWN0aW9uLngsIHZPdXRwdXREaXJlY3Rpb24ueXogKSApO1xuXG5cdFx0XHR9XG5cdFx0YCxcbiAgICBibGVuZGluZzogMCxcbiAgICBkZXB0aFRlc3Q6ICExLFxuICAgIGRlcHRoV3JpdGU6ICExXG4gIH0pO1xufVxuZnVuY3Rpb24gR3MoKSB7XG4gIHJldHVybiBgXG5cblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRhdHRyaWJ1dGUgZmxvYXQgZmFjZUluZGV4O1xuXG5cdFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XG5cblx0XHQvLyBSSCBjb29yZGluYXRlIHN5c3RlbTsgUE1SRU0gZmFjZS1pbmRleGluZyBjb252ZW50aW9uXG5cdFx0dmVjMyBnZXREaXJlY3Rpb24oIHZlYzIgdXYsIGZsb2F0IGZhY2UgKSB7XG5cblx0XHRcdHV2ID0gMi4wICogdXYgLSAxLjA7XG5cblx0XHRcdHZlYzMgZGlyZWN0aW9uID0gdmVjMyggdXYsIDEuMCApO1xuXG5cdFx0XHRpZiAoIGZhY2UgPT0gMC4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7IC8vICggMSwgdiwgdSApIHBvcyB4XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7XG5cdFx0XHRcdGRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC11LCAxLCAtdiApIHBvcyB5XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMi4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbi54ICo9IC0xLjA7IC8vICggLXUsIHYsIDEgKSBwb3MgelxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4O1xuXHRcdFx0XHRkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeFxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24ueHp5O1xuXHRcdFx0XHRkaXJlY3Rpb24ueHkgKj0gLTEuMDsgLy8gKCAtdSwgLTEsIHYgKSBuZWcgeVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDUuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24ueiAqPSAtMS4wOyAvLyAoIHUsIHYsIC0xICkgbmVnIHpcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlyZWN0aW9uO1xuXG5cdFx0fVxuXG5cdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHR2T3V0cHV0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKCB1diwgZmFjZUluZGV4ICk7XG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcblxuXHRcdH1cblx0YDtcbn1cbmZ1bmN0aW9uIEhjKGgpIHtcbiAgbGV0IGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgdCA9IG51bGw7XG4gIGZ1bmN0aW9uIG4ocikge1xuICAgIGlmIChyICYmIHIuaXNUZXh0dXJlKSB7XG4gICAgICBjb25zdCBsID0gci5tYXBwaW5nLCBhID0gbCA9PT0gMzAzIHx8IGwgPT09IDMwNCwgYyA9IGwgPT09IDMwMSB8fCBsID09PSAzMDI7XG4gICAgICBpZiAoYSB8fCBjKVxuICAgICAgICBpZiAoci5pc1JlbmRlclRhcmdldFRleHR1cmUgJiYgci5uZWVkc1BNUkVNVXBkYXRlID09PSAhMCkge1xuICAgICAgICAgIHIubmVlZHNQTVJFTVVwZGF0ZSA9ICExO1xuICAgICAgICAgIGxldCBkID0gZS5nZXQocik7XG4gICAgICAgICAgcmV0dXJuIHQgPT09IG51bGwgJiYgKHQgPSBuZXcgdXIoaCkpLCBkID0gYSA/IHQuZnJvbUVxdWlyZWN0YW5ndWxhcihyLCBkKSA6IHQuZnJvbUN1YmVtYXAociwgZCksIGUuc2V0KHIsIGQpLCBkLnRleHR1cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGUuaGFzKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGUuZ2V0KHIpLnRleHR1cmU7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZCA9IHIuaW1hZ2U7XG4gICAgICAgICAgICBpZiAoYSAmJiBkICYmIGQuaGVpZ2h0ID4gMCB8fCBjICYmIGQgJiYgaShkKSkge1xuICAgICAgICAgICAgICB0ID09PSBudWxsICYmICh0ID0gbmV3IHVyKGgpKTtcbiAgICAgICAgICAgICAgY29uc3QgdSA9IGEgPyB0LmZyb21FcXVpcmVjdGFuZ3VsYXIocikgOiB0LmZyb21DdWJlbWFwKHIpO1xuICAgICAgICAgICAgICByZXR1cm4gZS5zZXQociwgdSksIHIuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIiwgcyksIHUudGV4dHVyZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gaShyKSB7XG4gICAgbGV0IGwgPSAwO1xuICAgIGNvbnN0IGEgPSA2O1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYTsgYysrKVxuICAgICAgcltjXSAhPT0gdm9pZCAwICYmIGwrKztcbiAgICByZXR1cm4gbCA9PT0gYTtcbiAgfVxuICBmdW5jdGlvbiBzKHIpIHtcbiAgICBjb25zdCBsID0gci50YXJnZXQ7XG4gICAgbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCBzKTtcbiAgICBjb25zdCBhID0gZS5nZXQobCk7XG4gICAgYSAhPT0gdm9pZCAwICYmIChlLmRlbGV0ZShsKSwgYS5kaXNwb3NlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCB0ICE9PSBudWxsICYmICh0LmRpc3Bvc2UoKSwgdCA9IG51bGwpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiBuLFxuICAgIGRpc3Bvc2U6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHFjKGgpIHtcbiAgY29uc3QgZSA9IHt9O1xuICBmdW5jdGlvbiB0KG4pIHtcbiAgICBpZiAoZVtuXSAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGVbbl07XG4gICAgbGV0IGk7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiOlxuICAgICAgICBpID0gaC5nZXRFeHRlbnNpb24oXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIpIHx8IGguZ2V0RXh0ZW5zaW9uKFwiTU9aX1dFQkdMX2RlcHRoX3RleHR1cmVcIikgfHwgaC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCI6XG4gICAgICAgIGkgPSBoLmdldEV4dGVuc2lvbihcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSB8fCBoLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikgfHwgaC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiOlxuICAgICAgICBpID0gaC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSB8fCBoLmdldEV4dGVuc2lvbihcIk1PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSB8fCBoLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCI6XG4gICAgICAgIGkgPSBoLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSB8fCBoLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaSA9IGguZ2V0RXh0ZW5zaW9uKG4pO1xuICAgIH1cbiAgICByZXR1cm4gZVtuXSA9IGksIGk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoYXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB0KG4pICE9PSBudWxsO1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24obikge1xuICAgICAgbi5pc1dlYkdMMiA/IHQoXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpIDogKHQoXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIpLCB0KFwiT0VTX3RleHR1cmVfZmxvYXRcIiksIHQoXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLCB0KFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIiksIHQoXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIiksIHQoXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpLCB0KFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiksIHQoXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpKSwgdChcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSwgdChcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSwgdChcIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZVwiKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24obikge1xuICAgICAgY29uc3QgaSA9IHQobik7XG4gICAgICByZXR1cm4gaSA9PT0gbnVsbCAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBcIiArIG4gKyBcIiBleHRlbnNpb24gbm90IHN1cHBvcnRlZC5cIiksIGk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gWGMoaCwgZSwgdCwgbikge1xuICBjb25zdCBpID0ge30sIHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gbyhkKSB7XG4gICAgY29uc3QgdSA9IGQudGFyZ2V0O1xuICAgIHUuaW5kZXggIT09IG51bGwgJiYgZS5yZW1vdmUodS5pbmRleCk7XG4gICAgZm9yIChjb25zdCBnIGluIHUuYXR0cmlidXRlcylcbiAgICAgIGUucmVtb3ZlKHUuYXR0cmlidXRlc1tnXSk7XG4gICAgdS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCBvKSwgZGVsZXRlIGlbdS5pZF07XG4gICAgY29uc3QgbSA9IHMuZ2V0KHUpO1xuICAgIG0gJiYgKGUucmVtb3ZlKG0pLCBzLmRlbGV0ZSh1KSksIG4ucmVsZWFzZVN0YXRlc09mR2VvbWV0cnkodSksIHUuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9PT0gITAgJiYgZGVsZXRlIHUuX21heEluc3RhbmNlQ291bnQsIHQubWVtb3J5Lmdlb21ldHJpZXMtLTtcbiAgfVxuICBmdW5jdGlvbiByKGQsIHUpIHtcbiAgICByZXR1cm4gaVt1LmlkXSA9PT0gITAgfHwgKHUuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIiwgbyksIGlbdS5pZF0gPSAhMCwgdC5tZW1vcnkuZ2VvbWV0cmllcysrKSwgdTtcbiAgfVxuICBmdW5jdGlvbiBsKGQpIHtcbiAgICBjb25zdCB1ID0gZC5hdHRyaWJ1dGVzO1xuICAgIGZvciAoY29uc3QgZyBpbiB1KVxuICAgICAgZS51cGRhdGUodVtnXSwgMzQ5NjIpO1xuICAgIGNvbnN0IG0gPSBkLm1vcnBoQXR0cmlidXRlcztcbiAgICBmb3IgKGNvbnN0IGcgaW4gbSkge1xuICAgICAgY29uc3QgcCA9IG1bZ107XG4gICAgICBmb3IgKGxldCBmID0gMCwgdiA9IHAubGVuZ3RoOyBmIDwgdjsgZisrKVxuICAgICAgICBlLnVwZGF0ZShwW2ZdLCAzNDk2Mik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGEoZCkge1xuICAgIGNvbnN0IHUgPSBbXSwgbSA9IGQuaW5kZXgsIGcgPSBkLmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgbGV0IHAgPSAwO1xuICAgIGlmIChtICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBfID0gbS5hcnJheTtcbiAgICAgIHAgPSBtLnZlcnNpb247XG4gICAgICBmb3IgKGxldCB3ID0gMCwgeCA9IF8ubGVuZ3RoOyB3IDwgeDsgdyArPSAzKSB7XG4gICAgICAgIGNvbnN0IE0gPSBfW3cgKyAwXSwgRSA9IF9bdyArIDFdLCBSID0gX1t3ICsgMl07XG4gICAgICAgIHUucHVzaChNLCBFLCBFLCBSLCBSLCBNKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgXyA9IGcuYXJyYXk7XG4gICAgICBwID0gZy52ZXJzaW9uO1xuICAgICAgZm9yIChsZXQgdyA9IDAsIHggPSBfLmxlbmd0aCAvIDMgLSAxOyB3IDwgeDsgdyArPSAzKSB7XG4gICAgICAgIGNvbnN0IE0gPSB3ICsgMCwgRSA9IHcgKyAxLCBSID0gdyArIDI7XG4gICAgICAgIHUucHVzaChNLCBFLCBFLCBSLCBSLCBNKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZiA9IG5ldyAodG8odSkgPyBjbyA6IGxvKSh1LCAxKTtcbiAgICBmLnZlcnNpb24gPSBwO1xuICAgIGNvbnN0IHYgPSBzLmdldChkKTtcbiAgICB2ICYmIGUucmVtb3ZlKHYpLCBzLnNldChkLCBmKTtcbiAgfVxuICBmdW5jdGlvbiBjKGQpIHtcbiAgICBjb25zdCB1ID0gcy5nZXQoZCk7XG4gICAgaWYgKHUpIHtcbiAgICAgIGNvbnN0IG0gPSBkLmluZGV4O1xuICAgICAgbSAhPT0gbnVsbCAmJiB1LnZlcnNpb24gPCBtLnZlcnNpb24gJiYgYShkKTtcbiAgICB9IGVsc2VcbiAgICAgIGEoZCk7XG4gICAgcmV0dXJuIHMuZ2V0KGQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiByLFxuICAgIHVwZGF0ZTogbCxcbiAgICBnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIGpjKGgsIGUsIHQsIG4pIHtcbiAgY29uc3QgaSA9IG4uaXNXZWJHTDI7XG4gIGxldCBzO1xuICBmdW5jdGlvbiBvKHUpIHtcbiAgICBzID0gdTtcbiAgfVxuICBsZXQgciwgbDtcbiAgZnVuY3Rpb24gYSh1KSB7XG4gICAgciA9IHUudHlwZSwgbCA9IHUuYnl0ZXNQZXJFbGVtZW50O1xuICB9XG4gIGZ1bmN0aW9uIGModSwgbSkge1xuICAgIGguZHJhd0VsZW1lbnRzKHMsIG0sIHIsIHUgKiBsKSwgdC51cGRhdGUobSwgcywgMSk7XG4gIH1cbiAgZnVuY3Rpb24gZCh1LCBtLCBnKSB7XG4gICAgaWYgKGcgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IHAsIGY7XG4gICAgaWYgKGkpXG4gICAgICBwID0gaCwgZiA9IFwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkXCI7XG4gICAgZWxzZSBpZiAocCA9IGUuZ2V0KFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKSwgZiA9IFwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEVcIiwgcCA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBbZl0ocywgbSwgciwgdSAqIGwsIGcpLCB0LnVwZGF0ZShtLCBzLCBnKTtcbiAgfVxuICB0aGlzLnNldE1vZGUgPSBvLCB0aGlzLnNldEluZGV4ID0gYSwgdGhpcy5yZW5kZXIgPSBjLCB0aGlzLnJlbmRlckluc3RhbmNlcyA9IGQ7XG59XG5mdW5jdGlvbiBZYyhoKSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgZ2VvbWV0cmllczogMCxcbiAgICB0ZXh0dXJlczogMFxuICB9LCB0ID0ge1xuICAgIGZyYW1lOiAwLFxuICAgIGNhbGxzOiAwLFxuICAgIHRyaWFuZ2xlczogMCxcbiAgICBwb2ludHM6IDAsXG4gICAgbGluZXM6IDBcbiAgfTtcbiAgZnVuY3Rpb24gbihzLCBvLCByKSB7XG4gICAgc3dpdGNoICh0LmNhbGxzKyssIG8pIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgdC50cmlhbmdsZXMgKz0gciAqIChzIC8gMyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0LmxpbmVzICs9IHIgKiAocyAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdC5saW5lcyArPSByICogKHMgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHQubGluZXMgKz0gciAqIHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0LnBvaW50cyArPSByICogcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xJbmZvOiBVbmtub3duIGRyYXcgbW9kZTpcIiwgbyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpKCkge1xuICAgIHQuZnJhbWUrKywgdC5jYWxscyA9IDAsIHQudHJpYW5nbGVzID0gMCwgdC5wb2ludHMgPSAwLCB0LmxpbmVzID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lbW9yeTogZSxcbiAgICByZW5kZXI6IHQsXG4gICAgcHJvZ3JhbXM6IG51bGwsXG4gICAgYXV0b1Jlc2V0OiAhMCxcbiAgICByZXNldDogaSxcbiAgICB1cGRhdGU6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIFpjKGgsIGUpIHtcbiAgcmV0dXJuIGhbMF0gLSBlWzBdO1xufVxuZnVuY3Rpb24gJGMoaCwgZSkge1xuICByZXR1cm4gTWF0aC5hYnMoZVsxXSkgLSBNYXRoLmFicyhoWzFdKTtcbn1cbmZ1bmN0aW9uIFNzKGgsIGUpIHtcbiAgbGV0IHQgPSAxO1xuICBjb25zdCBuID0gZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gZS5kYXRhLmFycmF5IDogZS5hcnJheTtcbiAgbiBpbnN0YW5jZW9mIEludDhBcnJheSA/IHQgPSAxMjcgOiBuIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHQgPSAyNTUgOiBuIGluc3RhbmNlb2YgVWludDE2QXJyYXkgPyB0ID0gNjU1MzUgOiBuIGluc3RhbmNlb2YgSW50MTZBcnJheSA/IHQgPSAzMjc2NyA6IG4gaW5zdGFuY2VvZiBJbnQzMkFycmF5ID8gdCA9IDIxNDc0ODM2NDcgOiBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xNb3JwaHRhcmdldHM6IFVuc3VwcG9ydGVkIG1vcnBoIGF0dHJpYnV0ZSBkYXRhIHR5cGU6IFwiLCBuKSwgaC5kaXZpZGVTY2FsYXIodCk7XG59XG5mdW5jdGlvbiBLYyhoLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSB7fSwgaSA9IG5ldyBGbG9hdDMyQXJyYXkoOCksIHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgbyA9IG5ldyAkZSgpLCByID0gW107XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgODsgYSsrKVxuICAgIHJbYV0gPSBbYSwgMF07XG4gIGZ1bmN0aW9uIGwoYSwgYywgZCwgdSkge1xuICAgIGNvbnN0IG0gPSBhLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcbiAgICBpZiAoZS5pc1dlYkdMMiA9PT0gITApIHtcbiAgICAgIGNvbnN0IGcgPSBjLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBjLm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgYy5tb3JwaEF0dHJpYnV0ZXMuY29sb3IsIHAgPSBnICE9PSB2b2lkIDAgPyBnLmxlbmd0aCA6IDA7XG4gICAgICBsZXQgZiA9IHMuZ2V0KGMpO1xuICAgICAgaWYgKGYgPT09IHZvaWQgMCB8fCBmLmNvdW50ICE9PSBwKSB7XG4gICAgICAgIGxldCBJID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgei5kaXNwb3NlKCksIHMuZGVsZXRlKGMpLCBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIEkpO1xuICAgICAgICB9O1xuICAgICAgICBmICE9PSB2b2lkIDAgJiYgZi50ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgY29uc3QgdyA9IGMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB2b2lkIDAsIHggPSBjLm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHZvaWQgMCwgTSA9IGMubW9ycGhBdHRyaWJ1dGVzLmNvbG9yICE9PSB2b2lkIDAsIEUgPSBjLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBbXSwgUiA9IGMubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBbXSwgeSA9IGMubW9ycGhBdHRyaWJ1dGVzLmNvbG9yIHx8IFtdO1xuICAgICAgICBsZXQgQSA9IDA7XG4gICAgICAgIHcgPT09ICEwICYmIChBID0gMSksIHggPT09ICEwICYmIChBID0gMiksIE0gPT09ICEwICYmIChBID0gMyk7XG4gICAgICAgIGxldCBGID0gYy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICogQSwgUCA9IDE7XG4gICAgICAgIEYgPiBlLm1heFRleHR1cmVTaXplICYmIChQID0gTWF0aC5jZWlsKEYgLyBlLm1heFRleHR1cmVTaXplKSwgRiA9IGUubWF4VGV4dHVyZVNpemUpO1xuICAgICAgICBjb25zdCBHID0gbmV3IEZsb2F0MzJBcnJheShGICogUCAqIDQgKiBwKSwgeiA9IG5ldyBybyhHLCBGLCBQLCBwKTtcbiAgICAgICAgei50eXBlID0gMTAxNSwgei5uZWVkc1VwZGF0ZSA9ICEwO1xuICAgICAgICBjb25zdCBMID0gQSAqIDQ7XG4gICAgICAgIGZvciAobGV0IEQgPSAwOyBEIDwgcDsgRCsrKSB7XG4gICAgICAgICAgY29uc3QgcSA9IEVbRF0sIGsgPSBSW0RdLCBOID0geVtEXSwgSCA9IEYgKiBQICogNCAqIEQ7XG4gICAgICAgICAgZm9yIChsZXQgSiA9IDA7IEogPCBxLmNvdW50OyBKKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFYgPSBKICogTDtcbiAgICAgICAgICAgIHcgPT09ICEwICYmIChvLmZyb21CdWZmZXJBdHRyaWJ1dGUocSwgSiksIHEubm9ybWFsaXplZCA9PT0gITAgJiYgU3MobywgcSksIEdbSCArIFYgKyAwXSA9IG8ueCwgR1tIICsgViArIDFdID0gby55LCBHW0ggKyBWICsgMl0gPSBvLnosIEdbSCArIFYgKyAzXSA9IDApLCB4ID09PSAhMCAmJiAoby5mcm9tQnVmZmVyQXR0cmlidXRlKGssIEopLCBrLm5vcm1hbGl6ZWQgPT09ICEwICYmIFNzKG8sIGspLCBHW0ggKyBWICsgNF0gPSBvLngsIEdbSCArIFYgKyA1XSA9IG8ueSwgR1tIICsgViArIDZdID0gby56LCBHW0ggKyBWICsgN10gPSAwKSwgTSA9PT0gITAgJiYgKG8uZnJvbUJ1ZmZlckF0dHJpYnV0ZShOLCBKKSwgTi5ub3JtYWxpemVkID09PSAhMCAmJiBTcyhvLCBOKSwgR1tIICsgViArIDhdID0gby54LCBHW0ggKyBWICsgOV0gPSBvLnksIEdbSCArIFYgKyAxMF0gPSBvLnosIEdbSCArIFYgKyAxMV0gPSBOLml0ZW1TaXplID09PSA0ID8gby53IDogMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGYgPSB7XG4gICAgICAgICAgY291bnQ6IHAsXG4gICAgICAgICAgdGV4dHVyZTogeixcbiAgICAgICAgICBzaXplOiBuZXcgQ2UoRiwgUClcbiAgICAgICAgfSwgcy5zZXQoYywgZiksIGMuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIiwgSSk7XG4gICAgICB9XG4gICAgICBsZXQgdiA9IDA7XG4gICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IG0ubGVuZ3RoOyB3KyspXG4gICAgICAgIHYgKz0gbVt3XTtcbiAgICAgIGNvbnN0IF8gPSBjLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID8gMSA6IDEgLSB2O1xuICAgICAgdS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGgsIFwibW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlXCIsIF8pLCB1LmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoaCwgXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiwgbSksIHUuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShoLCBcIm1vcnBoVGFyZ2V0c1RleHR1cmVcIiwgZi50ZXh0dXJlLCB0KSwgdS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGgsIFwibW9ycGhUYXJnZXRzVGV4dHVyZVNpemVcIiwgZi5zaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZyA9IG0gPT09IHZvaWQgMCA/IDAgOiBtLmxlbmd0aDtcbiAgICAgIGxldCBwID0gbltjLmlkXTtcbiAgICAgIGlmIChwID09PSB2b2lkIDAgfHwgcC5sZW5ndGggIT09IGcpIHtcbiAgICAgICAgcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGc7IHgrKylcbiAgICAgICAgICBwW3hdID0gW3gsIDBdO1xuICAgICAgICBuW2MuaWRdID0gcDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgZzsgeCsrKSB7XG4gICAgICAgIGNvbnN0IE0gPSBwW3hdO1xuICAgICAgICBNWzBdID0geCwgTVsxXSA9IG1beF07XG4gICAgICB9XG4gICAgICBwLnNvcnQoJGMpO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA4OyB4KyspXG4gICAgICAgIHggPCBnICYmIHBbeF1bMV0gPyAoclt4XVswXSA9IHBbeF1bMF0sIHJbeF1bMV0gPSBwW3hdWzFdKSA6IChyW3hdWzBdID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIHJbeF1bMV0gPSAwKTtcbiAgICAgIHIuc29ydChaYyk7XG4gICAgICBjb25zdCBmID0gYy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24sIHYgPSBjLm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICBsZXQgXyA9IDA7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDg7IHgrKykge1xuICAgICAgICBjb25zdCBNID0gclt4XSwgRSA9IE1bMF0sIFIgPSBNWzFdO1xuICAgICAgICBFICE9PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBSID8gKGYgJiYgYy5nZXRBdHRyaWJ1dGUoXCJtb3JwaFRhcmdldFwiICsgeCkgIT09IGZbRV0gJiYgYy5zZXRBdHRyaWJ1dGUoXCJtb3JwaFRhcmdldFwiICsgeCwgZltFXSksIHYgJiYgYy5nZXRBdHRyaWJ1dGUoXCJtb3JwaE5vcm1hbFwiICsgeCkgIT09IHZbRV0gJiYgYy5zZXRBdHRyaWJ1dGUoXCJtb3JwaE5vcm1hbFwiICsgeCwgdltFXSksIGlbeF0gPSBSLCBfICs9IFIpIDogKGYgJiYgYy5oYXNBdHRyaWJ1dGUoXCJtb3JwaFRhcmdldFwiICsgeCkgPT09ICEwICYmIGMuZGVsZXRlQXR0cmlidXRlKFwibW9ycGhUYXJnZXRcIiArIHgpLCB2ICYmIGMuaGFzQXR0cmlidXRlKFwibW9ycGhOb3JtYWxcIiArIHgpID09PSAhMCAmJiBjLmRlbGV0ZUF0dHJpYnV0ZShcIm1vcnBoTm9ybWFsXCIgKyB4KSwgaVt4XSA9IDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdyA9IGMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAxIDogMSAtIF87XG4gICAgICB1LmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoaCwgXCJtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2VcIiwgdyksIHUuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShoLCBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiLCBpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIEpjKGgsIGUsIHQsIG4pIHtcbiAgbGV0IGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcyhsKSB7XG4gICAgY29uc3QgYSA9IG4ucmVuZGVyLmZyYW1lLCBjID0gbC5nZW9tZXRyeSwgZCA9IGUuZ2V0KGwsIGMpO1xuICAgIHJldHVybiBpLmdldChkKSAhPT0gYSAmJiAoZS51cGRhdGUoZCksIGkuc2V0KGQsIGEpKSwgbC5pc0luc3RhbmNlZE1lc2ggJiYgKGwuaGFzRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIiwgcikgPT09ICExICYmIGwuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIiwgciksIHQudXBkYXRlKGwuaW5zdGFuY2VNYXRyaXgsIDM0OTYyKSwgbC5pbnN0YW5jZUNvbG9yICE9PSBudWxsICYmIHQudXBkYXRlKGwuaW5zdGFuY2VDb2xvciwgMzQ5NjIpKSwgZDtcbiAgfVxuICBmdW5jdGlvbiBvKCkge1xuICAgIGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxuICBmdW5jdGlvbiByKGwpIHtcbiAgICBjb25zdCBhID0gbC50YXJnZXQ7XG4gICAgYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCByKSwgdC5yZW1vdmUoYS5pbnN0YW5jZU1hdHJpeCksIGEuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCAmJiB0LnJlbW92ZShhLmluc3RhbmNlQ29sb3IpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBzLFxuICAgIGRpc3Bvc2U6IG9cbiAgfTtcbn1cbmNvbnN0IHBvID0gLyogQF9fUFVSRV9fICovIG5ldyBfdCgpLCBtbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgcm8oKSwgZ28gPSAvKiBAX19QVVJFX18gKi8gbmV3IFVvKCksIF9vID0gLyogQF9fUFVSRV9fICovIG5ldyB1bygpLCBtciA9IFtdLCBnciA9IFtdLCBfciA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpLCB2ciA9IG5ldyBGbG9hdDMyQXJyYXkoOSksIHhyID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbmZ1bmN0aW9uIEtuKGgsIGUsIHQpIHtcbiAgY29uc3QgbiA9IGhbMF07XG4gIGlmIChuIDw9IDAgfHwgbiA+IDApXG4gICAgcmV0dXJuIGg7XG4gIGNvbnN0IGkgPSBlICogdDtcbiAgbGV0IHMgPSBtcltpXTtcbiAgaWYgKHMgPT09IHZvaWQgMCAmJiAocyA9IG5ldyBGbG9hdDMyQXJyYXkoaSksIG1yW2ldID0gcyksIGUgIT09IDApIHtcbiAgICBuLnRvQXJyYXkocywgMCk7XG4gICAgZm9yIChsZXQgbyA9IDEsIHIgPSAwOyBvICE9PSBlOyArK28pXG4gICAgICByICs9IHQsIGhbb10udG9BcnJheShzLCByKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGx0KGgsIGUpIHtcbiAgaWYgKGgubGVuZ3RoICE9PSBlLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IHQgPSAwLCBuID0gaC5sZW5ndGg7IHQgPCBuOyB0KyspXG4gICAgaWYgKGhbdF0gIT09IGVbdF0pXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGN0KGgsIGUpIHtcbiAgZm9yIChsZXQgdCA9IDAsIG4gPSBlLmxlbmd0aDsgdCA8IG47IHQrKylcbiAgICBoW3RdID0gZVt0XTtcbn1cbmZ1bmN0aW9uIFlpKGgsIGUpIHtcbiAgbGV0IHQgPSBncltlXTtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IEludDMyQXJyYXkoZSksIGdyW2VdID0gdCk7XG4gIGZvciAobGV0IG4gPSAwOyBuICE9PSBlOyArK24pXG4gICAgdFtuXSA9IGguYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFFjKGgsIGUpIHtcbiAgY29uc3QgdCA9IHRoaXMuY2FjaGU7XG4gIHRbMF0gIT09IGUgJiYgKGgudW5pZm9ybTFmKHRoaXMuYWRkciwgZSksIHRbMF0gPSBlKTtcbn1cbmZ1bmN0aW9uIGVoKGgsIGUpIHtcbiAgY29uc3QgdCA9IHRoaXMuY2FjaGU7XG4gIGlmIChlLnggIT09IHZvaWQgMClcbiAgICAodFswXSAhPT0gZS54IHx8IHRbMV0gIT09IGUueSkgJiYgKGgudW5pZm9ybTJmKHRoaXMuYWRkciwgZS54LCBlLnkpLCB0WzBdID0gZS54LCB0WzFdID0gZS55KTtcbiAgZWxzZSB7XG4gICAgaWYgKGx0KHQsIGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGgudW5pZm9ybTJmdih0aGlzLmFkZHIsIGUpLCBjdCh0LCBlKTtcbiAgfVxufVxuZnVuY3Rpb24gdGgoaCwgZSkge1xuICBjb25zdCB0ID0gdGhpcy5jYWNoZTtcbiAgaWYgKGUueCAhPT0gdm9pZCAwKVxuICAgICh0WzBdICE9PSBlLnggfHwgdFsxXSAhPT0gZS55IHx8IHRbMl0gIT09IGUueikgJiYgKGgudW5pZm9ybTNmKHRoaXMuYWRkciwgZS54LCBlLnksIGUueiksIHRbMF0gPSBlLngsIHRbMV0gPSBlLnksIHRbMl0gPSBlLnopO1xuICBlbHNlIGlmIChlLnIgIT09IHZvaWQgMClcbiAgICAodFswXSAhPT0gZS5yIHx8IHRbMV0gIT09IGUuZyB8fCB0WzJdICE9PSBlLmIpICYmIChoLnVuaWZvcm0zZih0aGlzLmFkZHIsIGUuciwgZS5nLCBlLmIpLCB0WzBdID0gZS5yLCB0WzFdID0gZS5nLCB0WzJdID0gZS5iKTtcbiAgZWxzZSB7XG4gICAgaWYgKGx0KHQsIGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGgudW5pZm9ybTNmdih0aGlzLmFkZHIsIGUpLCBjdCh0LCBlKTtcbiAgfVxufVxuZnVuY3Rpb24gbmgoaCwgZSkge1xuICBjb25zdCB0ID0gdGhpcy5jYWNoZTtcbiAgaWYgKGUueCAhPT0gdm9pZCAwKVxuICAgICh0WzBdICE9PSBlLnggfHwgdFsxXSAhPT0gZS55IHx8IHRbMl0gIT09IGUueiB8fCB0WzNdICE9PSBlLncpICYmIChoLnVuaWZvcm00Zih0aGlzLmFkZHIsIGUueCwgZS55LCBlLnosIGUudyksIHRbMF0gPSBlLngsIHRbMV0gPSBlLnksIHRbMl0gPSBlLnosIHRbM10gPSBlLncpO1xuICBlbHNlIHtcbiAgICBpZiAobHQodCwgZSkpXG4gICAgICByZXR1cm47XG4gICAgaC51bmlmb3JtNGZ2KHRoaXMuYWRkciwgZSksIGN0KHQsIGUpO1xuICB9XG59XG5mdW5jdGlvbiBpaChoLCBlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmNhY2hlLCBuID0gZS5lbGVtZW50cztcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIGlmIChsdCh0LCBlKSlcbiAgICAgIHJldHVybjtcbiAgICBoLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCAhMSwgZSksIGN0KHQsIGUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChsdCh0LCBuKSlcbiAgICAgIHJldHVybjtcbiAgICB4ci5zZXQobiksIGgudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsICExLCB4ciksIGN0KHQsIG4pO1xuICB9XG59XG5mdW5jdGlvbiBzaChoLCBlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmNhY2hlLCBuID0gZS5lbGVtZW50cztcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIGlmIChsdCh0LCBlKSlcbiAgICAgIHJldHVybjtcbiAgICBoLnVuaWZvcm1NYXRyaXgzZnYodGhpcy5hZGRyLCAhMSwgZSksIGN0KHQsIGUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChsdCh0LCBuKSlcbiAgICAgIHJldHVybjtcbiAgICB2ci5zZXQobiksIGgudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsICExLCB2ciksIGN0KHQsIG4pO1xuICB9XG59XG5mdW5jdGlvbiByaChoLCBlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmNhY2hlLCBuID0gZS5lbGVtZW50cztcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIGlmIChsdCh0LCBlKSlcbiAgICAgIHJldHVybjtcbiAgICBoLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCAhMSwgZSksIGN0KHQsIGUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChsdCh0LCBuKSlcbiAgICAgIHJldHVybjtcbiAgICBfci5zZXQobiksIGgudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsICExLCBfciksIGN0KHQsIG4pO1xuICB9XG59XG5mdW5jdGlvbiBvaChoLCBlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmNhY2hlO1xuICB0WzBdICE9PSBlICYmIChoLnVuaWZvcm0xaSh0aGlzLmFkZHIsIGUpLCB0WzBdID0gZSk7XG59XG5mdW5jdGlvbiBhaChoLCBlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmNhY2hlO1xuICBsdCh0LCBlKSB8fCAoaC51bmlmb3JtMml2KHRoaXMuYWRkciwgZSksIGN0KHQsIGUpKTtcbn1cbmZ1bmN0aW9uIGxoKGgsIGUpIHtcbiAgY29uc3QgdCA9IHRoaXMuY2FjaGU7XG4gIGx0KHQsIGUpIHx8IChoLnVuaWZvcm0zaXYodGhpcy5hZGRyLCBlKSwgY3QodCwgZSkpO1xufVxuZnVuY3Rpb24gY2goaCwgZSkge1xuICBjb25zdCB0ID0gdGhpcy5jYWNoZTtcbiAgbHQodCwgZSkgfHwgKGgudW5pZm9ybTRpdih0aGlzLmFkZHIsIGUpLCBjdCh0LCBlKSk7XG59XG5mdW5jdGlvbiBoaChoLCBlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmNhY2hlO1xuICB0WzBdICE9PSBlICYmIChoLnVuaWZvcm0xdWkodGhpcy5hZGRyLCBlKSwgdFswXSA9IGUpO1xufVxuZnVuY3Rpb24gdWgoaCwgZSkge1xuICBjb25zdCB0ID0gdGhpcy5jYWNoZTtcbiAgbHQodCwgZSkgfHwgKGgudW5pZm9ybTJ1aXYodGhpcy5hZGRyLCBlKSwgY3QodCwgZSkpO1xufVxuZnVuY3Rpb24gZGgoaCwgZSkge1xuICBjb25zdCB0ID0gdGhpcy5jYWNoZTtcbiAgbHQodCwgZSkgfHwgKGgudW5pZm9ybTN1aXYodGhpcy5hZGRyLCBlKSwgY3QodCwgZSkpO1xufVxuZnVuY3Rpb24gZmgoaCwgZSkge1xuICBjb25zdCB0ID0gdGhpcy5jYWNoZTtcbiAgbHQodCwgZSkgfHwgKGgudW5pZm9ybTR1aXYodGhpcy5hZGRyLCBlKSwgY3QodCwgZSkpO1xufVxuZnVuY3Rpb24gcGgoaCwgZSwgdCkge1xuICBjb25zdCBuID0gdGhpcy5jYWNoZSwgaSA9IHQuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuICBuWzBdICE9PSBpICYmIChoLnVuaWZvcm0xaSh0aGlzLmFkZHIsIGkpLCBuWzBdID0gaSksIHQuc2V0VGV4dHVyZTJEKGUgfHwgcG8sIGkpO1xufVxuZnVuY3Rpb24gbWgoaCwgZSwgdCkge1xuICBjb25zdCBuID0gdGhpcy5jYWNoZSwgaSA9IHQuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuICBuWzBdICE9PSBpICYmIChoLnVuaWZvcm0xaSh0aGlzLmFkZHIsIGkpLCBuWzBdID0gaSksIHQuc2V0VGV4dHVyZTNEKGUgfHwgZ28sIGkpO1xufVxuZnVuY3Rpb24gZ2goaCwgZSwgdCkge1xuICBjb25zdCBuID0gdGhpcy5jYWNoZSwgaSA9IHQuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuICBuWzBdICE9PSBpICYmIChoLnVuaWZvcm0xaSh0aGlzLmFkZHIsIGkpLCBuWzBdID0gaSksIHQuc2V0VGV4dHVyZUN1YmUoZSB8fCBfbywgaSk7XG59XG5mdW5jdGlvbiBfaChoLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSB0aGlzLmNhY2hlLCBpID0gdC5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XG4gIG5bMF0gIT09IGkgJiYgKGgudW5pZm9ybTFpKHRoaXMuYWRkciwgaSksIG5bMF0gPSBpKSwgdC5zZXRUZXh0dXJlMkRBcnJheShlIHx8IG1vLCBpKTtcbn1cbmZ1bmN0aW9uIHZoKGgpIHtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSA1MTI2OlxuICAgICAgcmV0dXJuIFFjO1xuICAgIGNhc2UgMzU2NjQ6XG4gICAgICByZXR1cm4gZWg7XG4gICAgY2FzZSAzNTY2NTpcbiAgICAgIHJldHVybiB0aDtcbiAgICBjYXNlIDM1NjY2OlxuICAgICAgcmV0dXJuIG5oO1xuICAgIGNhc2UgMzU2NzQ6XG4gICAgICByZXR1cm4gaWg7XG4gICAgY2FzZSAzNTY3NTpcbiAgICAgIHJldHVybiBzaDtcbiAgICBjYXNlIDM1Njc2OlxuICAgICAgcmV0dXJuIHJoO1xuICAgIGNhc2UgNTEyNDpcbiAgICBjYXNlIDM1NjcwOlxuICAgICAgcmV0dXJuIG9oO1xuICAgIGNhc2UgMzU2Njc6XG4gICAgY2FzZSAzNTY3MTpcbiAgICAgIHJldHVybiBhaDtcbiAgICBjYXNlIDM1NjY4OlxuICAgIGNhc2UgMzU2NzI6XG4gICAgICByZXR1cm4gbGg7XG4gICAgY2FzZSAzNTY2OTpcbiAgICBjYXNlIDM1NjczOlxuICAgICAgcmV0dXJuIGNoO1xuICAgIGNhc2UgNTEyNTpcbiAgICAgIHJldHVybiBoaDtcbiAgICBjYXNlIDM2Mjk0OlxuICAgICAgcmV0dXJuIHVoO1xuICAgIGNhc2UgMzYyOTU6XG4gICAgICByZXR1cm4gZGg7XG4gICAgY2FzZSAzNjI5NjpcbiAgICAgIHJldHVybiBmaDtcbiAgICBjYXNlIDM1Njc4OlxuICAgIGNhc2UgMzYxOTg6XG4gICAgY2FzZSAzNjI5ODpcbiAgICBjYXNlIDM2MzA2OlxuICAgIGNhc2UgMzU2ODI6XG4gICAgICByZXR1cm4gcGg7XG4gICAgY2FzZSAzNTY3OTpcbiAgICBjYXNlIDM2Mjk5OlxuICAgIGNhc2UgMzYzMDc6XG4gICAgICByZXR1cm4gbWg7XG4gICAgY2FzZSAzNTY4MDpcbiAgICBjYXNlIDM2MzAwOlxuICAgIGNhc2UgMzYzMDg6XG4gICAgY2FzZSAzNjI5MzpcbiAgICAgIHJldHVybiBnaDtcbiAgICBjYXNlIDM2Mjg5OlxuICAgIGNhc2UgMzYzMDM6XG4gICAgY2FzZSAzNjMxMTpcbiAgICBjYXNlIDM2MjkyOlxuICAgICAgcmV0dXJuIF9oO1xuICB9XG59XG5mdW5jdGlvbiB4aChoLCBlKSB7XG4gIGgudW5pZm9ybTFmdih0aGlzLmFkZHIsIGUpO1xufVxuZnVuY3Rpb24geWgoaCwgZSkge1xuICBjb25zdCB0ID0gS24oZSwgdGhpcy5zaXplLCAyKTtcbiAgaC51bmlmb3JtMmZ2KHRoaXMuYWRkciwgdCk7XG59XG5mdW5jdGlvbiBiaChoLCBlKSB7XG4gIGNvbnN0IHQgPSBLbihlLCB0aGlzLnNpemUsIDMpO1xuICBoLnVuaWZvcm0zZnYodGhpcy5hZGRyLCB0KTtcbn1cbmZ1bmN0aW9uIHdoKGgsIGUpIHtcbiAgY29uc3QgdCA9IEtuKGUsIHRoaXMuc2l6ZSwgNCk7XG4gIGgudW5pZm9ybTRmdih0aGlzLmFkZHIsIHQpO1xufVxuZnVuY3Rpb24gTWgoaCwgZSkge1xuICBjb25zdCB0ID0gS24oZSwgdGhpcy5zaXplLCA0KTtcbiAgaC51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwgITEsIHQpO1xufVxuZnVuY3Rpb24gU2goaCwgZSkge1xuICBjb25zdCB0ID0gS24oZSwgdGhpcy5zaXplLCA5KTtcbiAgaC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgITEsIHQpO1xufVxuZnVuY3Rpb24gRWgoaCwgZSkge1xuICBjb25zdCB0ID0gS24oZSwgdGhpcy5zaXplLCAxNik7XG4gIGgudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsICExLCB0KTtcbn1cbmZ1bmN0aW9uIFRoKGgsIGUpIHtcbiAgaC51bmlmb3JtMWl2KHRoaXMuYWRkciwgZSk7XG59XG5mdW5jdGlvbiBBaChoLCBlKSB7XG4gIGgudW5pZm9ybTJpdih0aGlzLmFkZHIsIGUpO1xufVxuZnVuY3Rpb24gQ2goaCwgZSkge1xuICBoLnVuaWZvcm0zaXYodGhpcy5hZGRyLCBlKTtcbn1cbmZ1bmN0aW9uIExoKGgsIGUpIHtcbiAgaC51bmlmb3JtNGl2KHRoaXMuYWRkciwgZSk7XG59XG5mdW5jdGlvbiBSaChoLCBlKSB7XG4gIGgudW5pZm9ybTF1aXYodGhpcy5hZGRyLCBlKTtcbn1cbmZ1bmN0aW9uIEZoKGgsIGUpIHtcbiAgaC51bmlmb3JtMnVpdih0aGlzLmFkZHIsIGUpO1xufVxuZnVuY3Rpb24gRGgoaCwgZSkge1xuICBoLnVuaWZvcm0zdWl2KHRoaXMuYWRkciwgZSk7XG59XG5mdW5jdGlvbiBQaChoLCBlKSB7XG4gIGgudW5pZm9ybTR1aXYodGhpcy5hZGRyLCBlKTtcbn1cbmZ1bmN0aW9uIEloKGgsIGUsIHQpIHtcbiAgY29uc3QgbiA9IGUubGVuZ3RoLCBpID0gWWkodCwgbik7XG4gIGgudW5pZm9ybTFpdih0aGlzLmFkZHIsIGkpO1xuICBmb3IgKGxldCBzID0gMDsgcyAhPT0gbjsgKytzKVxuICAgIHQuc2V0VGV4dHVyZTJEKGVbc10gfHwgcG8sIGlbc10pO1xufVxuZnVuY3Rpb24gemgoaCwgZSwgdCkge1xuICBjb25zdCBuID0gZS5sZW5ndGgsIGkgPSBZaSh0LCBuKTtcbiAgaC51bmlmb3JtMWl2KHRoaXMuYWRkciwgaSk7XG4gIGZvciAobGV0IHMgPSAwOyBzICE9PSBuOyArK3MpXG4gICAgdC5zZXRUZXh0dXJlM0QoZVtzXSB8fCBnbywgaVtzXSk7XG59XG5mdW5jdGlvbiBCaChoLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSBlLmxlbmd0aCwgaSA9IFlpKHQsIG4pO1xuICBoLnVuaWZvcm0xaXYodGhpcy5hZGRyLCBpKTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgIT09IG47ICsrcylcbiAgICB0LnNldFRleHR1cmVDdWJlKGVbc10gfHwgX28sIGlbc10pO1xufVxuZnVuY3Rpb24gTmgoaCwgZSwgdCkge1xuICBjb25zdCBuID0gZS5sZW5ndGgsIGkgPSBZaSh0LCBuKTtcbiAgaC51bmlmb3JtMWl2KHRoaXMuYWRkciwgaSk7XG4gIGZvciAobGV0IHMgPSAwOyBzICE9PSBuOyArK3MpXG4gICAgdC5zZXRUZXh0dXJlMkRBcnJheShlW3NdIHx8IG1vLCBpW3NdKTtcbn1cbmZ1bmN0aW9uIE9oKGgpIHtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSA1MTI2OlxuICAgICAgcmV0dXJuIHhoO1xuICAgIGNhc2UgMzU2NjQ6XG4gICAgICByZXR1cm4geWg7XG4gICAgY2FzZSAzNTY2NTpcbiAgICAgIHJldHVybiBiaDtcbiAgICBjYXNlIDM1NjY2OlxuICAgICAgcmV0dXJuIHdoO1xuICAgIGNhc2UgMzU2NzQ6XG4gICAgICByZXR1cm4gTWg7XG4gICAgY2FzZSAzNTY3NTpcbiAgICAgIHJldHVybiBTaDtcbiAgICBjYXNlIDM1Njc2OlxuICAgICAgcmV0dXJuIEVoO1xuICAgIGNhc2UgNTEyNDpcbiAgICBjYXNlIDM1NjcwOlxuICAgICAgcmV0dXJuIFRoO1xuICAgIGNhc2UgMzU2Njc6XG4gICAgY2FzZSAzNTY3MTpcbiAgICAgIHJldHVybiBBaDtcbiAgICBjYXNlIDM1NjY4OlxuICAgIGNhc2UgMzU2NzI6XG4gICAgICByZXR1cm4gQ2g7XG4gICAgY2FzZSAzNTY2OTpcbiAgICBjYXNlIDM1NjczOlxuICAgICAgcmV0dXJuIExoO1xuICAgIGNhc2UgNTEyNTpcbiAgICAgIHJldHVybiBSaDtcbiAgICBjYXNlIDM2Mjk0OlxuICAgICAgcmV0dXJuIEZoO1xuICAgIGNhc2UgMzYyOTU6XG4gICAgICByZXR1cm4gRGg7XG4gICAgY2FzZSAzNjI5NjpcbiAgICAgIHJldHVybiBQaDtcbiAgICBjYXNlIDM1Njc4OlxuICAgIGNhc2UgMzYxOTg6XG4gICAgY2FzZSAzNjI5ODpcbiAgICBjYXNlIDM2MzA2OlxuICAgIGNhc2UgMzU2ODI6XG4gICAgICByZXR1cm4gSWg7XG4gICAgY2FzZSAzNTY3OTpcbiAgICBjYXNlIDM2Mjk5OlxuICAgIGNhc2UgMzYzMDc6XG4gICAgICByZXR1cm4gemg7XG4gICAgY2FzZSAzNTY4MDpcbiAgICBjYXNlIDM2MzAwOlxuICAgIGNhc2UgMzYzMDg6XG4gICAgY2FzZSAzNjI5MzpcbiAgICAgIHJldHVybiBCaDtcbiAgICBjYXNlIDM2Mjg5OlxuICAgIGNhc2UgMzYzMDM6XG4gICAgY2FzZSAzNjMxMTpcbiAgICBjYXNlIDM2MjkyOlxuICAgICAgcmV0dXJuIE5oO1xuICB9XG59XG5jbGFzcyBVaCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICB0aGlzLmlkID0gZSwgdGhpcy5hZGRyID0gbiwgdGhpcy5jYWNoZSA9IFtdLCB0aGlzLnNldFZhbHVlID0gdmgodC50eXBlKTtcbiAgfVxufVxuY2xhc3MgR2gge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgdGhpcy5pZCA9IGUsIHRoaXMuYWRkciA9IG4sIHRoaXMuY2FjaGUgPSBbXSwgdGhpcy5zaXplID0gdC5zaXplLCB0aGlzLnNldFZhbHVlID0gT2godC50eXBlKTtcbiAgfVxufVxuY2xhc3Mga2gge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5pZCA9IGUsIHRoaXMuc2VxID0gW10sIHRoaXMubWFwID0ge307XG4gIH1cbiAgc2V0VmFsdWUoZSwgdCwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLnNlcTtcbiAgICBmb3IgKGxldCBzID0gMCwgbyA9IGkubGVuZ3RoOyBzICE9PSBvOyArK3MpIHtcbiAgICAgIGNvbnN0IHIgPSBpW3NdO1xuICAgICAgci5zZXRWYWx1ZShlLCB0W3IuaWRdLCBuKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IEVzID0gLyhcXHcrKShcXF0pPyhcXFt8XFwuKT8vZztcbmZ1bmN0aW9uIHlyKGgsIGUpIHtcbiAgaC5zZXEucHVzaChlKSwgaC5tYXBbZS5pZF0gPSBlO1xufVxuZnVuY3Rpb24gV2goaCwgZSwgdCkge1xuICBjb25zdCBuID0gaC5uYW1lLCBpID0gbi5sZW5ndGg7XG4gIGZvciAoRXMubGFzdEluZGV4ID0gMDsgOyApIHtcbiAgICBjb25zdCBzID0gRXMuZXhlYyhuKSwgbyA9IEVzLmxhc3RJbmRleDtcbiAgICBsZXQgciA9IHNbMV07XG4gICAgY29uc3QgbCA9IHNbMl0gPT09IFwiXVwiLCBhID0gc1szXTtcbiAgICBpZiAobCAmJiAociA9IHIgfCAwKSwgYSA9PT0gdm9pZCAwIHx8IGEgPT09IFwiW1wiICYmIG8gKyAyID09PSBpKSB7XG4gICAgICB5cih0LCBhID09PSB2b2lkIDAgPyBuZXcgVWgociwgaCwgZSkgOiBuZXcgR2gociwgaCwgZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkID0gdC5tYXBbcl07XG4gICAgICBkID09PSB2b2lkIDAgJiYgKGQgPSBuZXcga2gociksIHlyKHQsIGQpKSwgdCA9IGQ7XG4gICAgfVxuICB9XG59XG5jbGFzcyBWaSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnNlcSA9IFtdLCB0aGlzLm1hcCA9IHt9O1xuICAgIGNvbnN0IG4gPSBlLmdldFByb2dyYW1QYXJhbWV0ZXIodCwgMzU3MTgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBzID0gZS5nZXRBY3RpdmVVbmlmb3JtKHQsIGkpLCBvID0gZS5nZXRVbmlmb3JtTG9jYXRpb24odCwgcy5uYW1lKTtcbiAgICAgIFdoKHMsIG8sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShlLCB0LCBuLCBpKSB7XG4gICAgY29uc3QgcyA9IHRoaXMubWFwW3RdO1xuICAgIHMgIT09IHZvaWQgMCAmJiBzLnNldFZhbHVlKGUsIG4sIGkpO1xuICB9XG4gIHNldE9wdGlvbmFsKGUsIHQsIG4pIHtcbiAgICBjb25zdCBpID0gdFtuXTtcbiAgICBpICE9PSB2b2lkIDAgJiYgdGhpcy5zZXRWYWx1ZShlLCBuLCBpKTtcbiAgfVxuICBzdGF0aWMgdXBsb2FkKGUsIHQsIG4sIGkpIHtcbiAgICBmb3IgKGxldCBzID0gMCwgbyA9IHQubGVuZ3RoOyBzICE9PSBvOyArK3MpIHtcbiAgICAgIGNvbnN0IHIgPSB0W3NdLCBsID0gbltyLmlkXTtcbiAgICAgIGwubmVlZHNVcGRhdGUgIT09ICExICYmIHIuc2V0VmFsdWUoZSwgbC52YWx1ZSwgaSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXFXaXRoVmFsdWUoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgcyA9IGUubGVuZ3RoOyBpICE9PSBzOyArK2kpIHtcbiAgICAgIGNvbnN0IG8gPSBlW2ldO1xuICAgICAgby5pZCBpbiB0ICYmIG4ucHVzaChvKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbn1cbmZ1bmN0aW9uIGJyKGgsIGUsIHQpIHtcbiAgY29uc3QgbiA9IGguY3JlYXRlU2hhZGVyKGUpO1xuICByZXR1cm4gaC5zaGFkZXJTb3VyY2UobiwgdCksIGguY29tcGlsZVNoYWRlcihuKSwgbjtcbn1cbmxldCBWaCA9IDA7XG5mdW5jdGlvbiBIaChoLCBlKSB7XG4gIGNvbnN0IHQgPSBoLnNwbGl0KGBcbmApLCBuID0gW10sIGkgPSBNYXRoLm1heChlIC0gNiwgMCksIHMgPSBNYXRoLm1pbihlICsgNiwgdC5sZW5ndGgpO1xuICBmb3IgKGxldCBvID0gaTsgbyA8IHM7IG8rKykge1xuICAgIGNvbnN0IHIgPSBvICsgMTtcbiAgICBuLnB1c2goYCR7ciA9PT0gZSA/IFwiPlwiIDogXCIgXCJ9ICR7cn06ICR7dFtvXX1gKTtcbiAgfVxuICByZXR1cm4gbi5qb2luKGBcbmApO1xufVxuZnVuY3Rpb24gcWgoaCkge1xuICBzd2l0Y2ggKGgpIHtcbiAgICBjYXNlIDNlMzpcbiAgICAgIHJldHVybiBbXCJMaW5lYXJcIiwgXCIoIHZhbHVlIClcIl07XG4gICAgY2FzZSAzMDAxOlxuICAgICAgcmV0dXJuIFtcInNSR0JcIiwgXCIoIHZhbHVlIClcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIGVuY29kaW5nOlwiLCBoKSwgW1wiTGluZWFyXCIsIFwiKCB2YWx1ZSApXCJdO1xuICB9XG59XG5mdW5jdGlvbiB3cihoLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSBoLmdldFNoYWRlclBhcmFtZXRlcihlLCAzNTcxMyksIGkgPSBoLmdldFNoYWRlckluZm9Mb2coZSkudHJpbSgpO1xuICBpZiAobiAmJiBpID09PSBcIlwiKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCBzID0gL0VSUk9SOiAwOihcXGQrKS8uZXhlYyhpKTtcbiAgaWYgKHMpIHtcbiAgICBjb25zdCBvID0gcGFyc2VJbnQoc1sxXSk7XG4gICAgcmV0dXJuIHQudG9VcHBlckNhc2UoKSArIGBcblxuYCArIGkgKyBgXG5cbmAgKyBIaChoLmdldFNoYWRlclNvdXJjZShlKSwgbyk7XG4gIH0gZWxzZVxuICAgIHJldHVybiBpO1xufVxuZnVuY3Rpb24gWGgoaCwgZSkge1xuICBjb25zdCB0ID0gcWgoZSk7XG4gIHJldHVybiBcInZlYzQgXCIgKyBoICsgXCIoIHZlYzQgdmFsdWUgKSB7IHJldHVybiBMaW5lYXJUb1wiICsgdFswXSArIHRbMV0gKyBcIjsgfVwiO1xufVxuZnVuY3Rpb24gamgoaCwgZSkge1xuICBsZXQgdDtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSAxOlxuICAgICAgdCA9IFwiTGluZWFyXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICB0ID0gXCJSZWluaGFyZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgdCA9IFwiT3B0aW1pemVkQ2luZW9uXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICB0ID0gXCJBQ0VTRmlsbWljXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICB0ID0gXCJDdXN0b21cIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOlwiLCBlKSwgdCA9IFwiTGluZWFyXCI7XG4gIH1cbiAgcmV0dXJuIFwidmVjMyBcIiArIGggKyBcIiggdmVjMyBjb2xvciApIHsgcmV0dXJuIFwiICsgdCArIFwiVG9uZU1hcHBpbmcoIGNvbG9yICk7IH1cIjtcbn1cbmZ1bmN0aW9uIFloKGgpIHtcbiAgcmV0dXJuIFtcbiAgICBoLmV4dGVuc2lvbkRlcml2YXRpdmVzIHx8ICEhaC5lbnZNYXBDdWJlVVZIZWlnaHQgfHwgaC5idW1wTWFwIHx8IGgudGFuZ2VudFNwYWNlTm9ybWFsTWFwIHx8IGguY2xlYXJjb2F0Tm9ybWFsTWFwIHx8IGguZmxhdFNoYWRpbmcgfHwgaC5zaGFkZXJJRCA9PT0gXCJwaHlzaWNhbFwiID8gXCIjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVwiIDogXCJcIixcbiAgICAoaC5leHRlbnNpb25GcmFnRGVwdGggfHwgaC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSAmJiBoLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoID8gXCIjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXCIgOiBcIlwiLFxuICAgIGguZXh0ZW5zaW9uRHJhd0J1ZmZlcnMgJiYgaC5yZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzID8gXCIjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlXCIgOiBcIlwiLFxuICAgIChoLmV4dGVuc2lvblNoYWRlclRleHR1cmVMT0QgfHwgaC5lbnZNYXAgfHwgaC50cmFuc21pc3Npb24pICYmIGgucmVuZGVyZXJFeHRlbnNpb25TaGFkZXJUZXh0dXJlTG9kID8gXCIjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcIiA6IFwiXCJcbiAgXS5maWx0ZXIobGkpLmpvaW4oYFxuYCk7XG59XG5mdW5jdGlvbiBaaChoKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgZm9yIChjb25zdCB0IGluIGgpIHtcbiAgICBjb25zdCBuID0gaFt0XTtcbiAgICBuICE9PSAhMSAmJiBlLnB1c2goXCIjZGVmaW5lIFwiICsgdCArIFwiIFwiICsgbik7XG4gIH1cbiAgcmV0dXJuIGUuam9pbihgXG5gKTtcbn1cbmZ1bmN0aW9uICRoKGgsIGUpIHtcbiAgY29uc3QgdCA9IHt9LCBuID0gaC5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsIDM1NzIxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBjb25zdCBzID0gaC5nZXRBY3RpdmVBdHRyaWIoZSwgaSksIG8gPSBzLm5hbWU7XG4gICAgbGV0IHIgPSAxO1xuICAgIHMudHlwZSA9PT0gMzU2NzQgJiYgKHIgPSAyKSwgcy50eXBlID09PSAzNTY3NSAmJiAociA9IDMpLCBzLnR5cGUgPT09IDM1Njc2ICYmIChyID0gNCksIHRbb10gPSB7XG4gICAgICB0eXBlOiBzLnR5cGUsXG4gICAgICBsb2NhdGlvbjogaC5nZXRBdHRyaWJMb2NhdGlvbihlLCBvKSxcbiAgICAgIGxvY2F0aW9uU2l6ZTogclxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBsaShoKSB7XG4gIHJldHVybiBoICE9PSBcIlwiO1xufVxuZnVuY3Rpb24gTXIoaCwgZSkge1xuICByZXR1cm4gaC5yZXBsYWNlKC9OVU1fRElSX0xJR0hUUy9nLCBlLm51bURpckxpZ2h0cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRTL2csIGUubnVtU3BvdExpZ2h0cykucmVwbGFjZSgvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZywgZS5udW1SZWN0QXJlYUxpZ2h0cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUUy9nLCBlLm51bVBvaW50TGlnaHRzKS5yZXBsYWNlKC9OVU1fSEVNSV9MSUdIVFMvZywgZS5udW1IZW1pTGlnaHRzKS5yZXBsYWNlKC9OVU1fRElSX0xJR0hUX1NIQURPV1MvZywgZS5udW1EaXJMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUX1NIQURPV1MvZywgZS5udW1TcG90TGlnaHRTaGFkb3dzKS5yZXBsYWNlKC9OVU1fUE9JTlRfTElHSFRfU0hBRE9XUy9nLCBlLm51bVBvaW50TGlnaHRTaGFkb3dzKTtcbn1cbmZ1bmN0aW9uIFNyKGgsIGUpIHtcbiAgcmV0dXJuIGgucmVwbGFjZSgvTlVNX0NMSVBQSU5HX1BMQU5FUy9nLCBlLm51bUNsaXBwaW5nUGxhbmVzKS5yZXBsYWNlKC9VTklPTl9DTElQUElOR19QTEFORVMvZywgZS5udW1DbGlwcGluZ1BsYW5lcyAtIGUubnVtQ2xpcEludGVyc2VjdGlvbik7XG59XG5jb25zdCBLaCA9IC9eWyBcXHRdKiNpbmNsdWRlICs8KFtcXHdcXGQuL10rKT4vZ207XG5mdW5jdGlvbiBOcyhoKSB7XG4gIHJldHVybiBoLnJlcGxhY2UoS2gsIEpoKTtcbn1cbmZ1bmN0aW9uIEpoKGgsIGUpIHtcbiAgY29uc3QgdCA9IFRlW2VdO1xuICBpZiAodCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8XCIgKyBlICsgXCI+XCIpO1xuICByZXR1cm4gTnModCk7XG59XG5jb25zdCBRaCA9IC8jcHJhZ21hIHVucm9sbF9sb29wW1xcc10rP2ZvciBcXCggaW50IGkgXFw9IChcXGQrKVxcOyBpIDwgKFxcZCspXFw7IGkgXFwrXFwrIFxcKSBcXHsoW1xcc1xcU10rPykoPz1cXH0pXFx9L2csIGV1ID0gLyNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXHMrZm9yXFxzKlxcKFxccyppbnRcXHMraVxccyo9XFxzKihcXGQrKVxccyo7XFxzKmlcXHMqPFxccyooXFxkKylcXHMqO1xccyppXFxzKlxcK1xcK1xccypcXClcXHMqeyhbXFxzXFxTXSs/KX1cXHMrI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQvZztcbmZ1bmN0aW9uIEVyKGgpIHtcbiAgcmV0dXJuIGgucmVwbGFjZShldSwgdm8pLnJlcGxhY2UoUWgsIHR1KTtcbn1cbmZ1bmN0aW9uIHR1KGgsIGUsIHQsIG4pIHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihcIldlYkdMUHJvZ3JhbTogI3ByYWdtYSB1bnJvbGxfbG9vcCBzaGFkZXIgc3ludGF4IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydCBzeW50YXggaW5zdGVhZC5cIiksIHZvKGgsIGUsIHQsIG4pO1xufVxuZnVuY3Rpb24gdm8oaCwgZSwgdCwgbikge1xuICBsZXQgaSA9IFwiXCI7XG4gIGZvciAobGV0IHMgPSBwYXJzZUludChlKTsgcyA8IHBhcnNlSW50KHQpOyBzKyspXG4gICAgaSArPSBuLnJlcGxhY2UoL1xcW1xccyppXFxzKlxcXS9nLCBcIlsgXCIgKyBzICsgXCIgXVwiKS5yZXBsYWNlKC9VTlJPTExFRF9MT09QX0lOREVYL2csIHMpO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIFRyKGgpIHtcbiAgbGV0IGUgPSBcInByZWNpc2lvbiBcIiArIGgucHJlY2lzaW9uICsgYCBmbG9hdDtcbnByZWNpc2lvbiBgICsgaC5wcmVjaXNpb24gKyBcIiBpbnQ7XCI7XG4gIHJldHVybiBoLnByZWNpc2lvbiA9PT0gXCJoaWdocFwiID8gZSArPSBgXG4jZGVmaW5lIEhJR0hfUFJFQ0lTSU9OYCA6IGgucHJlY2lzaW9uID09PSBcIm1lZGl1bXBcIiA/IGUgKz0gYFxuI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OYCA6IGgucHJlY2lzaW9uID09PSBcImxvd3BcIiAmJiAoZSArPSBgXG4jZGVmaW5lIExPV19QUkVDSVNJT05gKSwgZTtcbn1cbmZ1bmN0aW9uIG51KGgpIHtcbiAgbGV0IGUgPSBcIlNIQURPV01BUF9UWVBFX0JBU0lDXCI7XG4gIHJldHVybiBoLnNoYWRvd01hcFR5cGUgPT09IDEgPyBlID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZcIiA6IGguc2hhZG93TWFwVHlwZSA9PT0gMiA/IGUgPSBcIlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUXCIgOiBoLnNoYWRvd01hcFR5cGUgPT09IDMgJiYgKGUgPSBcIlNIQURPV01BUF9UWVBFX1ZTTVwiKSwgZTtcbn1cbmZ1bmN0aW9uIGl1KGgpIHtcbiAgbGV0IGUgPSBcIkVOVk1BUF9UWVBFX0NVQkVcIjtcbiAgaWYgKGguZW52TWFwKVxuICAgIHN3aXRjaCAoaC5lbnZNYXBNb2RlKSB7XG4gICAgICBjYXNlIDMwMTpcbiAgICAgIGNhc2UgMzAyOlxuICAgICAgICBlID0gXCJFTlZNQVBfVFlQRV9DVUJFXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzMDY6XG4gICAgICAgIGUgPSBcIkVOVk1BUF9UWVBFX0NVQkVfVVZcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHN1KGgpIHtcbiAgbGV0IGUgPSBcIkVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cIjtcbiAgaWYgKGguZW52TWFwKVxuICAgIHN3aXRjaCAoaC5lbnZNYXBNb2RlKSB7XG4gICAgICBjYXNlIDMwMjpcbiAgICAgICAgZSA9IFwiRU5WTUFQX01PREVfUkVGUkFDVElPTlwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcnUoaCkge1xuICBsZXQgZSA9IFwiRU5WTUFQX0JMRU5ESU5HX05PTkVcIjtcbiAgaWYgKGguZW52TWFwKVxuICAgIHN3aXRjaCAoaC5jb21iaW5lKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGUgPSBcIkVOVk1BUF9CTEVORElOR19NVUxUSVBMWVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgZSA9IFwiRU5WTUFQX0JMRU5ESU5HX01JWFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZSA9IFwiRU5WTUFQX0JMRU5ESU5HX0FERFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gb3UoaCkge1xuICBjb25zdCBlID0gaC5lbnZNYXBDdWJlVVZIZWlnaHQ7XG4gIGlmIChlID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB0ID0gTWF0aC5sb2cyKGUpIC0gMiwgbiA9IDEgLyBlO1xuICByZXR1cm4geyB0ZXhlbFdpZHRoOiAxIC8gKDMgKiBNYXRoLm1heChNYXRoLnBvdygyLCB0KSwgNyAqIDE2KSksIHRleGVsSGVpZ2h0OiBuLCBtYXhNaXA6IHQgfTtcbn1cbmZ1bmN0aW9uIGF1KGgsIGUsIHQsIG4pIHtcbiAgY29uc3QgaSA9IGguZ2V0Q29udGV4dCgpLCBzID0gdC5kZWZpbmVzO1xuICBsZXQgbyA9IHQudmVydGV4U2hhZGVyLCByID0gdC5mcmFnbWVudFNoYWRlcjtcbiAgY29uc3QgbCA9IG51KHQpLCBhID0gaXUodCksIGMgPSBzdSh0KSwgZCA9IHJ1KHQpLCB1ID0gb3UodCksIG0gPSB0LmlzV2ViR0wyID8gXCJcIiA6IFloKHQpLCBnID0gWmgocyksIHAgPSBpLmNyZWF0ZVByb2dyYW0oKTtcbiAgbGV0IGYsIHYsIF8gPSB0Lmdsc2xWZXJzaW9uID8gXCIjdmVyc2lvbiBcIiArIHQuZ2xzbFZlcnNpb24gKyBgXG5gIDogXCJcIjtcbiAgdC5pc1Jhd1NoYWRlck1hdGVyaWFsID8gKGYgPSBbXG4gICAgZ1xuICBdLmZpbHRlcihsaSkuam9pbihgXG5gKSwgZi5sZW5ndGggPiAwICYmIChmICs9IGBcbmApLCB2ID0gW1xuICAgIG0sXG4gICAgZ1xuICBdLmZpbHRlcihsaSkuam9pbihgXG5gKSwgdi5sZW5ndGggPiAwICYmICh2ICs9IGBcbmApKSA6IChmID0gW1xuICAgIFRyKHQpLFxuICAgIFwiI2RlZmluZSBTSEFERVJfTkFNRSBcIiArIHQuc2hhZGVyTmFtZSxcbiAgICBnLFxuICAgIHQuaW5zdGFuY2luZyA/IFwiI2RlZmluZSBVU0VfSU5TVEFOQ0lOR1wiIDogXCJcIixcbiAgICB0Lmluc3RhbmNpbmdDb2xvciA/IFwiI2RlZmluZSBVU0VfSU5TVEFOQ0lOR19DT0xPUlwiIDogXCJcIixcbiAgICB0LnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyBcIiNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTXCIgOiBcIlwiLFxuICAgIHQudXNlRm9nICYmIHQuZm9nID8gXCIjZGVmaW5lIFVTRV9GT0dcIiA6IFwiXCIsXG4gICAgdC51c2VGb2cgJiYgdC5mb2dFeHAyID8gXCIjZGVmaW5lIEZPR19FWFAyXCIgOiBcIlwiLFxuICAgIHQubWFwID8gXCIjZGVmaW5lIFVTRV9NQVBcIiA6IFwiXCIsXG4gICAgdC5lbnZNYXAgPyBcIiNkZWZpbmUgVVNFX0VOVk1BUFwiIDogXCJcIixcbiAgICB0LmVudk1hcCA/IFwiI2RlZmluZSBcIiArIGMgOiBcIlwiLFxuICAgIHQubGlnaHRNYXAgPyBcIiNkZWZpbmUgVVNFX0xJR0hUTUFQXCIgOiBcIlwiLFxuICAgIHQuYW9NYXAgPyBcIiNkZWZpbmUgVVNFX0FPTUFQXCIgOiBcIlwiLFxuICAgIHQuZW1pc3NpdmVNYXAgPyBcIiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQXCIgOiBcIlwiLFxuICAgIHQuYnVtcE1hcCA/IFwiI2RlZmluZSBVU0VfQlVNUE1BUFwiIDogXCJcIixcbiAgICB0Lm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxuICAgIHQubm9ybWFsTWFwICYmIHQub2JqZWN0U3BhY2VOb3JtYWxNYXAgPyBcIiNkZWZpbmUgT0JKRUNUU1BBQ0VfTk9STUFMTUFQXCIgOiBcIlwiLFxuICAgIHQubm9ybWFsTWFwICYmIHQudGFuZ2VudFNwYWNlTm9ybWFsTWFwID8gXCIjZGVmaW5lIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVBcIiA6IFwiXCIsXG4gICAgdC5jbGVhcmNvYXRNYXAgPyBcIiNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUFwiIDogXCJcIixcbiAgICB0LmNsZWFyY29hdFJvdWdobmVzc01hcCA/IFwiI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFwiIDogXCJcIixcbiAgICB0LmNsZWFyY29hdE5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFwiIDogXCJcIixcbiAgICB0LmlyaWRlc2NlbmNlTWFwID8gXCIjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUFwiIDogXCJcIixcbiAgICB0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcIiA6IFwiXCIsXG4gICAgdC5kaXNwbGFjZW1lbnRNYXAgJiYgdC5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gXCIjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVBcIiA6IFwiXCIsXG4gICAgdC5zcGVjdWxhck1hcCA/IFwiI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVBcIiA6IFwiXCIsXG4gICAgdC5zcGVjdWxhckludGVuc2l0eU1hcCA/IFwiI2RlZmluZSBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcIiA6IFwiXCIsXG4gICAgdC5zcGVjdWxhckNvbG9yTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUkNPTE9STUFQXCIgOiBcIlwiLFxuICAgIHQucm91Z2huZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVBcIiA6IFwiXCIsXG4gICAgdC5tZXRhbG5lc3NNYXAgPyBcIiNkZWZpbmUgVVNFX01FVEFMTkVTU01BUFwiIDogXCJcIixcbiAgICB0LmFscGhhTWFwID8gXCIjZGVmaW5lIFVTRV9BTFBIQU1BUFwiIDogXCJcIixcbiAgICB0LnRyYW5zbWlzc2lvbiA/IFwiI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OXCIgOiBcIlwiLFxuICAgIHQudHJhbnNtaXNzaW9uTWFwID8gXCIjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVBcIiA6IFwiXCIsXG4gICAgdC50aGlja25lc3NNYXAgPyBcIiNkZWZpbmUgVVNFX1RISUNLTkVTU01BUFwiIDogXCJcIixcbiAgICB0LnNoZWVuQ29sb3JNYXAgPyBcIiNkZWZpbmUgVVNFX1NIRUVOQ09MT1JNQVBcIiA6IFwiXCIsXG4gICAgdC5zaGVlblJvdWdobmVzc01hcCA/IFwiI2RlZmluZSBVU0VfU0hFRU5ST1VHSE5FU1NNQVBcIiA6IFwiXCIsXG4gICAgdC52ZXJ0ZXhUYW5nZW50cyA/IFwiI2RlZmluZSBVU0VfVEFOR0VOVFwiIDogXCJcIixcbiAgICB0LnZlcnRleENvbG9ycyA/IFwiI2RlZmluZSBVU0VfQ09MT1JcIiA6IFwiXCIsXG4gICAgdC52ZXJ0ZXhBbHBoYXMgPyBcIiNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBXCIgOiBcIlwiLFxuICAgIHQudmVydGV4VXZzID8gXCIjZGVmaW5lIFVTRV9VVlwiIDogXCJcIixcbiAgICB0LnV2c1ZlcnRleE9ubHkgPyBcIiNkZWZpbmUgVVZTX1ZFUlRFWF9PTkxZXCIgOiBcIlwiLFxuICAgIHQuZmxhdFNoYWRpbmcgPyBcIiNkZWZpbmUgRkxBVF9TSEFERURcIiA6IFwiXCIsXG4gICAgdC5za2lubmluZyA/IFwiI2RlZmluZSBVU0VfU0tJTk5JTkdcIiA6IFwiXCIsXG4gICAgdC5tb3JwaFRhcmdldHMgPyBcIiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUU1wiIDogXCJcIixcbiAgICB0Lm1vcnBoTm9ybWFscyAmJiB0LmZsYXRTaGFkaW5nID09PSAhMSA/IFwiI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTXCIgOiBcIlwiLFxuICAgIHQubW9ycGhDb2xvcnMgJiYgdC5pc1dlYkdMMiA/IFwiI2RlZmluZSBVU0VfTU9SUEhDT0xPUlNcIiA6IFwiXCIsXG4gICAgdC5tb3JwaFRhcmdldHNDb3VudCA+IDAgJiYgdC5pc1dlYkdMMiA/IFwiI2RlZmluZSBNT1JQSFRBUkdFVFNfVEVYVFVSRVwiIDogXCJcIixcbiAgICB0Lm1vcnBoVGFyZ2V0c0NvdW50ID4gMCAmJiB0LmlzV2ViR0wyID8gXCIjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSBcIiArIHQubW9ycGhUZXh0dXJlU3RyaWRlIDogXCJcIixcbiAgICB0Lm1vcnBoVGFyZ2V0c0NvdW50ID4gMCAmJiB0LmlzV2ViR0wyID8gXCIjZGVmaW5lIE1PUlBIVEFSR0VUU19DT1VOVCBcIiArIHQubW9ycGhUYXJnZXRzQ291bnQgOiBcIlwiLFxuICAgIHQuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxuICAgIHQuZmxpcFNpZGVkID8gXCIjZGVmaW5lIEZMSVBfU0lERURcIiA6IFwiXCIsXG4gICAgdC5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFVTRV9TSEFET1dNQVBcIiA6IFwiXCIsXG4gICAgdC5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFwiICsgbCA6IFwiXCIsXG4gICAgdC5zaXplQXR0ZW51YXRpb24gPyBcIiNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTlwiIDogXCJcIixcbiAgICB0LmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyBcIiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGXCIgOiBcIlwiLFxuICAgIHQubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiB0LnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoID8gXCIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFRcIiA6IFwiXCIsXG4gICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIsXG4gICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1wiLFxuICAgIFwidW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XCIsXG4gICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcbiAgICBcInVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XCIsXG4gICAgXCJ1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XCIsXG4gICAgXCJ1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7XCIsXG4gICAgXCIjaWZkZWYgVVNFX0lOU1RBTkNJTkdcIixcbiAgICBcIlx0YXR0cmlidXRlIG1hdDQgaW5zdGFuY2VNYXRyaXg7XCIsXG4gICAgXCIjZW5kaWZcIixcbiAgICBcIiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUlwiLFxuICAgIFwiXHRhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUNvbG9yO1wiLFxuICAgIFwiI2VuZGlmXCIsXG4gICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcbiAgICBcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcbiAgICBcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuICAgIFwiI2lmZGVmIFVTRV9UQU5HRU5UXCIsXG4gICAgXCJcdGF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7XCIsXG4gICAgXCIjZW5kaWZcIixcbiAgICBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVwiLFxuICAgIFwiXHRhdHRyaWJ1dGUgdmVjNCBjb2xvcjtcIixcbiAgICBcIiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXCIsXG4gICAgXCJcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1wiLFxuICAgIFwiI2VuZGlmXCIsXG4gICAgXCIjaWYgKCBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTICkgJiYgISBkZWZpbmVkKCBNT1JQSFRBUkdFVFNfVEVYVFVSRSApIClcIixcbiAgICBcIlx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwO1wiLFxuICAgIFwiXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7XCIsXG4gICAgXCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjtcIixcbiAgICBcIlx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzO1wiLFxuICAgIFwiXHQjaWZkZWYgVVNFX01PUlBITk9STUFMU1wiLFxuICAgIFwiXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDtcIixcbiAgICBcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7XCIsXG4gICAgXCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyO1wiLFxuICAgIFwiXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMztcIixcbiAgICBcIlx0I2Vsc2VcIixcbiAgICBcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7XCIsXG4gICAgXCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1O1wiLFxuICAgIFwiXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjtcIixcbiAgICBcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7XCIsXG4gICAgXCJcdCNlbmRpZlwiLFxuICAgIFwiI2VuZGlmXCIsXG4gICAgXCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXG4gICAgXCJcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDtcIixcbiAgICBcIlx0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDtcIixcbiAgICBcIiNlbmRpZlwiLFxuICAgIGBcbmBcbiAgXS5maWx0ZXIobGkpLmpvaW4oYFxuYCksIHYgPSBbXG4gICAgbSxcbiAgICBUcih0KSxcbiAgICBcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIgKyB0LnNoYWRlck5hbWUsXG4gICAgZyxcbiAgICB0LnVzZUZvZyAmJiB0LmZvZyA/IFwiI2RlZmluZSBVU0VfRk9HXCIgOiBcIlwiLFxuICAgIHQudXNlRm9nICYmIHQuZm9nRXhwMiA/IFwiI2RlZmluZSBGT0dfRVhQMlwiIDogXCJcIixcbiAgICB0Lm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxuICAgIHQubWF0Y2FwID8gXCIjZGVmaW5lIFVTRV9NQVRDQVBcIiA6IFwiXCIsXG4gICAgdC5lbnZNYXAgPyBcIiNkZWZpbmUgVVNFX0VOVk1BUFwiIDogXCJcIixcbiAgICB0LmVudk1hcCA/IFwiI2RlZmluZSBcIiArIGEgOiBcIlwiLFxuICAgIHQuZW52TWFwID8gXCIjZGVmaW5lIFwiICsgYyA6IFwiXCIsXG4gICAgdC5lbnZNYXAgPyBcIiNkZWZpbmUgXCIgKyBkIDogXCJcIixcbiAgICB1ID8gXCIjZGVmaW5lIENVQkVVVl9URVhFTF9XSURUSCBcIiArIHUudGV4ZWxXaWR0aCA6IFwiXCIsXG4gICAgdSA/IFwiI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUIFwiICsgdS50ZXhlbEhlaWdodCA6IFwiXCIsXG4gICAgdSA/IFwiI2RlZmluZSBDVUJFVVZfTUFYX01JUCBcIiArIHUubWF4TWlwICsgXCIuMFwiIDogXCJcIixcbiAgICB0LmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcbiAgICB0LmFvTWFwID8gXCIjZGVmaW5lIFVTRV9BT01BUFwiIDogXCJcIixcbiAgICB0LmVtaXNzaXZlTWFwID8gXCIjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUFwiIDogXCJcIixcbiAgICB0LmJ1bXBNYXAgPyBcIiNkZWZpbmUgVVNFX0JVTVBNQVBcIiA6IFwiXCIsXG4gICAgdC5ub3JtYWxNYXAgPyBcIiNkZWZpbmUgVVNFX05PUk1BTE1BUFwiIDogXCJcIixcbiAgICB0Lm5vcm1hbE1hcCAmJiB0Lm9iamVjdFNwYWNlTm9ybWFsTWFwID8gXCIjZGVmaW5lIE9CSkVDVFNQQUNFX05PUk1BTE1BUFwiIDogXCJcIixcbiAgICB0Lm5vcm1hbE1hcCAmJiB0LnRhbmdlbnRTcGFjZU5vcm1hbE1hcCA/IFwiI2RlZmluZSBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQXCIgOiBcIlwiLFxuICAgIHQuY2xlYXJjb2F0ID8gXCIjZGVmaW5lIFVTRV9DTEVBUkNPQVRcIiA6IFwiXCIsXG4gICAgdC5jbGVhcmNvYXRNYXAgPyBcIiNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUFwiIDogXCJcIixcbiAgICB0LmNsZWFyY29hdFJvdWdobmVzc01hcCA/IFwiI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFwiIDogXCJcIixcbiAgICB0LmNsZWFyY29hdE5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFwiIDogXCJcIixcbiAgICB0LmlyaWRlc2NlbmNlID8gXCIjZGVmaW5lIFVTRV9JUklERVNDRU5DRVwiIDogXCJcIixcbiAgICB0LmlyaWRlc2NlbmNlTWFwID8gXCIjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUFwiIDogXCJcIixcbiAgICB0LmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcIiA6IFwiXCIsXG4gICAgdC5zcGVjdWxhck1hcCA/IFwiI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVBcIiA6IFwiXCIsXG4gICAgdC5zcGVjdWxhckludGVuc2l0eU1hcCA/IFwiI2RlZmluZSBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcIiA6IFwiXCIsXG4gICAgdC5zcGVjdWxhckNvbG9yTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUkNPTE9STUFQXCIgOiBcIlwiLFxuICAgIHQucm91Z2huZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVBcIiA6IFwiXCIsXG4gICAgdC5tZXRhbG5lc3NNYXAgPyBcIiNkZWZpbmUgVVNFX01FVEFMTkVTU01BUFwiIDogXCJcIixcbiAgICB0LmFscGhhTWFwID8gXCIjZGVmaW5lIFVTRV9BTFBIQU1BUFwiIDogXCJcIixcbiAgICB0LmFscGhhVGVzdCA/IFwiI2RlZmluZSBVU0VfQUxQSEFURVNUXCIgOiBcIlwiLFxuICAgIHQuc2hlZW4gPyBcIiNkZWZpbmUgVVNFX1NIRUVOXCIgOiBcIlwiLFxuICAgIHQuc2hlZW5Db2xvck1hcCA/IFwiI2RlZmluZSBVU0VfU0hFRU5DT0xPUk1BUFwiIDogXCJcIixcbiAgICB0LnNoZWVuUm91Z2huZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9TSEVFTlJPVUdITkVTU01BUFwiIDogXCJcIixcbiAgICB0LnRyYW5zbWlzc2lvbiA/IFwiI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OXCIgOiBcIlwiLFxuICAgIHQudHJhbnNtaXNzaW9uTWFwID8gXCIjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVBcIiA6IFwiXCIsXG4gICAgdC50aGlja25lc3NNYXAgPyBcIiNkZWZpbmUgVVNFX1RISUNLTkVTU01BUFwiIDogXCJcIixcbiAgICB0LmRlY29kZVZpZGVvVGV4dHVyZSA/IFwiI2RlZmluZSBERUNPREVfVklERU9fVEVYVFVSRVwiIDogXCJcIixcbiAgICB0LnZlcnRleFRhbmdlbnRzID8gXCIjZGVmaW5lIFVTRV9UQU5HRU5UXCIgOiBcIlwiLFxuICAgIHQudmVydGV4Q29sb3JzIHx8IHQuaW5zdGFuY2luZ0NvbG9yID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIixcbiAgICB0LnZlcnRleEFscGhhcyA/IFwiI2RlZmluZSBVU0VfQ09MT1JfQUxQSEFcIiA6IFwiXCIsXG4gICAgdC52ZXJ0ZXhVdnMgPyBcIiNkZWZpbmUgVVNFX1VWXCIgOiBcIlwiLFxuICAgIHQudXZzVmVydGV4T25seSA/IFwiI2RlZmluZSBVVlNfVkVSVEVYX09OTFlcIiA6IFwiXCIsXG4gICAgdC5ncmFkaWVudE1hcCA/IFwiI2RlZmluZSBVU0VfR1JBRElFTlRNQVBcIiA6IFwiXCIsXG4gICAgdC5mbGF0U2hhZGluZyA/IFwiI2RlZmluZSBGTEFUX1NIQURFRFwiIDogXCJcIixcbiAgICB0LmRvdWJsZVNpZGVkID8gXCIjZGVmaW5lIERPVUJMRV9TSURFRFwiIDogXCJcIixcbiAgICB0LmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxuICAgIHQuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOiBcIlwiLFxuICAgIHQuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBcIiArIGwgOiBcIlwiLFxuICAgIHQucHJlbXVsdGlwbGllZEFscGhhID8gXCIjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEFcIiA6IFwiXCIsXG4gICAgdC5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA/IFwiI2RlZmluZSBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXCIgOiBcIlwiLFxuICAgIHQubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/IFwiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZcIiA6IFwiXCIsXG4gICAgdC5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHQucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGggPyBcIiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVFwiIDogXCJcIixcbiAgICBcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxuICAgIFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLFxuICAgIFwidW5pZm9ybSBib29sIGlzT3J0aG9ncmFwaGljO1wiLFxuICAgIHQudG9uZU1hcHBpbmcgIT09IDAgPyBcIiNkZWZpbmUgVE9ORV9NQVBQSU5HXCIgOiBcIlwiLFxuICAgIHQudG9uZU1hcHBpbmcgIT09IDAgPyBUZS50b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50IDogXCJcIixcbiAgICB0LnRvbmVNYXBwaW5nICE9PSAwID8gamgoXCJ0b25lTWFwcGluZ1wiLCB0LnRvbmVNYXBwaW5nKSA6IFwiXCIsXG4gICAgdC5kaXRoZXJpbmcgPyBcIiNkZWZpbmUgRElUSEVSSU5HXCIgOiBcIlwiLFxuICAgIHQub3BhcXVlID8gXCIjZGVmaW5lIE9QQVFVRVwiIDogXCJcIixcbiAgICBUZS5lbmNvZGluZ3NfcGFyc19mcmFnbWVudCxcbiAgICBYaChcImxpbmVhclRvT3V0cHV0VGV4ZWxcIiwgdC5vdXRwdXRFbmNvZGluZyksXG4gICAgdC51c2VEZXB0aFBhY2tpbmcgPyBcIiNkZWZpbmUgREVQVEhfUEFDS0lORyBcIiArIHQuZGVwdGhQYWNraW5nIDogXCJcIixcbiAgICBgXG5gXG4gIF0uZmlsdGVyKGxpKS5qb2luKGBcbmApKSwgbyA9IE5zKG8pLCBvID0gTXIobywgdCksIG8gPSBTcihvLCB0KSwgciA9IE5zKHIpLCByID0gTXIociwgdCksIHIgPSBTcihyLCB0KSwgbyA9IEVyKG8pLCByID0gRXIociksIHQuaXNXZWJHTDIgJiYgdC5pc1Jhd1NoYWRlck1hdGVyaWFsICE9PSAhMCAmJiAoXyA9IGAjdmVyc2lvbiAzMDAgZXNcbmAsIGYgPSBbXG4gICAgXCJwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkRBcnJheTtcIixcbiAgICBcIiNkZWZpbmUgYXR0cmlidXRlIGluXCIsXG4gICAgXCIjZGVmaW5lIHZhcnlpbmcgb3V0XCIsXG4gICAgXCIjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlXCJcbiAgXS5qb2luKGBcbmApICsgYFxuYCArIGYsIHYgPSBbXG4gICAgXCIjZGVmaW5lIHZhcnlpbmcgaW5cIixcbiAgICB0Lmdsc2xWZXJzaW9uID09PSBacyA/IFwiXCIgOiBcImxheW91dChsb2NhdGlvbiA9IDApIG91dCBoaWdocCB2ZWM0IHBjX2ZyYWdDb2xvcjtcIixcbiAgICB0Lmdsc2xWZXJzaW9uID09PSBacyA/IFwiXCIgOiBcIiNkZWZpbmUgZ2xfRnJhZ0NvbG9yIHBjX2ZyYWdDb2xvclwiLFxuICAgIFwiI2RlZmluZSBnbF9GcmFnRGVwdGhFWFQgZ2xfRnJhZ0RlcHRoXCIsXG4gICAgXCIjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlXCIsXG4gICAgXCIjZGVmaW5lIHRleHR1cmVDdWJlIHRleHR1cmVcIixcbiAgICBcIiNkZWZpbmUgdGV4dHVyZTJEUHJvaiB0ZXh0dXJlUHJvalwiLFxuICAgIFwiI2RlZmluZSB0ZXh0dXJlMkRMb2RFWFQgdGV4dHVyZUxvZFwiLFxuICAgIFwiI2RlZmluZSB0ZXh0dXJlMkRQcm9qTG9kRVhUIHRleHR1cmVQcm9qTG9kXCIsXG4gICAgXCIjZGVmaW5lIHRleHR1cmVDdWJlTG9kRVhUIHRleHR1cmVMb2RcIixcbiAgICBcIiNkZWZpbmUgdGV4dHVyZTJER3JhZEVYVCB0ZXh0dXJlR3JhZFwiLFxuICAgIFwiI2RlZmluZSB0ZXh0dXJlMkRQcm9qR3JhZEVYVCB0ZXh0dXJlUHJvakdyYWRcIixcbiAgICBcIiNkZWZpbmUgdGV4dHVyZUN1YmVHcmFkRVhUIHRleHR1cmVHcmFkXCJcbiAgXS5qb2luKGBcbmApICsgYFxuYCArIHYpO1xuICBjb25zdCB3ID0gXyArIGYgKyBvLCB4ID0gXyArIHYgKyByLCBNID0gYnIoaSwgMzU2MzMsIHcpLCBFID0gYnIoaSwgMzU2MzIsIHgpO1xuICBpZiAoaS5hdHRhY2hTaGFkZXIocCwgTSksIGkuYXR0YWNoU2hhZGVyKHAsIEUpLCB0LmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHZvaWQgMCA/IGkuYmluZEF0dHJpYkxvY2F0aW9uKHAsIDAsIHQuaW5kZXgwQXR0cmlidXRlTmFtZSkgOiB0Lm1vcnBoVGFyZ2V0cyA9PT0gITAgJiYgaS5iaW5kQXR0cmliTG9jYXRpb24ocCwgMCwgXCJwb3NpdGlvblwiKSwgaS5saW5rUHJvZ3JhbShwKSwgaC5kZWJ1Zy5jaGVja1NoYWRlckVycm9ycykge1xuICAgIGNvbnN0IEEgPSBpLmdldFByb2dyYW1JbmZvTG9nKHApLnRyaW0oKSwgRiA9IGkuZ2V0U2hhZGVySW5mb0xvZyhNKS50cmltKCksIFAgPSBpLmdldFNoYWRlckluZm9Mb2coRSkudHJpbSgpO1xuICAgIGxldCBHID0gITAsIHogPSAhMDtcbiAgICBpZiAoaS5nZXRQcm9ncmFtUGFyYW1ldGVyKHAsIDM1NzE0KSA9PT0gITEpIHtcbiAgICAgIEcgPSAhMTtcbiAgICAgIGNvbnN0IEwgPSB3cihpLCBNLCBcInZlcnRleFwiKSwgSSA9IHdyKGksIEUsIFwiZnJhZ21lbnRcIik7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLldlYkdMUHJvZ3JhbTogU2hhZGVyIEVycm9yIFwiICsgaS5nZXRFcnJvcigpICsgXCIgLSBWQUxJREFURV9TVEFUVVMgXCIgKyBpLmdldFByb2dyYW1QYXJhbWV0ZXIocCwgMzU3MTUpICsgYFxuXG5Qcm9ncmFtIEluZm8gTG9nOiBgICsgQSArIGBcbmAgKyBMICsgYFxuYCArIElcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBBICE9PSBcIlwiID8gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBQcm9ncmFtIEluZm8gTG9nOlwiLCBBKSA6IChGID09PSBcIlwiIHx8IFAgPT09IFwiXCIpICYmICh6ID0gITEpO1xuICAgIHogJiYgKHRoaXMuZGlhZ25vc3RpY3MgPSB7XG4gICAgICBydW5uYWJsZTogRyxcbiAgICAgIHByb2dyYW1Mb2c6IEEsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHtcbiAgICAgICAgbG9nOiBGLFxuICAgICAgICBwcmVmaXg6IGZcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudFNoYWRlcjoge1xuICAgICAgICBsb2c6IFAsXG4gICAgICAgIHByZWZpeDogdlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGkuZGVsZXRlU2hhZGVyKE0pLCBpLmRlbGV0ZVNoYWRlcihFKTtcbiAgbGV0IFI7XG4gIHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUiA9PT0gdm9pZCAwICYmIChSID0gbmV3IFZpKGksIHApKSwgUjtcbiAgfTtcbiAgbGV0IHk7XG4gIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geSA9PT0gdm9pZCAwICYmICh5ID0gJGgoaSwgcCkpLCB5O1xuICB9LCB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBuLnJlbGVhc2VTdGF0ZXNPZlByb2dyYW0odGhpcyksIGkuZGVsZXRlUHJvZ3JhbShwKSwgdGhpcy5wcm9ncmFtID0gdm9pZCAwO1xuICB9LCB0aGlzLm5hbWUgPSB0LnNoYWRlck5hbWUsIHRoaXMuaWQgPSBWaCsrLCB0aGlzLmNhY2hlS2V5ID0gZSwgdGhpcy51c2VkVGltZXMgPSAxLCB0aGlzLnByb2dyYW0gPSBwLCB0aGlzLnZlcnRleFNoYWRlciA9IE0sIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBFLCB0aGlzO1xufVxubGV0IGx1ID0gMDtcbmNsYXNzIGN1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zaGFkZXJDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMubWF0ZXJpYWxDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBjb25zdCB0ID0gZS52ZXJ0ZXhTaGFkZXIsIG4gPSBlLmZyYWdtZW50U2hhZGVyLCBpID0gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UodCksIHMgPSB0aGlzLl9nZXRTaGFkZXJTdGFnZShuKSwgbyA9IHRoaXMuX2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwoZSk7XG4gICAgcmV0dXJuIG8uaGFzKGkpID09PSAhMSAmJiAoby5hZGQoaSksIGkudXNlZFRpbWVzKyspLCBvLmhhcyhzKSA9PT0gITEgJiYgKG8uYWRkKHMpLCBzLnVzZWRUaW1lcysrKSwgdGhpcztcbiAgfVxuICByZW1vdmUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1hdGVyaWFsQ2FjaGUuZ2V0KGUpO1xuICAgIGZvciAoY29uc3QgbiBvZiB0KVxuICAgICAgbi51c2VkVGltZXMtLSwgbi51c2VkVGltZXMgPT09IDAgJiYgdGhpcy5zaGFkZXJDYWNoZS5kZWxldGUobi5jb2RlKTtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbENhY2hlLmRlbGV0ZShlKSwgdGhpcztcbiAgfVxuICBnZXRWZXJ0ZXhTaGFkZXJJRChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKGUudmVydGV4U2hhZGVyKS5pZDtcbiAgfVxuICBnZXRGcmFnbWVudFNoYWRlcklEKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UoZS5mcmFnbWVudFNoYWRlcikuaWQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnNoYWRlckNhY2hlLmNsZWFyKCksIHRoaXMubWF0ZXJpYWxDYWNoZS5jbGVhcigpO1xuICB9XG4gIF9nZXRTaGFkZXJDYWNoZUZvck1hdGVyaWFsKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tYXRlcmlhbENhY2hlO1xuICAgIHJldHVybiB0LmhhcyhlKSA9PT0gITEgJiYgdC5zZXQoZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSksIHQuZ2V0KGUpO1xuICB9XG4gIF9nZXRTaGFkZXJTdGFnZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2hhZGVyQ2FjaGU7XG4gICAgaWYgKHQuaGFzKGUpID09PSAhMSkge1xuICAgICAgY29uc3QgbiA9IG5ldyBodShlKTtcbiAgICAgIHQuc2V0KGUsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gdC5nZXQoZSk7XG4gIH1cbn1cbmNsYXNzIGh1IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaWQgPSBsdSsrLCB0aGlzLmNvZGUgPSBlLCB0aGlzLnVzZWRUaW1lcyA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHV1KGgsIGUsIHQsIG4sIGksIHMsIG8pIHtcbiAgY29uc3QgciA9IG5ldyBvbygpLCBsID0gbmV3IGN1KCksIGEgPSBbXSwgYyA9IGkuaXNXZWJHTDIsIGQgPSBpLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIsIHUgPSBpLnZlcnRleFRleHR1cmVzO1xuICBsZXQgbSA9IGkucHJlY2lzaW9uO1xuICBjb25zdCBnID0ge1xuICAgIE1lc2hEZXB0aE1hdGVyaWFsOiBcImRlcHRoXCIsXG4gICAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6IFwiZGlzdGFuY2VSR0JBXCIsXG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsOiBcIm5vcm1hbFwiLFxuICAgIE1lc2hCYXNpY01hdGVyaWFsOiBcImJhc2ljXCIsXG4gICAgTWVzaExhbWJlcnRNYXRlcmlhbDogXCJsYW1iZXJ0XCIsXG4gICAgTWVzaFBob25nTWF0ZXJpYWw6IFwicGhvbmdcIixcbiAgICBNZXNoVG9vbk1hdGVyaWFsOiBcInRvb25cIixcbiAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogXCJwaHlzaWNhbFwiLFxuICAgIE1lc2hQaHlzaWNhbE1hdGVyaWFsOiBcInBoeXNpY2FsXCIsXG4gICAgTWVzaE1hdGNhcE1hdGVyaWFsOiBcIm1hdGNhcFwiLFxuICAgIExpbmVCYXNpY01hdGVyaWFsOiBcImJhc2ljXCIsXG4gICAgTGluZURhc2hlZE1hdGVyaWFsOiBcImRhc2hlZFwiLFxuICAgIFBvaW50c01hdGVyaWFsOiBcInBvaW50c1wiLFxuICAgIFNoYWRvd01hdGVyaWFsOiBcInNoYWRvd1wiLFxuICAgIFNwcml0ZU1hdGVyaWFsOiBcInNwcml0ZVwiXG4gIH07XG4gIGZ1bmN0aW9uIHAoeSwgQSwgRiwgUCwgRykge1xuICAgIGNvbnN0IHogPSBQLmZvZywgTCA9IEcuZ2VvbWV0cnksIEkgPSB5LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBQLmVudmlyb25tZW50IDogbnVsbCwgRCA9ICh5LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyB0IDogZSkuZ2V0KHkuZW52TWFwIHx8IEkpLCBxID0gISFEICYmIEQubWFwcGluZyA9PT0gMzA2ID8gRC5pbWFnZS5oZWlnaHQgOiBudWxsLCBrID0gZ1t5LnR5cGVdO1xuICAgIHkucHJlY2lzaW9uICE9PSBudWxsICYmIChtID0gaS5nZXRNYXhQcmVjaXNpb24oeS5wcmVjaXNpb24pLCBtICE9PSB5LnByZWNpc2lvbiAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczpcIiwgeS5wcmVjaXNpb24sIFwibm90IHN1cHBvcnRlZCwgdXNpbmdcIiwgbSwgXCJpbnN0ZWFkLlwiKSk7XG4gICAgY29uc3QgTiA9IEwubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IEwubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBMLm1vcnBoQXR0cmlidXRlcy5jb2xvciwgSCA9IE4gIT09IHZvaWQgMCA/IE4ubGVuZ3RoIDogMDtcbiAgICBsZXQgSiA9IDA7XG4gICAgTC5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCAmJiAoSiA9IDEpLCBMLm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHZvaWQgMCAmJiAoSiA9IDIpLCBMLm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdm9pZCAwICYmIChKID0gMyk7XG4gICAgbGV0IFYsIGVlLCBjZSwgZ2U7XG4gICAgaWYgKGspIHtcbiAgICAgIGNvbnN0IE9lID0gQnRba107XG4gICAgICBWID0gT2UudmVydGV4U2hhZGVyLCBlZSA9IE9lLmZyYWdtZW50U2hhZGVyO1xuICAgIH0gZWxzZVxuICAgICAgViA9IHkudmVydGV4U2hhZGVyLCBlZSA9IHkuZnJhZ21lbnRTaGFkZXIsIGwudXBkYXRlKHkpLCBjZSA9IGwuZ2V0VmVydGV4U2hhZGVySUQoeSksIGdlID0gbC5nZXRGcmFnbWVudFNoYWRlcklEKHkpO1xuICAgIGNvbnN0ICQgPSBoLmdldFJlbmRlclRhcmdldCgpLCBEZSA9IHkuYWxwaGFUZXN0ID4gMCwgdmUgPSB5LmNsZWFyY29hdCA+IDAsIHhlID0geS5pcmlkZXNjZW5jZSA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzV2ViR0wyOiBjLFxuICAgICAgc2hhZGVySUQ6IGssXG4gICAgICBzaGFkZXJOYW1lOiB5LnR5cGUsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFYsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZWUsXG4gICAgICBkZWZpbmVzOiB5LmRlZmluZXMsXG4gICAgICBjdXN0b21WZXJ0ZXhTaGFkZXJJRDogY2UsXG4gICAgICBjdXN0b21GcmFnbWVudFNoYWRlcklEOiBnZSxcbiAgICAgIGlzUmF3U2hhZGVyTWF0ZXJpYWw6IHkuaXNSYXdTaGFkZXJNYXRlcmlhbCA9PT0gITAsXG4gICAgICBnbHNsVmVyc2lvbjogeS5nbHNsVmVyc2lvbixcbiAgICAgIHByZWNpc2lvbjogbSxcbiAgICAgIGluc3RhbmNpbmc6IEcuaXNJbnN0YW5jZWRNZXNoID09PSAhMCxcbiAgICAgIGluc3RhbmNpbmdDb2xvcjogRy5pc0luc3RhbmNlZE1lc2ggPT09ICEwICYmIEcuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCxcbiAgICAgIHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IHUsXG4gICAgICBvdXRwdXRFbmNvZGluZzogJCA9PT0gbnVsbCA/IGgub3V0cHV0RW5jb2RpbmcgOiAkLmlzWFJSZW5kZXJUYXJnZXQgPT09ICEwID8gJC50ZXh0dXJlLmVuY29kaW5nIDogM2UzLFxuICAgICAgbWFwOiAhIXkubWFwLFxuICAgICAgbWF0Y2FwOiAhIXkubWF0Y2FwLFxuICAgICAgZW52TWFwOiAhIUQsXG4gICAgICBlbnZNYXBNb2RlOiBEICYmIEQubWFwcGluZyxcbiAgICAgIGVudk1hcEN1YmVVVkhlaWdodDogcSxcbiAgICAgIGxpZ2h0TWFwOiAhIXkubGlnaHRNYXAsXG4gICAgICBhb01hcDogISF5LmFvTWFwLFxuICAgICAgZW1pc3NpdmVNYXA6ICEheS5lbWlzc2l2ZU1hcCxcbiAgICAgIGJ1bXBNYXA6ICEheS5idW1wTWFwLFxuICAgICAgbm9ybWFsTWFwOiAhIXkubm9ybWFsTWFwLFxuICAgICAgb2JqZWN0U3BhY2VOb3JtYWxNYXA6IHkubm9ybWFsTWFwVHlwZSA9PT0gMSxcbiAgICAgIHRhbmdlbnRTcGFjZU5vcm1hbE1hcDogeS5ub3JtYWxNYXBUeXBlID09PSAwLFxuICAgICAgZGVjb2RlVmlkZW9UZXh0dXJlOiAhIXkubWFwICYmIHkubWFwLmlzVmlkZW9UZXh0dXJlID09PSAhMCAmJiB5Lm1hcC5lbmNvZGluZyA9PT0gMzAwMSxcbiAgICAgIGNsZWFyY29hdDogdmUsXG4gICAgICBjbGVhcmNvYXRNYXA6IHZlICYmICEheS5jbGVhcmNvYXRNYXAsXG4gICAgICBjbGVhcmNvYXRSb3VnaG5lc3NNYXA6IHZlICYmICEheS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsXG4gICAgICBjbGVhcmNvYXROb3JtYWxNYXA6IHZlICYmICEheS5jbGVhcmNvYXROb3JtYWxNYXAsXG4gICAgICBpcmlkZXNjZW5jZTogeGUsXG4gICAgICBpcmlkZXNjZW5jZU1hcDogeGUgJiYgISF5LmlyaWRlc2NlbmNlTWFwLFxuICAgICAgaXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IHhlICYmICEheS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCxcbiAgICAgIGRpc3BsYWNlbWVudE1hcDogISF5LmRpc3BsYWNlbWVudE1hcCxcbiAgICAgIHJvdWdobmVzc01hcDogISF5LnJvdWdobmVzc01hcCxcbiAgICAgIG1ldGFsbmVzc01hcDogISF5Lm1ldGFsbmVzc01hcCxcbiAgICAgIHNwZWN1bGFyTWFwOiAhIXkuc3BlY3VsYXJNYXAsXG4gICAgICBzcGVjdWxhckludGVuc2l0eU1hcDogISF5LnNwZWN1bGFySW50ZW5zaXR5TWFwLFxuICAgICAgc3BlY3VsYXJDb2xvck1hcDogISF5LnNwZWN1bGFyQ29sb3JNYXAsXG4gICAgICBvcGFxdWU6IHkudHJhbnNwYXJlbnQgPT09ICExICYmIHkuYmxlbmRpbmcgPT09IDEsXG4gICAgICBhbHBoYU1hcDogISF5LmFscGhhTWFwLFxuICAgICAgYWxwaGFUZXN0OiBEZSxcbiAgICAgIGdyYWRpZW50TWFwOiAhIXkuZ3JhZGllbnRNYXAsXG4gICAgICBzaGVlbjogeS5zaGVlbiA+IDAsXG4gICAgICBzaGVlbkNvbG9yTWFwOiAhIXkuc2hlZW5Db2xvck1hcCxcbiAgICAgIHNoZWVuUm91Z2huZXNzTWFwOiAhIXkuc2hlZW5Sb3VnaG5lc3NNYXAsXG4gICAgICB0cmFuc21pc3Npb246IHkudHJhbnNtaXNzaW9uID4gMCxcbiAgICAgIHRyYW5zbWlzc2lvbk1hcDogISF5LnRyYW5zbWlzc2lvbk1hcCxcbiAgICAgIHRoaWNrbmVzc01hcDogISF5LnRoaWNrbmVzc01hcCxcbiAgICAgIGNvbWJpbmU6IHkuY29tYmluZSxcbiAgICAgIHZlcnRleFRhbmdlbnRzOiAhIXkubm9ybWFsTWFwICYmICEhTC5hdHRyaWJ1dGVzLnRhbmdlbnQsXG4gICAgICB2ZXJ0ZXhDb2xvcnM6IHkudmVydGV4Q29sb3JzLFxuICAgICAgdmVydGV4QWxwaGFzOiB5LnZlcnRleENvbG9ycyA9PT0gITAgJiYgISFMLmF0dHJpYnV0ZXMuY29sb3IgJiYgTC5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplID09PSA0LFxuICAgICAgdmVydGV4VXZzOiAhIXkubWFwIHx8ICEheS5idW1wTWFwIHx8ICEheS5ub3JtYWxNYXAgfHwgISF5LnNwZWN1bGFyTWFwIHx8ICEheS5hbHBoYU1hcCB8fCAhIXkuZW1pc3NpdmVNYXAgfHwgISF5LnJvdWdobmVzc01hcCB8fCAhIXkubWV0YWxuZXNzTWFwIHx8ICEheS5jbGVhcmNvYXRNYXAgfHwgISF5LmNsZWFyY29hdFJvdWdobmVzc01hcCB8fCAhIXkuY2xlYXJjb2F0Tm9ybWFsTWFwIHx8ICEheS5pcmlkZXNjZW5jZU1hcCB8fCAhIXkuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgfHwgISF5LmRpc3BsYWNlbWVudE1hcCB8fCAhIXkudHJhbnNtaXNzaW9uTWFwIHx8ICEheS50aGlja25lc3NNYXAgfHwgISF5LnNwZWN1bGFySW50ZW5zaXR5TWFwIHx8ICEheS5zcGVjdWxhckNvbG9yTWFwIHx8ICEheS5zaGVlbkNvbG9yTWFwIHx8ICEheS5zaGVlblJvdWdobmVzc01hcCxcbiAgICAgIHV2c1ZlcnRleE9ubHk6ICEoISF5Lm1hcCB8fCAhIXkuYnVtcE1hcCB8fCAhIXkubm9ybWFsTWFwIHx8ICEheS5zcGVjdWxhck1hcCB8fCAhIXkuYWxwaGFNYXAgfHwgISF5LmVtaXNzaXZlTWFwIHx8ICEheS5yb3VnaG5lc3NNYXAgfHwgISF5Lm1ldGFsbmVzc01hcCB8fCAhIXkuY2xlYXJjb2F0Tm9ybWFsTWFwIHx8ICEheS5pcmlkZXNjZW5jZU1hcCB8fCAhIXkuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgfHwgeS50cmFuc21pc3Npb24gPiAwIHx8ICEheS50cmFuc21pc3Npb25NYXAgfHwgISF5LnRoaWNrbmVzc01hcCB8fCAhIXkuc3BlY3VsYXJJbnRlbnNpdHlNYXAgfHwgISF5LnNwZWN1bGFyQ29sb3JNYXAgfHwgeS5zaGVlbiA+IDAgfHwgISF5LnNoZWVuQ29sb3JNYXAgfHwgISF5LnNoZWVuUm91Z2huZXNzTWFwKSAmJiAhIXkuZGlzcGxhY2VtZW50TWFwLFxuICAgICAgZm9nOiAhIXosXG4gICAgICB1c2VGb2c6IHkuZm9nID09PSAhMCxcbiAgICAgIGZvZ0V4cDI6IHogJiYgei5pc0ZvZ0V4cDIsXG4gICAgICBmbGF0U2hhZGluZzogISF5LmZsYXRTaGFkaW5nLFxuICAgICAgc2l6ZUF0dGVudWF0aW9uOiB5LnNpemVBdHRlbnVhdGlvbixcbiAgICAgIGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGQsXG4gICAgICBza2lubmluZzogRy5pc1NraW5uZWRNZXNoID09PSAhMCxcbiAgICAgIG1vcnBoVGFyZ2V0czogTC5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCxcbiAgICAgIG1vcnBoTm9ybWFsczogTC5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB2b2lkIDAsXG4gICAgICBtb3JwaENvbG9yczogTC5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgIT09IHZvaWQgMCxcbiAgICAgIG1vcnBoVGFyZ2V0c0NvdW50OiBILFxuICAgICAgbW9ycGhUZXh0dXJlU3RyaWRlOiBKLFxuICAgICAgbnVtRGlyTGlnaHRzOiBBLmRpcmVjdGlvbmFsLmxlbmd0aCxcbiAgICAgIG51bVBvaW50TGlnaHRzOiBBLnBvaW50Lmxlbmd0aCxcbiAgICAgIG51bVNwb3RMaWdodHM6IEEuc3BvdC5sZW5ndGgsXG4gICAgICBudW1SZWN0QXJlYUxpZ2h0czogQS5yZWN0QXJlYS5sZW5ndGgsXG4gICAgICBudW1IZW1pTGlnaHRzOiBBLmhlbWkubGVuZ3RoLFxuICAgICAgbnVtRGlyTGlnaHRTaGFkb3dzOiBBLmRpcmVjdGlvbmFsU2hhZG93TWFwLmxlbmd0aCxcbiAgICAgIG51bVBvaW50TGlnaHRTaGFkb3dzOiBBLnBvaW50U2hhZG93TWFwLmxlbmd0aCxcbiAgICAgIG51bVNwb3RMaWdodFNoYWRvd3M6IEEuc3BvdFNoYWRvd01hcC5sZW5ndGgsXG4gICAgICBudW1DbGlwcGluZ1BsYW5lczogby5udW1QbGFuZXMsXG4gICAgICBudW1DbGlwSW50ZXJzZWN0aW9uOiBvLm51bUludGVyc2VjdGlvbixcbiAgICAgIGRpdGhlcmluZzogeS5kaXRoZXJpbmcsXG4gICAgICBzaGFkb3dNYXBFbmFibGVkOiBoLnNoYWRvd01hcC5lbmFibGVkICYmIEYubGVuZ3RoID4gMCxcbiAgICAgIHNoYWRvd01hcFR5cGU6IGguc2hhZG93TWFwLnR5cGUsXG4gICAgICB0b25lTWFwcGluZzogeS50b25lTWFwcGVkID8gaC50b25lTWFwcGluZyA6IDAsXG4gICAgICBwaHlzaWNhbGx5Q29ycmVjdExpZ2h0czogaC5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyxcbiAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogeS5wcmVtdWx0aXBsaWVkQWxwaGEsXG4gICAgICBkb3VibGVTaWRlZDogeS5zaWRlID09PSAyLFxuICAgICAgZmxpcFNpZGVkOiB5LnNpZGUgPT09IDEsXG4gICAgICB1c2VEZXB0aFBhY2tpbmc6ICEheS5kZXB0aFBhY2tpbmcsXG4gICAgICBkZXB0aFBhY2tpbmc6IHkuZGVwdGhQYWNraW5nIHx8IDAsXG4gICAgICBpbmRleDBBdHRyaWJ1dGVOYW1lOiB5LmluZGV4MEF0dHJpYnV0ZU5hbWUsXG4gICAgICBleHRlbnNpb25EZXJpdmF0aXZlczogeS5leHRlbnNpb25zICYmIHkuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyxcbiAgICAgIGV4dGVuc2lvbkZyYWdEZXB0aDogeS5leHRlbnNpb25zICYmIHkuZXh0ZW5zaW9ucy5mcmFnRGVwdGgsXG4gICAgICBleHRlbnNpb25EcmF3QnVmZmVyczogeS5leHRlbnNpb25zICYmIHkuZXh0ZW5zaW9ucy5kcmF3QnVmZmVycyxcbiAgICAgIGV4dGVuc2lvblNoYWRlclRleHR1cmVMT0Q6IHkuZXh0ZW5zaW9ucyAmJiB5LmV4dGVuc2lvbnMuc2hhZGVyVGV4dHVyZUxPRCxcbiAgICAgIHJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoOiBjIHx8IG4uaGFzKFwiRVhUX2ZyYWdfZGVwdGhcIiksXG4gICAgICByZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzOiBjIHx8IG4uaGFzKFwiV0VCR0xfZHJhd19idWZmZXJzXCIpLFxuICAgICAgcmVuZGVyZXJFeHRlbnNpb25TaGFkZXJUZXh0dXJlTG9kOiBjIHx8IG4uaGFzKFwiRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFwiKSxcbiAgICAgIGN1c3RvbVByb2dyYW1DYWNoZUtleTogeS5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZih5KSB7XG4gICAgY29uc3QgQSA9IFtdO1xuICAgIGlmICh5LnNoYWRlcklEID8gQS5wdXNoKHkuc2hhZGVySUQpIDogKEEucHVzaCh5LmN1c3RvbVZlcnRleFNoYWRlcklEKSwgQS5wdXNoKHkuY3VzdG9tRnJhZ21lbnRTaGFkZXJJRCkpLCB5LmRlZmluZXMgIT09IHZvaWQgMClcbiAgICAgIGZvciAoY29uc3QgRiBpbiB5LmRlZmluZXMpXG4gICAgICAgIEEucHVzaChGKSwgQS5wdXNoKHkuZGVmaW5lc1tGXSk7XG4gICAgcmV0dXJuIHkuaXNSYXdTaGFkZXJNYXRlcmlhbCA9PT0gITEgJiYgKHYoQSwgeSksIF8oQSwgeSksIEEucHVzaChoLm91dHB1dEVuY29kaW5nKSksIEEucHVzaCh5LmN1c3RvbVByb2dyYW1DYWNoZUtleSksIEEuam9pbigpO1xuICB9XG4gIGZ1bmN0aW9uIHYoeSwgQSkge1xuICAgIHkucHVzaChBLnByZWNpc2lvbiksIHkucHVzaChBLm91dHB1dEVuY29kaW5nKSwgeS5wdXNoKEEuZW52TWFwTW9kZSksIHkucHVzaChBLmVudk1hcEN1YmVVVkhlaWdodCksIHkucHVzaChBLmNvbWJpbmUpLCB5LnB1c2goQS52ZXJ0ZXhVdnMpLCB5LnB1c2goQS5mb2dFeHAyKSwgeS5wdXNoKEEuc2l6ZUF0dGVudWF0aW9uKSwgeS5wdXNoKEEubW9ycGhUYXJnZXRzQ291bnQpLCB5LnB1c2goQS5tb3JwaEF0dHJpYnV0ZUNvdW50KSwgeS5wdXNoKEEubnVtRGlyTGlnaHRzKSwgeS5wdXNoKEEubnVtUG9pbnRMaWdodHMpLCB5LnB1c2goQS5udW1TcG90TGlnaHRzKSwgeS5wdXNoKEEubnVtSGVtaUxpZ2h0cyksIHkucHVzaChBLm51bVJlY3RBcmVhTGlnaHRzKSwgeS5wdXNoKEEubnVtRGlyTGlnaHRTaGFkb3dzKSwgeS5wdXNoKEEubnVtUG9pbnRMaWdodFNoYWRvd3MpLCB5LnB1c2goQS5udW1TcG90TGlnaHRTaGFkb3dzKSwgeS5wdXNoKEEuc2hhZG93TWFwVHlwZSksIHkucHVzaChBLnRvbmVNYXBwaW5nKSwgeS5wdXNoKEEubnVtQ2xpcHBpbmdQbGFuZXMpLCB5LnB1c2goQS5udW1DbGlwSW50ZXJzZWN0aW9uKSwgeS5wdXNoKEEuZGVwdGhQYWNraW5nKTtcbiAgfVxuICBmdW5jdGlvbiBfKHksIEEpIHtcbiAgICByLmRpc2FibGVBbGwoKSwgQS5pc1dlYkdMMiAmJiByLmVuYWJsZSgwKSwgQS5zdXBwb3J0c1ZlcnRleFRleHR1cmVzICYmIHIuZW5hYmxlKDEpLCBBLmluc3RhbmNpbmcgJiYgci5lbmFibGUoMiksIEEuaW5zdGFuY2luZ0NvbG9yICYmIHIuZW5hYmxlKDMpLCBBLm1hcCAmJiByLmVuYWJsZSg0KSwgQS5tYXRjYXAgJiYgci5lbmFibGUoNSksIEEuZW52TWFwICYmIHIuZW5hYmxlKDYpLCBBLmxpZ2h0TWFwICYmIHIuZW5hYmxlKDcpLCBBLmFvTWFwICYmIHIuZW5hYmxlKDgpLCBBLmVtaXNzaXZlTWFwICYmIHIuZW5hYmxlKDkpLCBBLmJ1bXBNYXAgJiYgci5lbmFibGUoMTApLCBBLm5vcm1hbE1hcCAmJiByLmVuYWJsZSgxMSksIEEub2JqZWN0U3BhY2VOb3JtYWxNYXAgJiYgci5lbmFibGUoMTIpLCBBLnRhbmdlbnRTcGFjZU5vcm1hbE1hcCAmJiByLmVuYWJsZSgxMyksIEEuY2xlYXJjb2F0ICYmIHIuZW5hYmxlKDE0KSwgQS5jbGVhcmNvYXRNYXAgJiYgci5lbmFibGUoMTUpLCBBLmNsZWFyY29hdFJvdWdobmVzc01hcCAmJiByLmVuYWJsZSgxNiksIEEuY2xlYXJjb2F0Tm9ybWFsTWFwICYmIHIuZW5hYmxlKDE3KSwgQS5pcmlkZXNjZW5jZSAmJiByLmVuYWJsZSgxOCksIEEuaXJpZGVzY2VuY2VNYXAgJiYgci5lbmFibGUoMTkpLCBBLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICYmIHIuZW5hYmxlKDIwKSwgQS5kaXNwbGFjZW1lbnRNYXAgJiYgci5lbmFibGUoMjEpLCBBLnNwZWN1bGFyTWFwICYmIHIuZW5hYmxlKDIyKSwgQS5yb3VnaG5lc3NNYXAgJiYgci5lbmFibGUoMjMpLCBBLm1ldGFsbmVzc01hcCAmJiByLmVuYWJsZSgyNCksIEEuZ3JhZGllbnRNYXAgJiYgci5lbmFibGUoMjUpLCBBLmFscGhhTWFwICYmIHIuZW5hYmxlKDI2KSwgQS5hbHBoYVRlc3QgJiYgci5lbmFibGUoMjcpLCBBLnZlcnRleENvbG9ycyAmJiByLmVuYWJsZSgyOCksIEEudmVydGV4QWxwaGFzICYmIHIuZW5hYmxlKDI5KSwgQS52ZXJ0ZXhVdnMgJiYgci5lbmFibGUoMzApLCBBLnZlcnRleFRhbmdlbnRzICYmIHIuZW5hYmxlKDMxKSwgQS51dnNWZXJ0ZXhPbmx5ICYmIHIuZW5hYmxlKDMyKSwgQS5mb2cgJiYgci5lbmFibGUoMzMpLCB5LnB1c2goci5tYXNrKSwgci5kaXNhYmxlQWxsKCksIEEudXNlRm9nICYmIHIuZW5hYmxlKDApLCBBLmZsYXRTaGFkaW5nICYmIHIuZW5hYmxlKDEpLCBBLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgci5lbmFibGUoMiksIEEuc2tpbm5pbmcgJiYgci5lbmFibGUoMyksIEEubW9ycGhUYXJnZXRzICYmIHIuZW5hYmxlKDQpLCBBLm1vcnBoTm9ybWFscyAmJiByLmVuYWJsZSg1KSwgQS5tb3JwaENvbG9ycyAmJiByLmVuYWJsZSg2KSwgQS5wcmVtdWx0aXBsaWVkQWxwaGEgJiYgci5lbmFibGUoNyksIEEuc2hhZG93TWFwRW5hYmxlZCAmJiByLmVuYWJsZSg4KSwgQS5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyAmJiByLmVuYWJsZSg5KSwgQS5kb3VibGVTaWRlZCAmJiByLmVuYWJsZSgxMCksIEEuZmxpcFNpZGVkICYmIHIuZW5hYmxlKDExKSwgQS51c2VEZXB0aFBhY2tpbmcgJiYgci5lbmFibGUoMTIpLCBBLmRpdGhlcmluZyAmJiByLmVuYWJsZSgxMyksIEEuc3BlY3VsYXJJbnRlbnNpdHlNYXAgJiYgci5lbmFibGUoMTQpLCBBLnNwZWN1bGFyQ29sb3JNYXAgJiYgci5lbmFibGUoMTUpLCBBLnRyYW5zbWlzc2lvbiAmJiByLmVuYWJsZSgxNiksIEEudHJhbnNtaXNzaW9uTWFwICYmIHIuZW5hYmxlKDE3KSwgQS50aGlja25lc3NNYXAgJiYgci5lbmFibGUoMTgpLCBBLnNoZWVuICYmIHIuZW5hYmxlKDE5KSwgQS5zaGVlbkNvbG9yTWFwICYmIHIuZW5hYmxlKDIwKSwgQS5zaGVlblJvdWdobmVzc01hcCAmJiByLmVuYWJsZSgyMSksIEEuZGVjb2RlVmlkZW9UZXh0dXJlICYmIHIuZW5hYmxlKDIyKSwgQS5vcGFxdWUgJiYgci5lbmFibGUoMjMpLCB5LnB1c2goci5tYXNrKTtcbiAgfVxuICBmdW5jdGlvbiB3KHkpIHtcbiAgICBjb25zdCBBID0gZ1t5LnR5cGVdO1xuICAgIGxldCBGO1xuICAgIGlmIChBKSB7XG4gICAgICBjb25zdCBQID0gQnRbQV07XG4gICAgICBGID0gSm8uY2xvbmUoUC51bmlmb3Jtcyk7XG4gICAgfSBlbHNlXG4gICAgICBGID0geS51bmlmb3JtcztcbiAgICByZXR1cm4gRjtcbiAgfVxuICBmdW5jdGlvbiB4KHksIEEpIHtcbiAgICBsZXQgRjtcbiAgICBmb3IgKGxldCBQID0gMCwgRyA9IGEubGVuZ3RoOyBQIDwgRzsgUCsrKSB7XG4gICAgICBjb25zdCB6ID0gYVtQXTtcbiAgICAgIGlmICh6LmNhY2hlS2V5ID09PSBBKSB7XG4gICAgICAgIEYgPSB6LCArK0YudXNlZFRpbWVzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEYgPT09IHZvaWQgMCAmJiAoRiA9IG5ldyBhdShoLCBBLCB5LCBzKSwgYS5wdXNoKEYpKSwgRjtcbiAgfVxuICBmdW5jdGlvbiBNKHkpIHtcbiAgICBpZiAoLS15LnVzZWRUaW1lcyA9PT0gMCkge1xuICAgICAgY29uc3QgQSA9IGEuaW5kZXhPZih5KTtcbiAgICAgIGFbQV0gPSBhW2EubGVuZ3RoIC0gMV0sIGEucG9wKCksIHkuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBFKHkpIHtcbiAgICBsLnJlbW92ZSh5KTtcbiAgfVxuICBmdW5jdGlvbiBSKCkge1xuICAgIGwuZGlzcG9zZSgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0UGFyYW1ldGVyczogcCxcbiAgICBnZXRQcm9ncmFtQ2FjaGVLZXk6IGYsXG4gICAgZ2V0VW5pZm9ybXM6IHcsXG4gICAgYWNxdWlyZVByb2dyYW06IHgsXG4gICAgcmVsZWFzZVByb2dyYW06IE0sXG4gICAgcmVsZWFzZVNoYWRlckNhY2hlOiBFLFxuICAgIHByb2dyYW1zOiBhLFxuICAgIGRpc3Bvc2U6IFJcbiAgfTtcbn1cbmZ1bmN0aW9uIGR1KCkge1xuICBsZXQgaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBmdW5jdGlvbiBlKHMpIHtcbiAgICBsZXQgbyA9IGguZ2V0KHMpO1xuICAgIHJldHVybiBvID09PSB2b2lkIDAgJiYgKG8gPSB7fSwgaC5zZXQocywgbykpLCBvO1xuICB9XG4gIGZ1bmN0aW9uIHQocykge1xuICAgIGguZGVsZXRlKHMpO1xuICB9XG4gIGZ1bmN0aW9uIG4ocywgbywgcikge1xuICAgIGguZ2V0KHMpW29dID0gcjtcbiAgfVxuICBmdW5jdGlvbiBpKCkge1xuICAgIGggPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldDogZSxcbiAgICByZW1vdmU6IHQsXG4gICAgdXBkYXRlOiBuLFxuICAgIGRpc3Bvc2U6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIGZ1KGgsIGUpIHtcbiAgcmV0dXJuIGguZ3JvdXBPcmRlciAhPT0gZS5ncm91cE9yZGVyID8gaC5ncm91cE9yZGVyIC0gZS5ncm91cE9yZGVyIDogaC5yZW5kZXJPcmRlciAhPT0gZS5yZW5kZXJPcmRlciA/IGgucmVuZGVyT3JkZXIgLSBlLnJlbmRlck9yZGVyIDogaC5tYXRlcmlhbC5pZCAhPT0gZS5tYXRlcmlhbC5pZCA/IGgubWF0ZXJpYWwuaWQgLSBlLm1hdGVyaWFsLmlkIDogaC56ICE9PSBlLnogPyBoLnogLSBlLnogOiBoLmlkIC0gZS5pZDtcbn1cbmZ1bmN0aW9uIEFyKGgsIGUpIHtcbiAgcmV0dXJuIGguZ3JvdXBPcmRlciAhPT0gZS5ncm91cE9yZGVyID8gaC5ncm91cE9yZGVyIC0gZS5ncm91cE9yZGVyIDogaC5yZW5kZXJPcmRlciAhPT0gZS5yZW5kZXJPcmRlciA/IGgucmVuZGVyT3JkZXIgLSBlLnJlbmRlck9yZGVyIDogaC56ICE9PSBlLnogPyBlLnogLSBoLnogOiBoLmlkIC0gZS5pZDtcbn1cbmZ1bmN0aW9uIENyKCkge1xuICBjb25zdCBoID0gW107XG4gIGxldCBlID0gMDtcbiAgY29uc3QgdCA9IFtdLCBuID0gW10sIGkgPSBbXTtcbiAgZnVuY3Rpb24gcygpIHtcbiAgICBlID0gMCwgdC5sZW5ndGggPSAwLCBuLmxlbmd0aCA9IDAsIGkubGVuZ3RoID0gMDtcbiAgfVxuICBmdW5jdGlvbiBvKGQsIHUsIG0sIGcsIHAsIGYpIHtcbiAgICBsZXQgdiA9IGhbZV07XG4gICAgcmV0dXJuIHYgPT09IHZvaWQgMCA/ICh2ID0ge1xuICAgICAgaWQ6IGQuaWQsXG4gICAgICBvYmplY3Q6IGQsXG4gICAgICBnZW9tZXRyeTogdSxcbiAgICAgIG1hdGVyaWFsOiBtLFxuICAgICAgZ3JvdXBPcmRlcjogZyxcbiAgICAgIHJlbmRlck9yZGVyOiBkLnJlbmRlck9yZGVyLFxuICAgICAgejogcCxcbiAgICAgIGdyb3VwOiBmXG4gICAgfSwgaFtlXSA9IHYpIDogKHYuaWQgPSBkLmlkLCB2Lm9iamVjdCA9IGQsIHYuZ2VvbWV0cnkgPSB1LCB2Lm1hdGVyaWFsID0gbSwgdi5ncm91cE9yZGVyID0gZywgdi5yZW5kZXJPcmRlciA9IGQucmVuZGVyT3JkZXIsIHYueiA9IHAsIHYuZ3JvdXAgPSBmKSwgZSsrLCB2O1xuICB9XG4gIGZ1bmN0aW9uIHIoZCwgdSwgbSwgZywgcCwgZikge1xuICAgIGNvbnN0IHYgPSBvKGQsIHUsIG0sIGcsIHAsIGYpO1xuICAgIG0udHJhbnNtaXNzaW9uID4gMCA/IG4ucHVzaCh2KSA6IG0udHJhbnNwYXJlbnQgPT09ICEwID8gaS5wdXNoKHYpIDogdC5wdXNoKHYpO1xuICB9XG4gIGZ1bmN0aW9uIGwoZCwgdSwgbSwgZywgcCwgZikge1xuICAgIGNvbnN0IHYgPSBvKGQsIHUsIG0sIGcsIHAsIGYpO1xuICAgIG0udHJhbnNtaXNzaW9uID4gMCA/IG4udW5zaGlmdCh2KSA6IG0udHJhbnNwYXJlbnQgPT09ICEwID8gaS51bnNoaWZ0KHYpIDogdC51bnNoaWZ0KHYpO1xuICB9XG4gIGZ1bmN0aW9uIGEoZCwgdSkge1xuICAgIHQubGVuZ3RoID4gMSAmJiB0LnNvcnQoZCB8fCBmdSksIG4ubGVuZ3RoID4gMSAmJiBuLnNvcnQodSB8fCBBciksIGkubGVuZ3RoID4gMSAmJiBpLnNvcnQodSB8fCBBcik7XG4gIH1cbiAgZnVuY3Rpb24gYygpIHtcbiAgICBmb3IgKGxldCBkID0gZSwgdSA9IGgubGVuZ3RoOyBkIDwgdTsgZCsrKSB7XG4gICAgICBjb25zdCBtID0gaFtkXTtcbiAgICAgIGlmIChtLmlkID09PSBudWxsKVxuICAgICAgICBicmVhaztcbiAgICAgIG0uaWQgPSBudWxsLCBtLm9iamVjdCA9IG51bGwsIG0uZ2VvbWV0cnkgPSBudWxsLCBtLm1hdGVyaWFsID0gbnVsbCwgbS5ncm91cCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgb3BhcXVlOiB0LFxuICAgIHRyYW5zbWlzc2l2ZTogbixcbiAgICB0cmFuc3BhcmVudDogaSxcbiAgICBpbml0OiBzLFxuICAgIHB1c2g6IHIsXG4gICAgdW5zaGlmdDogbCxcbiAgICBmaW5pc2g6IGMsXG4gICAgc29ydDogYVxuICB9O1xufVxuZnVuY3Rpb24gcHUoKSB7XG4gIGxldCBoID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIGUobiwgaSkge1xuICAgIGxldCBzO1xuICAgIHJldHVybiBoLmhhcyhuKSA9PT0gITEgPyAocyA9IG5ldyBDcigpLCBoLnNldChuLCBbc10pKSA6IGkgPj0gaC5nZXQobikubGVuZ3RoID8gKHMgPSBuZXcgQ3IoKSwgaC5nZXQobikucHVzaChzKSkgOiBzID0gaC5nZXQobilbaV0sIHM7XG4gIH1cbiAgZnVuY3Rpb24gdCgpIHtcbiAgICBoID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGUsXG4gICAgZGlzcG9zZTogdFxuICB9O1xufVxuZnVuY3Rpb24gbXUoKSB7XG4gIGNvbnN0IGggPSB7fTtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChoW2UuaWRdICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBoW2UuaWRdO1xuICAgICAgbGV0IHQ7XG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICBjYXNlIFwiRGlyZWN0aW9uYWxMaWdodFwiOlxuICAgICAgICAgIHQgPSB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IG5ldyBPKCksXG4gICAgICAgICAgICBjb2xvcjogbmV3IEFlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU3BvdExpZ2h0XCI6XG4gICAgICAgICAgdCA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgTygpLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBuZXcgTygpLFxuICAgICAgICAgICAgY29sb3I6IG5ldyBBZSgpLFxuICAgICAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgICAgICBjb25lQ29zOiAwLFxuICAgICAgICAgICAgcGVudW1icmFDb3M6IDAsXG4gICAgICAgICAgICBkZWNheTogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQb2ludExpZ2h0XCI6XG4gICAgICAgICAgdCA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgTygpLFxuICAgICAgICAgICAgY29sb3I6IG5ldyBBZSgpLFxuICAgICAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgICAgICBkZWNheTogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIZW1pc3BoZXJlTGlnaHRcIjpcbiAgICAgICAgICB0ID0ge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBuZXcgTygpLFxuICAgICAgICAgICAgc2t5Q29sb3I6IG5ldyBBZSgpLFxuICAgICAgICAgICAgZ3JvdW5kQ29sb3I6IG5ldyBBZSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJlY3RBcmVhTGlnaHRcIjpcbiAgICAgICAgICB0ID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBBZSgpLFxuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBPKCksXG4gICAgICAgICAgICBoYWxmV2lkdGg6IG5ldyBPKCksXG4gICAgICAgICAgICBoYWxmSGVpZ2h0OiBuZXcgTygpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBoW2UuaWRdID0gdCwgdDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBndSgpIHtcbiAgY29uc3QgaCA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGhbZS5pZF0gIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIGhbZS5pZF07XG4gICAgICBsZXQgdDtcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJEaXJlY3Rpb25hbExpZ2h0XCI6XG4gICAgICAgICAgdCA9IHtcbiAgICAgICAgICAgIHNoYWRvd0JpYXM6IDAsXG4gICAgICAgICAgICBzaGFkb3dOb3JtYWxCaWFzOiAwLFxuICAgICAgICAgICAgc2hhZG93UmFkaXVzOiAxLFxuICAgICAgICAgICAgc2hhZG93TWFwU2l6ZTogbmV3IENlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU3BvdExpZ2h0XCI6XG4gICAgICAgICAgdCA9IHtcbiAgICAgICAgICAgIHNoYWRvd0JpYXM6IDAsXG4gICAgICAgICAgICBzaGFkb3dOb3JtYWxCaWFzOiAwLFxuICAgICAgICAgICAgc2hhZG93UmFkaXVzOiAxLFxuICAgICAgICAgICAgc2hhZG93TWFwU2l6ZTogbmV3IENlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUG9pbnRMaWdodFwiOlxuICAgICAgICAgIHQgPSB7XG4gICAgICAgICAgICBzaGFkb3dCaWFzOiAwLFxuICAgICAgICAgICAgc2hhZG93Tm9ybWFsQmlhczogMCxcbiAgICAgICAgICAgIHNoYWRvd1JhZGl1czogMSxcbiAgICAgICAgICAgIHNoYWRvd01hcFNpemU6IG5ldyBDZSgpLFxuICAgICAgICAgICAgc2hhZG93Q2FtZXJhTmVhcjogMSxcbiAgICAgICAgICAgIHNoYWRvd0NhbWVyYUZhcjogMWUzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBoW2UuaWRdID0gdCwgdDtcbiAgICB9XG4gIH07XG59XG5sZXQgX3UgPSAwO1xuZnVuY3Rpb24gdnUoaCwgZSkge1xuICByZXR1cm4gKGUuY2FzdFNoYWRvdyA/IDEgOiAwKSAtIChoLmNhc3RTaGFkb3cgPyAxIDogMCk7XG59XG5mdW5jdGlvbiB4dShoLCBlKSB7XG4gIGNvbnN0IHQgPSBuZXcgbXUoKSwgbiA9IGd1KCksIGkgPSB7XG4gICAgdmVyc2lvbjogMCxcbiAgICBoYXNoOiB7XG4gICAgICBkaXJlY3Rpb25hbExlbmd0aDogLTEsXG4gICAgICBwb2ludExlbmd0aDogLTEsXG4gICAgICBzcG90TGVuZ3RoOiAtMSxcbiAgICAgIHJlY3RBcmVhTGVuZ3RoOiAtMSxcbiAgICAgIGhlbWlMZW5ndGg6IC0xLFxuICAgICAgbnVtRGlyZWN0aW9uYWxTaGFkb3dzOiAtMSxcbiAgICAgIG51bVBvaW50U2hhZG93czogLTEsXG4gICAgICBudW1TcG90U2hhZG93czogLTFcbiAgICB9LFxuICAgIGFtYmllbnQ6IFswLCAwLCAwXSxcbiAgICBwcm9iZTogW10sXG4gICAgZGlyZWN0aW9uYWw6IFtdLFxuICAgIGRpcmVjdGlvbmFsU2hhZG93OiBbXSxcbiAgICBkaXJlY3Rpb25hbFNoYWRvd01hcDogW10sXG4gICAgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IFtdLFxuICAgIHNwb3Q6IFtdLFxuICAgIHNwb3RTaGFkb3c6IFtdLFxuICAgIHNwb3RTaGFkb3dNYXA6IFtdLFxuICAgIHNwb3RTaGFkb3dNYXRyaXg6IFtdLFxuICAgIHJlY3RBcmVhOiBbXSxcbiAgICByZWN0QXJlYUxUQzE6IG51bGwsXG4gICAgcmVjdEFyZWFMVEMyOiBudWxsLFxuICAgIHBvaW50OiBbXSxcbiAgICBwb2ludFNoYWRvdzogW10sXG4gICAgcG9pbnRTaGFkb3dNYXA6IFtdLFxuICAgIHBvaW50U2hhZG93TWF0cml4OiBbXSxcbiAgICBoZW1pOiBbXVxuICB9O1xuICBmb3IgKGxldCBjID0gMDsgYyA8IDk7IGMrKylcbiAgICBpLnByb2JlLnB1c2gobmV3IE8oKSk7XG4gIGNvbnN0IHMgPSBuZXcgTygpLCBvID0gbmV3IEtlKCksIHIgPSBuZXcgS2UoKTtcbiAgZnVuY3Rpb24gbChjLCBkKSB7XG4gICAgbGV0IHUgPSAwLCBtID0gMCwgZyA9IDA7XG4gICAgZm9yIChsZXQgQSA9IDA7IEEgPCA5OyBBKyspXG4gICAgICBpLnByb2JlW0FdLnNldCgwLCAwLCAwKTtcbiAgICBsZXQgcCA9IDAsIGYgPSAwLCB2ID0gMCwgXyA9IDAsIHcgPSAwLCB4ID0gMCwgTSA9IDAsIEUgPSAwO1xuICAgIGMuc29ydCh2dSk7XG4gICAgY29uc3QgUiA9IGQgIT09ICEwID8gTWF0aC5QSSA6IDE7XG4gICAgZm9yIChsZXQgQSA9IDAsIEYgPSBjLmxlbmd0aDsgQSA8IEY7IEErKykge1xuICAgICAgY29uc3QgUCA9IGNbQV0sIEcgPSBQLmNvbG9yLCB6ID0gUC5pbnRlbnNpdHksIEwgPSBQLmRpc3RhbmNlLCBJID0gUC5zaGFkb3cgJiYgUC5zaGFkb3cubWFwID8gUC5zaGFkb3cubWFwLnRleHR1cmUgOiBudWxsO1xuICAgICAgaWYgKFAuaXNBbWJpZW50TGlnaHQpXG4gICAgICAgIHUgKz0gRy5yICogeiAqIFIsIG0gKz0gRy5nICogeiAqIFIsIGcgKz0gRy5iICogeiAqIFI7XG4gICAgICBlbHNlIGlmIChQLmlzTGlnaHRQcm9iZSlcbiAgICAgICAgZm9yIChsZXQgRCA9IDA7IEQgPCA5OyBEKyspXG4gICAgICAgICAgaS5wcm9iZVtEXS5hZGRTY2FsZWRWZWN0b3IoUC5zaC5jb2VmZmljaWVudHNbRF0sIHopO1xuICAgICAgZWxzZSBpZiAoUC5pc0RpcmVjdGlvbmFsTGlnaHQpIHtcbiAgICAgICAgY29uc3QgRCA9IHQuZ2V0KFApO1xuICAgICAgICBpZiAoRC5jb2xvci5jb3B5KFAuY29sb3IpLm11bHRpcGx5U2NhbGFyKFAuaW50ZW5zaXR5ICogUiksIFAuY2FzdFNoYWRvdykge1xuICAgICAgICAgIGNvbnN0IHEgPSBQLnNoYWRvdywgayA9IG4uZ2V0KFApO1xuICAgICAgICAgIGsuc2hhZG93QmlhcyA9IHEuYmlhcywgay5zaGFkb3dOb3JtYWxCaWFzID0gcS5ub3JtYWxCaWFzLCBrLnNoYWRvd1JhZGl1cyA9IHEucmFkaXVzLCBrLnNoYWRvd01hcFNpemUgPSBxLm1hcFNpemUsIGkuZGlyZWN0aW9uYWxTaGFkb3dbcF0gPSBrLCBpLmRpcmVjdGlvbmFsU2hhZG93TWFwW3BdID0gSSwgaS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeFtwXSA9IFAuc2hhZG93Lm1hdHJpeCwgeCsrO1xuICAgICAgICB9XG4gICAgICAgIGkuZGlyZWN0aW9uYWxbcF0gPSBELCBwKys7XG4gICAgICB9IGVsc2UgaWYgKFAuaXNTcG90TGlnaHQpIHtcbiAgICAgICAgY29uc3QgRCA9IHQuZ2V0KFApO1xuICAgICAgICBpZiAoRC5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oUC5tYXRyaXhXb3JsZCksIEQuY29sb3IuY29weShHKS5tdWx0aXBseVNjYWxhcih6ICogUiksIEQuZGlzdGFuY2UgPSBMLCBELmNvbmVDb3MgPSBNYXRoLmNvcyhQLmFuZ2xlKSwgRC5wZW51bWJyYUNvcyA9IE1hdGguY29zKFAuYW5nbGUgKiAoMSAtIFAucGVudW1icmEpKSwgRC5kZWNheSA9IFAuZGVjYXksIFAuY2FzdFNoYWRvdykge1xuICAgICAgICAgIGNvbnN0IHEgPSBQLnNoYWRvdywgayA9IG4uZ2V0KFApO1xuICAgICAgICAgIGsuc2hhZG93QmlhcyA9IHEuYmlhcywgay5zaGFkb3dOb3JtYWxCaWFzID0gcS5ub3JtYWxCaWFzLCBrLnNoYWRvd1JhZGl1cyA9IHEucmFkaXVzLCBrLnNoYWRvd01hcFNpemUgPSBxLm1hcFNpemUsIGkuc3BvdFNoYWRvd1t2XSA9IGssIGkuc3BvdFNoYWRvd01hcFt2XSA9IEksIGkuc3BvdFNoYWRvd01hdHJpeFt2XSA9IFAuc2hhZG93Lm1hdHJpeCwgRSsrO1xuICAgICAgICB9XG4gICAgICAgIGkuc3BvdFt2XSA9IEQsIHYrKztcbiAgICAgIH0gZWxzZSBpZiAoUC5pc1JlY3RBcmVhTGlnaHQpIHtcbiAgICAgICAgY29uc3QgRCA9IHQuZ2V0KFApO1xuICAgICAgICBELmNvbG9yLmNvcHkoRykubXVsdGlwbHlTY2FsYXIoeiksIEQuaGFsZldpZHRoLnNldChQLndpZHRoICogMC41LCAwLCAwKSwgRC5oYWxmSGVpZ2h0LnNldCgwLCBQLmhlaWdodCAqIDAuNSwgMCksIGkucmVjdEFyZWFbX10gPSBELCBfKys7XG4gICAgICB9IGVsc2UgaWYgKFAuaXNQb2ludExpZ2h0KSB7XG4gICAgICAgIGNvbnN0IEQgPSB0LmdldChQKTtcbiAgICAgICAgaWYgKEQuY29sb3IuY29weShQLmNvbG9yKS5tdWx0aXBseVNjYWxhcihQLmludGVuc2l0eSAqIFIpLCBELmRpc3RhbmNlID0gUC5kaXN0YW5jZSwgRC5kZWNheSA9IFAuZGVjYXksIFAuY2FzdFNoYWRvdykge1xuICAgICAgICAgIGNvbnN0IHEgPSBQLnNoYWRvdywgayA9IG4uZ2V0KFApO1xuICAgICAgICAgIGsuc2hhZG93QmlhcyA9IHEuYmlhcywgay5zaGFkb3dOb3JtYWxCaWFzID0gcS5ub3JtYWxCaWFzLCBrLnNoYWRvd1JhZGl1cyA9IHEucmFkaXVzLCBrLnNoYWRvd01hcFNpemUgPSBxLm1hcFNpemUsIGsuc2hhZG93Q2FtZXJhTmVhciA9IHEuY2FtZXJhLm5lYXIsIGsuc2hhZG93Q2FtZXJhRmFyID0gcS5jYW1lcmEuZmFyLCBpLnBvaW50U2hhZG93W2ZdID0gaywgaS5wb2ludFNoYWRvd01hcFtmXSA9IEksIGkucG9pbnRTaGFkb3dNYXRyaXhbZl0gPSBQLnNoYWRvdy5tYXRyaXgsIE0rKztcbiAgICAgICAgfVxuICAgICAgICBpLnBvaW50W2ZdID0gRCwgZisrO1xuICAgICAgfSBlbHNlIGlmIChQLmlzSGVtaXNwaGVyZUxpZ2h0KSB7XG4gICAgICAgIGNvbnN0IEQgPSB0LmdldChQKTtcbiAgICAgICAgRC5za3lDb2xvci5jb3B5KFAuY29sb3IpLm11bHRpcGx5U2NhbGFyKHogKiBSKSwgRC5ncm91bmRDb2xvci5jb3B5KFAuZ3JvdW5kQ29sb3IpLm11bHRpcGx5U2NhbGFyKHogKiBSKSwgaS5oZW1pW3ddID0gRCwgdysrO1xuICAgICAgfVxuICAgIH1cbiAgICBfID4gMCAmJiAoZS5pc1dlYkdMMiB8fCBoLmhhcyhcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSA9PT0gITAgPyAoaS5yZWN0QXJlYUxUQzEgPSBuZS5MVENfRkxPQVRfMSwgaS5yZWN0QXJlYUxUQzIgPSBuZS5MVENfRkxPQVRfMikgOiBoLmhhcyhcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpID09PSAhMCA/IChpLnJlY3RBcmVhTFRDMSA9IG5lLkxUQ19IQUxGXzEsIGkucmVjdEFyZWFMVEMyID0gbmUuTFRDX0hBTEZfMikgOiBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5hYmxlIHRvIHVzZSBSZWN0QXJlYUxpZ2h0LiBNaXNzaW5nIFdlYkdMIGV4dGVuc2lvbnMuXCIpKSwgaS5hbWJpZW50WzBdID0gdSwgaS5hbWJpZW50WzFdID0gbSwgaS5hbWJpZW50WzJdID0gZztcbiAgICBjb25zdCB5ID0gaS5oYXNoO1xuICAgICh5LmRpcmVjdGlvbmFsTGVuZ3RoICE9PSBwIHx8IHkucG9pbnRMZW5ndGggIT09IGYgfHwgeS5zcG90TGVuZ3RoICE9PSB2IHx8IHkucmVjdEFyZWFMZW5ndGggIT09IF8gfHwgeS5oZW1pTGVuZ3RoICE9PSB3IHx8IHkubnVtRGlyZWN0aW9uYWxTaGFkb3dzICE9PSB4IHx8IHkubnVtUG9pbnRTaGFkb3dzICE9PSBNIHx8IHkubnVtU3BvdFNoYWRvd3MgIT09IEUpICYmIChpLmRpcmVjdGlvbmFsLmxlbmd0aCA9IHAsIGkuc3BvdC5sZW5ndGggPSB2LCBpLnJlY3RBcmVhLmxlbmd0aCA9IF8sIGkucG9pbnQubGVuZ3RoID0gZiwgaS5oZW1pLmxlbmd0aCA9IHcsIGkuZGlyZWN0aW9uYWxTaGFkb3cubGVuZ3RoID0geCwgaS5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGggPSB4LCBpLnBvaW50U2hhZG93Lmxlbmd0aCA9IE0sIGkucG9pbnRTaGFkb3dNYXAubGVuZ3RoID0gTSwgaS5zcG90U2hhZG93Lmxlbmd0aCA9IEUsIGkuc3BvdFNoYWRvd01hcC5sZW5ndGggPSBFLCBpLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4Lmxlbmd0aCA9IHgsIGkucG9pbnRTaGFkb3dNYXRyaXgubGVuZ3RoID0gTSwgaS5zcG90U2hhZG93TWF0cml4Lmxlbmd0aCA9IEUsIHkuZGlyZWN0aW9uYWxMZW5ndGggPSBwLCB5LnBvaW50TGVuZ3RoID0gZiwgeS5zcG90TGVuZ3RoID0gdiwgeS5yZWN0QXJlYUxlbmd0aCA9IF8sIHkuaGVtaUxlbmd0aCA9IHcsIHkubnVtRGlyZWN0aW9uYWxTaGFkb3dzID0geCwgeS5udW1Qb2ludFNoYWRvd3MgPSBNLCB5Lm51bVNwb3RTaGFkb3dzID0gRSwgaS52ZXJzaW9uID0gX3UrKyk7XG4gIH1cbiAgZnVuY3Rpb24gYShjLCBkKSB7XG4gICAgbGV0IHUgPSAwLCBtID0gMCwgZyA9IDAsIHAgPSAwLCBmID0gMDtcbiAgICBjb25zdCB2ID0gZC5tYXRyaXhXb3JsZEludmVyc2U7XG4gICAgZm9yIChsZXQgXyA9IDAsIHcgPSBjLmxlbmd0aDsgXyA8IHc7IF8rKykge1xuICAgICAgY29uc3QgeCA9IGNbX107XG4gICAgICBpZiAoeC5pc0RpcmVjdGlvbmFsTGlnaHQpIHtcbiAgICAgICAgY29uc3QgTSA9IGkuZGlyZWN0aW9uYWxbdV07XG4gICAgICAgIE0uZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih4Lm1hdHJpeFdvcmxkKSwgcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oeC50YXJnZXQubWF0cml4V29ybGQpLCBNLmRpcmVjdGlvbi5zdWIocyksIE0uZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2KSwgdSsrO1xuICAgICAgfSBlbHNlIGlmICh4LmlzU3BvdExpZ2h0KSB7XG4gICAgICAgIGNvbnN0IE0gPSBpLnNwb3RbZ107XG4gICAgICAgIE0ucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHgubWF0cml4V29ybGQpLCBNLnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2KSwgTS5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHgubWF0cml4V29ybGQpLCBzLnNldEZyb21NYXRyaXhQb3NpdGlvbih4LnRhcmdldC5tYXRyaXhXb3JsZCksIE0uZGlyZWN0aW9uLnN1YihzKSwgTS5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKHYpLCBnKys7XG4gICAgICB9IGVsc2UgaWYgKHguaXNSZWN0QXJlYUxpZ2h0KSB7XG4gICAgICAgIGNvbnN0IE0gPSBpLnJlY3RBcmVhW3BdO1xuICAgICAgICBNLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih4Lm1hdHJpeFdvcmxkKSwgTS5wb3NpdGlvbi5hcHBseU1hdHJpeDQodiksIHIuaWRlbnRpdHkoKSwgby5jb3B5KHgubWF0cml4V29ybGQpLCBvLnByZW11bHRpcGx5KHYpLCByLmV4dHJhY3RSb3RhdGlvbihvKSwgTS5oYWxmV2lkdGguc2V0KHgud2lkdGggKiAwLjUsIDAsIDApLCBNLmhhbGZIZWlnaHQuc2V0KDAsIHguaGVpZ2h0ICogMC41LCAwKSwgTS5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KHIpLCBNLmhhbGZIZWlnaHQuYXBwbHlNYXRyaXg0KHIpLCBwKys7XG4gICAgICB9IGVsc2UgaWYgKHguaXNQb2ludExpZ2h0KSB7XG4gICAgICAgIGNvbnN0IE0gPSBpLnBvaW50W21dO1xuICAgICAgICBNLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih4Lm1hdHJpeFdvcmxkKSwgTS5wb3NpdGlvbi5hcHBseU1hdHJpeDQodiksIG0rKztcbiAgICAgIH0gZWxzZSBpZiAoeC5pc0hlbWlzcGhlcmVMaWdodCkge1xuICAgICAgICBjb25zdCBNID0gaS5oZW1pW2ZdO1xuICAgICAgICBNLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oeC5tYXRyaXhXb3JsZCksIE0uZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2KSwgZisrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNldHVwOiBsLFxuICAgIHNldHVwVmlldzogYSxcbiAgICBzdGF0ZTogaVxuICB9O1xufVxuZnVuY3Rpb24gTHIoaCwgZSkge1xuICBjb25zdCB0ID0gbmV3IHh1KGgsIGUpLCBuID0gW10sIGkgPSBbXTtcbiAgZnVuY3Rpb24gcygpIHtcbiAgICBuLmxlbmd0aCA9IDAsIGkubGVuZ3RoID0gMDtcbiAgfVxuICBmdW5jdGlvbiBvKGQpIHtcbiAgICBuLnB1c2goZCk7XG4gIH1cbiAgZnVuY3Rpb24gcihkKSB7XG4gICAgaS5wdXNoKGQpO1xuICB9XG4gIGZ1bmN0aW9uIGwoZCkge1xuICAgIHQuc2V0dXAobiwgZCk7XG4gIH1cbiAgZnVuY3Rpb24gYShkKSB7XG4gICAgdC5zZXR1cFZpZXcobiwgZCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbml0OiBzLFxuICAgIHN0YXRlOiB7XG4gICAgICBsaWdodHNBcnJheTogbixcbiAgICAgIHNoYWRvd3NBcnJheTogaSxcbiAgICAgIGxpZ2h0czogdFxuICAgIH0sXG4gICAgc2V0dXBMaWdodHM6IGwsXG4gICAgc2V0dXBMaWdodHNWaWV3OiBhLFxuICAgIHB1c2hMaWdodDogbyxcbiAgICBwdXNoU2hhZG93OiByXG4gIH07XG59XG5mdW5jdGlvbiB5dShoLCBlKSB7XG4gIGxldCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIG4ocywgbyA9IDApIHtcbiAgICBsZXQgcjtcbiAgICByZXR1cm4gdC5oYXMocykgPT09ICExID8gKHIgPSBuZXcgTHIoaCwgZSksIHQuc2V0KHMsIFtyXSkpIDogbyA+PSB0LmdldChzKS5sZW5ndGggPyAociA9IG5ldyBMcihoLCBlKSwgdC5nZXQocykucHVzaChyKSkgOiByID0gdC5nZXQocylbb10sIHI7XG4gIH1cbiAgZnVuY3Rpb24gaSgpIHtcbiAgICB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IG4sXG4gICAgZGlzcG9zZTogaVxuICB9O1xufVxuY2xhc3MgYnUgZXh0ZW5kcyBBbiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSAhMCwgdGhpcy50eXBlID0gXCJNZXNoRGVwdGhNYXRlcmlhbFwiLCB0aGlzLmRlcHRoUGFja2luZyA9IDMyMDAsIHRoaXMubWFwID0gbnVsbCwgdGhpcy5hbHBoYU1hcCA9IG51bGwsIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbCwgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDEsIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDAsIHRoaXMud2lyZWZyYW1lID0gITEsIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMSwgdGhpcy5zZXRWYWx1ZXMoZSk7XG4gIH1cbiAgY29weShlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSksIHRoaXMuZGVwdGhQYWNraW5nID0gZS5kZXB0aFBhY2tpbmcsIHRoaXMubWFwID0gZS5tYXAsIHRoaXMuYWxwaGFNYXAgPSBlLmFscGhhTWFwLCB0aGlzLmRpc3BsYWNlbWVudE1hcCA9IGUuZGlzcGxhY2VtZW50TWFwLCB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gZS5kaXNwbGFjZW1lbnRTY2FsZSwgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gZS5kaXNwbGFjZW1lbnRCaWFzLCB0aGlzLndpcmVmcmFtZSA9IGUud2lyZWZyYW1lLCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGUud2lyZWZyYW1lTGluZXdpZHRoLCB0aGlzO1xuICB9XG59XG5jbGFzcyB3dSBleHRlbmRzIEFuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9ICEwLCB0aGlzLnR5cGUgPSBcIk1lc2hEaXN0YW5jZU1hdGVyaWFsXCIsIHRoaXMucmVmZXJlbmNlUG9zaXRpb24gPSBuZXcgTygpLCB0aGlzLm5lYXJEaXN0YW5jZSA9IDEsIHRoaXMuZmFyRGlzdGFuY2UgPSAxZTMsIHRoaXMubWFwID0gbnVsbCwgdGhpcy5hbHBoYU1hcCA9IG51bGwsIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbCwgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDEsIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDAsIHRoaXMuc2V0VmFsdWVzKGUpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KGUpLCB0aGlzLnJlZmVyZW5jZVBvc2l0aW9uLmNvcHkoZS5yZWZlcmVuY2VQb3NpdGlvbiksIHRoaXMubmVhckRpc3RhbmNlID0gZS5uZWFyRGlzdGFuY2UsIHRoaXMuZmFyRGlzdGFuY2UgPSBlLmZhckRpc3RhbmNlLCB0aGlzLm1hcCA9IGUubWFwLCB0aGlzLmFscGhhTWFwID0gZS5hbHBoYU1hcCwgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBlLmRpc3BsYWNlbWVudE1hcCwgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IGUuZGlzcGxhY2VtZW50U2NhbGUsIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IGUuZGlzcGxhY2VtZW50QmlhcywgdGhpcztcbiAgfVxufVxuY29uc3QgTXUgPSBgdm9pZCBtYWluKCkge1xuXHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbn1gLCBTdSA9IGB1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dfcGFzcztcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xudW5pZm9ybSBmbG9hdCByYWRpdXM7XG4jaW5jbHVkZSA8cGFja2luZz5cbnZvaWQgbWFpbigpIHtcblx0Y29uc3QgZmxvYXQgc2FtcGxlcyA9IGZsb2F0KCBWU01fU0FNUExFUyApO1xuXHRmbG9hdCBtZWFuID0gMC4wO1xuXHRmbG9hdCBzcXVhcmVkX21lYW4gPSAwLjA7XG5cdGZsb2F0IHV2U3RyaWRlID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAyLjAgLyAoIHNhbXBsZXMgLSAxLjAgKTtcblx0ZmxvYXQgdXZTdGFydCA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogLSAxLjA7XG5cdGZvciAoIGZsb2F0IGkgPSAwLjA7IGkgPCBzYW1wbGVzOyBpICsrICkge1xuXHRcdGZsb2F0IHV2T2Zmc2V0ID0gdXZTdGFydCArIGkgKiB1dlN0cmlkZTtcblx0XHQjaWZkZWYgSE9SSVpPTlRBTF9QQVNTXG5cdFx0XHR2ZWMyIGRpc3RyaWJ1dGlvbiA9IHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIHV2T2Zmc2V0LCAwLjAgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XG5cdFx0XHRtZWFuICs9IGRpc3RyaWJ1dGlvbi54O1xuXHRcdFx0c3F1YXJlZF9tZWFuICs9IGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKyBkaXN0cmlidXRpb24ueCAqIGRpc3RyaWJ1dGlvbi54O1xuXHRcdCNlbHNlXG5cdFx0XHRmbG9hdCBkZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIDAuMCwgdXZPZmZzZXQgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XG5cdFx0XHRtZWFuICs9IGRlcHRoO1xuXHRcdFx0c3F1YXJlZF9tZWFuICs9IGRlcHRoICogZGVwdGg7XG5cdFx0I2VuZGlmXG5cdH1cblx0bWVhbiA9IG1lYW4gLyBzYW1wbGVzO1xuXHRzcXVhcmVkX21lYW4gPSBzcXVhcmVkX21lYW4gLyBzYW1wbGVzO1xuXHRmbG9hdCBzdGRfZGV2ID0gc3FydCggc3F1YXJlZF9tZWFuIC0gbWVhbiAqIG1lYW4gKTtcblx0Z2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKCB2ZWMyKCBtZWFuLCBzdGRfZGV2ICkgKTtcbn1gO1xuZnVuY3Rpb24gRXUoaCwgZSwgdCkge1xuICBsZXQgbiA9IG5ldyBVcygpO1xuICBjb25zdCBpID0gbmV3IENlKCksIHMgPSBuZXcgQ2UoKSwgbyA9IG5ldyAkZSgpLCByID0gbmV3IGJ1KHsgZGVwdGhQYWNraW5nOiAzMjAxIH0pLCBsID0gbmV3IHd1KCksIGEgPSB7fSwgYyA9IHQubWF4VGV4dHVyZVNpemUsIGQgPSB7IDA6IDEsIDE6IDAsIDI6IDIgfSwgdSA9IG5ldyBUbih7XG4gICAgZGVmaW5lczoge1xuICAgICAgVlNNX1NBTVBMRVM6IDhcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICBzaGFkb3dfcGFzczogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgcmVzb2x1dGlvbjogeyB2YWx1ZTogbmV3IENlKCkgfSxcbiAgICAgIHJhZGl1czogeyB2YWx1ZTogNCB9XG4gICAgfSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IE11LFxuICAgIGZyYWdtZW50U2hhZGVyOiBTdVxuICB9KSwgbSA9IHUuY2xvbmUoKTtcbiAgbS5kZWZpbmVzLkhPUklaT05UQUxfUEFTUyA9IDE7XG4gIGNvbnN0IGcgPSBuZXcgVXQoKTtcbiAgZy5zZXRBdHRyaWJ1dGUoXG4gICAgXCJwb3NpdGlvblwiLFxuICAgIG5ldyBPdChcbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgMC41LCAzLCAtMSwgMC41LCAtMSwgMywgMC41XSksXG4gICAgICAzXG4gICAgKVxuICApO1xuICBjb25zdCBwID0gbmV3IE50KGcsIHUpLCBmID0gdGhpcztcbiAgdGhpcy5lbmFibGVkID0gITEsIHRoaXMuYXV0b1VwZGF0ZSA9ICEwLCB0aGlzLm5lZWRzVXBkYXRlID0gITEsIHRoaXMudHlwZSA9IDEsIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oeCwgTSwgRSkge1xuICAgIGlmIChmLmVuYWJsZWQgPT09ICExIHx8IGYuYXV0b1VwZGF0ZSA9PT0gITEgJiYgZi5uZWVkc1VwZGF0ZSA9PT0gITEgfHwgeC5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgUiA9IGguZ2V0UmVuZGVyVGFyZ2V0KCksIHkgPSBoLmdldEFjdGl2ZUN1YmVGYWNlKCksIEEgPSBoLmdldEFjdGl2ZU1pcG1hcExldmVsKCksIEYgPSBoLnN0YXRlO1xuICAgIEYuc2V0QmxlbmRpbmcoMCksIEYuYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLCAxLCAxLCAxKSwgRi5idWZmZXJzLmRlcHRoLnNldFRlc3QoITApLCBGLnNldFNjaXNzb3JUZXN0KCExKTtcbiAgICBmb3IgKGxldCBQID0gMCwgRyA9IHgubGVuZ3RoOyBQIDwgRzsgUCsrKSB7XG4gICAgICBjb25zdCB6ID0geFtQXSwgTCA9IHouc2hhZG93O1xuICAgICAgaWYgKEwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFNoYWRvd01hcDpcIiwgeiwgXCJoYXMgbm8gc2hhZG93LlwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoTC5hdXRvVXBkYXRlID09PSAhMSAmJiBMLm5lZWRzVXBkYXRlID09PSAhMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpLmNvcHkoTC5tYXBTaXplKTtcbiAgICAgIGNvbnN0IEkgPSBMLmdldEZyYW1lRXh0ZW50cygpO1xuICAgICAgaWYgKGkubXVsdGlwbHkoSSksIHMuY29weShMLm1hcFNpemUpLCAoaS54ID4gYyB8fCBpLnkgPiBjKSAmJiAoaS54ID4gYyAmJiAocy54ID0gTWF0aC5mbG9vcihjIC8gSS54KSwgaS54ID0gcy54ICogSS54LCBMLm1hcFNpemUueCA9IHMueCksIGkueSA+IGMgJiYgKHMueSA9IE1hdGguZmxvb3IoYyAvIEkueSksIGkueSA9IHMueSAqIEkueSwgTC5tYXBTaXplLnkgPSBzLnkpKSwgTC5tYXAgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcSA9IHRoaXMudHlwZSAhPT0gMyA/IHsgbWluRmlsdGVyOiAxMDAzLCBtYWdGaWx0ZXI6IDEwMDMgfSA6IHt9O1xuICAgICAgICBMLm1hcCA9IG5ldyBFbihpLngsIGkueSwgcSksIEwubWFwLnRleHR1cmUubmFtZSA9IHoubmFtZSArIFwiLnNoYWRvd01hcFwiLCBMLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICB9XG4gICAgICBoLnNldFJlbmRlclRhcmdldChMLm1hcCksIGguY2xlYXIoKTtcbiAgICAgIGNvbnN0IEQgPSBMLmdldFZpZXdwb3J0Q291bnQoKTtcbiAgICAgIGZvciAobGV0IHEgPSAwOyBxIDwgRDsgcSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBMLmdldFZpZXdwb3J0KHEpO1xuICAgICAgICBvLnNldChcbiAgICAgICAgICBzLnggKiBrLngsXG4gICAgICAgICAgcy55ICogay55LFxuICAgICAgICAgIHMueCAqIGsueixcbiAgICAgICAgICBzLnkgKiBrLndcbiAgICAgICAgKSwgRi52aWV3cG9ydChvKSwgTC51cGRhdGVNYXRyaWNlcyh6LCBxKSwgbiA9IEwuZ2V0RnJ1c3R1bSgpLCB3KE0sIEUsIEwuY2FtZXJhLCB6LCB0aGlzLnR5cGUpO1xuICAgICAgfVxuICAgICAgTC5pc1BvaW50TGlnaHRTaGFkb3cgIT09ICEwICYmIHRoaXMudHlwZSA9PT0gMyAmJiB2KEwsIEUpLCBMLm5lZWRzVXBkYXRlID0gITE7XG4gICAgfVxuICAgIGYubmVlZHNVcGRhdGUgPSAhMSwgaC5zZXRSZW5kZXJUYXJnZXQoUiwgeSwgQSk7XG4gIH07XG4gIGZ1bmN0aW9uIHYoeCwgTSkge1xuICAgIGNvbnN0IEUgPSBlLnVwZGF0ZShwKTtcbiAgICB1LmRlZmluZXMuVlNNX1NBTVBMRVMgIT09IHguYmx1clNhbXBsZXMgJiYgKHUuZGVmaW5lcy5WU01fU0FNUExFUyA9IHguYmx1clNhbXBsZXMsIG0uZGVmaW5lcy5WU01fU0FNUExFUyA9IHguYmx1clNhbXBsZXMsIHUubmVlZHNVcGRhdGUgPSAhMCwgbS5uZWVkc1VwZGF0ZSA9ICEwKSwgeC5tYXBQYXNzID09PSBudWxsICYmICh4Lm1hcFBhc3MgPSBuZXcgRW4oaS54LCBpLnkpKSwgdS51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHgubWFwLnRleHR1cmUsIHUudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZSA9IHgubWFwU2l6ZSwgdS51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSB4LnJhZGl1cywgaC5zZXRSZW5kZXJUYXJnZXQoeC5tYXBQYXNzKSwgaC5jbGVhcigpLCBoLnJlbmRlckJ1ZmZlckRpcmVjdChNLCBudWxsLCBFLCB1LCBwLCBudWxsKSwgbS51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHgubWFwUGFzcy50ZXh0dXJlLCBtLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSB4Lm1hcFNpemUsIG0udW5pZm9ybXMucmFkaXVzLnZhbHVlID0geC5yYWRpdXMsIGguc2V0UmVuZGVyVGFyZ2V0KHgubWFwKSwgaC5jbGVhcigpLCBoLnJlbmRlckJ1ZmZlckRpcmVjdChNLCBudWxsLCBFLCBtLCBwLCBudWxsKTtcbiAgfVxuICBmdW5jdGlvbiBfKHgsIE0sIEUsIFIsIHksIEEpIHtcbiAgICBsZXQgRiA9IG51bGw7XG4gICAgY29uc3QgUCA9IEUuaXNQb2ludExpZ2h0ID09PSAhMCA/IHguY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCA6IHguY3VzdG9tRGVwdGhNYXRlcmlhbDtcbiAgICBpZiAoUCAhPT0gdm9pZCAwID8gRiA9IFAgOiBGID0gRS5pc1BvaW50TGlnaHQgPT09ICEwID8gbCA6IHIsIGgubG9jYWxDbGlwcGluZ0VuYWJsZWQgJiYgTS5jbGlwU2hhZG93cyA9PT0gITAgJiYgQXJyYXkuaXNBcnJheShNLmNsaXBwaW5nUGxhbmVzKSAmJiBNLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAhPT0gMCB8fCBNLmRpc3BsYWNlbWVudE1hcCAmJiBNLmRpc3BsYWNlbWVudFNjYWxlICE9PSAwIHx8IE0uYWxwaGFNYXAgJiYgTS5hbHBoYVRlc3QgPiAwKSB7XG4gICAgICBjb25zdCBHID0gRi51dWlkLCB6ID0gTS51dWlkO1xuICAgICAgbGV0IEwgPSBhW0ddO1xuICAgICAgTCA9PT0gdm9pZCAwICYmIChMID0ge30sIGFbR10gPSBMKTtcbiAgICAgIGxldCBJID0gTFt6XTtcbiAgICAgIEkgPT09IHZvaWQgMCAmJiAoSSA9IEYuY2xvbmUoKSwgTFt6XSA9IEkpLCBGID0gSTtcbiAgICB9XG4gICAgcmV0dXJuIEYudmlzaWJsZSA9IE0udmlzaWJsZSwgRi53aXJlZnJhbWUgPSBNLndpcmVmcmFtZSwgQSA9PT0gMyA/IEYuc2lkZSA9IE0uc2hhZG93U2lkZSAhPT0gbnVsbCA/IE0uc2hhZG93U2lkZSA6IE0uc2lkZSA6IEYuc2lkZSA9IE0uc2hhZG93U2lkZSAhPT0gbnVsbCA/IE0uc2hhZG93U2lkZSA6IGRbTS5zaWRlXSwgRi5hbHBoYU1hcCA9IE0uYWxwaGFNYXAsIEYuYWxwaGFUZXN0ID0gTS5hbHBoYVRlc3QsIEYuY2xpcFNoYWRvd3MgPSBNLmNsaXBTaGFkb3dzLCBGLmNsaXBwaW5nUGxhbmVzID0gTS5jbGlwcGluZ1BsYW5lcywgRi5jbGlwSW50ZXJzZWN0aW9uID0gTS5jbGlwSW50ZXJzZWN0aW9uLCBGLmRpc3BsYWNlbWVudE1hcCA9IE0uZGlzcGxhY2VtZW50TWFwLCBGLmRpc3BsYWNlbWVudFNjYWxlID0gTS5kaXNwbGFjZW1lbnRTY2FsZSwgRi5kaXNwbGFjZW1lbnRCaWFzID0gTS5kaXNwbGFjZW1lbnRCaWFzLCBGLndpcmVmcmFtZUxpbmV3aWR0aCA9IE0ud2lyZWZyYW1lTGluZXdpZHRoLCBGLmxpbmV3aWR0aCA9IE0ubGluZXdpZHRoLCBFLmlzUG9pbnRMaWdodCA9PT0gITAgJiYgRi5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID09PSAhMCAmJiAoRi5yZWZlcmVuY2VQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oRS5tYXRyaXhXb3JsZCksIEYubmVhckRpc3RhbmNlID0gUiwgRi5mYXJEaXN0YW5jZSA9IHkpLCBGO1xuICB9XG4gIGZ1bmN0aW9uIHcoeCwgTSwgRSwgUiwgeSkge1xuICAgIGlmICh4LnZpc2libGUgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh4LmxheWVycy50ZXN0KE0ubGF5ZXJzKSAmJiAoeC5pc01lc2ggfHwgeC5pc0xpbmUgfHwgeC5pc1BvaW50cykgJiYgKHguY2FzdFNoYWRvdyB8fCB4LnJlY2VpdmVTaGFkb3cgJiYgeSA9PT0gMykgJiYgKCF4LmZydXN0dW1DdWxsZWQgfHwgbi5pbnRlcnNlY3RzT2JqZWN0KHgpKSkge1xuICAgICAgeC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhFLm1hdHJpeFdvcmxkSW52ZXJzZSwgeC5tYXRyaXhXb3JsZCk7XG4gICAgICBjb25zdCBQID0gZS51cGRhdGUoeCksIEcgPSB4Lm1hdGVyaWFsO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoRykpIHtcbiAgICAgICAgY29uc3QgeiA9IFAuZ3JvdXBzO1xuICAgICAgICBmb3IgKGxldCBMID0gMCwgSSA9IHoubGVuZ3RoOyBMIDwgSTsgTCsrKSB7XG4gICAgICAgICAgY29uc3QgRCA9IHpbTF0sIHEgPSBHW0QubWF0ZXJpYWxJbmRleF07XG4gICAgICAgICAgaWYgKHEgJiYgcS52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gXyh4LCBxLCBSLCBFLm5lYXIsIEUuZmFyLCB5KTtcbiAgICAgICAgICAgIGgucmVuZGVyQnVmZmVyRGlyZWN0KEUsIG51bGwsIFAsIGssIHgsIEQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChHLnZpc2libGUpIHtcbiAgICAgICAgY29uc3QgeiA9IF8oeCwgRywgUiwgRS5uZWFyLCBFLmZhciwgeSk7XG4gICAgICAgIGgucmVuZGVyQnVmZmVyRGlyZWN0KEUsIG51bGwsIFAsIHosIHgsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBGID0geC5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBQID0gMCwgRyA9IEYubGVuZ3RoOyBQIDwgRzsgUCsrKVxuICAgICAgdyhGW1BdLCBNLCBFLCBSLCB5KTtcbiAgfVxufVxuZnVuY3Rpb24gVHUoaCwgZSwgdCkge1xuICBjb25zdCBuID0gdC5pc1dlYkdMMjtcbiAgZnVuY3Rpb24gaSgpIHtcbiAgICBsZXQgQiA9ICExO1xuICAgIGNvbnN0IGFlID0gbmV3ICRlKCk7XG4gICAgbGV0IFkgPSBudWxsO1xuICAgIGNvbnN0IG9lID0gbmV3ICRlKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiB7XG4gICAgICBzZXRNYXNrOiBmdW5jdGlvbihzZSkge1xuICAgICAgICBZICE9PSBzZSAmJiAhQiAmJiAoaC5jb2xvck1hc2soc2UsIHNlLCBzZSwgc2UpLCBZID0gc2UpO1xuICAgICAgfSxcbiAgICAgIHNldExvY2tlZDogZnVuY3Rpb24oc2UpIHtcbiAgICAgICAgQiA9IHNlO1xuICAgICAgfSxcbiAgICAgIHNldENsZWFyOiBmdW5jdGlvbihzZSwgUmUsIEplLCBWZSwgZW4pIHtcbiAgICAgICAgZW4gPT09ICEwICYmIChzZSAqPSBWZSwgUmUgKj0gVmUsIEplICo9IFZlKSwgYWUuc2V0KHNlLCBSZSwgSmUsIFZlKSwgb2UuZXF1YWxzKGFlKSA9PT0gITEgJiYgKGguY2xlYXJDb2xvcihzZSwgUmUsIEplLCBWZSksIG9lLmNvcHkoYWUpKTtcbiAgICAgIH0sXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIEIgPSAhMSwgWSA9IG51bGwsIG9lLnNldCgtMSwgMCwgMCwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzKCkge1xuICAgIGxldCBCID0gITEsIGFlID0gbnVsbCwgWSA9IG51bGwsIG9lID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0VGVzdDogZnVuY3Rpb24oc2UpIHtcbiAgICAgICAgc2UgPyBEZSgyOTI5KSA6IHZlKDI5MjkpO1xuICAgICAgfSxcbiAgICAgIHNldE1hc2s6IGZ1bmN0aW9uKHNlKSB7XG4gICAgICAgIGFlICE9PSBzZSAmJiAhQiAmJiAoaC5kZXB0aE1hc2soc2UpLCBhZSA9IHNlKTtcbiAgICAgIH0sXG4gICAgICBzZXRGdW5jOiBmdW5jdGlvbihzZSkge1xuICAgICAgICBpZiAoWSAhPT0gc2UpIHtcbiAgICAgICAgICBpZiAoc2UpXG4gICAgICAgICAgICBzd2l0Y2ggKHNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBoLmRlcHRoRnVuYyg1MTIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaC5kZXB0aEZ1bmMoNTE5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGguZGVwdGhGdW5jKDUxMyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBoLmRlcHRoRnVuYyg1MTUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaC5kZXB0aEZ1bmMoNTE0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGguZGVwdGhGdW5jKDUxOCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBoLmRlcHRoRnVuYyg1MTYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgaC5kZXB0aEZ1bmMoNTE3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBoLmRlcHRoRnVuYyg1MTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGguZGVwdGhGdW5jKDUxNSk7XG4gICAgICAgICAgWSA9IHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0TG9ja2VkOiBmdW5jdGlvbihzZSkge1xuICAgICAgICBCID0gc2U7XG4gICAgICB9LFxuICAgICAgc2V0Q2xlYXI6IGZ1bmN0aW9uKHNlKSB7XG4gICAgICAgIG9lICE9PSBzZSAmJiAoaC5jbGVhckRlcHRoKHNlKSwgb2UgPSBzZSk7XG4gICAgICB9LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBCID0gITEsIGFlID0gbnVsbCwgWSA9IG51bGwsIG9lID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgbGV0IEIgPSAhMSwgYWUgPSBudWxsLCBZID0gbnVsbCwgb2UgPSBudWxsLCBzZSA9IG51bGwsIFJlID0gbnVsbCwgSmUgPSBudWxsLCBWZSA9IG51bGwsIGVuID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0VGVzdDogZnVuY3Rpb24oR2UpIHtcbiAgICAgICAgQiB8fCAoR2UgPyBEZSgyOTYwKSA6IHZlKDI5NjApKTtcbiAgICAgIH0sXG4gICAgICBzZXRNYXNrOiBmdW5jdGlvbihHZSkge1xuICAgICAgICBhZSAhPT0gR2UgJiYgIUIgJiYgKGguc3RlbmNpbE1hc2soR2UpLCBhZSA9IEdlKTtcbiAgICAgIH0sXG4gICAgICBzZXRGdW5jOiBmdW5jdGlvbihHZSwga3QsIHh0KSB7XG4gICAgICAgIChZICE9PSBHZSB8fCBvZSAhPT0ga3QgfHwgc2UgIT09IHh0KSAmJiAoaC5zdGVuY2lsRnVuYyhHZSwga3QsIHh0KSwgWSA9IEdlLCBvZSA9IGt0LCBzZSA9IHh0KTtcbiAgICAgIH0sXG4gICAgICBzZXRPcDogZnVuY3Rpb24oR2UsIGt0LCB4dCkge1xuICAgICAgICAoUmUgIT09IEdlIHx8IEplICE9PSBrdCB8fCBWZSAhPT0geHQpICYmIChoLnN0ZW5jaWxPcChHZSwga3QsIHh0KSwgUmUgPSBHZSwgSmUgPSBrdCwgVmUgPSB4dCk7XG4gICAgICB9LFxuICAgICAgc2V0TG9ja2VkOiBmdW5jdGlvbihHZSkge1xuICAgICAgICBCID0gR2U7XG4gICAgICB9LFxuICAgICAgc2V0Q2xlYXI6IGZ1bmN0aW9uKEdlKSB7XG4gICAgICAgIGVuICE9PSBHZSAmJiAoaC5jbGVhclN0ZW5jaWwoR2UpLCBlbiA9IEdlKTtcbiAgICAgIH0sXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIEIgPSAhMSwgYWUgPSBudWxsLCBZID0gbnVsbCwgb2UgPSBudWxsLCBzZSA9IG51bGwsIFJlID0gbnVsbCwgSmUgPSBudWxsLCBWZSA9IG51bGwsIGVuID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbnN0IHIgPSBuZXcgaSgpLCBsID0gbmV3IHMoKSwgYSA9IG5ldyBvKCksIGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBsZXQgdSA9IHt9LCBtID0ge30sIGcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgcCA9IFtdLCBmID0gbnVsbCwgdiA9ICExLCBfID0gbnVsbCwgdyA9IG51bGwsIHggPSBudWxsLCBNID0gbnVsbCwgRSA9IG51bGwsIFIgPSBudWxsLCB5ID0gbnVsbCwgQSA9ICExLCBGID0gbnVsbCwgUCA9IG51bGwsIEcgPSBudWxsLCB6ID0gbnVsbCwgTCA9IG51bGw7XG4gIGNvbnN0IEkgPSBoLmdldFBhcmFtZXRlcigzNTY2MSk7XG4gIGxldCBEID0gITEsIHEgPSAwO1xuICBjb25zdCBrID0gaC5nZXRQYXJhbWV0ZXIoNzkzOCk7XG4gIGsuaW5kZXhPZihcIldlYkdMXCIpICE9PSAtMSA/IChxID0gcGFyc2VGbG9hdCgvXldlYkdMIChcXGQpLy5leGVjKGspWzFdKSwgRCA9IHEgPj0gMSkgOiBrLmluZGV4T2YoXCJPcGVuR0wgRVNcIikgIT09IC0xICYmIChxID0gcGFyc2VGbG9hdCgvXk9wZW5HTCBFUyAoXFxkKS8uZXhlYyhrKVsxXSksIEQgPSBxID49IDIpO1xuICBsZXQgTiA9IG51bGwsIEggPSB7fTtcbiAgY29uc3QgSiA9IGguZ2V0UGFyYW1ldGVyKDMwODgpLCBWID0gaC5nZXRQYXJhbWV0ZXIoMjk3OCksIGVlID0gbmV3ICRlKCkuZnJvbUFycmF5KEopLCBjZSA9IG5ldyAkZSgpLmZyb21BcnJheShWKTtcbiAgZnVuY3Rpb24gZ2UoQiwgYWUsIFkpIHtcbiAgICBjb25zdCBvZSA9IG5ldyBVaW50OEFycmF5KDQpLCBzZSA9IGguY3JlYXRlVGV4dHVyZSgpO1xuICAgIGguYmluZFRleHR1cmUoQiwgc2UpLCBoLnRleFBhcmFtZXRlcmkoQiwgMTAyNDEsIDk3MjgpLCBoLnRleFBhcmFtZXRlcmkoQiwgMTAyNDAsIDk3MjgpO1xuICAgIGZvciAobGV0IFJlID0gMDsgUmUgPCBZOyBSZSsrKVxuICAgICAgaC50ZXhJbWFnZTJEKGFlICsgUmUsIDAsIDY0MDgsIDEsIDEsIDAsIDY0MDgsIDUxMjEsIG9lKTtcbiAgICByZXR1cm4gc2U7XG4gIH1cbiAgY29uc3QgJCA9IHt9O1xuICAkWzM1NTNdID0gZ2UoMzU1MywgMzU1MywgMSksICRbMzQwNjddID0gZ2UoMzQwNjcsIDM0MDY5LCA2KSwgci5zZXRDbGVhcigwLCAwLCAwLCAxKSwgbC5zZXRDbGVhcigxKSwgYS5zZXRDbGVhcigwKSwgRGUoMjkyOSksIGwuc2V0RnVuYygzKSwgcnQoITEpLCBSdCgxKSwgRGUoMjg4NCksIGV0KDApO1xuICBmdW5jdGlvbiBEZShCKSB7XG4gICAgdVtCXSAhPT0gITAgJiYgKGguZW5hYmxlKEIpLCB1W0JdID0gITApO1xuICB9XG4gIGZ1bmN0aW9uIHZlKEIpIHtcbiAgICB1W0JdICE9PSAhMSAmJiAoaC5kaXNhYmxlKEIpLCB1W0JdID0gITEpO1xuICB9XG4gIGZ1bmN0aW9uIHhlKEIsIGFlKSB7XG4gICAgcmV0dXJuIG1bQl0gIT09IGFlID8gKGguYmluZEZyYW1lYnVmZmVyKEIsIGFlKSwgbVtCXSA9IGFlLCBuICYmIChCID09PSAzNjAwOSAmJiAobVszNjE2MF0gPSBhZSksIEIgPT09IDM2MTYwICYmIChtWzM2MDA5XSA9IGFlKSksICEwKSA6ICExO1xuICB9XG4gIGZ1bmN0aW9uIHVlKEIsIGFlKSB7XG4gICAgbGV0IFkgPSBwLCBvZSA9ICExO1xuICAgIGlmIChCKVxuICAgICAgaWYgKFkgPSBnLmdldChhZSksIFkgPT09IHZvaWQgMCAmJiAoWSA9IFtdLCBnLnNldChhZSwgWSkpLCBCLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcbiAgICAgICAgY29uc3Qgc2UgPSBCLnRleHR1cmU7XG4gICAgICAgIGlmIChZLmxlbmd0aCAhPT0gc2UubGVuZ3RoIHx8IFlbMF0gIT09IDM2MDY0KSB7XG4gICAgICAgICAgZm9yIChsZXQgUmUgPSAwLCBKZSA9IHNlLmxlbmd0aDsgUmUgPCBKZTsgUmUrKylcbiAgICAgICAgICAgIFlbUmVdID0gMzYwNjQgKyBSZTtcbiAgICAgICAgICBZLmxlbmd0aCA9IHNlLmxlbmd0aCwgb2UgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIFlbMF0gIT09IDM2MDY0ICYmIChZWzBdID0gMzYwNjQsIG9lID0gITApO1xuICAgIGVsc2VcbiAgICAgIFlbMF0gIT09IDEwMjkgJiYgKFlbMF0gPSAxMDI5LCBvZSA9ICEwKTtcbiAgICBvZSAmJiAodC5pc1dlYkdMMiA/IGguZHJhd0J1ZmZlcnMoWSkgOiBlLmdldChcIldFQkdMX2RyYXdfYnVmZmVyc1wiKS5kcmF3QnVmZmVyc1dFQkdMKFkpKTtcbiAgfVxuICBmdW5jdGlvbiBPZShCKSB7XG4gICAgcmV0dXJuIGYgIT09IEIgPyAoaC51c2VQcm9ncmFtKEIpLCBmID0gQiwgITApIDogITE7XG4gIH1cbiAgY29uc3QgRWUgPSB7XG4gICAgWzEwMF06IDMyNzc0LFxuICAgIFsxMDFdOiAzMjc3OCxcbiAgICBbMTAyXTogMzI3NzlcbiAgfTtcbiAgaWYgKG4pXG4gICAgRWVbMTAzXSA9IDMyNzc1LCBFZVsxMDRdID0gMzI3NzY7XG4gIGVsc2Uge1xuICAgIGNvbnN0IEIgPSBlLmdldChcIkVYVF9ibGVuZF9taW5tYXhcIik7XG4gICAgQiAhPT0gbnVsbCAmJiAoRWVbMTAzXSA9IEIuTUlOX0VYVCwgRWVbMTA0XSA9IEIuTUFYX0VYVCk7XG4gIH1cbiAgY29uc3QgbWUgPSB7XG4gICAgWzIwMF06IDAsXG4gICAgWzIwMV06IDEsXG4gICAgWzIwMl06IDc2OCxcbiAgICBbMjA0XTogNzcwLFxuICAgIFsyMTBdOiA3NzYsXG4gICAgWzIwOF06IDc3NCxcbiAgICBbMjA2XTogNzcyLFxuICAgIFsyMDNdOiA3NjksXG4gICAgWzIwNV06IDc3MSxcbiAgICBbMjA5XTogNzc1LFxuICAgIFsyMDddOiA3NzNcbiAgfTtcbiAgZnVuY3Rpb24gZXQoQiwgYWUsIFksIG9lLCBzZSwgUmUsIEplLCBWZSkge1xuICAgIGlmIChCID09PSAwKSB7XG4gICAgICB2ID09PSAhMCAmJiAodmUoMzA0MiksIHYgPSAhMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2ID09PSAhMSAmJiAoRGUoMzA0MiksIHYgPSAhMCksIEIgIT09IDUpIHtcbiAgICAgIGlmIChCICE9PSBfIHx8IFZlICE9PSBBKSB7XG4gICAgICAgIGlmICgodyAhPT0gMTAwIHx8IEUgIT09IDEwMCkgJiYgKGguYmxlbmRFcXVhdGlvbigzMjc3NCksIHcgPSAxMDAsIEUgPSAxMDApLCBWZSlcbiAgICAgICAgICBzd2l0Y2ggKEIpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgaC5ibGVuZEZ1bmNTZXBhcmF0ZSgxLCA3NzEsIDEsIDc3MSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBoLmJsZW5kRnVuYygxLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGguYmxlbmRGdW5jU2VwYXJhdGUoMCwgNzY5LCAwLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGguYmxlbmRGdW5jU2VwYXJhdGUoMCwgNzY4LCAwLCA3NzApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiBcIiwgQik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN3aXRjaCAoQikge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBoLmJsZW5kRnVuY1NlcGFyYXRlKDc3MCwgNzcxLCAxLCA3NzEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgaC5ibGVuZEZ1bmMoNzcwLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGguYmxlbmRGdW5jU2VwYXJhdGUoMCwgNzY5LCAwLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGguYmxlbmRGdW5jKDAsIDc2OCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6IFwiLCBCKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB4ID0gbnVsbCwgTSA9IG51bGwsIFIgPSBudWxsLCB5ID0gbnVsbCwgXyA9IEIsIEEgPSBWZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2UgPSBzZSB8fCBhZSwgUmUgPSBSZSB8fCBZLCBKZSA9IEplIHx8IG9lLCAoYWUgIT09IHcgfHwgc2UgIT09IEUpICYmIChoLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShFZVthZV0sIEVlW3NlXSksIHcgPSBhZSwgRSA9IHNlKSwgKFkgIT09IHggfHwgb2UgIT09IE0gfHwgUmUgIT09IFIgfHwgSmUgIT09IHkpICYmIChoLmJsZW5kRnVuY1NlcGFyYXRlKG1lW1ldLCBtZVtvZV0sIG1lW1JlXSwgbWVbSmVdKSwgeCA9IFksIE0gPSBvZSwgUiA9IFJlLCB5ID0gSmUpLCBfID0gQiwgQSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdXQoQiwgYWUpIHtcbiAgICBCLnNpZGUgPT09IDIgPyB2ZSgyODg0KSA6IERlKDI4ODQpO1xuICAgIGxldCBZID0gQi5zaWRlID09PSAxO1xuICAgIGFlICYmIChZID0gIVkpLCBydChZKSwgQi5ibGVuZGluZyA9PT0gMSAmJiBCLnRyYW5zcGFyZW50ID09PSAhMSA/IGV0KDApIDogZXQoQi5ibGVuZGluZywgQi5ibGVuZEVxdWF0aW9uLCBCLmJsZW5kU3JjLCBCLmJsZW5kRHN0LCBCLmJsZW5kRXF1YXRpb25BbHBoYSwgQi5ibGVuZFNyY0FscGhhLCBCLmJsZW5kRHN0QWxwaGEsIEIucHJlbXVsdGlwbGllZEFscGhhKSwgbC5zZXRGdW5jKEIuZGVwdGhGdW5jKSwgbC5zZXRUZXN0KEIuZGVwdGhUZXN0KSwgbC5zZXRNYXNrKEIuZGVwdGhXcml0ZSksIHIuc2V0TWFzayhCLmNvbG9yV3JpdGUpO1xuICAgIGNvbnN0IG9lID0gQi5zdGVuY2lsV3JpdGU7XG4gICAgYS5zZXRUZXN0KG9lKSwgb2UgJiYgKGEuc2V0TWFzayhCLnN0ZW5jaWxXcml0ZU1hc2spLCBhLnNldEZ1bmMoQi5zdGVuY2lsRnVuYywgQi5zdGVuY2lsUmVmLCBCLnN0ZW5jaWxGdW5jTWFzayksIGEuc2V0T3AoQi5zdGVuY2lsRmFpbCwgQi5zdGVuY2lsWkZhaWwsIEIuc3RlbmNpbFpQYXNzKSksIE5lKEIucG9seWdvbk9mZnNldCwgQi5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBCLnBvbHlnb25PZmZzZXRVbml0cyksIEIuYWxwaGFUb0NvdmVyYWdlID09PSAhMCA/IERlKDMyOTI2KSA6IHZlKDMyOTI2KTtcbiAgfVxuICBmdW5jdGlvbiBydChCKSB7XG4gICAgRiAhPT0gQiAmJiAoQiA/IGguZnJvbnRGYWNlKDIzMDQpIDogaC5mcm9udEZhY2UoMjMwNSksIEYgPSBCKTtcbiAgfVxuICBmdW5jdGlvbiBSdChCKSB7XG4gICAgQiAhPT0gMCA/IChEZSgyODg0KSwgQiAhPT0gUCAmJiAoQiA9PT0gMSA/IGguY3VsbEZhY2UoMTAyOSkgOiBCID09PSAyID8gaC5jdWxsRmFjZSgxMDI4KSA6IGguY3VsbEZhY2UoMTAzMikpKSA6IHZlKDI4ODQpLCBQID0gQjtcbiAgfVxuICBmdW5jdGlvbiB0dChCKSB7XG4gICAgQiAhPT0gRyAmJiAoRCAmJiBoLmxpbmVXaWR0aChCKSwgRyA9IEIpO1xuICB9XG4gIGZ1bmN0aW9uIE5lKEIsIGFlLCBZKSB7XG4gICAgQiA/IChEZSgzMjgyMyksICh6ICE9PSBhZSB8fCBMICE9PSBZKSAmJiAoaC5wb2x5Z29uT2Zmc2V0KGFlLCBZKSwgeiA9IGFlLCBMID0gWSkpIDogdmUoMzI4MjMpO1xuICB9XG4gIGZ1bmN0aW9uIEd0KEIpIHtcbiAgICBCID8gRGUoMzA4OSkgOiB2ZSgzMDg5KTtcbiAgfVxuICBmdW5jdGlvbiBGdChCKSB7XG4gICAgQiA9PT0gdm9pZCAwICYmIChCID0gMzM5ODQgKyBJIC0gMSksIE4gIT09IEIgJiYgKGguYWN0aXZlVGV4dHVyZShCKSwgTiA9IEIpO1xuICB9XG4gIGZ1bmN0aW9uIEMoQiwgYWUpIHtcbiAgICBOID09PSBudWxsICYmIEZ0KCk7XG4gICAgbGV0IFkgPSBIW05dO1xuICAgIFkgPT09IHZvaWQgMCAmJiAoWSA9IHsgdHlwZTogdm9pZCAwLCB0ZXh0dXJlOiB2b2lkIDAgfSwgSFtOXSA9IFkpLCAoWS50eXBlICE9PSBCIHx8IFkudGV4dHVyZSAhPT0gYWUpICYmIChoLmJpbmRUZXh0dXJlKEIsIGFlIHx8ICRbQl0pLCBZLnR5cGUgPSBCLCBZLnRleHR1cmUgPSBhZSk7XG4gIH1cbiAgZnVuY3Rpb24gUygpIHtcbiAgICBjb25zdCBCID0gSFtOXTtcbiAgICBCICE9PSB2b2lkIDAgJiYgQi50eXBlICE9PSB2b2lkIDAgJiYgKGguYmluZFRleHR1cmUoQi50eXBlLCBudWxsKSwgQi50eXBlID0gdm9pZCAwLCBCLnRleHR1cmUgPSB2b2lkIDApO1xuICB9XG4gIGZ1bmN0aW9uIFooKSB7XG4gICAgdHJ5IHtcbiAgICAgIGguY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoaCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChCKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIiwgQik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFEoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGgudGV4U3ViSW1hZ2UyRC5hcHBseShoLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKEIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFN0YXRlOlwiLCBCKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGgudGV4U3ViSW1hZ2UzRC5hcHBseShoLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKEIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFN0YXRlOlwiLCBCKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGguY29tcHJlc3NlZFRleFN1YkltYWdlMkQuYXBwbHkoaCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChCKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIiwgQik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHllKCkge1xuICAgIHRyeSB7XG4gICAgICBoLnRleFN0b3JhZ2UyRC5hcHBseShoLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKEIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFN0YXRlOlwiLCBCKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaigpIHtcbiAgICB0cnkge1xuICAgICAgaC50ZXhTdG9yYWdlM0QuYXBwbHkoaCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChCKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIiwgQik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBlKCkge1xuICAgIHRyeSB7XG4gICAgICBoLnRleEltYWdlMkQuYXBwbHkoaCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChCKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIiwgQik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhlKCkge1xuICAgIHRyeSB7XG4gICAgICBoLnRleEltYWdlM0QuYXBwbHkoaCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChCKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIiwgQik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZlKEIpIHtcbiAgICBlZS5lcXVhbHMoQikgPT09ICExICYmIChoLnNjaXNzb3IoQi54LCBCLnksIEIueiwgQi53KSwgZWUuY29weShCKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGUoQikge1xuICAgIGNlLmVxdWFscyhCKSA9PT0gITEgJiYgKGgudmlld3BvcnQoQi54LCBCLnksIEIueiwgQi53KSwgY2UuY29weShCKSk7XG4gIH1cbiAgZnVuY3Rpb24gd2UoQiwgYWUpIHtcbiAgICBsZXQgWSA9IGQuZ2V0KGFlKTtcbiAgICBZID09PSB2b2lkIDAgJiYgKFkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgZC5zZXQoYWUsIFkpKTtcbiAgICBsZXQgb2UgPSBZLmdldChCKTtcbiAgICBvZSA9PT0gdm9pZCAwICYmIChvZSA9IGguZ2V0VW5pZm9ybUJsb2NrSW5kZXgoYWUsIEIubmFtZSksIFkuc2V0KEIsIG9lKSk7XG4gIH1cbiAgZnVuY3Rpb24gSWUoQiwgYWUpIHtcbiAgICBjb25zdCBvZSA9IGQuZ2V0KGFlKS5nZXQoQik7XG4gICAgYy5nZXQoQikgIT09IG9lICYmIChoLnVuaWZvcm1CbG9ja0JpbmRpbmcoYWUsIG9lLCBCLl9fYmluZGluZ1BvaW50SW5kZXgpLCBjLnNldChCLCBvZSkpO1xuICB9XG4gIGZ1bmN0aW9uIFdlKCkge1xuICAgIGguZGlzYWJsZSgzMDQyKSwgaC5kaXNhYmxlKDI4ODQpLCBoLmRpc2FibGUoMjkyOSksIGguZGlzYWJsZSgzMjgyMyksIGguZGlzYWJsZSgzMDg5KSwgaC5kaXNhYmxlKDI5NjApLCBoLmRpc2FibGUoMzI5MjYpLCBoLmJsZW5kRXF1YXRpb24oMzI3NzQpLCBoLmJsZW5kRnVuYygxLCAwKSwgaC5ibGVuZEZ1bmNTZXBhcmF0ZSgxLCAwLCAxLCAwKSwgaC5jb2xvck1hc2soITAsICEwLCAhMCwgITApLCBoLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCksIGguZGVwdGhNYXNrKCEwKSwgaC5kZXB0aEZ1bmMoNTEzKSwgaC5jbGVhckRlcHRoKDEpLCBoLnN0ZW5jaWxNYXNrKDQyOTQ5NjcyOTUpLCBoLnN0ZW5jaWxGdW5jKDUxOSwgMCwgNDI5NDk2NzI5NSksIGguc3RlbmNpbE9wKDc2ODAsIDc2ODAsIDc2ODApLCBoLmNsZWFyU3RlbmNpbCgwKSwgaC5jdWxsRmFjZSgxMDI5KSwgaC5mcm9udEZhY2UoMjMwNSksIGgucG9seWdvbk9mZnNldCgwLCAwKSwgaC5hY3RpdmVUZXh0dXJlKDMzOTg0KSwgaC5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIG51bGwpLCBuID09PSAhMCAmJiAoaC5iaW5kRnJhbWVidWZmZXIoMzYwMDksIG51bGwpLCBoLmJpbmRGcmFtZWJ1ZmZlcigzNjAwOCwgbnVsbCkpLCBoLnVzZVByb2dyYW0obnVsbCksIGgubGluZVdpZHRoKDEpLCBoLnNjaXNzb3IoMCwgMCwgaC5jYW52YXMud2lkdGgsIGguY2FudmFzLmhlaWdodCksIGgudmlld3BvcnQoMCwgMCwgaC5jYW52YXMud2lkdGgsIGguY2FudmFzLmhlaWdodCksIHUgPSB7fSwgTiA9IG51bGwsIEggPSB7fSwgbSA9IHt9LCBnID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHAgPSBbXSwgZiA9IG51bGwsIHYgPSAhMSwgXyA9IG51bGwsIHcgPSBudWxsLCB4ID0gbnVsbCwgTSA9IG51bGwsIEUgPSBudWxsLCBSID0gbnVsbCwgeSA9IG51bGwsIEEgPSAhMSwgRiA9IG51bGwsIFAgPSBudWxsLCBHID0gbnVsbCwgeiA9IG51bGwsIEwgPSBudWxsLCBlZS5zZXQoMCwgMCwgaC5jYW52YXMud2lkdGgsIGguY2FudmFzLmhlaWdodCksIGNlLnNldCgwLCAwLCBoLmNhbnZhcy53aWR0aCwgaC5jYW52YXMuaGVpZ2h0KSwgci5yZXNldCgpLCBsLnJlc2V0KCksIGEucmVzZXQoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJ1ZmZlcnM6IHtcbiAgICAgIGNvbG9yOiByLFxuICAgICAgZGVwdGg6IGwsXG4gICAgICBzdGVuY2lsOiBhXG4gICAgfSxcbiAgICBlbmFibGU6IERlLFxuICAgIGRpc2FibGU6IHZlLFxuICAgIGJpbmRGcmFtZWJ1ZmZlcjogeGUsXG4gICAgZHJhd0J1ZmZlcnM6IHVlLFxuICAgIHVzZVByb2dyYW06IE9lLFxuICAgIHNldEJsZW5kaW5nOiBldCxcbiAgICBzZXRNYXRlcmlhbDogdXQsXG4gICAgc2V0RmxpcFNpZGVkOiBydCxcbiAgICBzZXRDdWxsRmFjZTogUnQsXG4gICAgc2V0TGluZVdpZHRoOiB0dCxcbiAgICBzZXRQb2x5Z29uT2Zmc2V0OiBOZSxcbiAgICBzZXRTY2lzc29yVGVzdDogR3QsXG4gICAgYWN0aXZlVGV4dHVyZTogRnQsXG4gICAgYmluZFRleHR1cmU6IEMsXG4gICAgdW5iaW5kVGV4dHVyZTogUyxcbiAgICBjb21wcmVzc2VkVGV4SW1hZ2UyRDogWixcbiAgICB0ZXhJbWFnZTJEOiBwZSxcbiAgICB0ZXhJbWFnZTNEOiBoZSxcbiAgICB1cGRhdGVVQk9NYXBwaW5nOiB3ZSxcbiAgICB1bmlmb3JtQmxvY2tCaW5kaW5nOiBJZSxcbiAgICB0ZXhTdG9yYWdlMkQ6IHllLFxuICAgIHRleFN0b3JhZ2UzRDogaixcbiAgICB0ZXhTdWJJbWFnZTJEOiBRLFxuICAgIHRleFN1YkltYWdlM0Q6IHRlLFxuICAgIGNvbXByZXNzZWRUZXhTdWJJbWFnZTJEOiByZSxcbiAgICBzY2lzc29yOiBmZSxcbiAgICB2aWV3cG9ydDogZGUsXG4gICAgcmVzZXQ6IFdlXG4gIH07XG59XG5mdW5jdGlvbiBBdShoLCBlLCB0LCBuLCBpLCBzLCBvKSB7XG4gIGNvbnN0IHIgPSBpLmlzV2ViR0wyLCBsID0gaS5tYXhUZXh0dXJlcywgYSA9IGkubWF4Q3ViZW1hcFNpemUsIGMgPSBpLm1heFRleHR1cmVTaXplLCBkID0gaS5tYXhTYW1wbGVzLCB1ID0gZS5oYXMoXCJXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmVcIikgPyBlLmdldChcIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZVwiKSA6IG51bGwsIG0gPSAvT2N1bHVzQnJvd3Nlci9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksIGcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgbGV0IHA7XG4gIGNvbnN0IGYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgbGV0IHYgPSAhMTtcbiAgdHJ5IHtcbiAgICB2ID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA8IFwidVwiICYmIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkuZ2V0Q29udGV4dChcIjJkXCIpICE9PSBudWxsO1xuICB9IGNhdGNoIHtcbiAgfVxuICBmdW5jdGlvbiBfKEMsIFMpIHtcbiAgICByZXR1cm4gdiA/IG5ldyBPZmZzY3JlZW5DYW52YXMoQywgUykgOiBxaShcImNhbnZhc1wiKTtcbiAgfVxuICBmdW5jdGlvbiB3KEMsIFMsIFosIFEpIHtcbiAgICBsZXQgdGUgPSAxO1xuICAgIGlmICgoQy53aWR0aCA+IFEgfHwgQy5oZWlnaHQgPiBRKSAmJiAodGUgPSBRIC8gTWF0aC5tYXgoQy53aWR0aCwgQy5oZWlnaHQpKSwgdGUgPCAxIHx8IFMgPT09ICEwKVxuICAgICAgaWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50IDwgXCJ1XCIgJiYgQyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50IDwgXCJ1XCIgJiYgQyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IHR5cGVvZiBJbWFnZUJpdG1hcCA8IFwidVwiICYmIEMgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgICAgICBjb25zdCByZSA9IFMgPyBCcyA6IE1hdGguZmxvb3IsIHllID0gcmUodGUgKiBDLndpZHRoKSwgaiA9IHJlKHRlICogQy5oZWlnaHQpO1xuICAgICAgICBwID09PSB2b2lkIDAgJiYgKHAgPSBfKHllLCBqKSk7XG4gICAgICAgIGNvbnN0IHBlID0gWiA/IF8oeWUsIGopIDogcDtcbiAgICAgICAgcmV0dXJuIHBlLndpZHRoID0geWUsIHBlLmhlaWdodCA9IGosIHBlLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UoQywgMCwgMCwgeWUsIGopLCBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGhhcyBiZWVuIHJlc2l6ZWQgZnJvbSAoXCIgKyBDLndpZHRoICsgXCJ4XCIgKyBDLmhlaWdodCArIFwiKSB0byAoXCIgKyB5ZSArIFwieFwiICsgaiArIFwiKS5cIiksIHBlO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiBcImRhdGFcIiBpbiBDICYmIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEltYWdlIGluIERhdGFUZXh0dXJlIGlzIHRvbyBiaWcgKFwiICsgQy53aWR0aCArIFwieFwiICsgQy5oZWlnaHQgKyBcIikuXCIpLCBDO1xuICAgIHJldHVybiBDO1xuICB9XG4gIGZ1bmN0aW9uIHgoQykge1xuICAgIHJldHVybiAkcyhDLndpZHRoKSAmJiAkcyhDLmhlaWdodCk7XG4gIH1cbiAgZnVuY3Rpb24gTShDKSB7XG4gICAgcmV0dXJuIHIgPyAhMSA6IEMud3JhcFMgIT09IDEwMDEgfHwgQy53cmFwVCAhPT0gMTAwMSB8fCBDLm1pbkZpbHRlciAhPT0gMTAwMyAmJiBDLm1pbkZpbHRlciAhPT0gMTAwNjtcbiAgfVxuICBmdW5jdGlvbiBFKEMsIFMpIHtcbiAgICByZXR1cm4gQy5nZW5lcmF0ZU1pcG1hcHMgJiYgUyAmJiBDLm1pbkZpbHRlciAhPT0gMTAwMyAmJiBDLm1pbkZpbHRlciAhPT0gMTAwNjtcbiAgfVxuICBmdW5jdGlvbiBSKEMpIHtcbiAgICBoLmdlbmVyYXRlTWlwbWFwKEMpO1xuICB9XG4gIGZ1bmN0aW9uIHkoQywgUywgWiwgUSwgdGUgPSAhMSkge1xuICAgIGlmIChyID09PSAhMSlcbiAgICAgIHJldHVybiBTO1xuICAgIGlmIChDICE9PSBudWxsKSB7XG4gICAgICBpZiAoaFtDXSAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gaFtDXTtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gdXNlIG5vbi1leGlzdGluZyBXZWJHTCBpbnRlcm5hbCBmb3JtYXQgJ1wiICsgQyArIFwiJ1wiKTtcbiAgICB9XG4gICAgbGV0IHJlID0gUztcbiAgICByZXR1cm4gUyA9PT0gNjQwMyAmJiAoWiA9PT0gNTEyNiAmJiAocmUgPSAzMzMyNiksIFogPT09IDUxMzEgJiYgKHJlID0gMzMzMjUpLCBaID09PSA1MTIxICYmIChyZSA9IDMzMzIxKSksIFMgPT09IDMzMzE5ICYmIChaID09PSA1MTI2ICYmIChyZSA9IDMzMzI4KSwgWiA9PT0gNTEzMSAmJiAocmUgPSAzMzMyNyksIFogPT09IDUxMjEgJiYgKHJlID0gMzMzMjMpKSwgUyA9PT0gNjQwOCAmJiAoWiA9PT0gNTEyNiAmJiAocmUgPSAzNDgzNiksIFogPT09IDUxMzEgJiYgKHJlID0gMzQ4NDIpLCBaID09PSA1MTIxICYmIChyZSA9IFEgPT09IDMwMDEgJiYgdGUgPT09ICExID8gMzU5MDcgOiAzMjg1NiksIFogPT09IDMyODE5ICYmIChyZSA9IDMyODU0KSwgWiA9PT0gMzI4MjAgJiYgKHJlID0gMzI4NTUpKSwgKHJlID09PSAzMzMyNSB8fCByZSA9PT0gMzMzMjYgfHwgcmUgPT09IDMzMzI3IHx8IHJlID09PSAzMzMyOCB8fCByZSA9PT0gMzQ4NDIgfHwgcmUgPT09IDM0ODM2KSAmJiBlLmdldChcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIiksIHJlO1xuICB9XG4gIGZ1bmN0aW9uIEEoQywgUywgWikge1xuICAgIHJldHVybiBFKEMsIFopID09PSAhMCB8fCBDLmlzRnJhbWVidWZmZXJUZXh0dXJlICYmIEMubWluRmlsdGVyICE9PSAxMDAzICYmIEMubWluRmlsdGVyICE9PSAxMDA2ID8gTWF0aC5sb2cyKE1hdGgubWF4KFMud2lkdGgsIFMuaGVpZ2h0KSkgKyAxIDogQy5taXBtYXBzICE9PSB2b2lkIDAgJiYgQy5taXBtYXBzLmxlbmd0aCA+IDAgPyBDLm1pcG1hcHMubGVuZ3RoIDogQy5pc0NvbXByZXNzZWRUZXh0dXJlICYmIEFycmF5LmlzQXJyYXkoQy5pbWFnZSkgPyBTLm1pcG1hcHMubGVuZ3RoIDogMTtcbiAgfVxuICBmdW5jdGlvbiBGKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gMTAwMyB8fCBDID09PSAxMDA0IHx8IEMgPT09IDEwMDUgPyA5NzI4IDogOTcyOTtcbiAgfVxuICBmdW5jdGlvbiBQKEMpIHtcbiAgICBjb25zdCBTID0gQy50YXJnZXQ7XG4gICAgUy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCBQKSwgeihTKSwgUy5pc1ZpZGVvVGV4dHVyZSAmJiBnLmRlbGV0ZShTKTtcbiAgfVxuICBmdW5jdGlvbiBHKEMpIHtcbiAgICBjb25zdCBTID0gQy50YXJnZXQ7XG4gICAgUy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCBHKSwgSShTKTtcbiAgfVxuICBmdW5jdGlvbiB6KEMpIHtcbiAgICBjb25zdCBTID0gbi5nZXQoQyk7XG4gICAgaWYgKFMuX193ZWJnbEluaXQgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBaID0gQy5zb3VyY2UsIFEgPSBmLmdldChaKTtcbiAgICBpZiAoUSkge1xuICAgICAgY29uc3QgdGUgPSBRW1MuX19jYWNoZUtleV07XG4gICAgICB0ZS51c2VkVGltZXMtLSwgdGUudXNlZFRpbWVzID09PSAwICYmIEwoQyksIE9iamVjdC5rZXlzKFEpLmxlbmd0aCA9PT0gMCAmJiBmLmRlbGV0ZShaKTtcbiAgICB9XG4gICAgbi5yZW1vdmUoQyk7XG4gIH1cbiAgZnVuY3Rpb24gTChDKSB7XG4gICAgY29uc3QgUyA9IG4uZ2V0KEMpO1xuICAgIGguZGVsZXRlVGV4dHVyZShTLl9fd2ViZ2xUZXh0dXJlKTtcbiAgICBjb25zdCBaID0gQy5zb3VyY2UsIFEgPSBmLmdldChaKTtcbiAgICBkZWxldGUgUVtTLl9fY2FjaGVLZXldLCBvLm1lbW9yeS50ZXh0dXJlcy0tO1xuICB9XG4gIGZ1bmN0aW9uIEkoQykge1xuICAgIGNvbnN0IFMgPSBDLnRleHR1cmUsIFogPSBuLmdldChDKSwgUSA9IG4uZ2V0KFMpO1xuICAgIGlmIChRLl9fd2ViZ2xUZXh0dXJlICE9PSB2b2lkIDAgJiYgKGguZGVsZXRlVGV4dHVyZShRLl9fd2ViZ2xUZXh0dXJlKSwgby5tZW1vcnkudGV4dHVyZXMtLSksIEMuZGVwdGhUZXh0dXJlICYmIEMuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKSwgQy5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldClcbiAgICAgIGZvciAobGV0IHRlID0gMDsgdGUgPCA2OyB0ZSsrKVxuICAgICAgICBoLmRlbGV0ZUZyYW1lYnVmZmVyKFouX193ZWJnbEZyYW1lYnVmZmVyW3RlXSksIFouX193ZWJnbERlcHRoYnVmZmVyICYmIGguZGVsZXRlUmVuZGVyYnVmZmVyKFouX193ZWJnbERlcHRoYnVmZmVyW3RlXSk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaC5kZWxldGVGcmFtZWJ1ZmZlcihaLl9fd2ViZ2xGcmFtZWJ1ZmZlciksIFouX193ZWJnbERlcHRoYnVmZmVyICYmIGguZGVsZXRlUmVuZGVyYnVmZmVyKFouX193ZWJnbERlcHRoYnVmZmVyKSwgWi5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIgJiYgaC5kZWxldGVGcmFtZWJ1ZmZlcihaLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksIFouX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyKVxuICAgICAgICBmb3IgKGxldCB0ZSA9IDA7IHRlIDwgWi5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIubGVuZ3RoOyB0ZSsrKVxuICAgICAgICAgIFouX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW3RlXSAmJiBoLmRlbGV0ZVJlbmRlcmJ1ZmZlcihaLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlclt0ZV0pO1xuICAgICAgWi5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIgJiYgaC5kZWxldGVSZW5kZXJidWZmZXIoWi5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoQy5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzKVxuICAgICAgZm9yIChsZXQgdGUgPSAwLCByZSA9IFMubGVuZ3RoOyB0ZSA8IHJlOyB0ZSsrKSB7XG4gICAgICAgIGNvbnN0IHllID0gbi5nZXQoU1t0ZV0pO1xuICAgICAgICB5ZS5fX3dlYmdsVGV4dHVyZSAmJiAoaC5kZWxldGVUZXh0dXJlKHllLl9fd2ViZ2xUZXh0dXJlKSwgby5tZW1vcnkudGV4dHVyZXMtLSksIG4ucmVtb3ZlKFNbdGVdKTtcbiAgICAgIH1cbiAgICBuLnJlbW92ZShTKSwgbi5yZW1vdmUoQyk7XG4gIH1cbiAgbGV0IEQgPSAwO1xuICBmdW5jdGlvbiBxKCkge1xuICAgIEQgPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGsoKSB7XG4gICAgY29uc3QgQyA9IEQ7XG4gICAgcmV0dXJuIEMgPj0gbCAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFRleHR1cmVzOiBUcnlpbmcgdG8gdXNlIFwiICsgQyArIFwiIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSBcIiArIGwpLCBEICs9IDEsIEM7XG4gIH1cbiAgZnVuY3Rpb24gTihDKSB7XG4gICAgY29uc3QgUyA9IFtdO1xuICAgIHJldHVybiBTLnB1c2goQy53cmFwUyksIFMucHVzaChDLndyYXBUKSwgUy5wdXNoKEMubWFnRmlsdGVyKSwgUy5wdXNoKEMubWluRmlsdGVyKSwgUy5wdXNoKEMuYW5pc290cm9weSksIFMucHVzaChDLmludGVybmFsRm9ybWF0KSwgUy5wdXNoKEMuZm9ybWF0KSwgUy5wdXNoKEMudHlwZSksIFMucHVzaChDLmdlbmVyYXRlTWlwbWFwcyksIFMucHVzaChDLnByZW11bHRpcGx5QWxwaGEpLCBTLnB1c2goQy5mbGlwWSksIFMucHVzaChDLnVucGFja0FsaWdubWVudCksIFMucHVzaChDLmVuY29kaW5nKSwgUy5qb2luKCk7XG4gIH1cbiAgZnVuY3Rpb24gSChDLCBTKSB7XG4gICAgY29uc3QgWiA9IG4uZ2V0KEMpO1xuICAgIGlmIChDLmlzVmlkZW9UZXh0dXJlICYmIEd0KEMpLCBDLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gITEgJiYgQy52ZXJzaW9uID4gMCAmJiBaLl9fdmVyc2lvbiAhPT0gQy52ZXJzaW9uKSB7XG4gICAgICBjb25zdCBRID0gQy5pbWFnZTtcbiAgICAgIGlmIChRID09PSBudWxsKVxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBubyBpbWFnZSBkYXRhIGZvdW5kLlwiKTtcbiAgICAgIGVsc2UgaWYgKFEuY29tcGxldGUgPT09ICExKVxuICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlXCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZlKFosIEMsIFMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHQuYWN0aXZlVGV4dHVyZSgzMzk4NCArIFMpLCB0LmJpbmRUZXh0dXJlKDM1NTMsIFouX193ZWJnbFRleHR1cmUpO1xuICB9XG4gIGZ1bmN0aW9uIEooQywgUykge1xuICAgIGNvbnN0IFogPSBuLmdldChDKTtcbiAgICBpZiAoQy52ZXJzaW9uID4gMCAmJiBaLl9fdmVyc2lvbiAhPT0gQy52ZXJzaW9uKSB7XG4gICAgICB2ZShaLCBDLCBTKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5hY3RpdmVUZXh0dXJlKDMzOTg0ICsgUyksIHQuYmluZFRleHR1cmUoMzU4NjYsIFouX193ZWJnbFRleHR1cmUpO1xuICB9XG4gIGZ1bmN0aW9uIFYoQywgUykge1xuICAgIGNvbnN0IFogPSBuLmdldChDKTtcbiAgICBpZiAoQy52ZXJzaW9uID4gMCAmJiBaLl9fdmVyc2lvbiAhPT0gQy52ZXJzaW9uKSB7XG4gICAgICB2ZShaLCBDLCBTKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5hY3RpdmVUZXh0dXJlKDMzOTg0ICsgUyksIHQuYmluZFRleHR1cmUoMzI4NzksIFouX193ZWJnbFRleHR1cmUpO1xuICB9XG4gIGZ1bmN0aW9uIGVlKEMsIFMpIHtcbiAgICBjb25zdCBaID0gbi5nZXQoQyk7XG4gICAgaWYgKEMudmVyc2lvbiA+IDAgJiYgWi5fX3ZlcnNpb24gIT09IEMudmVyc2lvbikge1xuICAgICAgeGUoWiwgQywgUyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuYWN0aXZlVGV4dHVyZSgzMzk4NCArIFMpLCB0LmJpbmRUZXh0dXJlKDM0MDY3LCBaLl9fd2ViZ2xUZXh0dXJlKTtcbiAgfVxuICBjb25zdCBjZSA9IHtcbiAgICBbMWUzXTogMTA0OTcsXG4gICAgWzEwMDFdOiAzMzA3MSxcbiAgICBbMTAwMl06IDMzNjQ4XG4gIH0sIGdlID0ge1xuICAgIFsxMDAzXTogOTcyOCxcbiAgICBbMTAwNF06IDk5ODQsXG4gICAgWzEwMDVdOiA5OTg2LFxuICAgIFsxMDA2XTogOTcyOSxcbiAgICBbMTAwN106IDk5ODUsXG4gICAgWzEwMDhdOiA5OTg3XG4gIH07XG4gIGZ1bmN0aW9uICQoQywgUywgWikge1xuICAgIGlmIChaID8gKGgudGV4UGFyYW1ldGVyaShDLCAxMDI0MiwgY2VbUy53cmFwU10pLCBoLnRleFBhcmFtZXRlcmkoQywgMTAyNDMsIGNlW1Mud3JhcFRdKSwgKEMgPT09IDMyODc5IHx8IEMgPT09IDM1ODY2KSAmJiBoLnRleFBhcmFtZXRlcmkoQywgMzI4ODIsIGNlW1Mud3JhcFJdKSwgaC50ZXhQYXJhbWV0ZXJpKEMsIDEwMjQwLCBnZVtTLm1hZ0ZpbHRlcl0pLCBoLnRleFBhcmFtZXRlcmkoQywgMTAyNDEsIGdlW1MubWluRmlsdGVyXSkpIDogKGgudGV4UGFyYW1ldGVyaShDLCAxMDI0MiwgMzMwNzEpLCBoLnRleFBhcmFtZXRlcmkoQywgMTAyNDMsIDMzMDcxKSwgKEMgPT09IDMyODc5IHx8IEMgPT09IDM1ODY2KSAmJiBoLnRleFBhcmFtZXRlcmkoQywgMzI4ODIsIDMzMDcxKSwgKFMud3JhcFMgIT09IDEwMDEgfHwgUy53cmFwVCAhPT0gMTAwMSkgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy5cIiksIGgudGV4UGFyYW1ldGVyaShDLCAxMDI0MCwgRihTLm1hZ0ZpbHRlcikpLCBoLnRleFBhcmFtZXRlcmkoQywgMTAyNDEsIEYoUy5taW5GaWx0ZXIpKSwgUy5taW5GaWx0ZXIgIT09IDEwMDMgJiYgUy5taW5GaWx0ZXIgIT09IDEwMDYgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLlwiKSksIGUuaGFzKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpID09PSAhMCkge1xuICAgICAgY29uc3QgUSA9IGUuZ2V0KFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpO1xuICAgICAgaWYgKFMudHlwZSA9PT0gMTAxNSAmJiBlLmhhcyhcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSA9PT0gITEgfHwgciA9PT0gITEgJiYgUy50eXBlID09PSAxMDE2ICYmIGUuaGFzKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIikgPT09ICExKVxuICAgICAgICByZXR1cm47XG4gICAgICAoUy5hbmlzb3Ryb3B5ID4gMSB8fCBuLmdldChTKS5fX2N1cnJlbnRBbmlzb3Ryb3B5KSAmJiAoaC50ZXhQYXJhbWV0ZXJmKEMsIFEuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKFMuYW5pc290cm9weSwgaS5nZXRNYXhBbmlzb3Ryb3B5KCkpKSwgbi5nZXQoUykuX19jdXJyZW50QW5pc290cm9weSA9IFMuYW5pc290cm9weSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIERlKEMsIFMpIHtcbiAgICBsZXQgWiA9ICExO1xuICAgIEMuX193ZWJnbEluaXQgPT09IHZvaWQgMCAmJiAoQy5fX3dlYmdsSW5pdCA9ICEwLCBTLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIFApKTtcbiAgICBjb25zdCBRID0gUy5zb3VyY2U7XG4gICAgbGV0IHRlID0gZi5nZXQoUSk7XG4gICAgdGUgPT09IHZvaWQgMCAmJiAodGUgPSB7fSwgZi5zZXQoUSwgdGUpKTtcbiAgICBjb25zdCByZSA9IE4oUyk7XG4gICAgaWYgKHJlICE9PSBDLl9fY2FjaGVLZXkpIHtcbiAgICAgIHRlW3JlXSA9PT0gdm9pZCAwICYmICh0ZVtyZV0gPSB7XG4gICAgICAgIHRleHR1cmU6IGguY3JlYXRlVGV4dHVyZSgpLFxuICAgICAgICB1c2VkVGltZXM6IDBcbiAgICAgIH0sIG8ubWVtb3J5LnRleHR1cmVzKyssIFogPSAhMCksIHRlW3JlXS51c2VkVGltZXMrKztcbiAgICAgIGNvbnN0IHllID0gdGVbQy5fX2NhY2hlS2V5XTtcbiAgICAgIHllICE9PSB2b2lkIDAgJiYgKHRlW0MuX19jYWNoZUtleV0udXNlZFRpbWVzLS0sIHllLnVzZWRUaW1lcyA9PT0gMCAmJiBMKFMpKSwgQy5fX2NhY2hlS2V5ID0gcmUsIEMuX193ZWJnbFRleHR1cmUgPSB0ZVtyZV0udGV4dHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIFo7XG4gIH1cbiAgZnVuY3Rpb24gdmUoQywgUywgWikge1xuICAgIGxldCBRID0gMzU1MztcbiAgICBTLmlzRGF0YUFycmF5VGV4dHVyZSAmJiAoUSA9IDM1ODY2KSwgUy5pc0RhdGEzRFRleHR1cmUgJiYgKFEgPSAzMjg3OSk7XG4gICAgY29uc3QgdGUgPSBEZShDLCBTKSwgcmUgPSBTLnNvdXJjZTtcbiAgICBpZiAodC5hY3RpdmVUZXh0dXJlKDMzOTg0ICsgWiksIHQuYmluZFRleHR1cmUoUSwgQy5fX3dlYmdsVGV4dHVyZSksIHJlLnZlcnNpb24gIT09IHJlLl9fY3VycmVudFZlcnNpb24gfHwgdGUgPT09ICEwKSB7XG4gICAgICBoLnBpeGVsU3RvcmVpKDM3NDQwLCBTLmZsaXBZKSwgaC5waXhlbFN0b3JlaSgzNzQ0MSwgUy5wcmVtdWx0aXBseUFscGhhKSwgaC5waXhlbFN0b3JlaSgzMzE3LCBTLnVucGFja0FsaWdubWVudCksIGgucGl4ZWxTdG9yZWkoMzc0NDMsIDApO1xuICAgICAgY29uc3QgeWUgPSBNKFMpICYmIHgoUy5pbWFnZSkgPT09ICExO1xuICAgICAgbGV0IGogPSB3KFMuaW1hZ2UsIHllLCAhMSwgYyk7XG4gICAgICBqID0gRnQoUywgaik7XG4gICAgICBjb25zdCBwZSA9IHgoaikgfHwgciwgaGUgPSBzLmNvbnZlcnQoUy5mb3JtYXQsIFMuZW5jb2RpbmcpO1xuICAgICAgbGV0IGZlID0gcy5jb252ZXJ0KFMudHlwZSksIGRlID0geShTLmludGVybmFsRm9ybWF0LCBoZSwgZmUsIFMuZW5jb2RpbmcsIFMuaXNWaWRlb1RleHR1cmUpO1xuICAgICAgJChRLCBTLCBwZSk7XG4gICAgICBsZXQgd2U7XG4gICAgICBjb25zdCBJZSA9IFMubWlwbWFwcywgV2UgPSByICYmIFMuaXNWaWRlb1RleHR1cmUgIT09ICEwLCBCID0gcmUuX19jdXJyZW50VmVyc2lvbiA9PT0gdm9pZCAwIHx8IHRlID09PSAhMCwgYWUgPSBBKFMsIGosIHBlKTtcbiAgICAgIGlmIChTLmlzRGVwdGhUZXh0dXJlKVxuICAgICAgICBkZSA9IDY0MDIsIHIgPyBTLnR5cGUgPT09IDEwMTUgPyBkZSA9IDM2MDEyIDogUy50eXBlID09PSAxMDE0ID8gZGUgPSAzMzE5MCA6IFMudHlwZSA9PT0gMTAyMCA/IGRlID0gMzUwNTYgOiBkZSA9IDMzMTg5IDogUy50eXBlID09PSAxMDE1ICYmIGNvbnNvbGUuZXJyb3IoXCJXZWJHTFJlbmRlcmVyOiBGbG9hdGluZyBwb2ludCBkZXB0aCB0ZXh0dXJlIHJlcXVpcmVzIFdlYkdMMi5cIiksIFMuZm9ybWF0ID09PSAxMDI2ICYmIGRlID09PSA2NDAyICYmIFMudHlwZSAhPT0gMTAxMiAmJiBTLnR5cGUgIT09IDEwMTQgJiYgKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZFNob3J0VHlwZSBvciBVbnNpZ25lZEludFR5cGUgZm9yIERlcHRoRm9ybWF0IERlcHRoVGV4dHVyZS5cIiksIFMudHlwZSA9IDEwMTQsIGZlID0gcy5jb252ZXJ0KFMudHlwZSkpLCBTLmZvcm1hdCA9PT0gMTAyNyAmJiBkZSA9PT0gNjQwMiAmJiAoZGUgPSAzNDA0MSwgUy50eXBlICE9PSAxMDIwICYmIChjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBVc2UgVW5zaWduZWRJbnQyNDhUeXBlIGZvciBEZXB0aFN0ZW5jaWxGb3JtYXQgRGVwdGhUZXh0dXJlLlwiKSwgUy50eXBlID0gMTAyMCwgZmUgPSBzLmNvbnZlcnQoUy50eXBlKSkpLCBCICYmIChXZSA/IHQudGV4U3RvcmFnZTJEKDM1NTMsIDEsIGRlLCBqLndpZHRoLCBqLmhlaWdodCkgOiB0LnRleEltYWdlMkQoMzU1MywgMCwgZGUsIGoud2lkdGgsIGouaGVpZ2h0LCAwLCBoZSwgZmUsIG51bGwpKTtcbiAgICAgIGVsc2UgaWYgKFMuaXNEYXRhVGV4dHVyZSlcbiAgICAgICAgaWYgKEllLmxlbmd0aCA+IDAgJiYgcGUpIHtcbiAgICAgICAgICBXZSAmJiBCICYmIHQudGV4U3RvcmFnZTJEKDM1NTMsIGFlLCBkZSwgSWVbMF0ud2lkdGgsIEllWzBdLmhlaWdodCk7XG4gICAgICAgICAgZm9yIChsZXQgWSA9IDAsIG9lID0gSWUubGVuZ3RoOyBZIDwgb2U7IFkrKylcbiAgICAgICAgICAgIHdlID0gSWVbWV0sIFdlID8gdC50ZXhTdWJJbWFnZTJEKDM1NTMsIFksIDAsIDAsIHdlLndpZHRoLCB3ZS5oZWlnaHQsIGhlLCBmZSwgd2UuZGF0YSkgOiB0LnRleEltYWdlMkQoMzU1MywgWSwgZGUsIHdlLndpZHRoLCB3ZS5oZWlnaHQsIDAsIGhlLCBmZSwgd2UuZGF0YSk7XG4gICAgICAgICAgUy5nZW5lcmF0ZU1pcG1hcHMgPSAhMTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgV2UgPyAoQiAmJiB0LnRleFN0b3JhZ2UyRCgzNTUzLCBhZSwgZGUsIGoud2lkdGgsIGouaGVpZ2h0KSwgdC50ZXhTdWJJbWFnZTJEKDM1NTMsIDAsIDAsIDAsIGoud2lkdGgsIGouaGVpZ2h0LCBoZSwgZmUsIGouZGF0YSkpIDogdC50ZXhJbWFnZTJEKDM1NTMsIDAsIGRlLCBqLndpZHRoLCBqLmhlaWdodCwgMCwgaGUsIGZlLCBqLmRhdGEpO1xuICAgICAgZWxzZSBpZiAoUy5pc0NvbXByZXNzZWRUZXh0dXJlKSB7XG4gICAgICAgIFdlICYmIEIgJiYgdC50ZXhTdG9yYWdlMkQoMzU1MywgYWUsIGRlLCBJZVswXS53aWR0aCwgSWVbMF0uaGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgWSA9IDAsIG9lID0gSWUubGVuZ3RoOyBZIDwgb2U7IFkrKylcbiAgICAgICAgICB3ZSA9IEllW1ldLCBTLmZvcm1hdCAhPT0gMTAyMyA/IGhlICE9PSBudWxsID8gV2UgPyB0LmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKDM1NTMsIFksIDAsIDAsIHdlLndpZHRoLCB3ZS5oZWlnaHQsIGhlLCB3ZS5kYXRhKSA6IHQuY29tcHJlc3NlZFRleEltYWdlMkQoMzU1MywgWSwgZGUsIHdlLndpZHRoLCB3ZS5oZWlnaHQsIDAsIHdlLmRhdGEpIDogY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiKSA6IFdlID8gdC50ZXhTdWJJbWFnZTJEKDM1NTMsIFksIDAsIDAsIHdlLndpZHRoLCB3ZS5oZWlnaHQsIGhlLCBmZSwgd2UuZGF0YSkgOiB0LnRleEltYWdlMkQoMzU1MywgWSwgZGUsIHdlLndpZHRoLCB3ZS5oZWlnaHQsIDAsIGhlLCBmZSwgd2UuZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKFMuaXNEYXRhQXJyYXlUZXh0dXJlKVxuICAgICAgICBXZSA/IChCICYmIHQudGV4U3RvcmFnZTNEKDM1ODY2LCBhZSwgZGUsIGoud2lkdGgsIGouaGVpZ2h0LCBqLmRlcHRoKSwgdC50ZXhTdWJJbWFnZTNEKDM1ODY2LCAwLCAwLCAwLCAwLCBqLndpZHRoLCBqLmhlaWdodCwgai5kZXB0aCwgaGUsIGZlLCBqLmRhdGEpKSA6IHQudGV4SW1hZ2UzRCgzNTg2NiwgMCwgZGUsIGoud2lkdGgsIGouaGVpZ2h0LCBqLmRlcHRoLCAwLCBoZSwgZmUsIGouZGF0YSk7XG4gICAgICBlbHNlIGlmIChTLmlzRGF0YTNEVGV4dHVyZSlcbiAgICAgICAgV2UgPyAoQiAmJiB0LnRleFN0b3JhZ2UzRCgzMjg3OSwgYWUsIGRlLCBqLndpZHRoLCBqLmhlaWdodCwgai5kZXB0aCksIHQudGV4U3ViSW1hZ2UzRCgzMjg3OSwgMCwgMCwgMCwgMCwgai53aWR0aCwgai5oZWlnaHQsIGouZGVwdGgsIGhlLCBmZSwgai5kYXRhKSkgOiB0LnRleEltYWdlM0QoMzI4NzksIDAsIGRlLCBqLndpZHRoLCBqLmhlaWdodCwgai5kZXB0aCwgMCwgaGUsIGZlLCBqLmRhdGEpO1xuICAgICAgZWxzZSBpZiAoUy5pc0ZyYW1lYnVmZmVyVGV4dHVyZSkge1xuICAgICAgICBpZiAoQilcbiAgICAgICAgICBpZiAoV2UpXG4gICAgICAgICAgICB0LnRleFN0b3JhZ2UyRCgzNTUzLCBhZSwgZGUsIGoud2lkdGgsIGouaGVpZ2h0KTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBZID0gai53aWR0aCwgb2UgPSBqLmhlaWdodDtcbiAgICAgICAgICAgIGZvciAobGV0IHNlID0gMDsgc2UgPCBhZTsgc2UrKylcbiAgICAgICAgICAgICAgdC50ZXhJbWFnZTJEKDM1NTMsIHNlLCBkZSwgWSwgb2UsIDAsIGhlLCBmZSwgbnVsbCksIFkgPj49IDEsIG9lID4+PSAxO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoSWUubGVuZ3RoID4gMCAmJiBwZSkge1xuICAgICAgICBXZSAmJiBCICYmIHQudGV4U3RvcmFnZTJEKDM1NTMsIGFlLCBkZSwgSWVbMF0ud2lkdGgsIEllWzBdLmhlaWdodCk7XG4gICAgICAgIGZvciAobGV0IFkgPSAwLCBvZSA9IEllLmxlbmd0aDsgWSA8IG9lOyBZKyspXG4gICAgICAgICAgd2UgPSBJZVtZXSwgV2UgPyB0LnRleFN1YkltYWdlMkQoMzU1MywgWSwgMCwgMCwgaGUsIGZlLCB3ZSkgOiB0LnRleEltYWdlMkQoMzU1MywgWSwgZGUsIGhlLCBmZSwgd2UpO1xuICAgICAgICBTLmdlbmVyYXRlTWlwbWFwcyA9ICExO1xuICAgICAgfSBlbHNlXG4gICAgICAgIFdlID8gKEIgJiYgdC50ZXhTdG9yYWdlMkQoMzU1MywgYWUsIGRlLCBqLndpZHRoLCBqLmhlaWdodCksIHQudGV4U3ViSW1hZ2UyRCgzNTUzLCAwLCAwLCAwLCBoZSwgZmUsIGopKSA6IHQudGV4SW1hZ2UyRCgzNTUzLCAwLCBkZSwgaGUsIGZlLCBqKTtcbiAgICAgIEUoUywgcGUpICYmIFIoUSksIHJlLl9fY3VycmVudFZlcnNpb24gPSByZS52ZXJzaW9uLCBTLm9uVXBkYXRlICYmIFMub25VcGRhdGUoUyk7XG4gICAgfVxuICAgIEMuX192ZXJzaW9uID0gUy52ZXJzaW9uO1xuICB9XG4gIGZ1bmN0aW9uIHhlKEMsIFMsIFopIHtcbiAgICBpZiAoUy5pbWFnZS5sZW5ndGggIT09IDYpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgUSA9IERlKEMsIFMpLCB0ZSA9IFMuc291cmNlO1xuICAgIGlmICh0LmFjdGl2ZVRleHR1cmUoMzM5ODQgKyBaKSwgdC5iaW5kVGV4dHVyZSgzNDA2NywgQy5fX3dlYmdsVGV4dHVyZSksIHRlLnZlcnNpb24gIT09IHRlLl9fY3VycmVudFZlcnNpb24gfHwgUSA9PT0gITApIHtcbiAgICAgIGgucGl4ZWxTdG9yZWkoMzc0NDAsIFMuZmxpcFkpLCBoLnBpeGVsU3RvcmVpKDM3NDQxLCBTLnByZW11bHRpcGx5QWxwaGEpLCBoLnBpeGVsU3RvcmVpKDMzMTcsIFMudW5wYWNrQWxpZ25tZW50KSwgaC5waXhlbFN0b3JlaSgzNzQ0MywgMCk7XG4gICAgICBjb25zdCByZSA9IFMuaXNDb21wcmVzc2VkVGV4dHVyZSB8fCBTLmltYWdlWzBdLmlzQ29tcHJlc3NlZFRleHR1cmUsIHllID0gUy5pbWFnZVswXSAmJiBTLmltYWdlWzBdLmlzRGF0YVRleHR1cmUsIGogPSBbXTtcbiAgICAgIGZvciAobGV0IFkgPSAwOyBZIDwgNjsgWSsrKVxuICAgICAgICAhcmUgJiYgIXllID8galtZXSA9IHcoUy5pbWFnZVtZXSwgITEsICEwLCBhKSA6IGpbWV0gPSB5ZSA/IFMuaW1hZ2VbWV0uaW1hZ2UgOiBTLmltYWdlW1ldLCBqW1ldID0gRnQoUywgaltZXSk7XG4gICAgICBjb25zdCBwZSA9IGpbMF0sIGhlID0geChwZSkgfHwgciwgZmUgPSBzLmNvbnZlcnQoUy5mb3JtYXQsIFMuZW5jb2RpbmcpLCBkZSA9IHMuY29udmVydChTLnR5cGUpLCB3ZSA9IHkoUy5pbnRlcm5hbEZvcm1hdCwgZmUsIGRlLCBTLmVuY29kaW5nKSwgSWUgPSByICYmIFMuaXNWaWRlb1RleHR1cmUgIT09ICEwLCBXZSA9IHRlLl9fY3VycmVudFZlcnNpb24gPT09IHZvaWQgMCB8fCBRID09PSAhMDtcbiAgICAgIGxldCBCID0gQShTLCBwZSwgaGUpO1xuICAgICAgJCgzNDA2NywgUywgaGUpO1xuICAgICAgbGV0IGFlO1xuICAgICAgaWYgKHJlKSB7XG4gICAgICAgIEllICYmIFdlICYmIHQudGV4U3RvcmFnZTJEKDM0MDY3LCBCLCB3ZSwgcGUud2lkdGgsIHBlLmhlaWdodCk7XG4gICAgICAgIGZvciAobGV0IFkgPSAwOyBZIDwgNjsgWSsrKSB7XG4gICAgICAgICAgYWUgPSBqW1ldLm1pcG1hcHM7XG4gICAgICAgICAgZm9yIChsZXQgb2UgPSAwOyBvZSA8IGFlLmxlbmd0aDsgb2UrKykge1xuICAgICAgICAgICAgY29uc3Qgc2UgPSBhZVtvZV07XG4gICAgICAgICAgICBTLmZvcm1hdCAhPT0gMTAyMyA/IGZlICE9PSBudWxsID8gSWUgPyB0LmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKDM0MDY5ICsgWSwgb2UsIDAsIDAsIHNlLndpZHRoLCBzZS5oZWlnaHQsIGZlLCBzZS5kYXRhKSA6IHQuY29tcHJlc3NlZFRleEltYWdlMkQoMzQwNjkgKyBZLCBvZSwgd2UsIHNlLndpZHRoLCBzZS5oZWlnaHQsIDAsIHNlLmRhdGEpIDogY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKClcIikgOiBJZSA/IHQudGV4U3ViSW1hZ2UyRCgzNDA2OSArIFksIG9lLCAwLCAwLCBzZS53aWR0aCwgc2UuaGVpZ2h0LCBmZSwgZGUsIHNlLmRhdGEpIDogdC50ZXhJbWFnZTJEKDM0MDY5ICsgWSwgb2UsIHdlLCBzZS53aWR0aCwgc2UuaGVpZ2h0LCAwLCBmZSwgZGUsIHNlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWUgPSBTLm1pcG1hcHMsIEllICYmIFdlICYmIChhZS5sZW5ndGggPiAwICYmIEIrKywgdC50ZXhTdG9yYWdlMkQoMzQwNjcsIEIsIHdlLCBqWzBdLndpZHRoLCBqWzBdLmhlaWdodCkpO1xuICAgICAgICBmb3IgKGxldCBZID0gMDsgWSA8IDY7IFkrKylcbiAgICAgICAgICBpZiAoeWUpIHtcbiAgICAgICAgICAgIEllID8gdC50ZXhTdWJJbWFnZTJEKDM0MDY5ICsgWSwgMCwgMCwgMCwgaltZXS53aWR0aCwgaltZXS5oZWlnaHQsIGZlLCBkZSwgaltZXS5kYXRhKSA6IHQudGV4SW1hZ2UyRCgzNDA2OSArIFksIDAsIHdlLCBqW1ldLndpZHRoLCBqW1ldLmhlaWdodCwgMCwgZmUsIGRlLCBqW1ldLmRhdGEpO1xuICAgICAgICAgICAgZm9yIChsZXQgb2UgPSAwOyBvZSA8IGFlLmxlbmd0aDsgb2UrKykge1xuICAgICAgICAgICAgICBjb25zdCBSZSA9IGFlW29lXS5pbWFnZVtZXS5pbWFnZTtcbiAgICAgICAgICAgICAgSWUgPyB0LnRleFN1YkltYWdlMkQoMzQwNjkgKyBZLCBvZSArIDEsIDAsIDAsIFJlLndpZHRoLCBSZS5oZWlnaHQsIGZlLCBkZSwgUmUuZGF0YSkgOiB0LnRleEltYWdlMkQoMzQwNjkgKyBZLCBvZSArIDEsIHdlLCBSZS53aWR0aCwgUmUuaGVpZ2h0LCAwLCBmZSwgZGUsIFJlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBJZSA/IHQudGV4U3ViSW1hZ2UyRCgzNDA2OSArIFksIDAsIDAsIDAsIGZlLCBkZSwgaltZXSkgOiB0LnRleEltYWdlMkQoMzQwNjkgKyBZLCAwLCB3ZSwgZmUsIGRlLCBqW1ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9lID0gMDsgb2UgPCBhZS5sZW5ndGg7IG9lKyspIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2UgPSBhZVtvZV07XG4gICAgICAgICAgICAgIEllID8gdC50ZXhTdWJJbWFnZTJEKDM0MDY5ICsgWSwgb2UgKyAxLCAwLCAwLCBmZSwgZGUsIHNlLmltYWdlW1ldKSA6IHQudGV4SW1hZ2UyRCgzNDA2OSArIFksIG9lICsgMSwgd2UsIGZlLCBkZSwgc2UuaW1hZ2VbWV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEUoUywgaGUpICYmIFIoMzQwNjcpLCB0ZS5fX2N1cnJlbnRWZXJzaW9uID0gdGUudmVyc2lvbiwgUy5vblVwZGF0ZSAmJiBTLm9uVXBkYXRlKFMpO1xuICAgIH1cbiAgICBDLl9fdmVyc2lvbiA9IFMudmVyc2lvbjtcbiAgfVxuICBmdW5jdGlvbiB1ZShDLCBTLCBaLCBRLCB0ZSkge1xuICAgIGNvbnN0IHJlID0gcy5jb252ZXJ0KFouZm9ybWF0LCBaLmVuY29kaW5nKSwgeWUgPSBzLmNvbnZlcnQoWi50eXBlKSwgaiA9IHkoWi5pbnRlcm5hbEZvcm1hdCwgcmUsIHllLCBaLmVuY29kaW5nKTtcbiAgICBuLmdldChTKS5fX2hhc0V4dGVybmFsVGV4dHVyZXMgfHwgKHRlID09PSAzMjg3OSB8fCB0ZSA9PT0gMzU4NjYgPyB0LnRleEltYWdlM0QodGUsIDAsIGosIFMud2lkdGgsIFMuaGVpZ2h0LCBTLmRlcHRoLCAwLCByZSwgeWUsIG51bGwpIDogdC50ZXhJbWFnZTJEKHRlLCAwLCBqLCBTLndpZHRoLCBTLmhlaWdodCwgMCwgcmUsIHllLCBudWxsKSksIHQuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBDKSwgTmUoUykgPyB1LmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoMzYxNjAsIFEsIHRlLCBuLmdldChaKS5fX3dlYmdsVGV4dHVyZSwgMCwgdHQoUykpIDogaC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCwgUSwgdGUsIG4uZ2V0KFopLl9fd2ViZ2xUZXh0dXJlLCAwKSwgdC5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIE9lKEMsIFMsIFopIHtcbiAgICBpZiAoaC5iaW5kUmVuZGVyYnVmZmVyKDM2MTYxLCBDKSwgUy5kZXB0aEJ1ZmZlciAmJiAhUy5zdGVuY2lsQnVmZmVyKSB7XG4gICAgICBsZXQgUSA9IDMzMTg5O1xuICAgICAgaWYgKFogfHwgTmUoUykpIHtcbiAgICAgICAgY29uc3QgdGUgPSBTLmRlcHRoVGV4dHVyZTtcbiAgICAgICAgdGUgJiYgdGUuaXNEZXB0aFRleHR1cmUgJiYgKHRlLnR5cGUgPT09IDEwMTUgPyBRID0gMzYwMTIgOiB0ZS50eXBlID09PSAxMDE0ICYmIChRID0gMzMxOTApKTtcbiAgICAgICAgY29uc3QgcmUgPSB0dChTKTtcbiAgICAgICAgTmUoUykgPyB1LnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVCgzNjE2MSwgcmUsIFEsIFMud2lkdGgsIFMuaGVpZ2h0KSA6IGgucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKDM2MTYxLCByZSwgUSwgUy53aWR0aCwgUy5oZWlnaHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGgucmVuZGVyYnVmZmVyU3RvcmFnZSgzNjE2MSwgUSwgUy53aWR0aCwgUy5oZWlnaHQpO1xuICAgICAgaC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcigzNjE2MCwgMzYwOTYsIDM2MTYxLCBDKTtcbiAgICB9IGVsc2UgaWYgKFMuZGVwdGhCdWZmZXIgJiYgUy5zdGVuY2lsQnVmZmVyKSB7XG4gICAgICBjb25zdCBRID0gdHQoUyk7XG4gICAgICBaICYmIE5lKFMpID09PSAhMSA/IGgucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKDM2MTYxLCBRLCAzNTA1NiwgUy53aWR0aCwgUy5oZWlnaHQpIDogTmUoUykgPyB1LnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVCgzNjE2MSwgUSwgMzUwNTYsIFMud2lkdGgsIFMuaGVpZ2h0KSA6IGgucmVuZGVyYnVmZmVyU3RvcmFnZSgzNjE2MSwgMzQwNDEsIFMud2lkdGgsIFMuaGVpZ2h0KSwgaC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcigzNjE2MCwgMzMzMDYsIDM2MTYxLCBDKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgUSA9IFMuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gITAgPyBTLnRleHR1cmUgOiBbUy50ZXh0dXJlXTtcbiAgICAgIGZvciAobGV0IHRlID0gMDsgdGUgPCBRLmxlbmd0aDsgdGUrKykge1xuICAgICAgICBjb25zdCByZSA9IFFbdGVdLCB5ZSA9IHMuY29udmVydChyZS5mb3JtYXQsIHJlLmVuY29kaW5nKSwgaiA9IHMuY29udmVydChyZS50eXBlKSwgcGUgPSB5KHJlLmludGVybmFsRm9ybWF0LCB5ZSwgaiwgcmUuZW5jb2RpbmcpLCBoZSA9IHR0KFMpO1xuICAgICAgICBaICYmIE5lKFMpID09PSAhMSA/IGgucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKDM2MTYxLCBoZSwgcGUsIFMud2lkdGgsIFMuaGVpZ2h0KSA6IE5lKFMpID8gdS5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoMzYxNjEsIGhlLCBwZSwgUy53aWR0aCwgUy5oZWlnaHQpIDogaC5yZW5kZXJidWZmZXJTdG9yYWdlKDM2MTYxLCBwZSwgUy53aWR0aCwgUy5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBoLmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIEVlKEMsIFMpIHtcbiAgICBpZiAoUyAmJiBTLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICBpZiAodC5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIEMpLCAhKFMuZGVwdGhUZXh0dXJlICYmIFMuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmVcIik7XG4gICAgKCFuLmdldChTLmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmUgfHwgUy5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggIT09IFMud2lkdGggfHwgUy5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ICE9PSBTLmhlaWdodCkgJiYgKFMuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gUy53aWR0aCwgUy5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gUy5oZWlnaHQsIFMuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlID0gITApLCBIKFMuZGVwdGhUZXh0dXJlLCAwKTtcbiAgICBjb25zdCBRID0gbi5nZXQoUy5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlLCB0ZSA9IHR0KFMpO1xuICAgIGlmIChTLmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IDEwMjYpXG4gICAgICBOZShTKSA/IHUuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVCgzNjE2MCwgMzYwOTYsIDM1NTMsIFEsIDAsIHRlKSA6IGguZnJhbWVidWZmZXJUZXh0dXJlMkQoMzYxNjAsIDM2MDk2LCAzNTUzLCBRLCAwKTtcbiAgICBlbHNlIGlmIChTLmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IDEwMjcpXG4gICAgICBOZShTKSA/IHUuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVCgzNjE2MCwgMzMzMDYsIDM1NTMsIFEsIDAsIHRlKSA6IGguZnJhbWVidWZmZXJUZXh0dXJlMkQoMzYxNjAsIDMzMzA2LCAzNTUzLCBRLCAwKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXRcIik7XG4gIH1cbiAgZnVuY3Rpb24gbWUoQykge1xuICAgIGNvbnN0IFMgPSBuLmdldChDKSwgWiA9IEMuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPT09ICEwO1xuICAgIGlmIChDLmRlcHRoVGV4dHVyZSAmJiAhUy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyKSB7XG4gICAgICBpZiAoWilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHNcIik7XG4gICAgICBFZShTLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgQyk7XG4gICAgfSBlbHNlIGlmIChaKSB7XG4gICAgICBTLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IFtdO1xuICAgICAgZm9yIChsZXQgUSA9IDA7IFEgPCA2OyBRKyspXG4gICAgICAgIHQuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBTLl9fd2ViZ2xGcmFtZWJ1ZmZlcltRXSksIFMuX193ZWJnbERlcHRoYnVmZmVyW1FdID0gaC5jcmVhdGVSZW5kZXJidWZmZXIoKSwgT2UoUy5fX3dlYmdsRGVwdGhidWZmZXJbUV0sIEMsICExKTtcbiAgICB9IGVsc2VcbiAgICAgIHQuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBTLl9fd2ViZ2xGcmFtZWJ1ZmZlciksIFMuX193ZWJnbERlcHRoYnVmZmVyID0gaC5jcmVhdGVSZW5kZXJidWZmZXIoKSwgT2UoUy5fX3dlYmdsRGVwdGhidWZmZXIsIEMsICExKTtcbiAgICB0LmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgbnVsbCk7XG4gIH1cbiAgZnVuY3Rpb24gZXQoQywgUywgWikge1xuICAgIGNvbnN0IFEgPSBuLmdldChDKTtcbiAgICBTICE9PSB2b2lkIDAgJiYgdWUoUS5fX3dlYmdsRnJhbWVidWZmZXIsIEMsIEMudGV4dHVyZSwgMzYwNjQsIDM1NTMpLCBaICE9PSB2b2lkIDAgJiYgbWUoQyk7XG4gIH1cbiAgZnVuY3Rpb24gdXQoQykge1xuICAgIGNvbnN0IFMgPSBDLnRleHR1cmUsIFogPSBuLmdldChDKSwgUSA9IG4uZ2V0KFMpO1xuICAgIEMuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIiwgRyksIEMuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyAhPT0gITAgJiYgKFEuX193ZWJnbFRleHR1cmUgPT09IHZvaWQgMCAmJiAoUS5fX3dlYmdsVGV4dHVyZSA9IGguY3JlYXRlVGV4dHVyZSgpKSwgUS5fX3ZlcnNpb24gPSBTLnZlcnNpb24sIG8ubWVtb3J5LnRleHR1cmVzKyspO1xuICAgIGNvbnN0IHRlID0gQy5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9PT0gITAsIHJlID0gQy5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID09PSAhMCwgeWUgPSB4KEMpIHx8IHI7XG4gICAgaWYgKHRlKSB7XG4gICAgICBaLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2OyBqKyspXG4gICAgICAgIFouX193ZWJnbEZyYW1lYnVmZmVyW2pdID0gaC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoWi5fX3dlYmdsRnJhbWVidWZmZXIgPSBoLmNyZWF0ZUZyYW1lYnVmZmVyKCksIHJlKVxuICAgICAgICBpZiAoaS5kcmF3QnVmZmVycykge1xuICAgICAgICAgIGNvbnN0IGogPSBDLnRleHR1cmU7XG4gICAgICAgICAgZm9yIChsZXQgcGUgPSAwLCBoZSA9IGoubGVuZ3RoOyBwZSA8IGhlOyBwZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmZSA9IG4uZ2V0KGpbcGVdKTtcbiAgICAgICAgICAgIGZlLl9fd2ViZ2xUZXh0dXJlID09PSB2b2lkIDAgJiYgKGZlLl9fd2ViZ2xUZXh0dXJlID0gaC5jcmVhdGVUZXh0dXJlKCksIG8ubWVtb3J5LnRleHR1cmVzKyspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMMiBvciBXRUJHTF9kcmF3X2J1ZmZlcnMgZXh0ZW5zaW9uLlwiKTtcbiAgICAgIGlmIChyICYmIEMuc2FtcGxlcyA+IDAgJiYgTmUoQykgPT09ICExKSB7XG4gICAgICAgIGNvbnN0IGogPSByZSA/IFMgOiBbU107XG4gICAgICAgIFouX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyID0gaC5jcmVhdGVGcmFtZWJ1ZmZlcigpLCBaLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlciA9IFtdLCB0LmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgWi5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBwZSA9IDA7IHBlIDwgai5sZW5ndGg7IHBlKyspIHtcbiAgICAgICAgICBjb25zdCBoZSA9IGpbcGVdO1xuICAgICAgICAgIFouX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW3BlXSA9IGguY3JlYXRlUmVuZGVyYnVmZmVyKCksIGguYmluZFJlbmRlcmJ1ZmZlcigzNjE2MSwgWi5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbcGVdKTtcbiAgICAgICAgICBjb25zdCBmZSA9IHMuY29udmVydChoZS5mb3JtYXQsIGhlLmVuY29kaW5nKSwgZGUgPSBzLmNvbnZlcnQoaGUudHlwZSksIHdlID0geShoZS5pbnRlcm5hbEZvcm1hdCwgZmUsIGRlLCBoZS5lbmNvZGluZyksIEllID0gdHQoQyk7XG4gICAgICAgICAgaC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoMzYxNjEsIEllLCB3ZSwgQy53aWR0aCwgQy5oZWlnaHQpLCBoLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKDM2MTYwLCAzNjA2NCArIHBlLCAzNjE2MSwgWi5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbcGVdKTtcbiAgICAgICAgfVxuICAgICAgICBoLmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsIG51bGwpLCBDLmRlcHRoQnVmZmVyICYmIChaLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciA9IGguY3JlYXRlUmVuZGVyYnVmZmVyKCksIE9lKFouX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyLCBDLCAhMCkpLCB0LmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZSkge1xuICAgICAgdC5iaW5kVGV4dHVyZSgzNDA2NywgUS5fX3dlYmdsVGV4dHVyZSksICQoMzQwNjcsIFMsIHllKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjsgaisrKVxuICAgICAgICB1ZShaLl9fd2ViZ2xGcmFtZWJ1ZmZlcltqXSwgQywgUywgMzYwNjQsIDM0MDY5ICsgaik7XG4gICAgICBFKFMsIHllKSAmJiBSKDM0MDY3KSwgdC51bmJpbmRUZXh0dXJlKCk7XG4gICAgfSBlbHNlIGlmIChyZSkge1xuICAgICAgY29uc3QgaiA9IEMudGV4dHVyZTtcbiAgICAgIGZvciAobGV0IHBlID0gMCwgaGUgPSBqLmxlbmd0aDsgcGUgPCBoZTsgcGUrKykge1xuICAgICAgICBjb25zdCBmZSA9IGpbcGVdLCBkZSA9IG4uZ2V0KGZlKTtcbiAgICAgICAgdC5iaW5kVGV4dHVyZSgzNTUzLCBkZS5fX3dlYmdsVGV4dHVyZSksICQoMzU1MywgZmUsIHllKSwgdWUoWi5fX3dlYmdsRnJhbWVidWZmZXIsIEMsIGZlLCAzNjA2NCArIHBlLCAzNTUzKSwgRShmZSwgeWUpICYmIFIoMzU1Myk7XG4gICAgICB9XG4gICAgICB0LnVuYmluZFRleHR1cmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGogPSAzNTUzO1xuICAgICAgKEMuaXNXZWJHTDNEUmVuZGVyVGFyZ2V0IHx8IEMuaXNXZWJHTEFycmF5UmVuZGVyVGFyZ2V0KSAmJiAociA/IGogPSBDLmlzV2ViR0wzRFJlbmRlclRhcmdldCA/IDMyODc5IDogMzU4NjYgOiBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xUZXh0dXJlczogVEhSRUUuRGF0YTNEVGV4dHVyZSBhbmQgVEhSRUUuRGF0YUFycmF5VGV4dHVyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIFdlYkdMMi5cIikpLCB0LmJpbmRUZXh0dXJlKGosIFEuX193ZWJnbFRleHR1cmUpLCAkKGosIFMsIHllKSwgdWUoWi5fX3dlYmdsRnJhbWVidWZmZXIsIEMsIFMsIDM2MDY0LCBqKSwgRShTLCB5ZSkgJiYgUihqKSwgdC51bmJpbmRUZXh0dXJlKCk7XG4gICAgfVxuICAgIEMuZGVwdGhCdWZmZXIgJiYgbWUoQyk7XG4gIH1cbiAgZnVuY3Rpb24gcnQoQykge1xuICAgIGNvbnN0IFMgPSB4KEMpIHx8IHIsIFogPSBDLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPT09ICEwID8gQy50ZXh0dXJlIDogW0MudGV4dHVyZV07XG4gICAgZm9yIChsZXQgUSA9IDAsIHRlID0gWi5sZW5ndGg7IFEgPCB0ZTsgUSsrKSB7XG4gICAgICBjb25zdCByZSA9IFpbUV07XG4gICAgICBpZiAoRShyZSwgUykpIHtcbiAgICAgICAgY29uc3QgeWUgPSBDLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID8gMzQwNjcgOiAzNTUzLCBqID0gbi5nZXQocmUpLl9fd2ViZ2xUZXh0dXJlO1xuICAgICAgICB0LmJpbmRUZXh0dXJlKHllLCBqKSwgUih5ZSksIHQudW5iaW5kVGV4dHVyZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBSdChDKSB7XG4gICAgaWYgKHIgJiYgQy5zYW1wbGVzID4gMCAmJiBOZShDKSA9PT0gITEpIHtcbiAgICAgIGNvbnN0IFMgPSBDLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPyBDLnRleHR1cmUgOiBbQy50ZXh0dXJlXSwgWiA9IEMud2lkdGgsIFEgPSBDLmhlaWdodDtcbiAgICAgIGxldCB0ZSA9IDE2Mzg0O1xuICAgICAgY29uc3QgcmUgPSBbXSwgeWUgPSBDLnN0ZW5jaWxCdWZmZXIgPyAzMzMwNiA6IDM2MDk2LCBqID0gbi5nZXQoQyksIHBlID0gQy5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID09PSAhMDtcbiAgICAgIGlmIChwZSlcbiAgICAgICAgZm9yIChsZXQgaGUgPSAwOyBoZSA8IFMubGVuZ3RoOyBoZSsrKVxuICAgICAgICAgIHQuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBqLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksIGguZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoMzYxNjAsIDM2MDY0ICsgaGUsIDM2MTYxLCBudWxsKSwgdC5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIGouX193ZWJnbEZyYW1lYnVmZmVyKSwgaC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjAwOSwgMzYwNjQgKyBoZSwgMzU1MywgbnVsbCwgMCk7XG4gICAgICB0LmJpbmRGcmFtZWJ1ZmZlcigzNjAwOCwgai5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLCB0LmJpbmRGcmFtZWJ1ZmZlcigzNjAwOSwgai5fX3dlYmdsRnJhbWVidWZmZXIpO1xuICAgICAgZm9yIChsZXQgaGUgPSAwOyBoZSA8IFMubGVuZ3RoOyBoZSsrKSB7XG4gICAgICAgIHJlLnB1c2goMzYwNjQgKyBoZSksIEMuZGVwdGhCdWZmZXIgJiYgcmUucHVzaCh5ZSk7XG4gICAgICAgIGNvbnN0IGZlID0gai5fX2lnbm9yZURlcHRoVmFsdWVzICE9PSB2b2lkIDAgPyBqLl9faWdub3JlRGVwdGhWYWx1ZXMgOiAhMTtcbiAgICAgICAgaWYgKGZlID09PSAhMSAmJiAoQy5kZXB0aEJ1ZmZlciAmJiAodGUgfD0gMjU2KSwgQy5zdGVuY2lsQnVmZmVyICYmICh0ZSB8PSAxMDI0KSksIHBlICYmIGguZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoMzYwMDgsIDM2MDY0LCAzNjE2MSwgai5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbaGVdKSwgZmUgPT09ICEwICYmIChoLmludmFsaWRhdGVGcmFtZWJ1ZmZlcigzNjAwOCwgW3llXSksIGguaW52YWxpZGF0ZUZyYW1lYnVmZmVyKDM2MDA5LCBbeWVdKSksIHBlKSB7XG4gICAgICAgICAgY29uc3QgZGUgPSBuLmdldChTW2hlXSkuX193ZWJnbFRleHR1cmU7XG4gICAgICAgICAgaC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjAwOSwgMzYwNjQsIDM1NTMsIGRlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBoLmJsaXRGcmFtZWJ1ZmZlcigwLCAwLCBaLCBRLCAwLCAwLCBaLCBRLCB0ZSwgOTcyOCksIG0gJiYgaC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoMzYwMDgsIHJlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0LmJpbmRGcmFtZWJ1ZmZlcigzNjAwOCwgbnVsbCksIHQuYmluZEZyYW1lYnVmZmVyKDM2MDA5LCBudWxsKSwgcGUpXG4gICAgICAgIGZvciAobGV0IGhlID0gMDsgaGUgPCBTLmxlbmd0aDsgaGUrKykge1xuICAgICAgICAgIHQuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBqLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciksIGguZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoMzYxNjAsIDM2MDY0ICsgaGUsIDM2MTYxLCBqLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltoZV0pO1xuICAgICAgICAgIGNvbnN0IGZlID0gbi5nZXQoU1toZV0pLl9fd2ViZ2xUZXh0dXJlO1xuICAgICAgICAgIHQuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBqLl9fd2ViZ2xGcmFtZWJ1ZmZlciksIGguZnJhbWVidWZmZXJUZXh0dXJlMkQoMzYwMDksIDM2MDY0ICsgaGUsIDM1NTMsIGZlLCAwKTtcbiAgICAgICAgfVxuICAgICAgdC5iaW5kRnJhbWVidWZmZXIoMzYwMDksIGouX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHQoQykge1xuICAgIHJldHVybiBNYXRoLm1pbihkLCBDLnNhbXBsZXMpO1xuICB9XG4gIGZ1bmN0aW9uIE5lKEMpIHtcbiAgICBjb25zdCBTID0gbi5nZXQoQyk7XG4gICAgcmV0dXJuIHIgJiYgQy5zYW1wbGVzID4gMCAmJiBlLmhhcyhcIldFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZVwiKSA9PT0gITAgJiYgUy5fX3VzZVJlbmRlclRvVGV4dHVyZSAhPT0gITE7XG4gIH1cbiAgZnVuY3Rpb24gR3QoQykge1xuICAgIGNvbnN0IFMgPSBvLnJlbmRlci5mcmFtZTtcbiAgICBnLmdldChDKSAhPT0gUyAmJiAoZy5zZXQoQywgUyksIEMudXBkYXRlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIEZ0KEMsIFMpIHtcbiAgICBjb25zdCBaID0gQy5lbmNvZGluZywgUSA9IEMuZm9ybWF0LCB0ZSA9IEMudHlwZTtcbiAgICByZXR1cm4gQy5pc0NvbXByZXNzZWRUZXh0dXJlID09PSAhMCB8fCBDLmlzVmlkZW9UZXh0dXJlID09PSAhMCB8fCBDLmZvcm1hdCA9PT0gMTAzNSB8fCBaICE9PSAzZTMgJiYgKFogPT09IDMwMDEgPyByID09PSAhMSA/IGUuaGFzKFwiRVhUX3NSR0JcIikgPT09ICEwICYmIFEgPT09IDEwMjMgPyAoQy5mb3JtYXQgPSAxMDM1LCBDLm1pbkZpbHRlciA9IDEwMDYsIEMuZ2VuZXJhdGVNaXBtYXBzID0gITEpIDogUyA9IGlvLnNSR0JUb0xpbmVhcihTKSA6IChRICE9PSAxMDIzIHx8IHRlICE9PSAxMDA5KSAmJiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFRleHR1cmVzOiBzUkdCIGVuY29kZWQgdGV4dHVyZXMgaGF2ZSB0byB1c2UgUkdCQUZvcm1hdCBhbmQgVW5zaWduZWRCeXRlVHlwZS5cIikgOiBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xUZXh0dXJlczogVW5zdXBwb3J0ZWQgdGV4dHVyZSBlbmNvZGluZzpcIiwgWikpLCBTO1xuICB9XG4gIHRoaXMuYWxsb2NhdGVUZXh0dXJlVW5pdCA9IGssIHRoaXMucmVzZXRUZXh0dXJlVW5pdHMgPSBxLCB0aGlzLnNldFRleHR1cmUyRCA9IEgsIHRoaXMuc2V0VGV4dHVyZTJEQXJyYXkgPSBKLCB0aGlzLnNldFRleHR1cmUzRCA9IFYsIHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBlZSwgdGhpcy5yZWJpbmRUZXh0dXJlcyA9IGV0LCB0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gdXQsIHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gcnQsIHRoaXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgPSBSdCwgdGhpcy5zZXR1cERlcHRoUmVuZGVyYnVmZmVyID0gbWUsIHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUgPSB1ZSwgdGhpcy51c2VNdWx0aXNhbXBsZWRSVFQgPSBOZTtcbn1cbmZ1bmN0aW9uIEN1KGgsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHQuaXNXZWJHTDI7XG4gIGZ1bmN0aW9uIGkocywgbyA9IG51bGwpIHtcbiAgICBsZXQgcjtcbiAgICBpZiAocyA9PT0gMTAwOSlcbiAgICAgIHJldHVybiA1MTIxO1xuICAgIGlmIChzID09PSAxMDE3KVxuICAgICAgcmV0dXJuIDMyODE5O1xuICAgIGlmIChzID09PSAxMDE4KVxuICAgICAgcmV0dXJuIDMyODIwO1xuICAgIGlmIChzID09PSAxMDEwKVxuICAgICAgcmV0dXJuIDUxMjA7XG4gICAgaWYgKHMgPT09IDEwMTEpXG4gICAgICByZXR1cm4gNTEyMjtcbiAgICBpZiAocyA9PT0gMTAxMilcbiAgICAgIHJldHVybiA1MTIzO1xuICAgIGlmIChzID09PSAxMDEzKVxuICAgICAgcmV0dXJuIDUxMjQ7XG4gICAgaWYgKHMgPT09IDEwMTQpXG4gICAgICByZXR1cm4gNTEyNTtcbiAgICBpZiAocyA9PT0gMTAxNSlcbiAgICAgIHJldHVybiA1MTI2O1xuICAgIGlmIChzID09PSAxMDE2KVxuICAgICAgcmV0dXJuIG4gPyA1MTMxIDogKHIgPSBlLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksIHIgIT09IG51bGwgPyByLkhBTEZfRkxPQVRfT0VTIDogbnVsbCk7XG4gICAgaWYgKHMgPT09IDEwMjEpXG4gICAgICByZXR1cm4gNjQwNjtcbiAgICBpZiAocyA9PT0gMTAyMylcbiAgICAgIHJldHVybiA2NDA4O1xuICAgIGlmIChzID09PSAxMDI0KVxuICAgICAgcmV0dXJuIDY0MDk7XG4gICAgaWYgKHMgPT09IDEwMjUpXG4gICAgICByZXR1cm4gNjQxMDtcbiAgICBpZiAocyA9PT0gMTAyNilcbiAgICAgIHJldHVybiA2NDAyO1xuICAgIGlmIChzID09PSAxMDI3KVxuICAgICAgcmV0dXJuIDM0MDQxO1xuICAgIGlmIChzID09PSAxMDI4KVxuICAgICAgcmV0dXJuIDY0MDM7XG4gICAgaWYgKHMgPT09IDEwMjIpXG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVEhSRUUuUkdCRm9ybWF0IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5SR0JBRm9ybWF0IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzIyOFwiKSwgNjQwODtcbiAgICBpZiAocyA9PT0gMTAzNSlcbiAgICAgIHJldHVybiByID0gZS5nZXQoXCJFWFRfc1JHQlwiKSwgciAhPT0gbnVsbCA/IHIuU1JHQl9BTFBIQV9FWFQgOiBudWxsO1xuICAgIGlmIChzID09PSAxMDI5KVxuICAgICAgcmV0dXJuIDM2MjQ0O1xuICAgIGlmIChzID09PSAxMDMwKVxuICAgICAgcmV0dXJuIDMzMzE5O1xuICAgIGlmIChzID09PSAxMDMxKVxuICAgICAgcmV0dXJuIDMzMzIwO1xuICAgIGlmIChzID09PSAxMDMzKVxuICAgICAgcmV0dXJuIDM2MjQ5O1xuICAgIGlmIChzID09PSAzMzc3NiB8fCBzID09PSAzMzc3NyB8fCBzID09PSAzMzc3OCB8fCBzID09PSAzMzc3OSlcbiAgICAgIGlmIChvID09PSAzMDAxKVxuICAgICAgICBpZiAociA9IGUuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNfc3JnYlwiKSwgciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzID09PSAzMzc3NilcbiAgICAgICAgICAgIHJldHVybiByLkNPTVBSRVNTRURfU1JHQl9TM1RDX0RYVDFfRVhUO1xuICAgICAgICAgIGlmIChzID09PSAzMzc3NylcbiAgICAgICAgICAgIHJldHVybiByLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO1xuICAgICAgICAgIGlmIChzID09PSAzMzc3OClcbiAgICAgICAgICAgIHJldHVybiByLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUO1xuICAgICAgICAgIGlmIChzID09PSAzMzc3OSlcbiAgICAgICAgICAgIHJldHVybiByLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGVsc2UgaWYgKHIgPSBlLmdldChcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpLCByICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzID09PSAzMzc3NilcbiAgICAgICAgICByZXR1cm4gci5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICAgICAgICBpZiAocyA9PT0gMzM3NzcpXG4gICAgICAgICAgcmV0dXJuIHIuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XG4gICAgICAgIGlmIChzID09PSAzMzc3OClcbiAgICAgICAgICByZXR1cm4gci5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcbiAgICAgICAgaWYgKHMgPT09IDMzNzc5KVxuICAgICAgICAgIHJldHVybiByLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChzID09PSAzNTg0MCB8fCBzID09PSAzNTg0MSB8fCBzID09PSAzNTg0MiB8fCBzID09PSAzNTg0MylcbiAgICAgIGlmIChyID0gZS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIiksIHIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHMgPT09IDM1ODQwKVxuICAgICAgICAgIHJldHVybiByLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgICAgIGlmIChzID09PSAzNTg0MSlcbiAgICAgICAgICByZXR1cm4gci5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xuICAgICAgICBpZiAocyA9PT0gMzU4NDIpXG4gICAgICAgICAgcmV0dXJuIHIuQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgICAgIGlmIChzID09PSAzNTg0MylcbiAgICAgICAgICByZXR1cm4gci5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAocyA9PT0gMzYxOTYpXG4gICAgICByZXR1cm4gciA9IGUuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcIiksIHIgIT09IG51bGwgPyByLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wgOiBudWxsO1xuICAgIGlmIChzID09PSAzNzQ5MiB8fCBzID09PSAzNzQ5NilcbiAgICAgIGlmIChyID0gZS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjXCIpLCByICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzID09PSAzNzQ5MilcbiAgICAgICAgICByZXR1cm4gbyA9PT0gMzAwMSA/IHIuQ09NUFJFU1NFRF9TUkdCOF9FVEMyIDogci5DT01QUkVTU0VEX1JHQjhfRVRDMjtcbiAgICAgICAgaWYgKHMgPT09IDM3NDk2KVxuICAgICAgICAgIHJldHVybiBvID09PSAzMDAxID8gci5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyA6IHIuQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAocyA9PT0gMzc4MDggfHwgcyA9PT0gMzc4MDkgfHwgcyA9PT0gMzc4MTAgfHwgcyA9PT0gMzc4MTEgfHwgcyA9PT0gMzc4MTIgfHwgcyA9PT0gMzc4MTMgfHwgcyA9PT0gMzc4MTQgfHwgcyA9PT0gMzc4MTUgfHwgcyA9PT0gMzc4MTYgfHwgcyA9PT0gMzc4MTcgfHwgcyA9PT0gMzc4MTggfHwgcyA9PT0gMzc4MTkgfHwgcyA9PT0gMzc4MjAgfHwgcyA9PT0gMzc4MjEpXG4gICAgICBpZiAociA9IGUuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGNcIiksIHIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHMgPT09IDM3ODA4KVxuICAgICAgICAgIHJldHVybiBvID09PSAzMDAxID8gci5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzR4NF9LSFIgOiByLkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFI7XG4gICAgICAgIGlmIChzID09PSAzNzgwOSlcbiAgICAgICAgICByZXR1cm4gbyA9PT0gMzAwMSA/IHIuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDRfS0hSIDogci5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDRfS0hSO1xuICAgICAgICBpZiAocyA9PT0gMzc4MTApXG4gICAgICAgICAgcmV0dXJuIG8gPT09IDMwMDEgPyByLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg1X0tIUiA6IHIuQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg1X0tIUjtcbiAgICAgICAgaWYgKHMgPT09IDM3ODExKVxuICAgICAgICAgIHJldHVybiBvID09PSAzMDAxID8gci5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzZ4NV9LSFIgOiByLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4NV9LSFI7XG4gICAgICAgIGlmIChzID09PSAzNzgxMilcbiAgICAgICAgICByZXR1cm4gbyA9PT0gMzAwMSA/IHIuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDZfS0hSIDogci5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDZfS0hSO1xuICAgICAgICBpZiAocyA9PT0gMzc4MTMpXG4gICAgICAgICAgcmV0dXJuIG8gPT09IDMwMDEgPyByLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg1X0tIUiA6IHIuQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg1X0tIUjtcbiAgICAgICAgaWYgKHMgPT09IDM3ODE0KVxuICAgICAgICAgIHJldHVybiBvID09PSAzMDAxID8gci5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4Nl9LSFIgOiByLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4Nl9LSFI7XG4gICAgICAgIGlmIChzID09PSAzNzgxNSlcbiAgICAgICAgICByZXR1cm4gbyA9PT0gMzAwMSA/IHIuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDhfS0hSIDogci5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDhfS0hSO1xuICAgICAgICBpZiAocyA9PT0gMzc4MTYpXG4gICAgICAgICAgcmV0dXJuIG8gPT09IDMwMDEgPyByLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4NV9LSFIgOiByLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDVfS0hSO1xuICAgICAgICBpZiAocyA9PT0gMzc4MTcpXG4gICAgICAgICAgcmV0dXJuIG8gPT09IDMwMDEgPyByLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9LSFIgOiByLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDZfS0hSO1xuICAgICAgICBpZiAocyA9PT0gMzc4MTgpXG4gICAgICAgICAgcmV0dXJuIG8gPT09IDMwMDEgPyByLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9LSFIgOiByLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDhfS0hSO1xuICAgICAgICBpZiAocyA9PT0gMzc4MTkpXG4gICAgICAgICAgcmV0dXJuIG8gPT09IDMwMDEgPyByLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4MTBfS0hSIDogci5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHgxMF9LSFI7XG4gICAgICAgIGlmIChzID09PSAzNzgyMClcbiAgICAgICAgICByZXR1cm4gbyA9PT0gMzAwMSA/IHIuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMF9LSFIgOiByLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEyeDEwX0tIUjtcbiAgICAgICAgaWYgKHMgPT09IDM3ODIxKVxuICAgICAgICAgIHJldHVybiBvID09PSAzMDAxID8gci5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEyX0tIUiA6IHIuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTJfS0hSO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChzID09PSAzNjQ5MilcbiAgICAgIGlmIChyID0gZS5nZXQoXCJFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjXCIpLCByICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzID09PSAzNjQ5MilcbiAgICAgICAgICByZXR1cm4gbyA9PT0gMzAwMSA/IHIuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX0JQVENfVU5PUk1fRVhUIDogci5DT01QUkVTU0VEX1JHQkFfQlBUQ19VTk9STV9FWFQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHMgPT09IDEwMjAgPyBuID8gMzQwNDIgOiAociA9IGUuZ2V0KFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKSwgciAhPT0gbnVsbCA/IHIuVU5TSUdORURfSU5UXzI0XzhfV0VCR0wgOiBudWxsKSA6IGhbc10gIT09IHZvaWQgMCA/IGhbc10gOiBudWxsO1xuICB9XG4gIHJldHVybiB7IGNvbnZlcnQ6IGkgfTtcbn1cbmNsYXNzIEx1IGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3RvcihlID0gW10pIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzQXJyYXlDYW1lcmEgPSAhMCwgdGhpcy5jYW1lcmFzID0gZTtcbiAgfVxufVxuY2xhc3MgQmkgZXh0ZW5kcyBhdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuaXNHcm91cCA9ICEwLCB0aGlzLnR5cGUgPSBcIkdyb3VwXCI7XG4gIH1cbn1cbmNvbnN0IFJ1ID0geyB0eXBlOiBcIm1vdmVcIiB9O1xuY2xhc3MgVHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl90YXJnZXRSYXkgPSBudWxsLCB0aGlzLl9ncmlwID0gbnVsbCwgdGhpcy5faGFuZCA9IG51bGw7XG4gIH1cbiAgZ2V0SGFuZFNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl9oYW5kID09PSBudWxsICYmICh0aGlzLl9oYW5kID0gbmV3IEJpKCksIHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZSA9ICExLCB0aGlzLl9oYW5kLnZpc2libGUgPSAhMSwgdGhpcy5faGFuZC5qb2ludHMgPSB7fSwgdGhpcy5faGFuZC5pbnB1dFN0YXRlID0geyBwaW5jaGluZzogITEgfSksIHRoaXMuX2hhbmQ7XG4gIH1cbiAgZ2V0VGFyZ2V0UmF5U3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldFJheSA9PT0gbnVsbCAmJiAodGhpcy5fdGFyZ2V0UmF5ID0gbmV3IEJpKCksIHRoaXMuX3RhcmdldFJheS5tYXRyaXhBdXRvVXBkYXRlID0gITEsIHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gITEsIHRoaXMuX3RhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eSA9ICExLCB0aGlzLl90YXJnZXRSYXkubGluZWFyVmVsb2NpdHkgPSBuZXcgTygpLCB0aGlzLl90YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gITEsIHRoaXMuX3RhcmdldFJheS5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgTygpKSwgdGhpcy5fdGFyZ2V0UmF5O1xuICB9XG4gIGdldEdyaXBTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JpcCA9PT0gbnVsbCAmJiAodGhpcy5fZ3JpcCA9IG5ldyBCaSgpLCB0aGlzLl9ncmlwLm1hdHJpeEF1dG9VcGRhdGUgPSAhMSwgdGhpcy5fZ3JpcC52aXNpYmxlID0gITEsIHRoaXMuX2dyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSAhMSwgdGhpcy5fZ3JpcC5saW5lYXJWZWxvY2l0eSA9IG5ldyBPKCksIHRoaXMuX2dyaXAuaGFzQW5ndWxhclZlbG9jaXR5ID0gITEsIHRoaXMuX2dyaXAuYW5ndWxhclZlbG9jaXR5ID0gbmV3IE8oKSksIHRoaXMuX2dyaXA7XG4gIH1cbiAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldFJheSAhPT0gbnVsbCAmJiB0aGlzLl90YXJnZXRSYXkuZGlzcGF0Y2hFdmVudChlKSwgdGhpcy5fZ3JpcCAhPT0gbnVsbCAmJiB0aGlzLl9ncmlwLmRpc3BhdGNoRXZlbnQoZSksIHRoaXMuX2hhbmQgIT09IG51bGwgJiYgdGhpcy5faGFuZC5kaXNwYXRjaEV2ZW50KGUpLCB0aGlzO1xuICB9XG4gIGRpc2Nvbm5lY3QoZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImRpc2Nvbm5lY3RlZFwiLCBkYXRhOiBlIH0pLCB0aGlzLl90YXJnZXRSYXkgIT09IG51bGwgJiYgKHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gITEpLCB0aGlzLl9ncmlwICE9PSBudWxsICYmICh0aGlzLl9ncmlwLnZpc2libGUgPSAhMSksIHRoaXMuX2hhbmQgIT09IG51bGwgJiYgKHRoaXMuX2hhbmQudmlzaWJsZSA9ICExKSwgdGhpcztcbiAgfVxuICB1cGRhdGUoZSwgdCwgbikge1xuICAgIGxldCBpID0gbnVsbCwgcyA9IG51bGwsIG8gPSBudWxsO1xuICAgIGNvbnN0IHIgPSB0aGlzLl90YXJnZXRSYXksIGwgPSB0aGlzLl9ncmlwLCBhID0gdGhpcy5faGFuZDtcbiAgICBpZiAoZSAmJiB0LnNlc3Npb24udmlzaWJpbGl0eVN0YXRlICE9PSBcInZpc2libGUtYmx1cnJlZFwiKSB7XG4gICAgICBpZiAoYSAmJiBlLmhhbmQpIHtcbiAgICAgICAgbyA9ICEwO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgZS5oYW5kLnZhbHVlcygpKSB7XG4gICAgICAgICAgY29uc3QgZiA9IHQuZ2V0Sm9pbnRQb3NlKHAsIG4pO1xuICAgICAgICAgIGlmIChhLmpvaW50c1twLmpvaW50TmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgXyA9IG5ldyBCaSgpO1xuICAgICAgICAgICAgXy5tYXRyaXhBdXRvVXBkYXRlID0gITEsIF8udmlzaWJsZSA9ICExLCBhLmpvaW50c1twLmpvaW50TmFtZV0gPSBfLCBhLmFkZChfKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdiA9IGEuam9pbnRzW3Auam9pbnROYW1lXTtcbiAgICAgICAgICBmICE9PSBudWxsICYmICh2Lm1hdHJpeC5mcm9tQXJyYXkoZi50cmFuc2Zvcm0ubWF0cml4KSwgdi5tYXRyaXguZGVjb21wb3NlKHYucG9zaXRpb24sIHYucm90YXRpb24sIHYuc2NhbGUpLCB2LmpvaW50UmFkaXVzID0gZi5yYWRpdXMpLCB2LnZpc2libGUgPSBmICE9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBhLmpvaW50c1tcImluZGV4LWZpbmdlci10aXBcIl0sIGQgPSBhLmpvaW50c1tcInRodW1iLXRpcFwiXSwgdSA9IGMucG9zaXRpb24uZGlzdGFuY2VUbyhkLnBvc2l0aW9uKSwgbSA9IDAuMDIsIGcgPSA1ZS0zO1xuICAgICAgICBhLmlucHV0U3RhdGUucGluY2hpbmcgJiYgdSA+IG0gKyBnID8gKGEuaW5wdXRTdGF0ZS5waW5jaGluZyA9ICExLCB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6IFwicGluY2hlbmRcIixcbiAgICAgICAgICBoYW5kZWRuZXNzOiBlLmhhbmRlZG5lc3MsXG4gICAgICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgICAgIH0pKSA6ICFhLmlucHV0U3RhdGUucGluY2hpbmcgJiYgdSA8PSBtIC0gZyAmJiAoYS5pbnB1dFN0YXRlLnBpbmNoaW5nID0gITAsIHRoaXMuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogXCJwaW5jaHN0YXJ0XCIsXG4gICAgICAgICAgaGFuZGVkbmVzczogZS5oYW5kZWRuZXNzLFxuICAgICAgICAgIHRhcmdldDogdGhpc1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbCAhPT0gbnVsbCAmJiBlLmdyaXBTcGFjZSAmJiAocyA9IHQuZ2V0UG9zZShlLmdyaXBTcGFjZSwgbiksIHMgIT09IG51bGwgJiYgKGwubWF0cml4LmZyb21BcnJheShzLnRyYW5zZm9ybS5tYXRyaXgpLCBsLm1hdHJpeC5kZWNvbXBvc2UobC5wb3NpdGlvbiwgbC5yb3RhdGlvbiwgbC5zY2FsZSksIHMubGluZWFyVmVsb2NpdHkgPyAobC5oYXNMaW5lYXJWZWxvY2l0eSA9ICEwLCBsLmxpbmVhclZlbG9jaXR5LmNvcHkocy5saW5lYXJWZWxvY2l0eSkpIDogbC5oYXNMaW5lYXJWZWxvY2l0eSA9ICExLCBzLmFuZ3VsYXJWZWxvY2l0eSA/IChsLmhhc0FuZ3VsYXJWZWxvY2l0eSA9ICEwLCBsLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KHMuYW5ndWxhclZlbG9jaXR5KSkgOiBsLmhhc0FuZ3VsYXJWZWxvY2l0eSA9ICExKSk7XG4gICAgICByICE9PSBudWxsICYmIChpID0gdC5nZXRQb3NlKGUudGFyZ2V0UmF5U3BhY2UsIG4pLCBpID09PSBudWxsICYmIHMgIT09IG51bGwgJiYgKGkgPSBzKSwgaSAhPT0gbnVsbCAmJiAoci5tYXRyaXguZnJvbUFycmF5KGkudHJhbnNmb3JtLm1hdHJpeCksIHIubWF0cml4LmRlY29tcG9zZShyLnBvc2l0aW9uLCByLnJvdGF0aW9uLCByLnNjYWxlKSwgaS5saW5lYXJWZWxvY2l0eSA/IChyLmhhc0xpbmVhclZlbG9jaXR5ID0gITAsIHIubGluZWFyVmVsb2NpdHkuY29weShpLmxpbmVhclZlbG9jaXR5KSkgOiByLmhhc0xpbmVhclZlbG9jaXR5ID0gITEsIGkuYW5ndWxhclZlbG9jaXR5ID8gKHIuaGFzQW5ndWxhclZlbG9jaXR5ID0gITAsIHIuYW5ndWxhclZlbG9jaXR5LmNvcHkoaS5hbmd1bGFyVmVsb2NpdHkpKSA6IHIuaGFzQW5ndWxhclZlbG9jaXR5ID0gITEsIHRoaXMuZGlzcGF0Y2hFdmVudChSdSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHIgIT09IG51bGwgJiYgKHIudmlzaWJsZSA9IGkgIT09IG51bGwpLCBsICE9PSBudWxsICYmIChsLnZpc2libGUgPSBzICE9PSBudWxsKSwgYSAhPT0gbnVsbCAmJiAoYS52aXNpYmxlID0gbyAhPT0gbnVsbCksIHRoaXM7XG4gIH1cbn1cbmNsYXNzIEZ1IGV4dGVuZHMgX3Qge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjKSB7XG4gICAgaWYgKGMgPSBjICE9PSB2b2lkIDAgPyBjIDogMTAyNiwgYyAhPT0gMTAyNiAmJiBjICE9PSAxMDI3KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXRcIik7XG4gICAgbiA9PT0gdm9pZCAwICYmIGMgPT09IDEwMjYgJiYgKG4gPSAxMDE0KSwgbiA9PT0gdm9pZCAwICYmIGMgPT09IDEwMjcgJiYgKG4gPSAxMDIwKSwgc3VwZXIobnVsbCwgaSwgcywgbywgciwgbCwgYywgbiwgYSksIHRoaXMuaXNEZXB0aFRleHR1cmUgPSAhMCwgdGhpcy5pbWFnZSA9IHsgd2lkdGg6IGUsIGhlaWdodDogdCB9LCB0aGlzLm1hZ0ZpbHRlciA9IHIgIT09IHZvaWQgMCA/IHIgOiAxMDAzLCB0aGlzLm1pbkZpbHRlciA9IGwgIT09IHZvaWQgMCA/IGwgOiAxMDAzLCB0aGlzLmZsaXBZID0gITEsIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gITE7XG4gIH1cbn1cbmNsYXNzIER1IGV4dGVuZHMgJG4ge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBuID0gdGhpcztcbiAgICBsZXQgaSA9IG51bGwsIHMgPSAxLCBvID0gbnVsbCwgciA9IFwibG9jYWwtZmxvb3JcIiwgbCA9IG51bGwsIGEgPSBudWxsLCBjID0gbnVsbCwgZCA9IG51bGwsIHUgPSBudWxsLCBtID0gbnVsbDtcbiAgICBjb25zdCBnID0gdC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIGxldCBwID0gbnVsbCwgZiA9IG51bGw7XG4gICAgY29uc3QgdiA9IFtdLCBfID0gW10sIHcgPSBuZXcgZ3QoKTtcbiAgICB3LmxheWVycy5lbmFibGUoMSksIHcudmlld3BvcnQgPSBuZXcgJGUoKTtcbiAgICBjb25zdCB4ID0gbmV3IGd0KCk7XG4gICAgeC5sYXllcnMuZW5hYmxlKDIpLCB4LnZpZXdwb3J0ID0gbmV3ICRlKCk7XG4gICAgY29uc3QgTSA9IFt3LCB4XSwgRSA9IG5ldyBMdSgpO1xuICAgIEUubGF5ZXJzLmVuYWJsZSgxKSwgRS5sYXllcnMuZW5hYmxlKDIpO1xuICAgIGxldCBSID0gbnVsbCwgeSA9IG51bGw7XG4gICAgdGhpcy5jYW1lcmFBdXRvVXBkYXRlID0gITAsIHRoaXMuZW5hYmxlZCA9ICExLCB0aGlzLmlzUHJlc2VudGluZyA9ICExLCB0aGlzLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihOKSB7XG4gICAgICBsZXQgSCA9IHZbTl07XG4gICAgICByZXR1cm4gSCA9PT0gdm9pZCAwICYmIChIID0gbmV3IFRzKCksIHZbTl0gPSBIKSwgSC5nZXRUYXJnZXRSYXlTcGFjZSgpO1xuICAgIH0sIHRoaXMuZ2V0Q29udHJvbGxlckdyaXAgPSBmdW5jdGlvbihOKSB7XG4gICAgICBsZXQgSCA9IHZbTl07XG4gICAgICByZXR1cm4gSCA9PT0gdm9pZCAwICYmIChIID0gbmV3IFRzKCksIHZbTl0gPSBIKSwgSC5nZXRHcmlwU3BhY2UoKTtcbiAgICB9LCB0aGlzLmdldEhhbmQgPSBmdW5jdGlvbihOKSB7XG4gICAgICBsZXQgSCA9IHZbTl07XG4gICAgICByZXR1cm4gSCA9PT0gdm9pZCAwICYmIChIID0gbmV3IFRzKCksIHZbTl0gPSBIKSwgSC5nZXRIYW5kU3BhY2UoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEEoTikge1xuICAgICAgY29uc3QgSCA9IF8uaW5kZXhPZihOLmlucHV0U291cmNlKTtcbiAgICAgIGlmIChIID09PSAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgSiA9IHZbSF07XG4gICAgICBKICE9PSB2b2lkIDAgJiYgSi5kaXNwYXRjaEV2ZW50KHsgdHlwZTogTi50eXBlLCBkYXRhOiBOLmlucHV0U291cmNlIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGKCkge1xuICAgICAgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0XCIsIEEpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLCBBKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0ZW5kXCIsIEEpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzcXVlZXplXCIsIEEpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzcXVlZXplc3RhcnRcIiwgQSksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNxdWVlemVlbmRcIiwgQSksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZFwiLCBGKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRzb3VyY2VzY2hhbmdlXCIsIFApO1xuICAgICAgZm9yIChsZXQgTiA9IDA7IE4gPCB2Lmxlbmd0aDsgTisrKSB7XG4gICAgICAgIGNvbnN0IEggPSBfW05dO1xuICAgICAgICBIICE9PSBudWxsICYmIChfW05dID0gbnVsbCwgdltOXS5kaXNjb25uZWN0KEgpKTtcbiAgICAgIH1cbiAgICAgIFIgPSBudWxsLCB5ID0gbnVsbCwgZS5zZXRSZW5kZXJUYXJnZXQocCksIHUgPSBudWxsLCBkID0gbnVsbCwgYyA9IG51bGwsIGkgPSBudWxsLCBmID0gbnVsbCwgay5zdG9wKCksIG4uaXNQcmVzZW50aW5nID0gITEsIG4uZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwic2Vzc2lvbmVuZFwiIH0pO1xuICAgIH1cbiAgICB0aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSBmdW5jdGlvbihOKSB7XG4gICAgICBzID0gTiwgbi5pc1ByZXNlbnRpbmcgPT09ICEwICYmIGNvbnNvbGUud2FybihcIlRIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzY2FsZSB3aGlsZSBwcmVzZW50aW5nLlwiKTtcbiAgICB9LCB0aGlzLnNldFJlZmVyZW5jZVNwYWNlVHlwZSA9IGZ1bmN0aW9uKE4pIHtcbiAgICAgIHIgPSBOLCBuLmlzUHJlc2VudGluZyA9PT0gITAgJiYgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViWFJNYW5hZ2VyOiBDYW5ub3QgY2hhbmdlIHJlZmVyZW5jZSBzcGFjZSB0eXBlIHdoaWxlIHByZXNlbnRpbmcuXCIpO1xuICAgIH0sIHRoaXMuZ2V0UmVmZXJlbmNlU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsIHx8IG87XG4gICAgfSwgdGhpcy5zZXRSZWZlcmVuY2VTcGFjZSA9IGZ1bmN0aW9uKE4pIHtcbiAgICAgIGwgPSBOO1xuICAgIH0sIHRoaXMuZ2V0QmFzZUxheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZCAhPT0gbnVsbCA/IGQgOiB1O1xuICAgIH0sIHRoaXMuZ2V0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSwgdGhpcy5nZXRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG07XG4gICAgfSwgdGhpcy5nZXRTZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9LCB0aGlzLnNldFNlc3Npb24gPSBhc3luYyBmdW5jdGlvbihOKSB7XG4gICAgICBpZiAoaSA9IE4sIGkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHAgPSBlLmdldFJlbmRlclRhcmdldCgpLCBpLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RcIiwgQSksIGkuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIEEpLCBpLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RlbmRcIiwgQSksIGkuYWRkRXZlbnRMaXN0ZW5lcihcInNxdWVlemVcIiwgQSksIGkuYWRkRXZlbnRMaXN0ZW5lcihcInNxdWVlemVzdGFydFwiLCBBKSwgaS5hZGRFdmVudExpc3RlbmVyKFwic3F1ZWV6ZWVuZFwiLCBBKSwgaS5hZGRFdmVudExpc3RlbmVyKFwiZW5kXCIsIEYpLCBpLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dHNvdXJjZXNjaGFuZ2VcIiwgUCksIGcueHJDb21wYXRpYmxlICE9PSAhMCAmJiBhd2FpdCB0Lm1ha2VYUkNvbXBhdGlibGUoKSwgaS5yZW5kZXJTdGF0ZS5sYXllcnMgPT09IHZvaWQgMCB8fCBlLmNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gITEpIHtcbiAgICAgICAgICBjb25zdCBIID0ge1xuICAgICAgICAgICAgYW50aWFsaWFzOiBpLnJlbmRlclN0YXRlLmxheWVycyA9PT0gdm9pZCAwID8gZy5hbnRpYWxpYXMgOiAhMCxcbiAgICAgICAgICAgIGFscGhhOiBnLmFscGhhLFxuICAgICAgICAgICAgZGVwdGg6IGcuZGVwdGgsXG4gICAgICAgICAgICBzdGVuY2lsOiBnLnN0ZW5jaWwsXG4gICAgICAgICAgICBmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yOiBzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB1ID0gbmV3IFhSV2ViR0xMYXllcihpLCB0LCBIKSwgaS51cGRhdGVSZW5kZXJTdGF0ZSh7IGJhc2VMYXllcjogdSB9KSwgZiA9IG5ldyBFbihcbiAgICAgICAgICAgIHUuZnJhbWVidWZmZXJXaWR0aCxcbiAgICAgICAgICAgIHUuZnJhbWVidWZmZXJIZWlnaHQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvcm1hdDogMTAyMyxcbiAgICAgICAgICAgICAgdHlwZTogMTAwOSxcbiAgICAgICAgICAgICAgZW5jb2Rpbmc6IGUub3V0cHV0RW5jb2RpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBIID0gbnVsbCwgSiA9IG51bGwsIFYgPSBudWxsO1xuICAgICAgICAgIGcuZGVwdGggJiYgKFYgPSBnLnN0ZW5jaWwgPyAzNTA1NiA6IDMzMTkwLCBIID0gZy5zdGVuY2lsID8gMTAyNyA6IDEwMjYsIEogPSBnLnN0ZW5jaWwgPyAxMDIwIDogMTAxNCk7XG4gICAgICAgICAgY29uc3QgZWUgPSB7XG4gICAgICAgICAgICBjb2xvckZvcm1hdDogMzI4NTYsXG4gICAgICAgICAgICBkZXB0aEZvcm1hdDogVixcbiAgICAgICAgICAgIHNjYWxlRmFjdG9yOiBzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjID0gbmV3IFhSV2ViR0xCaW5kaW5nKGksIHQpLCBkID0gYy5jcmVhdGVQcm9qZWN0aW9uTGF5ZXIoZWUpLCBpLnVwZGF0ZVJlbmRlclN0YXRlKHsgbGF5ZXJzOiBbZF0gfSksIGYgPSBuZXcgRW4oXG4gICAgICAgICAgICBkLnRleHR1cmVXaWR0aCxcbiAgICAgICAgICAgIGQudGV4dHVyZUhlaWdodCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZm9ybWF0OiAxMDIzLFxuICAgICAgICAgICAgICB0eXBlOiAxMDA5LFxuICAgICAgICAgICAgICBkZXB0aFRleHR1cmU6IG5ldyBGdShkLnRleHR1cmVXaWR0aCwgZC50ZXh0dXJlSGVpZ2h0LCBKLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBIKSxcbiAgICAgICAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZy5zdGVuY2lsLFxuICAgICAgICAgICAgICBlbmNvZGluZzogZS5vdXRwdXRFbmNvZGluZyxcbiAgICAgICAgICAgICAgc2FtcGxlczogZy5hbnRpYWxpYXMgPyA0IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgY2UgPSBlLnByb3BlcnRpZXMuZ2V0KGYpO1xuICAgICAgICAgIGNlLl9faWdub3JlRGVwdGhWYWx1ZXMgPSBkLmlnbm9yZURlcHRoVmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGYuaXNYUlJlbmRlclRhcmdldCA9ICEwLCB0aGlzLnNldEZvdmVhdGlvbigxKSwgbCA9IG51bGwsIG8gPSBhd2FpdCBpLnJlcXVlc3RSZWZlcmVuY2VTcGFjZShyKSwgay5zZXRDb250ZXh0KGkpLCBrLnN0YXJ0KCksIG4uaXNQcmVzZW50aW5nID0gITAsIG4uZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwic2Vzc2lvbnN0YXJ0XCIgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBQKE4pIHtcbiAgICAgIGZvciAobGV0IEggPSAwOyBIIDwgTi5yZW1vdmVkLmxlbmd0aDsgSCsrKSB7XG4gICAgICAgIGNvbnN0IEogPSBOLnJlbW92ZWRbSF0sIFYgPSBfLmluZGV4T2YoSik7XG4gICAgICAgIFYgPj0gMCAmJiAoX1tWXSA9IG51bGwsIHZbVl0uZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiZGlzY29ubmVjdGVkXCIsIGRhdGE6IEogfSkpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgSCA9IDA7IEggPCBOLmFkZGVkLmxlbmd0aDsgSCsrKSB7XG4gICAgICAgIGNvbnN0IEogPSBOLmFkZGVkW0hdO1xuICAgICAgICBsZXQgViA9IF8uaW5kZXhPZihKKTtcbiAgICAgICAgaWYgKFYgPT09IC0xKSB7XG4gICAgICAgICAgZm9yIChsZXQgY2UgPSAwOyBjZSA8IHYubGVuZ3RoOyBjZSsrKVxuICAgICAgICAgICAgaWYgKGNlID49IF8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIF8ucHVzaChKKSwgViA9IGNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX1tjZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgX1tjZV0gPSBKLCBWID0gY2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChWID09PSAtMSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVlID0gdltWXTtcbiAgICAgICAgZWUgJiYgZWUuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY29ubmVjdGVkXCIsIGRhdGE6IEogfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IEcgPSBuZXcgTygpLCB6ID0gbmV3IE8oKTtcbiAgICBmdW5jdGlvbiBMKE4sIEgsIEopIHtcbiAgICAgIEcuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKEgubWF0cml4V29ybGQpLCB6LnNldEZyb21NYXRyaXhQb3NpdGlvbihKLm1hdHJpeFdvcmxkKTtcbiAgICAgIGNvbnN0IFYgPSBHLmRpc3RhbmNlVG8oeiksIGVlID0gSC5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzLCBjZSA9IEoucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cywgZ2UgPSBlZVsxNF0gLyAoZWVbMTBdIC0gMSksICQgPSBlZVsxNF0gLyAoZWVbMTBdICsgMSksIERlID0gKGVlWzldICsgMSkgLyBlZVs1XSwgdmUgPSAoZWVbOV0gLSAxKSAvIGVlWzVdLCB4ZSA9IChlZVs4XSAtIDEpIC8gZWVbMF0sIHVlID0gKGNlWzhdICsgMSkgLyBjZVswXSwgT2UgPSBnZSAqIHhlLCBFZSA9IGdlICogdWUsIG1lID0gViAvICgteGUgKyB1ZSksIGV0ID0gbWUgKiAteGU7XG4gICAgICBILm1hdHJpeFdvcmxkLmRlY29tcG9zZShOLnBvc2l0aW9uLCBOLnF1YXRlcm5pb24sIE4uc2NhbGUpLCBOLnRyYW5zbGF0ZVgoZXQpLCBOLnRyYW5zbGF0ZVoobWUpLCBOLm1hdHJpeFdvcmxkLmNvbXBvc2UoTi5wb3NpdGlvbiwgTi5xdWF0ZXJuaW9uLCBOLnNjYWxlKSwgTi5tYXRyaXhXb3JsZEludmVyc2UuY29weShOLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgIGNvbnN0IHV0ID0gZ2UgKyBtZSwgcnQgPSAkICsgbWUsIFJ0ID0gT2UgLSBldCwgdHQgPSBFZSArIChWIC0gZXQpLCBOZSA9IERlICogJCAvIHJ0ICogdXQsIEd0ID0gdmUgKiAkIC8gcnQgKiB1dDtcbiAgICAgIE4ucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoUnQsIHR0LCBOZSwgR3QsIHV0LCBydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEkoTiwgSCkge1xuICAgICAgSCA9PT0gbnVsbCA/IE4ubWF0cml4V29ybGQuY29weShOLm1hdHJpeCkgOiBOLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoSC5tYXRyaXhXb3JsZCwgTi5tYXRyaXgpLCBOLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KE4ubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNhbWVyYSA9IGZ1bmN0aW9uKE4pIHtcbiAgICAgIGlmIChpID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBFLm5lYXIgPSB4Lm5lYXIgPSB3Lm5lYXIgPSBOLm5lYXIsIEUuZmFyID0geC5mYXIgPSB3LmZhciA9IE4uZmFyLCAoUiAhPT0gRS5uZWFyIHx8IHkgIT09IEUuZmFyKSAmJiAoaS51cGRhdGVSZW5kZXJTdGF0ZSh7XG4gICAgICAgIGRlcHRoTmVhcjogRS5uZWFyLFxuICAgICAgICBkZXB0aEZhcjogRS5mYXJcbiAgICAgIH0pLCBSID0gRS5uZWFyLCB5ID0gRS5mYXIpO1xuICAgICAgY29uc3QgSCA9IE4ucGFyZW50LCBKID0gRS5jYW1lcmFzO1xuICAgICAgSShFLCBIKTtcbiAgICAgIGZvciAobGV0IGVlID0gMDsgZWUgPCBKLmxlbmd0aDsgZWUrKylcbiAgICAgICAgSShKW2VlXSwgSCk7XG4gICAgICBFLm1hdHJpeFdvcmxkLmRlY29tcG9zZShFLnBvc2l0aW9uLCBFLnF1YXRlcm5pb24sIEUuc2NhbGUpLCBOLnBvc2l0aW9uLmNvcHkoRS5wb3NpdGlvbiksIE4ucXVhdGVybmlvbi5jb3B5KEUucXVhdGVybmlvbiksIE4uc2NhbGUuY29weShFLnNjYWxlKSwgTi5tYXRyaXguY29weShFLm1hdHJpeCksIE4ubWF0cml4V29ybGQuY29weShFLm1hdHJpeFdvcmxkKTtcbiAgICAgIGNvbnN0IFYgPSBOLmNoaWxkcmVuO1xuICAgICAgZm9yIChsZXQgZWUgPSAwLCBjZSA9IFYubGVuZ3RoOyBlZSA8IGNlOyBlZSsrKVxuICAgICAgICBWW2VlXS51cGRhdGVNYXRyaXhXb3JsZCghMCk7XG4gICAgICBKLmxlbmd0aCA9PT0gMiA/IEwoRSwgdywgeCkgOiBFLnByb2plY3Rpb25NYXRyaXguY29weSh3LnByb2plY3Rpb25NYXRyaXgpO1xuICAgIH0sIHRoaXMuZ2V0Q2FtZXJhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRTtcbiAgICB9LCB0aGlzLmdldEZvdmVhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGQgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBkLmZpeGVkRm92ZWF0aW9uO1xuICAgICAgaWYgKHUgIT09IG51bGwpXG4gICAgICAgIHJldHVybiB1LmZpeGVkRm92ZWF0aW9uO1xuICAgIH0sIHRoaXMuc2V0Rm92ZWF0aW9uID0gZnVuY3Rpb24oTikge1xuICAgICAgZCAhPT0gbnVsbCAmJiAoZC5maXhlZEZvdmVhdGlvbiA9IE4pLCB1ICE9PSBudWxsICYmIHUuZml4ZWRGb3ZlYXRpb24gIT09IHZvaWQgMCAmJiAodS5maXhlZEZvdmVhdGlvbiA9IE4pO1xuICAgIH07XG4gICAgbGV0IEQgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHEoTiwgSCkge1xuICAgICAgaWYgKGEgPSBILmdldFZpZXdlclBvc2UobCB8fCBvKSwgbSA9IEgsIGEgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgSiA9IGEudmlld3M7XG4gICAgICAgIHUgIT09IG51bGwgJiYgKGUuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXIoZiwgdS5mcmFtZWJ1ZmZlciksIGUuc2V0UmVuZGVyVGFyZ2V0KGYpKTtcbiAgICAgICAgbGV0IFYgPSAhMTtcbiAgICAgICAgSi5sZW5ndGggIT09IEUuY2FtZXJhcy5sZW5ndGggJiYgKEUuY2FtZXJhcy5sZW5ndGggPSAwLCBWID0gITApO1xuICAgICAgICBmb3IgKGxldCBlZSA9IDA7IGVlIDwgSi5sZW5ndGg7IGVlKyspIHtcbiAgICAgICAgICBjb25zdCBjZSA9IEpbZWVdO1xuICAgICAgICAgIGxldCBnZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHUgIT09IG51bGwpXG4gICAgICAgICAgICBnZSA9IHUuZ2V0Vmlld3BvcnQoY2UpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgRGUgPSBjLmdldFZpZXdTdWJJbWFnZShkLCBjZSk7XG4gICAgICAgICAgICBnZSA9IERlLnZpZXdwb3J0LCBlZSA9PT0gMCAmJiAoZS5zZXRSZW5kZXJUYXJnZXRUZXh0dXJlcyhcbiAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgRGUuY29sb3JUZXh0dXJlLFxuICAgICAgICAgICAgICBkLmlnbm9yZURlcHRoVmFsdWVzID8gdm9pZCAwIDogRGUuZGVwdGhTdGVuY2lsVGV4dHVyZVxuICAgICAgICAgICAgKSwgZS5zZXRSZW5kZXJUYXJnZXQoZikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgJCA9IE1bZWVdO1xuICAgICAgICAgICQgPT09IHZvaWQgMCAmJiAoJCA9IG5ldyBndCgpLCAkLmxheWVycy5lbmFibGUoZWUpLCAkLnZpZXdwb3J0ID0gbmV3ICRlKCksIE1bZWVdID0gJCksICQubWF0cml4LmZyb21BcnJheShjZS50cmFuc2Zvcm0ubWF0cml4KSwgJC5wcm9qZWN0aW9uTWF0cml4LmZyb21BcnJheShjZS5wcm9qZWN0aW9uTWF0cml4KSwgJC52aWV3cG9ydC5zZXQoZ2UueCwgZ2UueSwgZ2Uud2lkdGgsIGdlLmhlaWdodCksIGVlID09PSAwICYmIEUubWF0cml4LmNvcHkoJC5tYXRyaXgpLCBWID09PSAhMCAmJiBFLmNhbWVyYXMucHVzaCgkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgSiA9IDA7IEogPCB2Lmxlbmd0aDsgSisrKSB7XG4gICAgICAgIGNvbnN0IFYgPSBfW0pdLCBlZSA9IHZbSl07XG4gICAgICAgIFYgIT09IG51bGwgJiYgZWUgIT09IHZvaWQgMCAmJiBlZS51cGRhdGUoViwgSCwgbCB8fCBvKTtcbiAgICAgIH1cbiAgICAgIEQgJiYgRChOLCBIKSwgbSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGsgPSBuZXcgZm8oKTtcbiAgICBrLnNldEFuaW1hdGlvbkxvb3AocSksIHRoaXMuc2V0QW5pbWF0aW9uTG9vcCA9IGZ1bmN0aW9uKE4pIHtcbiAgICAgIEQgPSBOO1xuICAgIH0sIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIFB1KGgsIGUpIHtcbiAgZnVuY3Rpb24gdChwLCBmKSB7XG4gICAgcC5mb2dDb2xvci52YWx1ZS5jb3B5KGYuY29sb3IpLCBmLmlzRm9nID8gKHAuZm9nTmVhci52YWx1ZSA9IGYubmVhciwgcC5mb2dGYXIudmFsdWUgPSBmLmZhcikgOiBmLmlzRm9nRXhwMiAmJiAocC5mb2dEZW5zaXR5LnZhbHVlID0gZi5kZW5zaXR5KTtcbiAgfVxuICBmdW5jdGlvbiBuKHAsIGYsIHYsIF8sIHcpIHtcbiAgICBmLmlzTWVzaEJhc2ljTWF0ZXJpYWwgfHwgZi5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgPyBpKHAsIGYpIDogZi5pc01lc2hUb29uTWF0ZXJpYWwgPyAoaShwLCBmKSwgYyhwLCBmKSkgOiBmLmlzTWVzaFBob25nTWF0ZXJpYWwgPyAoaShwLCBmKSwgYShwLCBmKSkgOiBmLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyAoaShwLCBmKSwgZChwLCBmKSwgZi5pc01lc2hQaHlzaWNhbE1hdGVyaWFsICYmIHUocCwgZiwgdykpIDogZi5pc01lc2hNYXRjYXBNYXRlcmlhbCA/IChpKHAsIGYpLCBtKHAsIGYpKSA6IGYuaXNNZXNoRGVwdGhNYXRlcmlhbCA/IGkocCwgZikgOiBmLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgPyAoaShwLCBmKSwgZyhwLCBmKSkgOiBmLmlzTWVzaE5vcm1hbE1hdGVyaWFsID8gaShwLCBmKSA6IGYuaXNMaW5lQmFzaWNNYXRlcmlhbCA/IChzKHAsIGYpLCBmLmlzTGluZURhc2hlZE1hdGVyaWFsICYmIG8ocCwgZikpIDogZi5pc1BvaW50c01hdGVyaWFsID8gcihwLCBmLCB2LCBfKSA6IGYuaXNTcHJpdGVNYXRlcmlhbCA/IGwocCwgZikgOiBmLmlzU2hhZG93TWF0ZXJpYWwgPyAocC5jb2xvci52YWx1ZS5jb3B5KGYuY29sb3IpLCBwLm9wYWNpdHkudmFsdWUgPSBmLm9wYWNpdHkpIDogZi5pc1NoYWRlck1hdGVyaWFsICYmIChmLnVuaWZvcm1zTmVlZFVwZGF0ZSA9ICExKTtcbiAgfVxuICBmdW5jdGlvbiBpKHAsIGYpIHtcbiAgICBwLm9wYWNpdHkudmFsdWUgPSBmLm9wYWNpdHksIGYuY29sb3IgJiYgcC5kaWZmdXNlLnZhbHVlLmNvcHkoZi5jb2xvciksIGYuZW1pc3NpdmUgJiYgcC5lbWlzc2l2ZS52YWx1ZS5jb3B5KGYuZW1pc3NpdmUpLm11bHRpcGx5U2NhbGFyKGYuZW1pc3NpdmVJbnRlbnNpdHkpLCBmLm1hcCAmJiAocC5tYXAudmFsdWUgPSBmLm1hcCksIGYuYWxwaGFNYXAgJiYgKHAuYWxwaGFNYXAudmFsdWUgPSBmLmFscGhhTWFwKSwgZi5idW1wTWFwICYmIChwLmJ1bXBNYXAudmFsdWUgPSBmLmJ1bXBNYXAsIHAuYnVtcFNjYWxlLnZhbHVlID0gZi5idW1wU2NhbGUsIGYuc2lkZSA9PT0gMSAmJiAocC5idW1wU2NhbGUudmFsdWUgKj0gLTEpKSwgZi5kaXNwbGFjZW1lbnRNYXAgJiYgKHAuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gZi5kaXNwbGFjZW1lbnRNYXAsIHAuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBmLmRpc3BsYWNlbWVudFNjYWxlLCBwLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBmLmRpc3BsYWNlbWVudEJpYXMpLCBmLmVtaXNzaXZlTWFwICYmIChwLmVtaXNzaXZlTWFwLnZhbHVlID0gZi5lbWlzc2l2ZU1hcCksIGYubm9ybWFsTWFwICYmIChwLm5vcm1hbE1hcC52YWx1ZSA9IGYubm9ybWFsTWFwLCBwLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoZi5ub3JtYWxTY2FsZSksIGYuc2lkZSA9PT0gMSAmJiBwLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKSwgZi5zcGVjdWxhck1hcCAmJiAocC5zcGVjdWxhck1hcC52YWx1ZSA9IGYuc3BlY3VsYXJNYXApLCBmLmFscGhhVGVzdCA+IDAgJiYgKHAuYWxwaGFUZXN0LnZhbHVlID0gZi5hbHBoYVRlc3QpO1xuICAgIGNvbnN0IHYgPSBlLmdldChmKS5lbnZNYXA7XG4gICAgaWYgKHYgJiYgKHAuZW52TWFwLnZhbHVlID0gdiwgcC5mbGlwRW52TWFwLnZhbHVlID0gdi5pc0N1YmVUZXh0dXJlICYmIHYuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSAhMSA/IC0xIDogMSwgcC5yZWZsZWN0aXZpdHkudmFsdWUgPSBmLnJlZmxlY3Rpdml0eSwgcC5pb3IudmFsdWUgPSBmLmlvciwgcC5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBmLnJlZnJhY3Rpb25SYXRpbyksIGYubGlnaHRNYXApIHtcbiAgICAgIHAubGlnaHRNYXAudmFsdWUgPSBmLmxpZ2h0TWFwO1xuICAgICAgY29uc3QgeCA9IGgucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgIT09ICEwID8gTWF0aC5QSSA6IDE7XG4gICAgICBwLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gZi5saWdodE1hcEludGVuc2l0eSAqIHg7XG4gICAgfVxuICAgIGYuYW9NYXAgJiYgKHAuYW9NYXAudmFsdWUgPSBmLmFvTWFwLCBwLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gZi5hb01hcEludGVuc2l0eSk7XG4gICAgbGV0IF87XG4gICAgZi5tYXAgPyBfID0gZi5tYXAgOiBmLnNwZWN1bGFyTWFwID8gXyA9IGYuc3BlY3VsYXJNYXAgOiBmLmRpc3BsYWNlbWVudE1hcCA/IF8gPSBmLmRpc3BsYWNlbWVudE1hcCA6IGYubm9ybWFsTWFwID8gXyA9IGYubm9ybWFsTWFwIDogZi5idW1wTWFwID8gXyA9IGYuYnVtcE1hcCA6IGYucm91Z2huZXNzTWFwID8gXyA9IGYucm91Z2huZXNzTWFwIDogZi5tZXRhbG5lc3NNYXAgPyBfID0gZi5tZXRhbG5lc3NNYXAgOiBmLmFscGhhTWFwID8gXyA9IGYuYWxwaGFNYXAgOiBmLmVtaXNzaXZlTWFwID8gXyA9IGYuZW1pc3NpdmVNYXAgOiBmLmNsZWFyY29hdE1hcCA/IF8gPSBmLmNsZWFyY29hdE1hcCA6IGYuY2xlYXJjb2F0Tm9ybWFsTWFwID8gXyA9IGYuY2xlYXJjb2F0Tm9ybWFsTWFwIDogZi5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPyBfID0gZi5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgOiBmLmlyaWRlc2NlbmNlTWFwID8gXyA9IGYuaXJpZGVzY2VuY2VNYXAgOiBmLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID8gXyA9IGYuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgOiBmLnNwZWN1bGFySW50ZW5zaXR5TWFwID8gXyA9IGYuc3BlY3VsYXJJbnRlbnNpdHlNYXAgOiBmLnNwZWN1bGFyQ29sb3JNYXAgPyBfID0gZi5zcGVjdWxhckNvbG9yTWFwIDogZi50cmFuc21pc3Npb25NYXAgPyBfID0gZi50cmFuc21pc3Npb25NYXAgOiBmLnRoaWNrbmVzc01hcCA/IF8gPSBmLnRoaWNrbmVzc01hcCA6IGYuc2hlZW5Db2xvck1hcCA/IF8gPSBmLnNoZWVuQ29sb3JNYXAgOiBmLnNoZWVuUm91Z2huZXNzTWFwICYmIChfID0gZi5zaGVlblJvdWdobmVzc01hcCksIF8gIT09IHZvaWQgMCAmJiAoXy5pc1dlYkdMUmVuZGVyVGFyZ2V0ICYmIChfID0gXy50ZXh0dXJlKSwgXy5tYXRyaXhBdXRvVXBkYXRlID09PSAhMCAmJiBfLnVwZGF0ZU1hdHJpeCgpLCBwLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkoXy5tYXRyaXgpKTtcbiAgICBsZXQgdztcbiAgICBmLmFvTWFwID8gdyA9IGYuYW9NYXAgOiBmLmxpZ2h0TWFwICYmICh3ID0gZi5saWdodE1hcCksIHcgIT09IHZvaWQgMCAmJiAody5pc1dlYkdMUmVuZGVyVGFyZ2V0ICYmICh3ID0gdy50ZXh0dXJlKSwgdy5tYXRyaXhBdXRvVXBkYXRlID09PSAhMCAmJiB3LnVwZGF0ZU1hdHJpeCgpLCBwLnV2MlRyYW5zZm9ybS52YWx1ZS5jb3B5KHcubWF0cml4KSk7XG4gIH1cbiAgZnVuY3Rpb24gcyhwLCBmKSB7XG4gICAgcC5kaWZmdXNlLnZhbHVlLmNvcHkoZi5jb2xvciksIHAub3BhY2l0eS52YWx1ZSA9IGYub3BhY2l0eTtcbiAgfVxuICBmdW5jdGlvbiBvKHAsIGYpIHtcbiAgICBwLmRhc2hTaXplLnZhbHVlID0gZi5kYXNoU2l6ZSwgcC50b3RhbFNpemUudmFsdWUgPSBmLmRhc2hTaXplICsgZi5nYXBTaXplLCBwLnNjYWxlLnZhbHVlID0gZi5zY2FsZTtcbiAgfVxuICBmdW5jdGlvbiByKHAsIGYsIHYsIF8pIHtcbiAgICBwLmRpZmZ1c2UudmFsdWUuY29weShmLmNvbG9yKSwgcC5vcGFjaXR5LnZhbHVlID0gZi5vcGFjaXR5LCBwLnNpemUudmFsdWUgPSBmLnNpemUgKiB2LCBwLnNjYWxlLnZhbHVlID0gXyAqIDAuNSwgZi5tYXAgJiYgKHAubWFwLnZhbHVlID0gZi5tYXApLCBmLmFscGhhTWFwICYmIChwLmFscGhhTWFwLnZhbHVlID0gZi5hbHBoYU1hcCksIGYuYWxwaGFUZXN0ID4gMCAmJiAocC5hbHBoYVRlc3QudmFsdWUgPSBmLmFscGhhVGVzdCk7XG4gICAgbGV0IHc7XG4gICAgZi5tYXAgPyB3ID0gZi5tYXAgOiBmLmFscGhhTWFwICYmICh3ID0gZi5hbHBoYU1hcCksIHcgIT09IHZvaWQgMCAmJiAody5tYXRyaXhBdXRvVXBkYXRlID09PSAhMCAmJiB3LnVwZGF0ZU1hdHJpeCgpLCBwLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkody5tYXRyaXgpKTtcbiAgfVxuICBmdW5jdGlvbiBsKHAsIGYpIHtcbiAgICBwLmRpZmZ1c2UudmFsdWUuY29weShmLmNvbG9yKSwgcC5vcGFjaXR5LnZhbHVlID0gZi5vcGFjaXR5LCBwLnJvdGF0aW9uLnZhbHVlID0gZi5yb3RhdGlvbiwgZi5tYXAgJiYgKHAubWFwLnZhbHVlID0gZi5tYXApLCBmLmFscGhhTWFwICYmIChwLmFscGhhTWFwLnZhbHVlID0gZi5hbHBoYU1hcCksIGYuYWxwaGFUZXN0ID4gMCAmJiAocC5hbHBoYVRlc3QudmFsdWUgPSBmLmFscGhhVGVzdCk7XG4gICAgbGV0IHY7XG4gICAgZi5tYXAgPyB2ID0gZi5tYXAgOiBmLmFscGhhTWFwICYmICh2ID0gZi5hbHBoYU1hcCksIHYgIT09IHZvaWQgMCAmJiAodi5tYXRyaXhBdXRvVXBkYXRlID09PSAhMCAmJiB2LnVwZGF0ZU1hdHJpeCgpLCBwLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkodi5tYXRyaXgpKTtcbiAgfVxuICBmdW5jdGlvbiBhKHAsIGYpIHtcbiAgICBwLnNwZWN1bGFyLnZhbHVlLmNvcHkoZi5zcGVjdWxhciksIHAuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgoZi5zaGluaW5lc3MsIDFlLTQpO1xuICB9XG4gIGZ1bmN0aW9uIGMocCwgZikge1xuICAgIGYuZ3JhZGllbnRNYXAgJiYgKHAuZ3JhZGllbnRNYXAudmFsdWUgPSBmLmdyYWRpZW50TWFwKTtcbiAgfVxuICBmdW5jdGlvbiBkKHAsIGYpIHtcbiAgICBwLnJvdWdobmVzcy52YWx1ZSA9IGYucm91Z2huZXNzLCBwLm1ldGFsbmVzcy52YWx1ZSA9IGYubWV0YWxuZXNzLCBmLnJvdWdobmVzc01hcCAmJiAocC5yb3VnaG5lc3NNYXAudmFsdWUgPSBmLnJvdWdobmVzc01hcCksIGYubWV0YWxuZXNzTWFwICYmIChwLm1ldGFsbmVzc01hcC52YWx1ZSA9IGYubWV0YWxuZXNzTWFwKSwgZS5nZXQoZikuZW52TWFwICYmIChwLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IGYuZW52TWFwSW50ZW5zaXR5KTtcbiAgfVxuICBmdW5jdGlvbiB1KHAsIGYsIHYpIHtcbiAgICBwLmlvci52YWx1ZSA9IGYuaW9yLCBmLnNoZWVuID4gMCAmJiAocC5zaGVlbkNvbG9yLnZhbHVlLmNvcHkoZi5zaGVlbkNvbG9yKS5tdWx0aXBseVNjYWxhcihmLnNoZWVuKSwgcC5zaGVlblJvdWdobmVzcy52YWx1ZSA9IGYuc2hlZW5Sb3VnaG5lc3MsIGYuc2hlZW5Db2xvck1hcCAmJiAocC5zaGVlbkNvbG9yTWFwLnZhbHVlID0gZi5zaGVlbkNvbG9yTWFwKSwgZi5zaGVlblJvdWdobmVzc01hcCAmJiAocC5zaGVlblJvdWdobmVzc01hcC52YWx1ZSA9IGYuc2hlZW5Sb3VnaG5lc3NNYXApKSwgZi5jbGVhcmNvYXQgPiAwICYmIChwLmNsZWFyY29hdC52YWx1ZSA9IGYuY2xlYXJjb2F0LCBwLmNsZWFyY29hdFJvdWdobmVzcy52YWx1ZSA9IGYuY2xlYXJjb2F0Um91Z2huZXNzLCBmLmNsZWFyY29hdE1hcCAmJiAocC5jbGVhcmNvYXRNYXAudmFsdWUgPSBmLmNsZWFyY29hdE1hcCksIGYuY2xlYXJjb2F0Um91Z2huZXNzTWFwICYmIChwLmNsZWFyY29hdFJvdWdobmVzc01hcC52YWx1ZSA9IGYuY2xlYXJjb2F0Um91Z2huZXNzTWFwKSwgZi5jbGVhcmNvYXROb3JtYWxNYXAgJiYgKHAuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUuY29weShmLmNsZWFyY29hdE5vcm1hbFNjYWxlKSwgcC5jbGVhcmNvYXROb3JtYWxNYXAudmFsdWUgPSBmLmNsZWFyY29hdE5vcm1hbE1hcCwgZi5zaWRlID09PSAxICYmIHAuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCkpKSwgZi5pcmlkZXNjZW5jZSA+IDAgJiYgKHAuaXJpZGVzY2VuY2UudmFsdWUgPSBmLmlyaWRlc2NlbmNlLCBwLmlyaWRlc2NlbmNlSU9SLnZhbHVlID0gZi5pcmlkZXNjZW5jZUlPUiwgcC5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0udmFsdWUgPSBmLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMF0sIHAuaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtLnZhbHVlID0gZi5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzFdLCBmLmlyaWRlc2NlbmNlTWFwICYmIChwLmlyaWRlc2NlbmNlTWFwLnZhbHVlID0gZi5pcmlkZXNjZW5jZU1hcCksIGYuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgJiYgKHAuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAudmFsdWUgPSBmLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwKSksIGYudHJhbnNtaXNzaW9uID4gMCAmJiAocC50cmFuc21pc3Npb24udmFsdWUgPSBmLnRyYW5zbWlzc2lvbiwgcC50cmFuc21pc3Npb25TYW1wbGVyTWFwLnZhbHVlID0gdi50ZXh0dXJlLCBwLnRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnZhbHVlLnNldCh2LndpZHRoLCB2LmhlaWdodCksIGYudHJhbnNtaXNzaW9uTWFwICYmIChwLnRyYW5zbWlzc2lvbk1hcC52YWx1ZSA9IGYudHJhbnNtaXNzaW9uTWFwKSwgcC50aGlja25lc3MudmFsdWUgPSBmLnRoaWNrbmVzcywgZi50aGlja25lc3NNYXAgJiYgKHAudGhpY2tuZXNzTWFwLnZhbHVlID0gZi50aGlja25lc3NNYXApLCBwLmF0dGVudWF0aW9uRGlzdGFuY2UudmFsdWUgPSBmLmF0dGVudWF0aW9uRGlzdGFuY2UsIHAuYXR0ZW51YXRpb25Db2xvci52YWx1ZS5jb3B5KGYuYXR0ZW51YXRpb25Db2xvcikpLCBwLnNwZWN1bGFySW50ZW5zaXR5LnZhbHVlID0gZi5zcGVjdWxhckludGVuc2l0eSwgcC5zcGVjdWxhckNvbG9yLnZhbHVlLmNvcHkoZi5zcGVjdWxhckNvbG9yKSwgZi5zcGVjdWxhckludGVuc2l0eU1hcCAmJiAocC5zcGVjdWxhckludGVuc2l0eU1hcC52YWx1ZSA9IGYuc3BlY3VsYXJJbnRlbnNpdHlNYXApLCBmLnNwZWN1bGFyQ29sb3JNYXAgJiYgKHAuc3BlY3VsYXJDb2xvck1hcC52YWx1ZSA9IGYuc3BlY3VsYXJDb2xvck1hcCk7XG4gIH1cbiAgZnVuY3Rpb24gbShwLCBmKSB7XG4gICAgZi5tYXRjYXAgJiYgKHAubWF0Y2FwLnZhbHVlID0gZi5tYXRjYXApO1xuICB9XG4gIGZ1bmN0aW9uIGcocCwgZikge1xuICAgIHAucmVmZXJlbmNlUG9zaXRpb24udmFsdWUuY29weShmLnJlZmVyZW5jZVBvc2l0aW9uKSwgcC5uZWFyRGlzdGFuY2UudmFsdWUgPSBmLm5lYXJEaXN0YW5jZSwgcC5mYXJEaXN0YW5jZS52YWx1ZSA9IGYuZmFyRGlzdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZWZyZXNoRm9nVW5pZm9ybXM6IHQsXG4gICAgcmVmcmVzaE1hdGVyaWFsVW5pZm9ybXM6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIEl1KGgsIGUsIHQsIG4pIHtcbiAgbGV0IGkgPSB7fSwgcyA9IHt9LCBvID0gW107XG4gIGNvbnN0IHIgPSB0LmlzV2ViR0wyID8gaC5nZXRQYXJhbWV0ZXIoMzUzNzUpIDogMDtcbiAgZnVuY3Rpb24gbChfLCB3KSB7XG4gICAgY29uc3QgeCA9IHcucHJvZ3JhbTtcbiAgICBuLnVuaWZvcm1CbG9ja0JpbmRpbmcoXywgeCk7XG4gIH1cbiAgZnVuY3Rpb24gYShfLCB3KSB7XG4gICAgbGV0IHggPSBpW18uaWRdO1xuICAgIHggPT09IHZvaWQgMCAmJiAoZyhfKSwgeCA9IGMoXyksIGlbXy5pZF0gPSB4LCBfLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIGYpKTtcbiAgICBjb25zdCBNID0gdy5wcm9ncmFtO1xuICAgIG4udXBkYXRlVUJPTWFwcGluZyhfLCBNKTtcbiAgICBjb25zdCBFID0gZS5yZW5kZXIuZnJhbWU7XG4gICAgc1tfLmlkXSAhPT0gRSAmJiAodShfKSwgc1tfLmlkXSA9IEUpO1xuICB9XG4gIGZ1bmN0aW9uIGMoXykge1xuICAgIGNvbnN0IHcgPSBkKCk7XG4gICAgXy5fX2JpbmRpbmdQb2ludEluZGV4ID0gdztcbiAgICBjb25zdCB4ID0gaC5jcmVhdGVCdWZmZXIoKSwgTSA9IF8uX19zaXplLCBFID0gXy51c2FnZTtcbiAgICByZXR1cm4gaC5iaW5kQnVmZmVyKDM1MzQ1LCB4KSwgaC5idWZmZXJEYXRhKDM1MzQ1LCBNLCBFKSwgaC5iaW5kQnVmZmVyKDM1MzQ1LCBudWxsKSwgaC5iaW5kQnVmZmVyQmFzZSgzNTM0NSwgdywgeCksIHg7XG4gIH1cbiAgZnVuY3Rpb24gZCgpIHtcbiAgICBmb3IgKGxldCBfID0gMDsgXyA8IHI7IF8rKylcbiAgICAgIGlmIChvLmluZGV4T2YoXykgPT09IC0xKVxuICAgICAgICByZXR1cm4gby5wdXNoKF8pLCBfO1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogTWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzbHkgdXNhYmxlIHVuaWZvcm1zIGdyb3VwcyByZWFjaGVkLlwiKSwgMDtcbiAgfVxuICBmdW5jdGlvbiB1KF8pIHtcbiAgICBjb25zdCB3ID0gaVtfLmlkXSwgeCA9IF8udW5pZm9ybXMsIE0gPSBfLl9fY2FjaGU7XG4gICAgaC5iaW5kQnVmZmVyKDM1MzQ1LCB3KTtcbiAgICBmb3IgKGxldCBFID0gMCwgUiA9IHgubGVuZ3RoOyBFIDwgUjsgRSsrKSB7XG4gICAgICBjb25zdCB5ID0geFtFXTtcbiAgICAgIGlmIChtKHksIEUsIE0pID09PSAhMCkge1xuICAgICAgICBjb25zdCBBID0geS52YWx1ZSwgRiA9IHkuX19vZmZzZXQ7XG4gICAgICAgIHR5cGVvZiBBID09IFwibnVtYmVyXCIgPyAoeS5fX2RhdGFbMF0gPSBBLCBoLmJ1ZmZlclN1YkRhdGEoMzUzNDUsIEYsIHkuX19kYXRhKSkgOiAoeS52YWx1ZS5pc01hdHJpeDMgPyAoeS5fX2RhdGFbMF0gPSB5LnZhbHVlLmVsZW1lbnRzWzBdLCB5Ll9fZGF0YVsxXSA9IHkudmFsdWUuZWxlbWVudHNbMV0sIHkuX19kYXRhWzJdID0geS52YWx1ZS5lbGVtZW50c1syXSwgeS5fX2RhdGFbM10gPSB5LnZhbHVlLmVsZW1lbnRzWzBdLCB5Ll9fZGF0YVs0XSA9IHkudmFsdWUuZWxlbWVudHNbM10sIHkuX19kYXRhWzVdID0geS52YWx1ZS5lbGVtZW50c1s0XSwgeS5fX2RhdGFbNl0gPSB5LnZhbHVlLmVsZW1lbnRzWzVdLCB5Ll9fZGF0YVs3XSA9IHkudmFsdWUuZWxlbWVudHNbMF0sIHkuX19kYXRhWzhdID0geS52YWx1ZS5lbGVtZW50c1s2XSwgeS5fX2RhdGFbOV0gPSB5LnZhbHVlLmVsZW1lbnRzWzddLCB5Ll9fZGF0YVsxMF0gPSB5LnZhbHVlLmVsZW1lbnRzWzhdLCB5Ll9fZGF0YVsxMV0gPSB5LnZhbHVlLmVsZW1lbnRzWzBdKSA6IEEudG9BcnJheSh5Ll9fZGF0YSksIGguYnVmZmVyU3ViRGF0YSgzNTM0NSwgRiwgeS5fX2RhdGEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaC5iaW5kQnVmZmVyKDM1MzQ1LCBudWxsKTtcbiAgfVxuICBmdW5jdGlvbiBtKF8sIHcsIHgpIHtcbiAgICBjb25zdCBNID0gXy52YWx1ZTtcbiAgICBpZiAoeFt3XSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHR5cGVvZiBNID09IFwibnVtYmVyXCIgPyB4W3ddID0gTSA6IHhbd10gPSBNLmNsb25lKCksICEwO1xuICAgIGlmICh0eXBlb2YgTSA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoeFt3XSAhPT0gTSlcbiAgICAgICAgcmV0dXJuIHhbd10gPSBNLCAhMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgRSA9IHhbd107XG4gICAgICBpZiAoRS5lcXVhbHMoTSkgPT09ICExKVxuICAgICAgICByZXR1cm4gRS5jb3B5KE0pLCAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIGcoXykge1xuICAgIGNvbnN0IHcgPSBfLnVuaWZvcm1zO1xuICAgIGxldCB4ID0gMDtcbiAgICBjb25zdCBNID0gMTY7XG4gICAgbGV0IEUgPSAwO1xuICAgIGZvciAobGV0IFIgPSAwLCB5ID0gdy5sZW5ndGg7IFIgPCB5OyBSKyspIHtcbiAgICAgIGNvbnN0IEEgPSB3W1JdLCBGID0gcChBKTtcbiAgICAgIGlmIChBLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoRi5zdG9yYWdlIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKSwgQS5fX29mZnNldCA9IHgsIFIgPiAwKSB7XG4gICAgICAgIEUgPSB4ICUgTTtcbiAgICAgICAgY29uc3QgUCA9IE0gLSBFO1xuICAgICAgICBFICE9PSAwICYmIFAgLSBGLmJvdW5kYXJ5IDwgMCAmJiAoeCArPSBNIC0gRSwgQS5fX29mZnNldCA9IHgpO1xuICAgICAgfVxuICAgICAgeCArPSBGLnN0b3JhZ2U7XG4gICAgfVxuICAgIHJldHVybiBFID0geCAlIE0sIEUgPiAwICYmICh4ICs9IE0gLSBFKSwgXy5fX3NpemUgPSB4LCBfLl9fY2FjaGUgPSB7fSwgdGhpcztcbiAgfVxuICBmdW5jdGlvbiBwKF8pIHtcbiAgICBjb25zdCB3ID0gXy52YWx1ZSwgeCA9IHtcbiAgICAgIGJvdW5kYXJ5OiAwLFxuICAgICAgc3RvcmFnZTogMFxuICAgIH07XG4gICAgcmV0dXJuIHR5cGVvZiB3ID09IFwibnVtYmVyXCIgPyAoeC5ib3VuZGFyeSA9IDQsIHguc3RvcmFnZSA9IDQpIDogdy5pc1ZlY3RvcjIgPyAoeC5ib3VuZGFyeSA9IDgsIHguc3RvcmFnZSA9IDgpIDogdy5pc1ZlY3RvcjMgfHwgdy5pc0NvbG9yID8gKHguYm91bmRhcnkgPSAxNiwgeC5zdG9yYWdlID0gMTIpIDogdy5pc1ZlY3RvcjQgPyAoeC5ib3VuZGFyeSA9IDE2LCB4LnN0b3JhZ2UgPSAxNikgOiB3LmlzTWF0cml4MyA/ICh4LmJvdW5kYXJ5ID0gNDgsIHguc3RvcmFnZSA9IDQ4KSA6IHcuaXNNYXRyaXg0ID8gKHguYm91bmRhcnkgPSA2NCwgeC5zdG9yYWdlID0gNjQpIDogdy5pc1RleHR1cmUgPyBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIHNhbXBsZXJzIGNhbiBub3QgYmUgcGFydCBvZiBhbiB1bmlmb3JtcyBncm91cC5cIikgOiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbnN1cHBvcnRlZCB1bmlmb3JtIHZhbHVlIHR5cGUuXCIsIHcpLCB4O1xuICB9XG4gIGZ1bmN0aW9uIGYoXykge1xuICAgIGNvbnN0IHcgPSBfLnRhcmdldDtcbiAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIGYpO1xuICAgIGNvbnN0IHggPSBvLmluZGV4T2Yody5fX2JpbmRpbmdQb2ludEluZGV4KTtcbiAgICBvLnNwbGljZSh4LCAxKSwgaC5kZWxldGVCdWZmZXIoaVt3LmlkXSksIGRlbGV0ZSBpW3cuaWRdLCBkZWxldGUgc1t3LmlkXTtcbiAgfVxuICBmdW5jdGlvbiB2KCkge1xuICAgIGZvciAoY29uc3QgXyBpbiBpKVxuICAgICAgaC5kZWxldGVCdWZmZXIoaVtfXSk7XG4gICAgbyA9IFtdLCBpID0ge30sIHMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJpbmQ6IGwsXG4gICAgdXBkYXRlOiBhLFxuICAgIGRpc3Bvc2U6IHZcbiAgfTtcbn1cbmZ1bmN0aW9uIHp1KCkge1xuICBjb25zdCBoID0gcWkoXCJjYW52YXNcIik7XG4gIHJldHVybiBoLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIGg7XG59XG5mdW5jdGlvbiB4byhoID0ge30pIHtcbiAgdGhpcy5pc1dlYkdMUmVuZGVyZXIgPSAhMDtcbiAgY29uc3QgZSA9IGguY2FudmFzICE9PSB2b2lkIDAgPyBoLmNhbnZhcyA6IHp1KCksIHQgPSBoLmNvbnRleHQgIT09IHZvaWQgMCA/IGguY29udGV4dCA6IG51bGwsIG4gPSBoLmRlcHRoICE9PSB2b2lkIDAgPyBoLmRlcHRoIDogITAsIGkgPSBoLnN0ZW5jaWwgIT09IHZvaWQgMCA/IGguc3RlbmNpbCA6ICEwLCBzID0gaC5hbnRpYWxpYXMgIT09IHZvaWQgMCA/IGguYW50aWFsaWFzIDogITEsIG8gPSBoLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdm9pZCAwID8gaC5wcmVtdWx0aXBsaWVkQWxwaGEgOiAhMCwgciA9IGgucHJlc2VydmVEcmF3aW5nQnVmZmVyICE9PSB2b2lkIDAgPyBoLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA6ICExLCBsID0gaC5wb3dlclByZWZlcmVuY2UgIT09IHZvaWQgMCA/IGgucG93ZXJQcmVmZXJlbmNlIDogXCJkZWZhdWx0XCIsIGEgPSBoLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgIT09IHZvaWQgMCA/IGguZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA6ICExO1xuICBsZXQgYztcbiAgdCAhPT0gbnVsbCA/IGMgPSB0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGEgOiBjID0gaC5hbHBoYSAhPT0gdm9pZCAwID8gaC5hbHBoYSA6ICExO1xuICBsZXQgZCA9IG51bGwsIHUgPSBudWxsO1xuICBjb25zdCBtID0gW10sIGcgPSBbXTtcbiAgdGhpcy5kb21FbGVtZW50ID0gZSwgdGhpcy5kZWJ1ZyA9IHtcbiAgICBjaGVja1NoYWRlckVycm9yczogITBcbiAgfSwgdGhpcy5hdXRvQ2xlYXIgPSAhMCwgdGhpcy5hdXRvQ2xlYXJDb2xvciA9ICEwLCB0aGlzLmF1dG9DbGVhckRlcHRoID0gITAsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9ICEwLCB0aGlzLnNvcnRPYmplY3RzID0gITAsIHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXSwgdGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZCA9ICExLCB0aGlzLm91dHB1dEVuY29kaW5nID0gM2UzLCB0aGlzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gITEsIHRoaXMudG9uZU1hcHBpbmcgPSAwLCB0aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgZ2FtbWFGYWN0b3I6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFGYWN0b3IgaGFzIGJlZW4gcmVtb3ZlZC5cIiksIDI7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdhbW1hRmFjdG9yIGhhcyBiZWVuIHJlbW92ZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHAgPSB0aGlzO1xuICBsZXQgZiA9ICExLCB2ID0gMCwgXyA9IDAsIHcgPSBudWxsLCB4ID0gLTEsIE0gPSBudWxsO1xuICBjb25zdCBFID0gbmV3ICRlKCksIFIgPSBuZXcgJGUoKTtcbiAgbGV0IHkgPSBudWxsLCBBID0gZS53aWR0aCwgRiA9IGUuaGVpZ2h0LCBQID0gMSwgRyA9IG51bGwsIHogPSBudWxsO1xuICBjb25zdCBMID0gbmV3ICRlKDAsIDAsIEEsIEYpLCBJID0gbmV3ICRlKDAsIDAsIEEsIEYpO1xuICBsZXQgRCA9ICExO1xuICBjb25zdCBxID0gbmV3IFVzKCk7XG4gIGxldCBrID0gITEsIE4gPSAhMSwgSCA9IG51bGw7XG4gIGNvbnN0IEogPSBuZXcgS2UoKSwgViA9IG5ldyBDZSgpLCBlZSA9IG5ldyBPKCksIGNlID0geyBiYWNrZ3JvdW5kOiBudWxsLCBmb2c6IG51bGwsIGVudmlyb25tZW50OiBudWxsLCBvdmVycmlkZU1hdGVyaWFsOiBudWxsLCBpc1NjZW5lOiAhMCB9O1xuICBmdW5jdGlvbiBnZSgpIHtcbiAgICByZXR1cm4gdyA9PT0gbnVsbCA/IFAgOiAxO1xuICB9XG4gIGxldCAkID0gdDtcbiAgZnVuY3Rpb24gRGUoVCwgVSkge1xuICAgIGZvciAobGV0IFggPSAwOyBYIDwgVC5sZW5ndGg7IFgrKykge1xuICAgICAgY29uc3QgVyA9IFRbWF0sIEsgPSBlLmdldENvbnRleHQoVywgVSk7XG4gICAgICBpZiAoSyAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgVCA9IHtcbiAgICAgIGFscGhhOiAhMCxcbiAgICAgIGRlcHRoOiBuLFxuICAgICAgc3RlbmNpbDogaSxcbiAgICAgIGFudGlhbGlhczogcyxcbiAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogbyxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogcixcbiAgICAgIHBvd2VyUHJlZmVyZW5jZTogbCxcbiAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGFcbiAgICB9O1xuICAgIGlmIChcInNldEF0dHJpYnV0ZVwiIGluIGUgJiYgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVuZ2luZVwiLCBgdGhyZWUuanMgciR7T3N9YCksIGUuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgd2UsICExKSwgZS5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgSWUsICExKSwgZS5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvclwiLCBXZSwgITEpLCAkID09PSBudWxsKSB7XG4gICAgICBjb25zdCBVID0gW1wid2ViZ2wyXCIsIFwid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gICAgICBpZiAocC5pc1dlYkdMMVJlbmRlcmVyID09PSAhMCAmJiBVLnNoaWZ0KCksICQgPSBEZShVLCBUKSwgJCA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgRGUoVSkgPyBuZXcgRXJyb3IoXCJFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLlwiKSA6IG5ldyBFcnJvcihcIkVycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuXCIpO1xuICAgIH1cbiAgICAkLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9PT0gdm9pZCAwICYmICgkLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgcmFuZ2VNaW46IDEsIHJhbmdlTWF4OiAxLCBwcmVjaXNpb246IDEgfTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoVCkge1xuICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBcIiArIFQubWVzc2FnZSksIFQ7XG4gIH1cbiAgbGV0IHZlLCB4ZSwgdWUsIE9lLCBFZSwgbWUsIGV0LCB1dCwgcnQsIFJ0LCB0dCwgTmUsIEd0LCBGdCwgQywgUywgWiwgUSwgdGUsIHJlLCB5ZSwgaiwgcGUsIGhlO1xuICBmdW5jdGlvbiBmZSgpIHtcbiAgICB2ZSA9IG5ldyBxYygkKSwgeGUgPSBuZXcgT2MoJCwgdmUsIGgpLCB2ZS5pbml0KHhlKSwgaiA9IG5ldyBDdSgkLCB2ZSwgeGUpLCB1ZSA9IG5ldyBUdSgkLCB2ZSwgeGUpLCBPZSA9IG5ldyBZYygpLCBFZSA9IG5ldyBkdSgpLCBtZSA9IG5ldyBBdSgkLCB2ZSwgdWUsIEVlLCB4ZSwgaiwgT2UpLCBldCA9IG5ldyBHYyhwKSwgdXQgPSBuZXcgSGMocCksIHJ0ID0gbmV3IHJhKCQsIHhlKSwgcGUgPSBuZXcgQmMoJCwgdmUsIHJ0LCB4ZSksIFJ0ID0gbmV3IFhjKCQsIHJ0LCBPZSwgcGUpLCB0dCA9IG5ldyBKYygkLCBSdCwgcnQsIE9lKSwgdGUgPSBuZXcgS2MoJCwgeGUsIG1lKSwgUyA9IG5ldyBVYyhFZSksIE5lID0gbmV3IHV1KHAsIGV0LCB1dCwgdmUsIHhlLCBwZSwgUyksIEd0ID0gbmV3IFB1KHAsIEVlKSwgRnQgPSBuZXcgcHUoKSwgQyA9IG5ldyB5dSh2ZSwgeGUpLCBRID0gbmV3IHpjKHAsIGV0LCB1ZSwgdHQsIGMsIG8pLCBaID0gbmV3IEV1KHAsIHR0LCB4ZSksIGhlID0gbmV3IEl1KCQsIE9lLCB4ZSwgdWUpLCByZSA9IG5ldyBOYygkLCB2ZSwgT2UsIHhlKSwgeWUgPSBuZXcgamMoJCwgdmUsIE9lLCB4ZSksIE9lLnByb2dyYW1zID0gTmUucHJvZ3JhbXMsIHAuY2FwYWJpbGl0aWVzID0geGUsIHAuZXh0ZW5zaW9ucyA9IHZlLCBwLnByb3BlcnRpZXMgPSBFZSwgcC5yZW5kZXJMaXN0cyA9IEZ0LCBwLnNoYWRvd01hcCA9IFosIHAuc3RhdGUgPSB1ZSwgcC5pbmZvID0gT2U7XG4gIH1cbiAgZmUoKTtcbiAgY29uc3QgZGUgPSBuZXcgRHUocCwgJCk7XG4gIHRoaXMueHIgPSBkZSwgdGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICQ7XG4gIH0sIHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICB9LCB0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBUID0gdmUuZ2V0KFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgIFQgJiYgVC5sb3NlQ29udGV4dCgpO1xuICB9LCB0aGlzLmZvcmNlQ29udGV4dFJlc3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBUID0gdmUuZ2V0KFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgIFQgJiYgVC5yZXN0b3JlQ29udGV4dCgpO1xuICB9LCB0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUDtcbiAgfSwgdGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oVCkge1xuICAgIFQgIT09IHZvaWQgMCAmJiAoUCA9IFQsIHRoaXMuc2V0U2l6ZShBLCBGLCAhMSkpO1xuICB9LCB0aGlzLmdldFNpemUgPSBmdW5jdGlvbihUKSB7XG4gICAgcmV0dXJuIFQuc2V0KEEsIEYpO1xuICB9LCB0aGlzLnNldFNpemUgPSBmdW5jdGlvbihULCBVLCBYKSB7XG4gICAgaWYgKGRlLmlzUHJlc2VudGluZykge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ2FuJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBID0gVCwgRiA9IFUsIGUud2lkdGggPSBNYXRoLmZsb29yKFQgKiBQKSwgZS5oZWlnaHQgPSBNYXRoLmZsb29yKFUgKiBQKSwgWCAhPT0gITEgJiYgKGUuc3R5bGUud2lkdGggPSBUICsgXCJweFwiLCBlLnN0eWxlLmhlaWdodCA9IFUgKyBcInB4XCIpLCB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIFQsIFUpO1xuICB9LCB0aGlzLmdldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24oVCkge1xuICAgIHJldHVybiBULnNldChBICogUCwgRiAqIFApLmZsb29yKCk7XG4gIH0sIHRoaXMuc2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbihULCBVLCBYKSB7XG4gICAgQSA9IFQsIEYgPSBVLCBQID0gWCwgZS53aWR0aCA9IE1hdGguZmxvb3IoVCAqIFgpLCBlLmhlaWdodCA9IE1hdGguZmxvb3IoVSAqIFgpLCB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIFQsIFUpO1xuICB9LCB0aGlzLmdldEN1cnJlbnRWaWV3cG9ydCA9IGZ1bmN0aW9uKFQpIHtcbiAgICByZXR1cm4gVC5jb3B5KEUpO1xuICB9LCB0aGlzLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24oVCkge1xuICAgIHJldHVybiBULmNvcHkoTCk7XG4gIH0sIHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbihULCBVLCBYLCBXKSB7XG4gICAgVC5pc1ZlY3RvcjQgPyBMLnNldChULngsIFQueSwgVC56LCBULncpIDogTC5zZXQoVCwgVSwgWCwgVyksIHVlLnZpZXdwb3J0KEUuY29weShMKS5tdWx0aXBseVNjYWxhcihQKS5mbG9vcigpKTtcbiAgfSwgdGhpcy5nZXRTY2lzc29yID0gZnVuY3Rpb24oVCkge1xuICAgIHJldHVybiBULmNvcHkoSSk7XG4gIH0sIHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uKFQsIFUsIFgsIFcpIHtcbiAgICBULmlzVmVjdG9yNCA/IEkuc2V0KFQueCwgVC55LCBULnosIFQudykgOiBJLnNldChULCBVLCBYLCBXKSwgdWUuc2Npc3NvcihSLmNvcHkoSSkubXVsdGlwbHlTY2FsYXIoUCkuZmxvb3IoKSk7XG4gIH0sIHRoaXMuZ2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRDtcbiAgfSwgdGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uKFQpIHtcbiAgICB1ZS5zZXRTY2lzc29yVGVzdChEID0gVCk7XG4gIH0sIHRoaXMuc2V0T3BhcXVlU29ydCA9IGZ1bmN0aW9uKFQpIHtcbiAgICBHID0gVDtcbiAgfSwgdGhpcy5zZXRUcmFuc3BhcmVudFNvcnQgPSBmdW5jdGlvbihUKSB7XG4gICAgeiA9IFQ7XG4gIH0sIHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uKFQpIHtcbiAgICByZXR1cm4gVC5jb3B5KFEuZ2V0Q2xlYXJDb2xvcigpKTtcbiAgfSwgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgUS5zZXRDbGVhckNvbG9yLmFwcGx5KFEsIGFyZ3VtZW50cyk7XG4gIH0sIHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBRLmdldENsZWFyQWxwaGEoKTtcbiAgfSwgdGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24oKSB7XG4gICAgUS5zZXRDbGVhckFscGhhLmFwcGx5KFEsIGFyZ3VtZW50cyk7XG4gIH0sIHRoaXMuY2xlYXIgPSBmdW5jdGlvbihUID0gITAsIFUgPSAhMCwgWCA9ICEwKSB7XG4gICAgbGV0IFcgPSAwO1xuICAgIFQgJiYgKFcgfD0gMTYzODQpLCBVICYmIChXIHw9IDI1NiksIFggJiYgKFcgfD0gMTAyNCksICQuY2xlYXIoVyk7XG4gIH0sIHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXIoITAsICExLCAhMSk7XG4gIH0sIHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXIoITEsICEwLCAhMSk7XG4gIH0sIHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhcighMSwgITEsICEwKTtcbiAgfSwgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB3ZSwgITEpLCBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCBJZSwgITEpLCBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yXCIsIFdlLCAhMSksIEZ0LmRpc3Bvc2UoKSwgQy5kaXNwb3NlKCksIEVlLmRpc3Bvc2UoKSwgZXQuZGlzcG9zZSgpLCB1dC5kaXNwb3NlKCksIHR0LmRpc3Bvc2UoKSwgcGUuZGlzcG9zZSgpLCBoZS5kaXNwb3NlKCksIE5lLmRpc3Bvc2UoKSwgZGUuZGlzcG9zZSgpLCBkZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vzc2lvbnN0YXJ0XCIsIFJlKSwgZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlc3Npb25lbmRcIiwgSmUpLCBIICYmIChILmRpc3Bvc2UoKSwgSCA9IG51bGwpLCBWZS5zdG9wKCk7XG4gIH07XG4gIGZ1bmN0aW9uIHdlKFQpIHtcbiAgICBULnByZXZlbnREZWZhdWx0KCksIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LlwiKSwgZiA9ICEwO1xuICB9XG4gIGZ1bmN0aW9uIEllKCkge1xuICAgIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC5cIiksIGYgPSAhMTtcbiAgICBjb25zdCBUID0gT2UuYXV0b1Jlc2V0LCBVID0gWi5lbmFibGVkLCBYID0gWi5hdXRvVXBkYXRlLCBXID0gWi5uZWVkc1VwZGF0ZSwgSyA9IFoudHlwZTtcbiAgICBmZSgpLCBPZS5hdXRvUmVzZXQgPSBULCBaLmVuYWJsZWQgPSBVLCBaLmF1dG9VcGRhdGUgPSBYLCBaLm5lZWRzVXBkYXRlID0gVywgWi50eXBlID0gSztcbiAgfVxuICBmdW5jdGlvbiBXZShUKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEEgV2ViR0wgY29udGV4dCBjb3VsZCBub3QgYmUgY3JlYXRlZC4gUmVhc29uOiBcIiwgVC5zdGF0dXNNZXNzYWdlKTtcbiAgfVxuICBmdW5jdGlvbiBCKFQpIHtcbiAgICBjb25zdCBVID0gVC50YXJnZXQ7XG4gICAgVS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLCBCKSwgYWUoVSk7XG4gIH1cbiAgZnVuY3Rpb24gYWUoVCkge1xuICAgIFkoVCksIEVlLnJlbW92ZShUKTtcbiAgfVxuICBmdW5jdGlvbiBZKFQpIHtcbiAgICBjb25zdCBVID0gRWUuZ2V0KFQpLnByb2dyYW1zO1xuICAgIFUgIT09IHZvaWQgMCAmJiAoVS5mb3JFYWNoKGZ1bmN0aW9uKFgpIHtcbiAgICAgIE5lLnJlbGVhc2VQcm9ncmFtKFgpO1xuICAgIH0pLCBULmlzU2hhZGVyTWF0ZXJpYWwgJiYgTmUucmVsZWFzZVNoYWRlckNhY2hlKFQpKTtcbiAgfVxuICB0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uKFQsIFUsIFgsIFcsIEssIF9lKSB7XG4gICAgVSA9PT0gbnVsbCAmJiAoVSA9IGNlKTtcbiAgICBjb25zdCBiZSA9IEsuaXNNZXNoICYmIEsubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDAsIFNlID0gRm8oVCwgVSwgWCwgVywgSyk7XG4gICAgdWUuc2V0TWF0ZXJpYWwoVywgYmUpO1xuICAgIGxldCBNZSA9IFguaW5kZXg7XG4gICAgY29uc3QgQmUgPSBYLmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgaWYgKE1lID09PSBudWxsKSB7XG4gICAgICBpZiAoQmUgPT09IHZvaWQgMCB8fCBCZS5jb3VudCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoTWUuY291bnQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IExlID0gMTtcbiAgICBXLndpcmVmcmFtZSA9PT0gITAgJiYgKE1lID0gUnQuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKFgpLCBMZSA9IDIpLCBwZS5zZXR1cChLLCBXLCBTZSwgWCwgTWUpO1xuICAgIGxldCBGZSwga2UgPSByZTtcbiAgICBNZSAhPT0gbnVsbCAmJiAoRmUgPSBydC5nZXQoTWUpLCBrZSA9IHllLCBrZS5zZXRJbmRleChGZSkpO1xuICAgIGNvbnN0IHVuID0gTWUgIT09IG51bGwgPyBNZS5jb3VudCA6IEJlLmNvdW50LCBDbiA9IFguZHJhd1JhbmdlLnN0YXJ0ICogTGUsIExuID0gWC5kcmF3UmFuZ2UuY291bnQgKiBMZSwgRHQgPSBfZSAhPT0gbnVsbCA/IF9lLnN0YXJ0ICogTGUgOiAwLCB6ZSA9IF9lICE9PSBudWxsID8gX2UuY291bnQgKiBMZSA6IDEgLyAwLCBSbiA9IE1hdGgubWF4KENuLCBEdCksIEhlID0gTWF0aC5taW4odW4sIENuICsgTG4sIER0ICsgemUpIC0gMSwgeXQgPSBNYXRoLm1heCgwLCBIZSAtIFJuICsgMSk7XG4gICAgaWYgKHl0ICE9PSAwKSB7XG4gICAgICBpZiAoSy5pc01lc2gpXG4gICAgICAgIFcud2lyZWZyYW1lID09PSAhMCA/ICh1ZS5zZXRMaW5lV2lkdGgoVy53aXJlZnJhbWVMaW5ld2lkdGggKiBnZSgpKSwga2Uuc2V0TW9kZSgxKSkgOiBrZS5zZXRNb2RlKDQpO1xuICAgICAgZWxzZSBpZiAoSy5pc0xpbmUpIHtcbiAgICAgICAgbGV0IHRuID0gVy5saW5ld2lkdGg7XG4gICAgICAgIHRuID09PSB2b2lkIDAgJiYgKHRuID0gMSksIHVlLnNldExpbmVXaWR0aCh0biAqIGdlKCkpLCBLLmlzTGluZVNlZ21lbnRzID8ga2Uuc2V0TW9kZSgxKSA6IEsuaXNMaW5lTG9vcCA/IGtlLnNldE1vZGUoMikgOiBrZS5zZXRNb2RlKDMpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEsuaXNQb2ludHMgPyBrZS5zZXRNb2RlKDApIDogSy5pc1Nwcml0ZSAmJiBrZS5zZXRNb2RlKDQpO1xuICAgICAgaWYgKEsuaXNJbnN0YW5jZWRNZXNoKVxuICAgICAgICBrZS5yZW5kZXJJbnN0YW5jZXMoUm4sIHl0LCBLLmNvdW50KTtcbiAgICAgIGVsc2UgaWYgKFguaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSkge1xuICAgICAgICBjb25zdCB0biA9IE1hdGgubWluKFguaW5zdGFuY2VDb3VudCwgWC5fbWF4SW5zdGFuY2VDb3VudCk7XG4gICAgICAgIGtlLnJlbmRlckluc3RhbmNlcyhSbiwgeXQsIHRuKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBrZS5yZW5kZXIoUm4sIHl0KTtcbiAgICB9XG4gIH0sIHRoaXMuY29tcGlsZSA9IGZ1bmN0aW9uKFQsIFUpIHtcbiAgICB1ID0gQy5nZXQoVCksIHUuaW5pdCgpLCBnLnB1c2godSksIFQudHJhdmVyc2VWaXNpYmxlKGZ1bmN0aW9uKFgpIHtcbiAgICAgIFguaXNMaWdodCAmJiBYLmxheWVycy50ZXN0KFUubGF5ZXJzKSAmJiAodS5wdXNoTGlnaHQoWCksIFguY2FzdFNoYWRvdyAmJiB1LnB1c2hTaGFkb3coWCkpO1xuICAgIH0pLCB1LnNldHVwTGlnaHRzKHAucGh5c2ljYWxseUNvcnJlY3RMaWdodHMpLCBULnRyYXZlcnNlKGZ1bmN0aW9uKFgpIHtcbiAgICAgIGNvbnN0IFcgPSBYLm1hdGVyaWFsO1xuICAgICAgaWYgKFcpXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KFcpKVxuICAgICAgICAgIGZvciAobGV0IEsgPSAwOyBLIDwgVy5sZW5ndGg7IEsrKykge1xuICAgICAgICAgICAgY29uc3QgX2UgPSBXW0tdO1xuICAgICAgICAgICAgWmkoX2UsIFQsIFgpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIFppKFcsIFQsIFgpO1xuICAgIH0pLCBnLnBvcCgpLCB1ID0gbnVsbDtcbiAgfTtcbiAgbGV0IG9lID0gbnVsbDtcbiAgZnVuY3Rpb24gc2UoVCkge1xuICAgIG9lICYmIG9lKFQpO1xuICB9XG4gIGZ1bmN0aW9uIFJlKCkge1xuICAgIFZlLnN0b3AoKTtcbiAgfVxuICBmdW5jdGlvbiBKZSgpIHtcbiAgICBWZS5zdGFydCgpO1xuICB9XG4gIGNvbnN0IFZlID0gbmV3IGZvKCk7XG4gIFZlLnNldEFuaW1hdGlvbkxvb3Aoc2UpLCB0eXBlb2Ygc2VsZiA8IFwidVwiICYmIFZlLnNldENvbnRleHQoc2VsZiksIHRoaXMuc2V0QW5pbWF0aW9uTG9vcCA9IGZ1bmN0aW9uKFQpIHtcbiAgICBvZSA9IFQsIGRlLnNldEFuaW1hdGlvbkxvb3AoVCksIFQgPT09IG51bGwgPyBWZS5zdG9wKCkgOiBWZS5zdGFydCgpO1xuICB9LCBkZS5hZGRFdmVudExpc3RlbmVyKFwic2Vzc2lvbnN0YXJ0XCIsIFJlKSwgZGUuYWRkRXZlbnRMaXN0ZW5lcihcInNlc3Npb25lbmRcIiwgSmUpLCB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKFQsIFUpIHtcbiAgICBpZiAoVSAhPT0gdm9pZCAwICYmIFUuaXNDYW1lcmEgIT09ICEwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGYgPT09ICEwKVxuICAgICAgcmV0dXJuO1xuICAgIFQuYXV0b1VwZGF0ZSA9PT0gITAgJiYgVC51cGRhdGVNYXRyaXhXb3JsZCgpLCBVLnBhcmVudCA9PT0gbnVsbCAmJiBVLnVwZGF0ZU1hdHJpeFdvcmxkKCksIGRlLmVuYWJsZWQgPT09ICEwICYmIGRlLmlzUHJlc2VudGluZyA9PT0gITAgJiYgKGRlLmNhbWVyYUF1dG9VcGRhdGUgPT09ICEwICYmIGRlLnVwZGF0ZUNhbWVyYShVKSwgVSA9IGRlLmdldENhbWVyYSgpKSwgVC5pc1NjZW5lID09PSAhMCAmJiBULm9uQmVmb3JlUmVuZGVyKHAsIFQsIFUsIHcpLCB1ID0gQy5nZXQoVCwgZy5sZW5ndGgpLCB1LmluaXQoKSwgZy5wdXNoKHUpLCBKLm11bHRpcGx5TWF0cmljZXMoVS5wcm9qZWN0aW9uTWF0cml4LCBVLm1hdHJpeFdvcmxkSW52ZXJzZSksIHEuc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoSiksIE4gPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkLCBrID0gUy5pbml0KHRoaXMuY2xpcHBpbmdQbGFuZXMsIE4sIFUpLCBkID0gRnQuZ2V0KFQsIG0ubGVuZ3RoKSwgZC5pbml0KCksIG0ucHVzaChkKSwgZW4oVCwgVSwgMCwgcC5zb3J0T2JqZWN0cyksIGQuZmluaXNoKCksIHAuc29ydE9iamVjdHMgPT09ICEwICYmIGQuc29ydChHLCB6KSwgayA9PT0gITAgJiYgUy5iZWdpblNoYWRvd3MoKTtcbiAgICBjb25zdCBYID0gdS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG4gICAgaWYgKFoucmVuZGVyKFgsIFQsIFUpLCBrID09PSAhMCAmJiBTLmVuZFNoYWRvd3MoKSwgdGhpcy5pbmZvLmF1dG9SZXNldCA9PT0gITAgJiYgdGhpcy5pbmZvLnJlc2V0KCksIFEucmVuZGVyKGQsIFQpLCB1LnNldHVwTGlnaHRzKHAucGh5c2ljYWxseUNvcnJlY3RMaWdodHMpLCBVLmlzQXJyYXlDYW1lcmEpIHtcbiAgICAgIGNvbnN0IFcgPSBVLmNhbWVyYXM7XG4gICAgICBmb3IgKGxldCBLID0gMCwgX2UgPSBXLmxlbmd0aDsgSyA8IF9lOyBLKyspIHtcbiAgICAgICAgY29uc3QgYmUgPSBXW0tdO1xuICAgICAgICBHZShkLCBULCBiZSwgYmUudmlld3BvcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgR2UoZCwgVCwgVSk7XG4gICAgdyAhPT0gbnVsbCAmJiAobWUudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQodyksIG1lLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCh3KSksIFQuaXNTY2VuZSA9PT0gITAgJiYgVC5vbkFmdGVyUmVuZGVyKHAsIFQsIFUpLCBwZS5yZXNldERlZmF1bHRTdGF0ZSgpLCB4ID0gLTEsIE0gPSBudWxsLCBnLnBvcCgpLCBnLmxlbmd0aCA+IDAgPyB1ID0gZ1tnLmxlbmd0aCAtIDFdIDogdSA9IG51bGwsIG0ucG9wKCksIG0ubGVuZ3RoID4gMCA/IGQgPSBtW20ubGVuZ3RoIC0gMV0gOiBkID0gbnVsbDtcbiAgfTtcbiAgZnVuY3Rpb24gZW4oVCwgVSwgWCwgVykge1xuICAgIGlmIChULnZpc2libGUgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChULmxheWVycy50ZXN0KFUubGF5ZXJzKSkge1xuICAgICAgaWYgKFQuaXNHcm91cClcbiAgICAgICAgWCA9IFQucmVuZGVyT3JkZXI7XG4gICAgICBlbHNlIGlmIChULmlzTE9EKVxuICAgICAgICBULmF1dG9VcGRhdGUgPT09ICEwICYmIFQudXBkYXRlKFUpO1xuICAgICAgZWxzZSBpZiAoVC5pc0xpZ2h0KVxuICAgICAgICB1LnB1c2hMaWdodChUKSwgVC5jYXN0U2hhZG93ICYmIHUucHVzaFNoYWRvdyhUKTtcbiAgICAgIGVsc2UgaWYgKFQuaXNTcHJpdGUpIHtcbiAgICAgICAgaWYgKCFULmZydXN0dW1DdWxsZWQgfHwgcS5pbnRlcnNlY3RzU3ByaXRlKFQpKSB7XG4gICAgICAgICAgVyAmJiBlZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oVC5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KEopO1xuICAgICAgICAgIGNvbnN0IGJlID0gdHQudXBkYXRlKFQpLCBTZSA9IFQubWF0ZXJpYWw7XG4gICAgICAgICAgU2UudmlzaWJsZSAmJiBkLnB1c2goVCwgYmUsIFNlLCBYLCBlZS56LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoVC5pc01lc2ggfHwgVC5pc0xpbmUgfHwgVC5pc1BvaW50cykgJiYgKFQuaXNTa2lubmVkTWVzaCAmJiBULnNrZWxldG9uLmZyYW1lICE9PSBPZS5yZW5kZXIuZnJhbWUgJiYgKFQuc2tlbGV0b24udXBkYXRlKCksIFQuc2tlbGV0b24uZnJhbWUgPSBPZS5yZW5kZXIuZnJhbWUpLCAhVC5mcnVzdHVtQ3VsbGVkIHx8IHEuaW50ZXJzZWN0c09iamVjdChUKSkpIHtcbiAgICAgICAgVyAmJiBlZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oVC5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KEopO1xuICAgICAgICBjb25zdCBiZSA9IHR0LnVwZGF0ZShUKSwgU2UgPSBULm1hdGVyaWFsO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShTZSkpIHtcbiAgICAgICAgICBjb25zdCBNZSA9IGJlLmdyb3VwcztcbiAgICAgICAgICBmb3IgKGxldCBCZSA9IDAsIExlID0gTWUubGVuZ3RoOyBCZSA8IExlOyBCZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBGZSA9IE1lW0JlXSwga2UgPSBTZVtGZS5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgICAgIGtlICYmIGtlLnZpc2libGUgJiYgZC5wdXNoKFQsIGJlLCBrZSwgWCwgZWUueiwgRmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgU2UudmlzaWJsZSAmJiBkLnB1c2goVCwgYmUsIFNlLCBYLCBlZS56LCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgX2UgPSBULmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGJlID0gMCwgU2UgPSBfZS5sZW5ndGg7IGJlIDwgU2U7IGJlKyspXG4gICAgICBlbihfZVtiZV0sIFUsIFgsIFcpO1xuICB9XG4gIGZ1bmN0aW9uIEdlKFQsIFUsIFgsIFcpIHtcbiAgICBjb25zdCBLID0gVC5vcGFxdWUsIF9lID0gVC50cmFuc21pc3NpdmUsIGJlID0gVC50cmFuc3BhcmVudDtcbiAgICB1LnNldHVwTGlnaHRzVmlldyhYKSwgX2UubGVuZ3RoID4gMCAmJiBrdChLLCBVLCBYKSwgVyAmJiB1ZS52aWV3cG9ydChFLmNvcHkoVykpLCBLLmxlbmd0aCA+IDAgJiYgeHQoSywgVSwgWCksIF9lLmxlbmd0aCA+IDAgJiYgeHQoX2UsIFUsIFgpLCBiZS5sZW5ndGggPiAwICYmIHh0KGJlLCBVLCBYKSwgdWUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCEwKSwgdWUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCEwKSwgdWUuYnVmZmVycy5jb2xvci5zZXRNYXNrKCEwKSwgdWUuc2V0UG9seWdvbk9mZnNldCghMSk7XG4gIH1cbiAgZnVuY3Rpb24ga3QoVCwgVSwgWCkge1xuICAgIGNvbnN0IFcgPSB4ZS5pc1dlYkdMMjtcbiAgICBIID09PSBudWxsICYmIChIID0gbmV3IEVuKDEsIDEsIHtcbiAgICAgIGdlbmVyYXRlTWlwbWFwczogITAsXG4gICAgICB0eXBlOiB2ZS5oYXMoXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikgPyAxMDE2IDogMTAwOSxcbiAgICAgIG1pbkZpbHRlcjogMTAwOCxcbiAgICAgIHNhbXBsZXM6IFcgJiYgcyA9PT0gITAgPyA0IDogMFxuICAgIH0pKSwgcC5nZXREcmF3aW5nQnVmZmVyU2l6ZShWKSwgVyA/IEguc2V0U2l6ZShWLngsIFYueSkgOiBILnNldFNpemUoQnMoVi54KSwgQnMoVi55KSk7XG4gICAgY29uc3QgSyA9IHAuZ2V0UmVuZGVyVGFyZ2V0KCk7XG4gICAgcC5zZXRSZW5kZXJUYXJnZXQoSCksIHAuY2xlYXIoKTtcbiAgICBjb25zdCBfZSA9IHAudG9uZU1hcHBpbmc7XG4gICAgcC50b25lTWFwcGluZyA9IDAsIHh0KFQsIFUsIFgpLCBwLnRvbmVNYXBwaW5nID0gX2UsIG1lLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KEgpLCBtZS51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoSCksIHAuc2V0UmVuZGVyVGFyZ2V0KEspO1xuICB9XG4gIGZ1bmN0aW9uIHh0KFQsIFUsIFgpIHtcbiAgICBjb25zdCBXID0gVS5pc1NjZW5lID09PSAhMCA/IFUub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XG4gICAgZm9yIChsZXQgSyA9IDAsIF9lID0gVC5sZW5ndGg7IEsgPCBfZTsgSysrKSB7XG4gICAgICBjb25zdCBiZSA9IFRbS10sIFNlID0gYmUub2JqZWN0LCBNZSA9IGJlLmdlb21ldHJ5LCBCZSA9IFcgPT09IG51bGwgPyBiZS5tYXRlcmlhbCA6IFcsIExlID0gYmUuZ3JvdXA7XG4gICAgICBTZS5sYXllcnMudGVzdChYLmxheWVycykgJiYgUm8oU2UsIFUsIFgsIE1lLCBCZSwgTGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBSbyhULCBVLCBYLCBXLCBLLCBfZSkge1xuICAgIFQub25CZWZvcmVSZW5kZXIocCwgVSwgWCwgVywgSywgX2UpLCBULm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKFgubWF0cml4V29ybGRJbnZlcnNlLCBULm1hdHJpeFdvcmxkKSwgVC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KFQubW9kZWxWaWV3TWF0cml4KSwgSy5vbkJlZm9yZVJlbmRlcihwLCBVLCBYLCBXLCBULCBfZSksIEsudHJhbnNwYXJlbnQgPT09ICEwICYmIEsuc2lkZSA9PT0gMiA/IChLLnNpZGUgPSAxLCBLLm5lZWRzVXBkYXRlID0gITAsIHAucmVuZGVyQnVmZmVyRGlyZWN0KFgsIFUsIFcsIEssIFQsIF9lKSwgSy5zaWRlID0gMCwgSy5uZWVkc1VwZGF0ZSA9ICEwLCBwLnJlbmRlckJ1ZmZlckRpcmVjdChYLCBVLCBXLCBLLCBULCBfZSksIEsuc2lkZSA9IDIpIDogcC5yZW5kZXJCdWZmZXJEaXJlY3QoWCwgVSwgVywgSywgVCwgX2UpLCBULm9uQWZ0ZXJSZW5kZXIocCwgVSwgWCwgVywgSywgX2UpO1xuICB9XG4gIGZ1bmN0aW9uIFppKFQsIFUsIFgpIHtcbiAgICBVLmlzU2NlbmUgIT09ICEwICYmIChVID0gY2UpO1xuICAgIGNvbnN0IFcgPSBFZS5nZXQoVCksIEsgPSB1LnN0YXRlLmxpZ2h0cywgX2UgPSB1LnN0YXRlLnNoYWRvd3NBcnJheSwgYmUgPSBLLnN0YXRlLnZlcnNpb24sIFNlID0gTmUuZ2V0UGFyYW1ldGVycyhULCBLLnN0YXRlLCBfZSwgVSwgWCksIE1lID0gTmUuZ2V0UHJvZ3JhbUNhY2hlS2V5KFNlKTtcbiAgICBsZXQgQmUgPSBXLnByb2dyYW1zO1xuICAgIFcuZW52aXJvbm1lbnQgPSBULmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBVLmVudmlyb25tZW50IDogbnVsbCwgVy5mb2cgPSBVLmZvZywgVy5lbnZNYXAgPSAoVC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gdXQgOiBldCkuZ2V0KFQuZW52TWFwIHx8IFcuZW52aXJvbm1lbnQpLCBCZSA9PT0gdm9pZCAwICYmIChULmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsIEIpLCBCZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIFcucHJvZ3JhbXMgPSBCZSk7XG4gICAgbGV0IExlID0gQmUuZ2V0KE1lKTtcbiAgICBpZiAoTGUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKFcuY3VycmVudFByb2dyYW0gPT09IExlICYmIFcubGlnaHRzU3RhdGVWZXJzaW9uID09PSBiZSlcbiAgICAgICAgcmV0dXJuIFhzKFQsIFNlKSwgTGU7XG4gICAgfSBlbHNlXG4gICAgICBTZS51bmlmb3JtcyA9IE5lLmdldFVuaWZvcm1zKFQpLCBULm9uQnVpbGQoWCwgU2UsIHApLCBULm9uQmVmb3JlQ29tcGlsZShTZSwgcCksIExlID0gTmUuYWNxdWlyZVByb2dyYW0oU2UsIE1lKSwgQmUuc2V0KE1lLCBMZSksIFcudW5pZm9ybXMgPSBTZS51bmlmb3JtcztcbiAgICBjb25zdCBGZSA9IFcudW5pZm9ybXM7XG4gICAgKCFULmlzU2hhZGVyTWF0ZXJpYWwgJiYgIVQuaXNSYXdTaGFkZXJNYXRlcmlhbCB8fCBULmNsaXBwaW5nID09PSAhMCkgJiYgKEZlLmNsaXBwaW5nUGxhbmVzID0gUy51bmlmb3JtKSwgWHMoVCwgU2UpLCBXLm5lZWRzTGlnaHRzID0gUG8oVCksIFcubGlnaHRzU3RhdGVWZXJzaW9uID0gYmUsIFcubmVlZHNMaWdodHMgJiYgKEZlLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gSy5zdGF0ZS5hbWJpZW50LCBGZS5saWdodFByb2JlLnZhbHVlID0gSy5zdGF0ZS5wcm9iZSwgRmUuZGlyZWN0aW9uYWxMaWdodHMudmFsdWUgPSBLLnN0YXRlLmRpcmVjdGlvbmFsLCBGZS5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy52YWx1ZSA9IEsuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3csIEZlLnNwb3RMaWdodHMudmFsdWUgPSBLLnN0YXRlLnNwb3QsIEZlLnNwb3RMaWdodFNoYWRvd3MudmFsdWUgPSBLLnN0YXRlLnNwb3RTaGFkb3csIEZlLnJlY3RBcmVhTGlnaHRzLnZhbHVlID0gSy5zdGF0ZS5yZWN0QXJlYSwgRmUubHRjXzEudmFsdWUgPSBLLnN0YXRlLnJlY3RBcmVhTFRDMSwgRmUubHRjXzIudmFsdWUgPSBLLnN0YXRlLnJlY3RBcmVhTFRDMiwgRmUucG9pbnRMaWdodHMudmFsdWUgPSBLLnN0YXRlLnBvaW50LCBGZS5wb2ludExpZ2h0U2hhZG93cy52YWx1ZSA9IEsuc3RhdGUucG9pbnRTaGFkb3csIEZlLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBLLnN0YXRlLmhlbWksIEZlLmRpcmVjdGlvbmFsU2hhZG93TWFwLnZhbHVlID0gSy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcCwgRmUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBLLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LCBGZS5zcG90U2hhZG93TWFwLnZhbHVlID0gSy5zdGF0ZS5zcG90U2hhZG93TWFwLCBGZS5zcG90U2hhZG93TWF0cml4LnZhbHVlID0gSy5zdGF0ZS5zcG90U2hhZG93TWF0cml4LCBGZS5wb2ludFNoYWRvd01hcC52YWx1ZSA9IEsuc3RhdGUucG9pbnRTaGFkb3dNYXAsIEZlLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gSy5zdGF0ZS5wb2ludFNoYWRvd01hdHJpeCk7XG4gICAgY29uc3Qga2UgPSBMZS5nZXRVbmlmb3JtcygpLCB1biA9IFZpLnNlcVdpdGhWYWx1ZShrZS5zZXEsIEZlKTtcbiAgICByZXR1cm4gVy5jdXJyZW50UHJvZ3JhbSA9IExlLCBXLnVuaWZvcm1zTGlzdCA9IHVuLCBMZTtcbiAgfVxuICBmdW5jdGlvbiBYcyhULCBVKSB7XG4gICAgY29uc3QgWCA9IEVlLmdldChUKTtcbiAgICBYLm91dHB1dEVuY29kaW5nID0gVS5vdXRwdXRFbmNvZGluZywgWC5pbnN0YW5jaW5nID0gVS5pbnN0YW5jaW5nLCBYLnNraW5uaW5nID0gVS5za2lubmluZywgWC5tb3JwaFRhcmdldHMgPSBVLm1vcnBoVGFyZ2V0cywgWC5tb3JwaE5vcm1hbHMgPSBVLm1vcnBoTm9ybWFscywgWC5tb3JwaENvbG9ycyA9IFUubW9ycGhDb2xvcnMsIFgubW9ycGhUYXJnZXRzQ291bnQgPSBVLm1vcnBoVGFyZ2V0c0NvdW50LCBYLm51bUNsaXBwaW5nUGxhbmVzID0gVS5udW1DbGlwcGluZ1BsYW5lcywgWC5udW1JbnRlcnNlY3Rpb24gPSBVLm51bUNsaXBJbnRlcnNlY3Rpb24sIFgudmVydGV4QWxwaGFzID0gVS52ZXJ0ZXhBbHBoYXMsIFgudmVydGV4VGFuZ2VudHMgPSBVLnZlcnRleFRhbmdlbnRzLCBYLnRvbmVNYXBwaW5nID0gVS50b25lTWFwcGluZztcbiAgfVxuICBmdW5jdGlvbiBGbyhULCBVLCBYLCBXLCBLKSB7XG4gICAgVS5pc1NjZW5lICE9PSAhMCAmJiAoVSA9IGNlKSwgbWUucmVzZXRUZXh0dXJlVW5pdHMoKTtcbiAgICBjb25zdCBfZSA9IFUuZm9nLCBiZSA9IFcuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IFUuZW52aXJvbm1lbnQgOiBudWxsLCBTZSA9IHcgPT09IG51bGwgPyBwLm91dHB1dEVuY29kaW5nIDogdy5pc1hSUmVuZGVyVGFyZ2V0ID09PSAhMCA/IHcudGV4dHVyZS5lbmNvZGluZyA6IDNlMywgTWUgPSAoVy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gdXQgOiBldCkuZ2V0KFcuZW52TWFwIHx8IGJlKSwgQmUgPSBXLnZlcnRleENvbG9ycyA9PT0gITAgJiYgISFYLmF0dHJpYnV0ZXMuY29sb3IgJiYgWC5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplID09PSA0LCBMZSA9ICEhVy5ub3JtYWxNYXAgJiYgISFYLmF0dHJpYnV0ZXMudGFuZ2VudCwgRmUgPSAhIVgubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLCBrZSA9ICEhWC5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsLCB1biA9ICEhWC5tb3JwaEF0dHJpYnV0ZXMuY29sb3IsIENuID0gVy50b25lTWFwcGVkID8gcC50b25lTWFwcGluZyA6IDAsIExuID0gWC5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgWC5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIHx8IFgubW9ycGhBdHRyaWJ1dGVzLmNvbG9yLCBEdCA9IExuICE9PSB2b2lkIDAgPyBMbi5sZW5ndGggOiAwLCB6ZSA9IEVlLmdldChXKSwgUm4gPSB1LnN0YXRlLmxpZ2h0cztcbiAgICBpZiAoayA9PT0gITAgJiYgKE4gPT09ICEwIHx8IFQgIT09IE0pKSB7XG4gICAgICBjb25zdCBkdCA9IFQgPT09IE0gJiYgVy5pZCA9PT0geDtcbiAgICAgIFMuc2V0U3RhdGUoVywgVCwgZHQpO1xuICAgIH1cbiAgICBsZXQgSGUgPSAhMTtcbiAgICBXLnZlcnNpb24gPT09IHplLl9fdmVyc2lvbiA/ICh6ZS5uZWVkc0xpZ2h0cyAmJiB6ZS5saWdodHNTdGF0ZVZlcnNpb24gIT09IFJuLnN0YXRlLnZlcnNpb24gfHwgemUub3V0cHV0RW5jb2RpbmcgIT09IFNlIHx8IEsuaXNJbnN0YW5jZWRNZXNoICYmIHplLmluc3RhbmNpbmcgPT09ICExIHx8ICFLLmlzSW5zdGFuY2VkTWVzaCAmJiB6ZS5pbnN0YW5jaW5nID09PSAhMCB8fCBLLmlzU2tpbm5lZE1lc2ggJiYgemUuc2tpbm5pbmcgPT09ICExIHx8ICFLLmlzU2tpbm5lZE1lc2ggJiYgemUuc2tpbm5pbmcgPT09ICEwIHx8IHplLmVudk1hcCAhPT0gTWUgfHwgVy5mb2cgPT09ICEwICYmIHplLmZvZyAhPT0gX2UgfHwgemUubnVtQ2xpcHBpbmdQbGFuZXMgIT09IHZvaWQgMCAmJiAoemUubnVtQ2xpcHBpbmdQbGFuZXMgIT09IFMubnVtUGxhbmVzIHx8IHplLm51bUludGVyc2VjdGlvbiAhPT0gUy5udW1JbnRlcnNlY3Rpb24pIHx8IHplLnZlcnRleEFscGhhcyAhPT0gQmUgfHwgemUudmVydGV4VGFuZ2VudHMgIT09IExlIHx8IHplLm1vcnBoVGFyZ2V0cyAhPT0gRmUgfHwgemUubW9ycGhOb3JtYWxzICE9PSBrZSB8fCB6ZS5tb3JwaENvbG9ycyAhPT0gdW4gfHwgemUudG9uZU1hcHBpbmcgIT09IENuIHx8IHhlLmlzV2ViR0wyID09PSAhMCAmJiB6ZS5tb3JwaFRhcmdldHNDb3VudCAhPT0gRHQpICYmIChIZSA9ICEwKSA6IChIZSA9ICEwLCB6ZS5fX3ZlcnNpb24gPSBXLnZlcnNpb24pO1xuICAgIGxldCB5dCA9IHplLmN1cnJlbnRQcm9ncmFtO1xuICAgIEhlID09PSAhMCAmJiAoeXQgPSBaaShXLCBVLCBLKSk7XG4gICAgbGV0IHRuID0gITEsIEpuID0gITEsICRpID0gITE7XG4gICAgY29uc3Qgb3QgPSB5dC5nZXRVbmlmb3JtcygpLCBRbiA9IHplLnVuaWZvcm1zO1xuICAgIGlmICh1ZS51c2VQcm9ncmFtKHl0LnByb2dyYW0pICYmICh0biA9ICEwLCBKbiA9ICEwLCAkaSA9ICEwKSwgVy5pZCAhPT0geCAmJiAoeCA9IFcuaWQsIEpuID0gITApLCB0biB8fCBNICE9PSBUKSB7XG4gICAgICBpZiAob3Quc2V0VmFsdWUoJCwgXCJwcm9qZWN0aW9uTWF0cml4XCIsIFQucHJvamVjdGlvbk1hdHJpeCksIHhlLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgb3Quc2V0VmFsdWUoXG4gICAgICAgICQsXG4gICAgICAgIFwibG9nRGVwdGhCdWZGQ1wiLFxuICAgICAgICAyIC8gKE1hdGgubG9nKFQuZmFyICsgMSkgLyBNYXRoLkxOMilcbiAgICAgICksIE0gIT09IFQgJiYgKE0gPSBULCBKbiA9ICEwLCAkaSA9ICEwKSwgVy5pc1NoYWRlck1hdGVyaWFsIHx8IFcuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBXLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBXLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgVy5lbnZNYXApIHtcbiAgICAgICAgY29uc3QgZHQgPSBvdC5tYXAuY2FtZXJhUG9zaXRpb247XG4gICAgICAgIGR0ICE9PSB2b2lkIDAgJiYgZHQuc2V0VmFsdWUoXG4gICAgICAgICAgJCxcbiAgICAgICAgICBlZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oVC5tYXRyaXhXb3JsZClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIChXLmlzTWVzaFBob25nTWF0ZXJpYWwgfHwgVy5pc01lc2hUb29uTWF0ZXJpYWwgfHwgVy5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHwgVy5pc01lc2hCYXNpY01hdGVyaWFsIHx8IFcuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fCBXLmlzU2hhZGVyTWF0ZXJpYWwpICYmIG90LnNldFZhbHVlKCQsIFwiaXNPcnRob2dyYXBoaWNcIiwgVC5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9PT0gITApLCAoVy5pc01lc2hQaG9uZ01hdGVyaWFsIHx8IFcuaXNNZXNoVG9vbk1hdGVyaWFsIHx8IFcuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IFcuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fCBXLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgVy5pc1NoYWRlck1hdGVyaWFsIHx8IFcuaXNTaGFkb3dNYXRlcmlhbCB8fCBLLmlzU2tpbm5lZE1lc2gpICYmIG90LnNldFZhbHVlKCQsIFwidmlld01hdHJpeFwiLCBULm1hdHJpeFdvcmxkSW52ZXJzZSk7XG4gICAgfVxuICAgIGlmIChLLmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgIG90LnNldE9wdGlvbmFsKCQsIEssIFwiYmluZE1hdHJpeFwiKSwgb3Quc2V0T3B0aW9uYWwoJCwgSywgXCJiaW5kTWF0cml4SW52ZXJzZVwiKTtcbiAgICAgIGNvbnN0IGR0ID0gSy5za2VsZXRvbjtcbiAgICAgIGR0ICYmICh4ZS5mbG9hdFZlcnRleFRleHR1cmVzID8gKGR0LmJvbmVUZXh0dXJlID09PSBudWxsICYmIGR0LmNvbXB1dGVCb25lVGV4dHVyZSgpLCBvdC5zZXRWYWx1ZSgkLCBcImJvbmVUZXh0dXJlXCIsIGR0LmJvbmVUZXh0dXJlLCBtZSksIG90LnNldFZhbHVlKCQsIFwiYm9uZVRleHR1cmVTaXplXCIsIGR0LmJvbmVUZXh0dXJlU2l6ZSkpIDogY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogU2tpbm5lZE1lc2ggY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMIDIuIFdpdGggV2ViR0wgMSBPRVNfdGV4dHVyZV9mbG9hdCBhbmQgdmVydGV4IHRleHR1cmVzIHN1cHBvcnQgaXMgcmVxdWlyZWQuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgS2kgPSBYLm1vcnBoQXR0cmlidXRlcztcbiAgICBpZiAoKEtpLnBvc2l0aW9uICE9PSB2b2lkIDAgfHwgS2kubm9ybWFsICE9PSB2b2lkIDAgfHwgS2kuY29sb3IgIT09IHZvaWQgMCAmJiB4ZS5pc1dlYkdMMiA9PT0gITApICYmIHRlLnVwZGF0ZShLLCBYLCBXLCB5dCksIChKbiB8fCB6ZS5yZWNlaXZlU2hhZG93ICE9PSBLLnJlY2VpdmVTaGFkb3cpICYmICh6ZS5yZWNlaXZlU2hhZG93ID0gSy5yZWNlaXZlU2hhZG93LCBvdC5zZXRWYWx1ZSgkLCBcInJlY2VpdmVTaGFkb3dcIiwgSy5yZWNlaXZlU2hhZG93KSksIEpuICYmIChvdC5zZXRWYWx1ZSgkLCBcInRvbmVNYXBwaW5nRXhwb3N1cmVcIiwgcC50b25lTWFwcGluZ0V4cG9zdXJlKSwgemUubmVlZHNMaWdodHMgJiYgRG8oUW4sICRpKSwgX2UgJiYgVy5mb2cgPT09ICEwICYmIEd0LnJlZnJlc2hGb2dVbmlmb3JtcyhRbiwgX2UpLCBHdC5yZWZyZXNoTWF0ZXJpYWxVbmlmb3JtcyhRbiwgVywgUCwgRiwgSCksIFZpLnVwbG9hZCgkLCB6ZS51bmlmb3Jtc0xpc3QsIFFuLCBtZSkpLCBXLmlzU2hhZGVyTWF0ZXJpYWwgJiYgVy51bmlmb3Jtc05lZWRVcGRhdGUgPT09ICEwICYmIChWaS51cGxvYWQoJCwgemUudW5pZm9ybXNMaXN0LCBRbiwgbWUpLCBXLnVuaWZvcm1zTmVlZFVwZGF0ZSA9ICExKSwgVy5pc1Nwcml0ZU1hdGVyaWFsICYmIG90LnNldFZhbHVlKCQsIFwiY2VudGVyXCIsIEsuY2VudGVyKSwgb3Quc2V0VmFsdWUoJCwgXCJtb2RlbFZpZXdNYXRyaXhcIiwgSy5tb2RlbFZpZXdNYXRyaXgpLCBvdC5zZXRWYWx1ZSgkLCBcIm5vcm1hbE1hdHJpeFwiLCBLLm5vcm1hbE1hdHJpeCksIG90LnNldFZhbHVlKCQsIFwibW9kZWxNYXRyaXhcIiwgSy5tYXRyaXhXb3JsZCksIFcuaXNTaGFkZXJNYXRlcmlhbCB8fCBXLmlzUmF3U2hhZGVyTWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IGR0ID0gVy51bmlmb3Jtc0dyb3VwcztcbiAgICAgIGZvciAobGV0IEppID0gMCwgSW8gPSBkdC5sZW5ndGg7IEppIDwgSW87IEppKyspXG4gICAgICAgIGlmICh4ZS5pc1dlYkdMMikge1xuICAgICAgICAgIGNvbnN0IGpzID0gZHRbSmldO1xuICAgICAgICAgIGhlLnVwZGF0ZShqcywgeXQpLCBoZS5iaW5kKGpzLCB5dCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVuaWZvcm0gQnVmZmVyIE9iamVjdHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMIDIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4geXQ7XG4gIH1cbiAgZnVuY3Rpb24gRG8oVCwgVSkge1xuICAgIFQuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSBVLCBULmxpZ2h0UHJvYmUubmVlZHNVcGRhdGUgPSBVLCBULmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlID0gVSwgVC5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IFUsIFQucG9pbnRMaWdodHMubmVlZHNVcGRhdGUgPSBVLCBULnBvaW50TGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlID0gVSwgVC5zcG90TGlnaHRzLm5lZWRzVXBkYXRlID0gVSwgVC5zcG90TGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlID0gVSwgVC5yZWN0QXJlYUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IFUsIFQuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IFU7XG4gIH1cbiAgZnVuY3Rpb24gUG8oVCkge1xuICAgIHJldHVybiBULmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBULmlzTWVzaFRvb25NYXRlcmlhbCB8fCBULmlzTWVzaFBob25nTWF0ZXJpYWwgfHwgVC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IFQuaXNTaGFkb3dNYXRlcmlhbCB8fCBULmlzU2hhZGVyTWF0ZXJpYWwgJiYgVC5saWdodHMgPT09ICEwO1xuICB9XG4gIHRoaXMuZ2V0QWN0aXZlQ3ViZUZhY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdjtcbiAgfSwgdGhpcy5nZXRBY3RpdmVNaXBtYXBMZXZlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfO1xuICB9LCB0aGlzLmdldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3O1xuICB9LCB0aGlzLnNldFJlbmRlclRhcmdldFRleHR1cmVzID0gZnVuY3Rpb24oVCwgVSwgWCkge1xuICAgIEVlLmdldChULnRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlID0gVSwgRWUuZ2V0KFQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSA9IFg7XG4gICAgY29uc3QgVyA9IEVlLmdldChUKTtcbiAgICBXLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyA9ICEwLCBXLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyAmJiAoVy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyID0gWCA9PT0gdm9pZCAwLCBXLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIgfHwgdmUuaGFzKFwiV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlXCIpID09PSAhMCAmJiAoY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogUmVuZGVyLXRvLXRleHR1cmUgZXh0ZW5zaW9uIHdhcyBkaXNhYmxlZCBiZWNhdXNlIGFuIGV4dGVybmFsIHRleHR1cmUgd2FzIHByb3ZpZGVkXCIpLCBXLl9fdXNlUmVuZGVyVG9UZXh0dXJlID0gITEpKTtcbiAgfSwgdGhpcy5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlciA9IGZ1bmN0aW9uKFQsIFUpIHtcbiAgICBjb25zdCBYID0gRWUuZ2V0KFQpO1xuICAgIFguX193ZWJnbEZyYW1lYnVmZmVyID0gVSwgWC5fX3VzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IFUgPT09IHZvaWQgMDtcbiAgfSwgdGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbihULCBVID0gMCwgWCA9IDApIHtcbiAgICB3ID0gVCwgdiA9IFUsIF8gPSBYO1xuICAgIGxldCBXID0gITA7XG4gICAgaWYgKFQpIHtcbiAgICAgIGNvbnN0IE1lID0gRWUuZ2V0KFQpO1xuICAgICAgTWUuX191c2VEZWZhdWx0RnJhbWVidWZmZXIgIT09IHZvaWQgMCA/ICh1ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIG51bGwpLCBXID0gITEpIDogTWUuX193ZWJnbEZyYW1lYnVmZmVyID09PSB2b2lkIDAgPyBtZS5zZXR1cFJlbmRlclRhcmdldChUKSA6IE1lLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyAmJiBtZS5yZWJpbmRUZXh0dXJlcyhULCBFZS5nZXQoVC50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSwgRWUuZ2V0KFQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSk7XG4gICAgfVxuICAgIGxldCBLID0gbnVsbCwgX2UgPSAhMSwgYmUgPSAhMTtcbiAgICBpZiAoVCkge1xuICAgICAgY29uc3QgTWUgPSBULnRleHR1cmU7XG4gICAgICAoTWUuaXNEYXRhM0RUZXh0dXJlIHx8IE1lLmlzRGF0YUFycmF5VGV4dHVyZSkgJiYgKGJlID0gITApO1xuICAgICAgY29uc3QgQmUgPSBFZS5nZXQoVCkuX193ZWJnbEZyYW1lYnVmZmVyO1xuICAgICAgVC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA/IChLID0gQmVbVV0sIF9lID0gITApIDogeGUuaXNXZWJHTDIgJiYgVC5zYW1wbGVzID4gMCAmJiBtZS51c2VNdWx0aXNhbXBsZWRSVFQoVCkgPT09ICExID8gSyA9IEVlLmdldChUKS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIgOiBLID0gQmUsIEUuY29weShULnZpZXdwb3J0KSwgUi5jb3B5KFQuc2Npc3NvciksIHkgPSBULnNjaXNzb3JUZXN0O1xuICAgIH0gZWxzZVxuICAgICAgRS5jb3B5KEwpLm11bHRpcGx5U2NhbGFyKFApLmZsb29yKCksIFIuY29weShJKS5tdWx0aXBseVNjYWxhcihQKS5mbG9vcigpLCB5ID0gRDtcbiAgICBpZiAodWUuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBLKSAmJiB4ZS5kcmF3QnVmZmVycyAmJiBXICYmIHVlLmRyYXdCdWZmZXJzKFQsIEspLCB1ZS52aWV3cG9ydChFKSwgdWUuc2Npc3NvcihSKSwgdWUuc2V0U2Npc3NvclRlc3QoeSksIF9lKSB7XG4gICAgICBjb25zdCBNZSA9IEVlLmdldChULnRleHR1cmUpO1xuICAgICAgJC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCwgMzYwNjQsIDM0MDY5ICsgVSwgTWUuX193ZWJnbFRleHR1cmUsIFgpO1xuICAgIH0gZWxzZSBpZiAoYmUpIHtcbiAgICAgIGNvbnN0IE1lID0gRWUuZ2V0KFQudGV4dHVyZSksIEJlID0gVSB8fCAwO1xuICAgICAgJC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcigzNjE2MCwgMzYwNjQsIE1lLl9fd2ViZ2xUZXh0dXJlLCBYIHx8IDAsIEJlKTtcbiAgICB9XG4gICAgeCA9IC0xO1xuICB9LCB0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbihULCBVLCBYLCBXLCBLLCBfZSwgYmUpIHtcbiAgICBpZiAoIShUICYmIFQuaXNXZWJHTFJlbmRlclRhcmdldCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgU2UgPSBFZS5nZXQoVCkuX193ZWJnbEZyYW1lYnVmZmVyO1xuICAgIGlmIChULmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICYmIGJlICE9PSB2b2lkIDAgJiYgKFNlID0gU2VbYmVdKSwgU2UpIHtcbiAgICAgIHVlLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgU2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgTWUgPSBULnRleHR1cmUsIEJlID0gTWUuZm9ybWF0LCBMZSA9IE1lLnR5cGU7XG4gICAgICAgIGlmIChCZSAhPT0gMTAyMyAmJiBqLmNvbnZlcnQoQmUpICE9PSAkLmdldFBhcmFtZXRlcigzNTczOSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBGZSA9IExlID09PSAxMDE2ICYmICh2ZS5oYXMoXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikgfHwgeGUuaXNXZWJHTDIgJiYgdmUuaGFzKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSk7XG4gICAgICAgIGlmIChMZSAhPT0gMTAwOSAmJiBqLmNvbnZlcnQoTGUpICE9PSAkLmdldFBhcmFtZXRlcigzNTczOCkgJiYgIShMZSA9PT0gMTAxNSAmJiAoeGUuaXNXZWJHTDIgfHwgdmUuaGFzKFwiT0VTX3RleHR1cmVfZmxvYXRcIikgfHwgdmUuaGFzKFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKSkgJiYgIUZlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFUgPj0gMCAmJiBVIDw9IFQud2lkdGggLSBXICYmIFggPj0gMCAmJiBYIDw9IFQuaGVpZ2h0IC0gSyAmJiAkLnJlYWRQaXhlbHMoVSwgWCwgVywgSywgai5jb252ZXJ0KEJlKSwgai5jb252ZXJ0KExlKSwgX2UpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgTWUgPSB3ICE9PSBudWxsID8gRWUuZ2V0KHcpLl9fd2ViZ2xGcmFtZWJ1ZmZlciA6IG51bGw7XG4gICAgICAgIHVlLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgTWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcy5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmUgPSBmdW5jdGlvbihULCBVLCBYID0gMCkge1xuICAgIGNvbnN0IFcgPSBNYXRoLnBvdygyLCAtWCksIEsgPSBNYXRoLmZsb29yKFUuaW1hZ2Uud2lkdGggKiBXKSwgX2UgPSBNYXRoLmZsb29yKFUuaW1hZ2UuaGVpZ2h0ICogVyk7XG4gICAgbWUuc2V0VGV4dHVyZTJEKFUsIDApLCAkLmNvcHlUZXhTdWJJbWFnZTJEKDM1NTMsIFgsIDAsIDAsIFQueCwgVC55LCBLLCBfZSksIHVlLnVuYmluZFRleHR1cmUoKTtcbiAgfSwgdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZSA9IGZ1bmN0aW9uKFQsIFUsIFgsIFcgPSAwKSB7XG4gICAgY29uc3QgSyA9IFUuaW1hZ2Uud2lkdGgsIF9lID0gVS5pbWFnZS5oZWlnaHQsIGJlID0gai5jb252ZXJ0KFguZm9ybWF0KSwgU2UgPSBqLmNvbnZlcnQoWC50eXBlKTtcbiAgICBtZS5zZXRUZXh0dXJlMkQoWCwgMCksICQucGl4ZWxTdG9yZWkoMzc0NDAsIFguZmxpcFkpLCAkLnBpeGVsU3RvcmVpKDM3NDQxLCBYLnByZW11bHRpcGx5QWxwaGEpLCAkLnBpeGVsU3RvcmVpKDMzMTcsIFgudW5wYWNrQWxpZ25tZW50KSwgVS5pc0RhdGFUZXh0dXJlID8gJC50ZXhTdWJJbWFnZTJEKDM1NTMsIFcsIFQueCwgVC55LCBLLCBfZSwgYmUsIFNlLCBVLmltYWdlLmRhdGEpIDogVS5pc0NvbXByZXNzZWRUZXh0dXJlID8gJC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCgzNTUzLCBXLCBULngsIFQueSwgVS5taXBtYXBzWzBdLndpZHRoLCBVLm1pcG1hcHNbMF0uaGVpZ2h0LCBiZSwgVS5taXBtYXBzWzBdLmRhdGEpIDogJC50ZXhTdWJJbWFnZTJEKDM1NTMsIFcsIFQueCwgVC55LCBiZSwgU2UsIFUuaW1hZ2UpLCBXID09PSAwICYmIFguZ2VuZXJhdGVNaXBtYXBzICYmICQuZ2VuZXJhdGVNaXBtYXAoMzU1MyksIHVlLnVuYmluZFRleHR1cmUoKTtcbiAgfSwgdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEID0gZnVuY3Rpb24oVCwgVSwgWCwgVywgSyA9IDApIHtcbiAgICBpZiAocC5pc1dlYkdMMVJlbmRlcmVyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBfZSA9IFQubWF4LnggLSBULm1pbi54ICsgMSwgYmUgPSBULm1heC55IC0gVC5taW4ueSArIDEsIFNlID0gVC5tYXgueiAtIFQubWluLnogKyAxLCBNZSA9IGouY29udmVydChXLmZvcm1hdCksIEJlID0gai5jb252ZXJ0KFcudHlwZSk7XG4gICAgbGV0IExlO1xuICAgIGlmIChXLmlzRGF0YTNEVGV4dHVyZSlcbiAgICAgIG1lLnNldFRleHR1cmUzRChXLCAwKSwgTGUgPSAzMjg3OTtcbiAgICBlbHNlIGlmIChXLmlzRGF0YUFycmF5VGV4dHVyZSlcbiAgICAgIG1lLnNldFRleHR1cmUyREFycmF5KFcsIDApLCBMZSA9IDM1ODY2O1xuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiBvbmx5IHN1cHBvcnRzIFRIUkVFLkRhdGFUZXh0dXJlM0QgYW5kIFRIUkVFLkRhdGFUZXh0dXJlMkRBcnJheS5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICQucGl4ZWxTdG9yZWkoMzc0NDAsIFcuZmxpcFkpLCAkLnBpeGVsU3RvcmVpKDM3NDQxLCBXLnByZW11bHRpcGx5QWxwaGEpLCAkLnBpeGVsU3RvcmVpKDMzMTcsIFcudW5wYWNrQWxpZ25tZW50KTtcbiAgICBjb25zdCBGZSA9ICQuZ2V0UGFyYW1ldGVyKDMzMTQpLCBrZSA9ICQuZ2V0UGFyYW1ldGVyKDMyODc4KSwgdW4gPSAkLmdldFBhcmFtZXRlcigzMzE2KSwgQ24gPSAkLmdldFBhcmFtZXRlcigzMzE1KSwgTG4gPSAkLmdldFBhcmFtZXRlcigzMjg3NyksIER0ID0gWC5pc0NvbXByZXNzZWRUZXh0dXJlID8gWC5taXBtYXBzWzBdIDogWC5pbWFnZTtcbiAgICAkLnBpeGVsU3RvcmVpKDMzMTQsIER0LndpZHRoKSwgJC5waXhlbFN0b3JlaSgzMjg3OCwgRHQuaGVpZ2h0KSwgJC5waXhlbFN0b3JlaSgzMzE2LCBULm1pbi54KSwgJC5waXhlbFN0b3JlaSgzMzE1LCBULm1pbi55KSwgJC5waXhlbFN0b3JlaSgzMjg3NywgVC5taW4ueiksIFguaXNEYXRhVGV4dHVyZSB8fCBYLmlzRGF0YTNEVGV4dHVyZSA/ICQudGV4U3ViSW1hZ2UzRChMZSwgSywgVS54LCBVLnksIFUueiwgX2UsIGJlLCBTZSwgTWUsIEJlLCBEdC5kYXRhKSA6IFguaXNDb21wcmVzc2VkVGV4dHVyZSA/IChjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IHVudGVzdGVkIHN1cHBvcnQgZm9yIGNvbXByZXNzZWQgc3JjVGV4dHVyZS5cIiksICQuY29tcHJlc3NlZFRleFN1YkltYWdlM0QoTGUsIEssIFUueCwgVS55LCBVLnosIF9lLCBiZSwgU2UsIE1lLCBEdC5kYXRhKSkgOiAkLnRleFN1YkltYWdlM0QoTGUsIEssIFUueCwgVS55LCBVLnosIF9lLCBiZSwgU2UsIE1lLCBCZSwgRHQpLCAkLnBpeGVsU3RvcmVpKDMzMTQsIEZlKSwgJC5waXhlbFN0b3JlaSgzMjg3OCwga2UpLCAkLnBpeGVsU3RvcmVpKDMzMTYsIHVuKSwgJC5waXhlbFN0b3JlaSgzMzE1LCBDbiksICQucGl4ZWxTdG9yZWkoMzI4NzcsIExuKSwgSyA9PT0gMCAmJiBXLmdlbmVyYXRlTWlwbWFwcyAmJiAkLmdlbmVyYXRlTWlwbWFwKExlKSwgdWUudW5iaW5kVGV4dHVyZSgpO1xuICB9LCB0aGlzLmluaXRUZXh0dXJlID0gZnVuY3Rpb24oVCkge1xuICAgIFQuaXNDdWJlVGV4dHVyZSA/IG1lLnNldFRleHR1cmVDdWJlKFQsIDApIDogVC5pc0RhdGEzRFRleHR1cmUgPyBtZS5zZXRUZXh0dXJlM0QoVCwgMCkgOiBULmlzRGF0YUFycmF5VGV4dHVyZSA/IG1lLnNldFRleHR1cmUyREFycmF5KFQsIDApIDogbWUuc2V0VGV4dHVyZTJEKFQsIDApLCB1ZS51bmJpbmRUZXh0dXJlKCk7XG4gIH0sIHRoaXMucmVzZXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHYgPSAwLCBfID0gMCwgdyA9IG51bGwsIHVlLnJlc2V0KCksIHBlLnJlc2V0KCk7XG4gIH0sIHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gPCBcInVcIiAmJiBfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJvYnNlcnZlXCIsIHsgZGV0YWlsOiB0aGlzIH0pKTtcbn1cbmNsYXNzIEJ1IGV4dGVuZHMgeG8ge1xufVxuQnUucHJvdG90eXBlLmlzV2ViR0wxUmVuZGVyZXIgPSAhMDtcbmNsYXNzIE51IGV4dGVuZHMgYXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzU2NlbmUgPSAhMCwgdGhpcy50eXBlID0gXCJTY2VuZVwiLCB0aGlzLmJhY2tncm91bmQgPSBudWxsLCB0aGlzLmVudmlyb25tZW50ID0gbnVsbCwgdGhpcy5mb2cgPSBudWxsLCB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsLCB0aGlzLmF1dG9VcGRhdGUgPSAhMCwgdHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyA8IFwidVwiICYmIF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIm9ic2VydmVcIiwgeyBkZXRhaWw6IHRoaXMgfSkpO1xuICB9XG4gIGNvcHkoZSwgdCkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KGUsIHQpLCBlLmJhY2tncm91bmQgIT09IG51bGwgJiYgKHRoaXMuYmFja2dyb3VuZCA9IGUuYmFja2dyb3VuZC5jbG9uZSgpKSwgZS5lbnZpcm9ubWVudCAhPT0gbnVsbCAmJiAodGhpcy5lbnZpcm9ubWVudCA9IGUuZW52aXJvbm1lbnQuY2xvbmUoKSksIGUuZm9nICE9PSBudWxsICYmICh0aGlzLmZvZyA9IGUuZm9nLmNsb25lKCkpLCBlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgJiYgKHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IGUub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpKSwgdGhpcy5hdXRvVXBkYXRlID0gZS5hdXRvVXBkYXRlLCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBlLm1hdHJpeEF1dG9VcGRhdGUsIHRoaXM7XG4gIH1cbiAgdG9KU09OKGUpIHtcbiAgICBjb25zdCB0ID0gc3VwZXIudG9KU09OKGUpO1xuICAgIHJldHVybiB0aGlzLmZvZyAhPT0gbnVsbCAmJiAodC5vYmplY3QuZm9nID0gdGhpcy5mb2cudG9KU09OKCkpLCB0O1xuICB9XG59XG5jbGFzcyBSciBleHRlbmRzIF90IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSkge1xuICAgIHN1cGVyKGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEpLCB0aGlzLmlzQ2FudmFzVGV4dHVyZSA9ICEwLCB0aGlzLm5lZWRzVXBkYXRlID0gITA7XG4gIH1cbn1cbmNsYXNzIGtzIGV4dGVuZHMgVXQge1xuICBjb25zdHJ1Y3RvcihlID0gMSwgdCA9IDEsIG4gPSAxLCBpID0gOCwgcyA9IDEsIG8gPSAhMSwgciA9IDAsIGwgPSBNYXRoLlBJICogMikge1xuICAgIHN1cGVyKCksIHRoaXMudHlwZSA9IFwiQ3lsaW5kZXJHZW9tZXRyeVwiLCB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICByYWRpdXNUb3A6IGUsXG4gICAgICByYWRpdXNCb3R0b206IHQsXG4gICAgICBoZWlnaHQ6IG4sXG4gICAgICByYWRpYWxTZWdtZW50czogaSxcbiAgICAgIGhlaWdodFNlZ21lbnRzOiBzLFxuICAgICAgb3BlbkVuZGVkOiBvLFxuICAgICAgdGhldGFTdGFydDogcixcbiAgICAgIHRoZXRhTGVuZ3RoOiBsXG4gICAgfTtcbiAgICBjb25zdCBhID0gdGhpcztcbiAgICBpID0gTWF0aC5mbG9vcihpKSwgcyA9IE1hdGguZmxvb3Iocyk7XG4gICAgY29uc3QgYyA9IFtdLCBkID0gW10sIHUgPSBbXSwgbSA9IFtdO1xuICAgIGxldCBnID0gMDtcbiAgICBjb25zdCBwID0gW10sIGYgPSBuIC8gMjtcbiAgICBsZXQgdiA9IDA7XG4gICAgXygpLCBvID09PSAhMSAmJiAoZSA+IDAgJiYgdyghMCksIHQgPiAwICYmIHcoITEpKSwgdGhpcy5zZXRJbmRleChjKSwgdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgc3QoZCwgMykpLCB0aGlzLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgc3QodSwgMykpLCB0aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBzdChtLCAyKSk7XG4gICAgZnVuY3Rpb24gXygpIHtcbiAgICAgIGNvbnN0IHggPSBuZXcgTygpLCBNID0gbmV3IE8oKTtcbiAgICAgIGxldCBFID0gMDtcbiAgICAgIGNvbnN0IFIgPSAodCAtIGUpIC8gbjtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IHM7IHkrKykge1xuICAgICAgICBjb25zdCBBID0gW10sIEYgPSB5IC8gcywgUCA9IEYgKiAodCAtIGUpICsgZTtcbiAgICAgICAgZm9yIChsZXQgRyA9IDA7IEcgPD0gaTsgRysrKSB7XG4gICAgICAgICAgY29uc3QgeiA9IEcgLyBpLCBMID0geiAqIGwgKyByLCBJID0gTWF0aC5zaW4oTCksIEQgPSBNYXRoLmNvcyhMKTtcbiAgICAgICAgICBNLnggPSBQICogSSwgTS55ID0gLUYgKiBuICsgZiwgTS56ID0gUCAqIEQsIGQucHVzaChNLngsIE0ueSwgTS56KSwgeC5zZXQoSSwgUiwgRCkubm9ybWFsaXplKCksIHUucHVzaCh4LngsIHgueSwgeC56KSwgbS5wdXNoKHosIDEgLSBGKSwgQS5wdXNoKGcrKyk7XG4gICAgICAgIH1cbiAgICAgICAgcC5wdXNoKEEpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpOyB5KyspXG4gICAgICAgIGZvciAobGV0IEEgPSAwOyBBIDwgczsgQSsrKSB7XG4gICAgICAgICAgY29uc3QgRiA9IHBbQV1beV0sIFAgPSBwW0EgKyAxXVt5XSwgRyA9IHBbQSArIDFdW3kgKyAxXSwgeiA9IHBbQV1beSArIDFdO1xuICAgICAgICAgIGMucHVzaChGLCBQLCB6KSwgYy5wdXNoKFAsIEcsIHopLCBFICs9IDY7XG4gICAgICAgIH1cbiAgICAgIGEuYWRkR3JvdXAodiwgRSwgMCksIHYgKz0gRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdyh4KSB7XG4gICAgICBjb25zdCBNID0gZywgRSA9IG5ldyBDZSgpLCBSID0gbmV3IE8oKTtcbiAgICAgIGxldCB5ID0gMDtcbiAgICAgIGNvbnN0IEEgPSB4ID09PSAhMCA/IGUgOiB0LCBGID0geCA9PT0gITAgPyAxIDogLTE7XG4gICAgICBmb3IgKGxldCBHID0gMTsgRyA8PSBpOyBHKyspXG4gICAgICAgIGQucHVzaCgwLCBmICogRiwgMCksIHUucHVzaCgwLCBGLCAwKSwgbS5wdXNoKDAuNSwgMC41KSwgZysrO1xuICAgICAgY29uc3QgUCA9IGc7XG4gICAgICBmb3IgKGxldCBHID0gMDsgRyA8PSBpOyBHKyspIHtcbiAgICAgICAgY29uc3QgTCA9IEcgLyBpICogbCArIHIsIEkgPSBNYXRoLmNvcyhMKSwgRCA9IE1hdGguc2luKEwpO1xuICAgICAgICBSLnggPSBBICogRCwgUi55ID0gZiAqIEYsIFIueiA9IEEgKiBJLCBkLnB1c2goUi54LCBSLnksIFIueiksIHUucHVzaCgwLCBGLCAwKSwgRS54ID0gSSAqIDAuNSArIDAuNSwgRS55ID0gRCAqIDAuNSAqIEYgKyAwLjUsIG0ucHVzaChFLngsIEUueSksIGcrKztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IEcgPSAwOyBHIDwgaTsgRysrKSB7XG4gICAgICAgIGNvbnN0IHogPSBNICsgRywgTCA9IFAgKyBHO1xuICAgICAgICB4ID09PSAhMCA/IGMucHVzaChMLCBMICsgMSwgeikgOiBjLnB1c2goTCArIDEsIEwsIHopLCB5ICs9IDM7XG4gICAgICB9XG4gICAgICBhLmFkZEdyb3VwKHYsIHksIHggPT09ICEwID8gMSA6IDIpLCB2ICs9IHk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tSlNPTihlKSB7XG4gICAgcmV0dXJuIG5ldyBrcyhlLnJhZGl1c1RvcCwgZS5yYWRpdXNCb3R0b20sIGUuaGVpZ2h0LCBlLnJhZGlhbFNlZ21lbnRzLCBlLmhlaWdodFNlZ21lbnRzLCBlLm9wZW5FbmRlZCwgZS50aGV0YVN0YXJ0LCBlLnRoZXRhTGVuZ3RoKTtcbiAgfVxufVxuY2xhc3MgT3UgZXh0ZW5kcyBBbiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzU2hhZG93TWF0ZXJpYWwgPSAhMCwgdGhpcy50eXBlID0gXCJTaGFkb3dNYXRlcmlhbFwiLCB0aGlzLmNvbG9yID0gbmV3IEFlKDApLCB0aGlzLnRyYW5zcGFyZW50ID0gITAsIHRoaXMuZm9nID0gITAsIHRoaXMuc2V0VmFsdWVzKGUpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KGUpLCB0aGlzLmNvbG9yLmNvcHkoZS5jb2xvciksIHRoaXMuZm9nID0gZS5mb2csIHRoaXM7XG4gIH1cbn1cbmNsYXNzIFV1IGV4dGVuZHMgQW4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gITAsIHRoaXMuZGVmaW5lcyA9IHsgU1RBTkRBUkQ6IFwiXCIgfSwgdGhpcy50eXBlID0gXCJNZXNoU3RhbmRhcmRNYXRlcmlhbFwiLCB0aGlzLmNvbG9yID0gbmV3IEFlKDE2Nzc3MjE1KSwgdGhpcy5yb3VnaG5lc3MgPSAxLCB0aGlzLm1ldGFsbmVzcyA9IDAsIHRoaXMubWFwID0gbnVsbCwgdGhpcy5saWdodE1hcCA9IG51bGwsIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLCB0aGlzLmFvTWFwID0gbnVsbCwgdGhpcy5hb01hcEludGVuc2l0eSA9IDEsIHRoaXMuZW1pc3NpdmUgPSBuZXcgQWUoMCksIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLCB0aGlzLmVtaXNzaXZlTWFwID0gbnVsbCwgdGhpcy5idW1wTWFwID0gbnVsbCwgdGhpcy5idW1wU2NhbGUgPSAxLCB0aGlzLm5vcm1hbE1hcCA9IG51bGwsIHRoaXMubm9ybWFsTWFwVHlwZSA9IDAsIHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgQ2UoMSwgMSksIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbCwgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDEsIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDAsIHRoaXMucm91Z2huZXNzTWFwID0gbnVsbCwgdGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsLCB0aGlzLmFscGhhTWFwID0gbnVsbCwgdGhpcy5lbnZNYXAgPSBudWxsLCB0aGlzLmVudk1hcEludGVuc2l0eSA9IDEsIHRoaXMud2lyZWZyYW1lID0gITEsIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMSwgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gXCJyb3VuZFwiLCB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gXCJyb3VuZFwiLCB0aGlzLmZsYXRTaGFkaW5nID0gITEsIHRoaXMuZm9nID0gITAsIHRoaXMuc2V0VmFsdWVzKGUpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KGUpLCB0aGlzLmRlZmluZXMgPSB7IFNUQU5EQVJEOiBcIlwiIH0sIHRoaXMuY29sb3IuY29weShlLmNvbG9yKSwgdGhpcy5yb3VnaG5lc3MgPSBlLnJvdWdobmVzcywgdGhpcy5tZXRhbG5lc3MgPSBlLm1ldGFsbmVzcywgdGhpcy5tYXAgPSBlLm1hcCwgdGhpcy5saWdodE1hcCA9IGUubGlnaHRNYXAsIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBlLmxpZ2h0TWFwSW50ZW5zaXR5LCB0aGlzLmFvTWFwID0gZS5hb01hcCwgdGhpcy5hb01hcEludGVuc2l0eSA9IGUuYW9NYXBJbnRlbnNpdHksIHRoaXMuZW1pc3NpdmUuY29weShlLmVtaXNzaXZlKSwgdGhpcy5lbWlzc2l2ZU1hcCA9IGUuZW1pc3NpdmVNYXAsIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBlLmVtaXNzaXZlSW50ZW5zaXR5LCB0aGlzLmJ1bXBNYXAgPSBlLmJ1bXBNYXAsIHRoaXMuYnVtcFNjYWxlID0gZS5idW1wU2NhbGUsIHRoaXMubm9ybWFsTWFwID0gZS5ub3JtYWxNYXAsIHRoaXMubm9ybWFsTWFwVHlwZSA9IGUubm9ybWFsTWFwVHlwZSwgdGhpcy5ub3JtYWxTY2FsZS5jb3B5KGUubm9ybWFsU2NhbGUpLCB0aGlzLmRpc3BsYWNlbWVudE1hcCA9IGUuZGlzcGxhY2VtZW50TWFwLCB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gZS5kaXNwbGFjZW1lbnRTY2FsZSwgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gZS5kaXNwbGFjZW1lbnRCaWFzLCB0aGlzLnJvdWdobmVzc01hcCA9IGUucm91Z2huZXNzTWFwLCB0aGlzLm1ldGFsbmVzc01hcCA9IGUubWV0YWxuZXNzTWFwLCB0aGlzLmFscGhhTWFwID0gZS5hbHBoYU1hcCwgdGhpcy5lbnZNYXAgPSBlLmVudk1hcCwgdGhpcy5lbnZNYXBJbnRlbnNpdHkgPSBlLmVudk1hcEludGVuc2l0eSwgdGhpcy53aXJlZnJhbWUgPSBlLndpcmVmcmFtZSwgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBlLndpcmVmcmFtZUxpbmV3aWR0aCwgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gZS53aXJlZnJhbWVMaW5lY2FwLCB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gZS53aXJlZnJhbWVMaW5lam9pbiwgdGhpcy5mbGF0U2hhZGluZyA9IGUuZmxhdFNoYWRpbmcsIHRoaXMuZm9nID0gZS5mb2csIHRoaXM7XG4gIH1cbn1cbmNsYXNzIEd1IGV4dGVuZHMgQW4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc01lc2hQaG9uZ01hdGVyaWFsID0gITAsIHRoaXMudHlwZSA9IFwiTWVzaFBob25nTWF0ZXJpYWxcIiwgdGhpcy5jb2xvciA9IG5ldyBBZSgxNjc3NzIxNSksIHRoaXMuc3BlY3VsYXIgPSBuZXcgQWUoMTExODQ4MSksIHRoaXMuc2hpbmluZXNzID0gMzAsIHRoaXMubWFwID0gbnVsbCwgdGhpcy5saWdodE1hcCA9IG51bGwsIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLCB0aGlzLmFvTWFwID0gbnVsbCwgdGhpcy5hb01hcEludGVuc2l0eSA9IDEsIHRoaXMuZW1pc3NpdmUgPSBuZXcgQWUoMCksIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLCB0aGlzLmVtaXNzaXZlTWFwID0gbnVsbCwgdGhpcy5idW1wTWFwID0gbnVsbCwgdGhpcy5idW1wU2NhbGUgPSAxLCB0aGlzLm5vcm1hbE1hcCA9IG51bGwsIHRoaXMubm9ybWFsTWFwVHlwZSA9IDAsIHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgQ2UoMSwgMSksIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbCwgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDEsIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDAsIHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsLCB0aGlzLmFscGhhTWFwID0gbnVsbCwgdGhpcy5lbnZNYXAgPSBudWxsLCB0aGlzLmNvbWJpbmUgPSAwLCB0aGlzLnJlZmxlY3Rpdml0eSA9IDEsIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45OCwgdGhpcy53aXJlZnJhbWUgPSAhMSwgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxLCB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBcInJvdW5kXCIsIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBcInJvdW5kXCIsIHRoaXMuZmxhdFNoYWRpbmcgPSAhMSwgdGhpcy5mb2cgPSAhMCwgdGhpcy5zZXRWYWx1ZXMoZSk7XG4gIH1cbiAgY29weShlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSksIHRoaXMuY29sb3IuY29weShlLmNvbG9yKSwgdGhpcy5zcGVjdWxhci5jb3B5KGUuc3BlY3VsYXIpLCB0aGlzLnNoaW5pbmVzcyA9IGUuc2hpbmluZXNzLCB0aGlzLm1hcCA9IGUubWFwLCB0aGlzLmxpZ2h0TWFwID0gZS5saWdodE1hcCwgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IGUubGlnaHRNYXBJbnRlbnNpdHksIHRoaXMuYW9NYXAgPSBlLmFvTWFwLCB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gZS5hb01hcEludGVuc2l0eSwgdGhpcy5lbWlzc2l2ZS5jb3B5KGUuZW1pc3NpdmUpLCB0aGlzLmVtaXNzaXZlTWFwID0gZS5lbWlzc2l2ZU1hcCwgdGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IGUuZW1pc3NpdmVJbnRlbnNpdHksIHRoaXMuYnVtcE1hcCA9IGUuYnVtcE1hcCwgdGhpcy5idW1wU2NhbGUgPSBlLmJ1bXBTY2FsZSwgdGhpcy5ub3JtYWxNYXAgPSBlLm5vcm1hbE1hcCwgdGhpcy5ub3JtYWxNYXBUeXBlID0gZS5ub3JtYWxNYXBUeXBlLCB0aGlzLm5vcm1hbFNjYWxlLmNvcHkoZS5ub3JtYWxTY2FsZSksIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gZS5kaXNwbGFjZW1lbnRNYXAsIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBlLmRpc3BsYWNlbWVudFNjYWxlLCB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBlLmRpc3BsYWNlbWVudEJpYXMsIHRoaXMuc3BlY3VsYXJNYXAgPSBlLnNwZWN1bGFyTWFwLCB0aGlzLmFscGhhTWFwID0gZS5hbHBoYU1hcCwgdGhpcy5lbnZNYXAgPSBlLmVudk1hcCwgdGhpcy5jb21iaW5lID0gZS5jb21iaW5lLCB0aGlzLnJlZmxlY3Rpdml0eSA9IGUucmVmbGVjdGl2aXR5LCB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IGUucmVmcmFjdGlvblJhdGlvLCB0aGlzLndpcmVmcmFtZSA9IGUud2lyZWZyYW1lLCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IGUud2lyZWZyYW1lTGluZXdpZHRoLCB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBlLndpcmVmcmFtZUxpbmVjYXAsIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBlLndpcmVmcmFtZUxpbmVqb2luLCB0aGlzLmZsYXRTaGFkaW5nID0gZS5mbGF0U2hhZGluZywgdGhpcy5mb2cgPSBlLmZvZywgdGhpcztcbiAgfVxufVxuY2xhc3MgeW8gZXh0ZW5kcyBhdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQgPSAxKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc0xpZ2h0ID0gITAsIHRoaXMudHlwZSA9IFwiTGlnaHRcIiwgdGhpcy5jb2xvciA9IG5ldyBBZShlKSwgdGhpcy5pbnRlbnNpdHkgPSB0O1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gIH1cbiAgY29weShlLCB0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSwgdCksIHRoaXMuY29sb3IuY29weShlLmNvbG9yKSwgdGhpcy5pbnRlbnNpdHkgPSBlLmludGVuc2l0eSwgdGhpcztcbiAgfVxuICB0b0pTT04oZSkge1xuICAgIGNvbnN0IHQgPSBzdXBlci50b0pTT04oZSk7XG4gICAgcmV0dXJuIHQub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKSwgdC5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHksIHRoaXMuZ3JvdW5kQ29sb3IgIT09IHZvaWQgMCAmJiAodC5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpKSwgdGhpcy5kaXN0YW5jZSAhPT0gdm9pZCAwICYmICh0Lm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UpLCB0aGlzLmFuZ2xlICE9PSB2b2lkIDAgJiYgKHQub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZSksIHRoaXMuZGVjYXkgIT09IHZvaWQgMCAmJiAodC5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5KSwgdGhpcy5wZW51bWJyYSAhPT0gdm9pZCAwICYmICh0Lm9iamVjdC5wZW51bWJyYSA9IHRoaXMucGVudW1icmEpLCB0aGlzLnNoYWRvdyAhPT0gdm9pZCAwICYmICh0Lm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKSksIHQ7XG4gIH1cbn1cbmNsYXNzIGt1IGV4dGVuZHMgeW8ge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgc3VwZXIoZSwgbiksIHRoaXMuaXNIZW1pc3BoZXJlTGlnaHQgPSAhMCwgdGhpcy50eXBlID0gXCJIZW1pc3BoZXJlTGlnaHRcIiwgdGhpcy5wb3NpdGlvbi5jb3B5KGF0LkRlZmF1bHRVcCksIHRoaXMudXBkYXRlTWF0cml4KCksIHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgQWUodCk7XG4gIH1cbiAgY29weShlLCB0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSwgdCksIHRoaXMuZ3JvdW5kQ29sb3IuY29weShlLmdyb3VuZENvbG9yKSwgdGhpcztcbiAgfVxufVxuY29uc3QgRnIgPSAvKiBAX19QVVJFX18gKi8gbmV3IEtlKCksIERyID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCksIFByID0gLyogQF9fUFVSRV9fICovIG5ldyBPKCk7XG5jbGFzcyBXdSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IGUsIHRoaXMuYmlhcyA9IDAsIHRoaXMubm9ybWFsQmlhcyA9IDAsIHRoaXMucmFkaXVzID0gMSwgdGhpcy5ibHVyU2FtcGxlcyA9IDgsIHRoaXMubWFwU2l6ZSA9IG5ldyBDZSg1MTIsIDUxMiksIHRoaXMubWFwID0gbnVsbCwgdGhpcy5tYXBQYXNzID0gbnVsbCwgdGhpcy5tYXRyaXggPSBuZXcgS2UoKSwgdGhpcy5hdXRvVXBkYXRlID0gITAsIHRoaXMubmVlZHNVcGRhdGUgPSAhMSwgdGhpcy5fZnJ1c3R1bSA9IG5ldyBVcygpLCB0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgQ2UoMSwgMSksIHRoaXMuX3ZpZXdwb3J0Q291bnQgPSAxLCB0aGlzLl92aWV3cG9ydHMgPSBbXG4gICAgICBuZXcgJGUoMCwgMCwgMSwgMSlcbiAgICBdO1xuICB9XG4gIGdldFZpZXdwb3J0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0Q291bnQ7XG4gIH1cbiAgZ2V0RnJ1c3R1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJ1c3R1bTtcbiAgfVxuICB1cGRhdGVNYXRyaWNlcyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2FtZXJhLCBuID0gdGhpcy5tYXRyaXg7XG4gICAgRHIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpLCB0LnBvc2l0aW9uLmNvcHkoRHIpLCBQci5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS50YXJnZXQubWF0cml4V29ybGQpLCB0Lmxvb2tBdChQciksIHQudXBkYXRlTWF0cml4V29ybGQoKSwgRnIubXVsdGlwbHlNYXRyaWNlcyh0LnByb2plY3Rpb25NYXRyaXgsIHQubWF0cml4V29ybGRJbnZlcnNlKSwgdGhpcy5fZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChGciksIG4uc2V0KFxuICAgICAgMC41LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjUsXG4gICAgICAwLFxuICAgICAgMC41LFxuICAgICAgMCxcbiAgICAgIDAuNSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMC41LFxuICAgICAgMC41LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgICksIG4ubXVsdGlwbHkodC5wcm9qZWN0aW9uTWF0cml4KSwgbi5tdWx0aXBseSh0Lm1hdHJpeFdvcmxkSW52ZXJzZSk7XG4gIH1cbiAgZ2V0Vmlld3BvcnQoZSkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydHNbZV07XG4gIH1cbiAgZ2V0RnJhbWVFeHRlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZUV4dGVudHM7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLm1hcCAmJiB0aGlzLm1hcC5kaXNwb3NlKCksIHRoaXMubWFwUGFzcyAmJiB0aGlzLm1hcFBhc3MuZGlzcG9zZSgpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYSA9IGUuY2FtZXJhLmNsb25lKCksIHRoaXMuYmlhcyA9IGUuYmlhcywgdGhpcy5yYWRpdXMgPSBlLnJhZGl1cywgdGhpcy5tYXBTaXplLmNvcHkoZS5tYXBTaXplKSwgdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgcmV0dXJuIHRoaXMuYmlhcyAhPT0gMCAmJiAoZS5iaWFzID0gdGhpcy5iaWFzKSwgdGhpcy5ub3JtYWxCaWFzICE9PSAwICYmIChlLm5vcm1hbEJpYXMgPSB0aGlzLm5vcm1hbEJpYXMpLCB0aGlzLnJhZGl1cyAhPT0gMSAmJiAoZS5yYWRpdXMgPSB0aGlzLnJhZGl1cyksICh0aGlzLm1hcFNpemUueCAhPT0gNTEyIHx8IHRoaXMubWFwU2l6ZS55ICE9PSA1MTIpICYmIChlLm1hcFNpemUgPSB0aGlzLm1hcFNpemUudG9BcnJheSgpKSwgZS5jYW1lcmEgPSB0aGlzLmNhbWVyYS50b0pTT04oITEpLm9iamVjdCwgZGVsZXRlIGUuY2FtZXJhLm1hdHJpeCwgZTtcbiAgfVxufVxuY2xhc3MgVnUgZXh0ZW5kcyBXdSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG5ldyBndCg1MCwgMSwgMC41LCA1MDApKSwgdGhpcy5pc1Nwb3RMaWdodFNoYWRvdyA9ICEwLCB0aGlzLmZvY3VzID0gMTtcbiAgfVxuICB1cGRhdGVNYXRyaWNlcyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2FtZXJhLCBuID0genMgKiAyICogZS5hbmdsZSAqIHRoaXMuZm9jdXMsIGkgPSB0aGlzLm1hcFNpemUud2lkdGggLyB0aGlzLm1hcFNpemUuaGVpZ2h0LCBzID0gZS5kaXN0YW5jZSB8fCB0LmZhcjtcbiAgICAobiAhPT0gdC5mb3YgfHwgaSAhPT0gdC5hc3BlY3QgfHwgcyAhPT0gdC5mYXIpICYmICh0LmZvdiA9IG4sIHQuYXNwZWN0ID0gaSwgdC5mYXIgPSBzLCB0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSksIHN1cGVyLnVwZGF0ZU1hdHJpY2VzKGUpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KGUpLCB0aGlzLmZvY3VzID0gZS5mb2N1cywgdGhpcztcbiAgfVxufVxuY2xhc3MgSHUgZXh0ZW5kcyB5byB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4gPSAwLCBpID0gTWF0aC5QSSAvIDMsIHMgPSAwLCBvID0gMSkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmlzU3BvdExpZ2h0ID0gITAsIHRoaXMudHlwZSA9IFwiU3BvdExpZ2h0XCIsIHRoaXMucG9zaXRpb24uY29weShhdC5EZWZhdWx0VXApLCB0aGlzLnVwZGF0ZU1hdHJpeCgpLCB0aGlzLnRhcmdldCA9IG5ldyBhdCgpLCB0aGlzLmRpc3RhbmNlID0gbiwgdGhpcy5hbmdsZSA9IGksIHRoaXMucGVudW1icmEgPSBzLCB0aGlzLmRlY2F5ID0gbywgdGhpcy5zaGFkb3cgPSBuZXcgVnUoKTtcbiAgfVxuICBnZXQgcG93ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogTWF0aC5QSTtcbiAgfVxuICBzZXQgcG93ZXIoZSkge1xuICAgIHRoaXMuaW50ZW5zaXR5ID0gZSAvIE1hdGguUEk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnNoYWRvdy5kaXNwb3NlKCk7XG4gIH1cbiAgY29weShlLCB0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoZSwgdCksIHRoaXMuZGlzdGFuY2UgPSBlLmRpc3RhbmNlLCB0aGlzLmFuZ2xlID0gZS5hbmdsZSwgdGhpcy5wZW51bWJyYSA9IGUucGVudW1icmEsIHRoaXMuZGVjYXkgPSBlLmRlY2F5LCB0aGlzLnRhcmdldCA9IGUudGFyZ2V0LmNsb25lKCksIHRoaXMuc2hhZG93ID0gZS5zaGFkb3cuY2xvbmUoKSwgdGhpcztcbiAgfVxufVxudHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyA8IFwidVwiICYmIF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInJlZ2lzdGVyXCIsIHsgZGV0YWlsOiB7XG4gIHJldmlzaW9uOiBPc1xufSB9KSk7XG50eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgKHdpbmRvdy5fX1RIUkVFX18gPyBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgVGhyZWUuanMgYmVpbmcgaW1wb3J0ZWQuXCIpIDogd2luZG93Ll9fVEhSRUVfXyA9IE9zKTtcbmNsYXNzIEx0IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIHRoaXMuZWxlbWVudHMgPSBlO1xuICB9XG4gIGlkZW50aXR5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGVbMF0gPSAxLCBlWzFdID0gMCwgZVsyXSA9IDAsIGVbM10gPSAwLCBlWzRdID0gMSwgZVs1XSA9IDAsIGVbNl0gPSAwLCBlWzddID0gMCwgZVs4XSA9IDE7XG4gIH1cbiAgc2V0WmVybygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gMCwgZVsxXSA9IDAsIGVbMl0gPSAwLCBlWzNdID0gMCwgZVs0XSA9IDAsIGVbNV0gPSAwLCBlWzZdID0gMCwgZVs3XSA9IDAsIGVbOF0gPSAwO1xuICB9XG4gIHNldFRyYWNlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cztcbiAgICB0WzBdID0gZS54LCB0WzRdID0gZS55LCB0WzhdID0gZS56O1xuICB9XG4gIGdldFRyYWNlKGUpIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgYigpKTtcbiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gZS54ID0gdFswXSwgZS55ID0gdFs0XSwgZS56ID0gdFs4XSwgZTtcbiAgfVxuICB2bXVsdChlLCB0KSB7XG4gICAgdCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IGIoKSk7XG4gICAgY29uc3QgbiA9IHRoaXMuZWxlbWVudHMsIGkgPSBlLngsIHMgPSBlLnksIG8gPSBlLno7XG4gICAgcmV0dXJuIHQueCA9IG5bMF0gKiBpICsgblsxXSAqIHMgKyBuWzJdICogbywgdC55ID0gblszXSAqIGkgKyBuWzRdICogcyArIG5bNV0gKiBvLCB0LnogPSBuWzZdICogaSArIG5bN10gKiBzICsgbls4XSAqIG8sIHQ7XG4gIH1cbiAgc211bHQoZSkge1xuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IHQrKylcbiAgICAgIHRoaXMuZWxlbWVudHNbdF0gKj0gZTtcbiAgfVxuICBtbXVsdChlLCB0KSB7XG4gICAgdCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IEx0KCkpO1xuICAgIGNvbnN0IG4gPSB0aGlzLmVsZW1lbnRzLCBpID0gZS5lbGVtZW50cywgcyA9IHQuZWxlbWVudHMsIG8gPSBuWzBdLCByID0gblsxXSwgbCA9IG5bMl0sIGEgPSBuWzNdLCBjID0gbls0XSwgZCA9IG5bNV0sIHUgPSBuWzZdLCBtID0gbls3XSwgZyA9IG5bOF0sIHAgPSBpWzBdLCBmID0gaVsxXSwgdiA9IGlbMl0sIF8gPSBpWzNdLCB3ID0gaVs0XSwgeCA9IGlbNV0sIE0gPSBpWzZdLCBFID0gaVs3XSwgUiA9IGlbOF07XG4gICAgcmV0dXJuIHNbMF0gPSBvICogcCArIHIgKiBfICsgbCAqIE0sIHNbMV0gPSBvICogZiArIHIgKiB3ICsgbCAqIEUsIHNbMl0gPSBvICogdiArIHIgKiB4ICsgbCAqIFIsIHNbM10gPSBhICogcCArIGMgKiBfICsgZCAqIE0sIHNbNF0gPSBhICogZiArIGMgKiB3ICsgZCAqIEUsIHNbNV0gPSBhICogdiArIGMgKiB4ICsgZCAqIFIsIHNbNl0gPSB1ICogcCArIG0gKiBfICsgZyAqIE0sIHNbN10gPSB1ICogZiArIG0gKiB3ICsgZyAqIEUsIHNbOF0gPSB1ICogdiArIG0gKiB4ICsgZyAqIFIsIHQ7XG4gIH1cbiAgc2NhbGUoZSwgdCkge1xuICAgIHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBMdCgpKTtcbiAgICBjb25zdCBuID0gdGhpcy5lbGVtZW50cywgaSA9IHQuZWxlbWVudHM7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgIT09IDM7IHMrKylcbiAgICAgIGlbMyAqIHMgKyAwXSA9IGUueCAqIG5bMyAqIHMgKyAwXSwgaVszICogcyArIDFdID0gZS55ICogblszICogcyArIDFdLCBpWzMgKiBzICsgMl0gPSBlLnogKiBuWzMgKiBzICsgMl07XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgc29sdmUoZSwgdCkge1xuICAgIHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBiKCkpO1xuICAgIGNvbnN0IG4gPSAzLCBpID0gNCwgcyA9IFtdO1xuICAgIGxldCBvLCByO1xuICAgIGZvciAobyA9IDA7IG8gPCBuICogaTsgbysrKVxuICAgICAgcy5wdXNoKDApO1xuICAgIGZvciAobyA9IDA7IG8gPCAzOyBvKyspXG4gICAgICBmb3IgKHIgPSAwOyByIDwgMzsgcisrKVxuICAgICAgICBzW28gKyBpICogcl0gPSB0aGlzLmVsZW1lbnRzW28gKyAzICogcl07XG4gICAgc1szICsgNCAqIDBdID0gZS54LCBzWzMgKyA0ICogMV0gPSBlLnksIHNbMyArIDQgKiAyXSA9IGUuejtcbiAgICBsZXQgbCA9IDM7XG4gICAgY29uc3QgYSA9IGw7XG4gICAgbGV0IGM7XG4gICAgY29uc3QgZCA9IDQ7XG4gICAgbGV0IHU7XG4gICAgZG8ge1xuICAgICAgaWYgKG8gPSBhIC0gbCwgc1tvICsgaSAqIG9dID09PSAwKSB7XG4gICAgICAgIGZvciAociA9IG8gKyAxOyByIDwgYTsgcisrKVxuICAgICAgICAgIGlmIChzW28gKyBpICogcl0gIT09IDApIHtcbiAgICAgICAgICAgIGMgPSBkO1xuICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgdSA9IGQgLSBjLCBzW3UgKyBpICogb10gKz0gc1t1ICsgaSAqIHJdO1xuICAgICAgICAgICAgd2hpbGUgKC0tYyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc1tvICsgaSAqIG9dICE9PSAwKVxuICAgICAgICBmb3IgKHIgPSBvICsgMTsgciA8IGE7IHIrKykge1xuICAgICAgICAgIGNvbnN0IG0gPSBzW28gKyBpICogcl0gLyBzW28gKyBpICogb107XG4gICAgICAgICAgYyA9IGQ7XG4gICAgICAgICAgZG9cbiAgICAgICAgICAgIHUgPSBkIC0gYywgc1t1ICsgaSAqIHJdID0gdSA8PSBvID8gMCA6IHNbdSArIGkgKiByXSAtIHNbdSArIGkgKiBvXSAqIG07XG4gICAgICAgICAgd2hpbGUgKC0tYyk7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgtLWwpO1xuICAgIGlmICh0LnogPSBzWzIgKiBpICsgM10gLyBzWzIgKiBpICsgMl0sIHQueSA9IChzWzEgKiBpICsgM10gLSBzWzEgKiBpICsgMl0gKiB0LnopIC8gc1sxICogaSArIDFdLCB0LnggPSAoc1swICogaSArIDNdIC0gc1swICogaSArIDJdICogdC56IC0gc1swICogaSArIDFdICogdC55KSAvIHNbMCAqIGkgKyAwXSwgaXNOYU4odC54KSB8fCBpc05hTih0LnkpIHx8IGlzTmFOKHQueikgfHwgdC54ID09PSAxIC8gMCB8fCB0LnkgPT09IDEgLyAwIHx8IHQueiA9PT0gMSAvIDApXG4gICAgICB0aHJvdyBgQ291bGQgbm90IHNvbHZlIGVxdWF0aW9uISBHb3QgeD1bJHt0LnRvU3RyaW5nKCl9XSwgYj1bJHtlLnRvU3RyaW5nKCl9XSwgQT1bJHt0aGlzLnRvU3RyaW5nKCl9XWA7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZShlLCB0LCBuKSB7XG4gICAgaWYgKG4gPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW3QgKyAzICogZV07XG4gICAgdGhpcy5lbGVtZW50c1t0ICsgMyAqIGVdID0gbjtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUuZWxlbWVudHMubGVuZ3RoOyB0KyspXG4gICAgICB0aGlzLmVsZW1lbnRzW3RdID0gZS5lbGVtZW50c1t0XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgZSA9IFwiXCI7XG4gICAgY29uc3QgdCA9IFwiLFwiO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgOTsgbisrKVxuICAgICAgZSArPSB0aGlzLmVsZW1lbnRzW25dICsgdDtcbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXZlcnNlKGUpIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgTHQoKSk7XG4gICAgY29uc3QgdCA9IDMsIG4gPSA2LCBpID0gcXU7XG4gICAgbGV0IHMsIG87XG4gICAgZm9yIChzID0gMDsgcyA8IDM7IHMrKylcbiAgICAgIGZvciAobyA9IDA7IG8gPCAzOyBvKyspXG4gICAgICAgIGlbcyArIG4gKiBvXSA9IHRoaXMuZWxlbWVudHNbcyArIDMgKiBvXTtcbiAgICBpWzMgKyA2ICogMF0gPSAxLCBpWzMgKyA2ICogMV0gPSAwLCBpWzMgKyA2ICogMl0gPSAwLCBpWzQgKyA2ICogMF0gPSAwLCBpWzQgKyA2ICogMV0gPSAxLCBpWzQgKyA2ICogMl0gPSAwLCBpWzUgKyA2ICogMF0gPSAwLCBpWzUgKyA2ICogMV0gPSAwLCBpWzUgKyA2ICogMl0gPSAxO1xuICAgIGxldCByID0gMztcbiAgICBjb25zdCBsID0gcjtcbiAgICBsZXQgYTtcbiAgICBjb25zdCBjID0gbjtcbiAgICBsZXQgZDtcbiAgICBkbyB7XG4gICAgICBpZiAocyA9IGwgLSByLCBpW3MgKyBuICogc10gPT09IDApIHtcbiAgICAgICAgZm9yIChvID0gcyArIDE7IG8gPCBsOyBvKyspXG4gICAgICAgICAgaWYgKGlbcyArIG4gKiBvXSAhPT0gMCkge1xuICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICBkb1xuICAgICAgICAgICAgICBkID0gYyAtIGEsIGlbZCArIG4gKiBzXSArPSBpW2QgKyBuICogb107XG4gICAgICAgICAgICB3aGlsZSAoLS1hKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpW3MgKyBuICogc10gIT09IDApXG4gICAgICAgIGZvciAobyA9IHMgKyAxOyBvIDwgbDsgbysrKSB7XG4gICAgICAgICAgY29uc3QgdSA9IGlbcyArIG4gKiBvXSAvIGlbcyArIG4gKiBzXTtcbiAgICAgICAgICBhID0gYztcbiAgICAgICAgICBkb1xuICAgICAgICAgICAgZCA9IGMgLSBhLCBpW2QgKyBuICogb10gPSBkIDw9IHMgPyAwIDogaVtkICsgbiAqIG9dIC0gaVtkICsgbiAqIHNdICogdTtcbiAgICAgICAgICB3aGlsZSAoLS1hKTtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKC0tcik7XG4gICAgcyA9IDI7XG4gICAgZG8ge1xuICAgICAgbyA9IHMgLSAxO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCB1ID0gaVtzICsgbiAqIG9dIC8gaVtzICsgbiAqIHNdO1xuICAgICAgICBhID0gbjtcbiAgICAgICAgZG9cbiAgICAgICAgICBkID0gbiAtIGEsIGlbZCArIG4gKiBvXSA9IGlbZCArIG4gKiBvXSAtIGlbZCArIG4gKiBzXSAqIHU7XG4gICAgICAgIHdoaWxlICgtLWEpO1xuICAgICAgfSB3aGlsZSAoby0tKTtcbiAgICB9IHdoaWxlICgtLXMpO1xuICAgIHMgPSAyO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHUgPSAxIC8gaVtzICsgbiAqIHNdO1xuICAgICAgYSA9IG47XG4gICAgICBkb1xuICAgICAgICBkID0gbiAtIGEsIGlbZCArIG4gKiBzXSA9IGlbZCArIG4gKiBzXSAqIHU7XG4gICAgICB3aGlsZSAoLS1hKTtcbiAgICB9IHdoaWxlIChzLS0pO1xuICAgIHMgPSAyO1xuICAgIGRvIHtcbiAgICAgIG8gPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoZCA9IGlbdCArIG8gKyBuICogc10sIGlzTmFOKGQpIHx8IGQgPT09IDEgLyAwKVxuICAgICAgICAgIHRocm93IGBDb3VsZCBub3QgcmV2ZXJzZSEgQT1bJHt0aGlzLnRvU3RyaW5nKCl9XWA7XG4gICAgICAgIGUuZShzLCBvLCBkKTtcbiAgICAgIH0gd2hpbGUgKG8tLSk7XG4gICAgfSB3aGlsZSAocy0tKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGUpIHtcbiAgICBjb25zdCB0ID0gZS54LCBuID0gZS55LCBpID0gZS56LCBzID0gZS53LCBvID0gdCArIHQsIHIgPSBuICsgbiwgbCA9IGkgKyBpLCBhID0gdCAqIG8sIGMgPSB0ICogciwgZCA9IHQgKiBsLCB1ID0gbiAqIHIsIG0gPSBuICogbCwgZyA9IGkgKiBsLCBwID0gcyAqIG8sIGYgPSBzICogciwgdiA9IHMgKiBsLCBfID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4gX1szICogMCArIDBdID0gMSAtICh1ICsgZyksIF9bMyAqIDAgKyAxXSA9IGMgLSB2LCBfWzMgKiAwICsgMl0gPSBkICsgZiwgX1szICogMSArIDBdID0gYyArIHYsIF9bMyAqIDEgKyAxXSA9IDEgLSAoYSArIGcpLCBfWzMgKiAxICsgMl0gPSBtIC0gcCwgX1szICogMiArIDBdID0gZCAtIGYsIF9bMyAqIDIgKyAxXSA9IG0gKyBwLCBfWzMgKiAyICsgMl0gPSAxIC0gKGEgKyB1KSwgdGhpcztcbiAgfVxuICB0cmFuc3Bvc2UoZSkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBMdCgpKTtcbiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cywgbiA9IGUuZWxlbWVudHM7XG4gICAgbGV0IGk7XG4gICAgcmV0dXJuIG5bMF0gPSB0WzBdLCBuWzRdID0gdFs0XSwgbls4XSA9IHRbOF0sIGkgPSB0WzFdLCBuWzFdID0gdFszXSwgblszXSA9IGksIGkgPSB0WzJdLCBuWzJdID0gdFs2XSwgbls2XSA9IGksIGkgPSB0WzVdLCBuWzVdID0gdFs3XSwgbls3XSA9IGksIGU7XG4gIH1cbn1cbmNvbnN0IHF1ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuY2xhc3MgYiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIG4gPT09IHZvaWQgMCAmJiAobiA9IDApLCB0aGlzLnggPSBlLCB0aGlzLnkgPSB0LCB0aGlzLnogPSBuO1xuICB9XG4gIGNyb3NzKGUsIHQpIHtcbiAgICB0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgYigpKTtcbiAgICBjb25zdCBuID0gZS54LCBpID0gZS55LCBzID0gZS56LCBvID0gdGhpcy54LCByID0gdGhpcy55LCBsID0gdGhpcy56O1xuICAgIHJldHVybiB0LnggPSByICogcyAtIGwgKiBpLCB0LnkgPSBsICogbiAtIG8gKiBzLCB0LnogPSBvICogaSAtIHIgKiBuLCB0O1xuICB9XG4gIHNldChlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUsIHRoaXMueSA9IHQsIHRoaXMueiA9IG4sIHRoaXM7XG4gIH1cbiAgc2V0WmVybygpIHtcbiAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLnogPSAwO1xuICB9XG4gIHZhZGQoZSwgdCkge1xuICAgIGlmICh0KVxuICAgICAgdC54ID0gZS54ICsgdGhpcy54LCB0LnkgPSBlLnkgKyB0aGlzLnksIHQueiA9IGUueiArIHRoaXMuejtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IGIodGhpcy54ICsgZS54LCB0aGlzLnkgKyBlLnksIHRoaXMueiArIGUueik7XG4gIH1cbiAgdnN1YihlLCB0KSB7XG4gICAgaWYgKHQpXG4gICAgICB0LnggPSB0aGlzLnggLSBlLngsIHQueSA9IHRoaXMueSAtIGUueSwgdC56ID0gdGhpcy56IC0gZS56O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBuZXcgYih0aGlzLnggLSBlLngsIHRoaXMueSAtIGUueSwgdGhpcy56IC0gZS56KTtcbiAgfVxuICBjcm9zc21hdCgpIHtcbiAgICByZXR1cm4gbmV3IEx0KFswLCAtdGhpcy56LCB0aGlzLnksIHRoaXMueiwgMCwgLXRoaXMueCwgLXRoaXMueSwgdGhpcy54LCAwXSk7XG4gIH1cbiAgbm9ybWFsaXplKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLngsIHQgPSB0aGlzLnksIG4gPSB0aGlzLnosIGkgPSBNYXRoLnNxcnQoZSAqIGUgKyB0ICogdCArIG4gKiBuKTtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGNvbnN0IHMgPSAxIC8gaTtcbiAgICAgIHRoaXMueCAqPSBzLCB0aGlzLnkgKj0gcywgdGhpcy56ICo9IHM7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLnggPSAwLCB0aGlzLnkgPSAwLCB0aGlzLnogPSAwO1xuICAgIHJldHVybiBpO1xuICB9XG4gIHVuaXQoZSkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBiKCkpO1xuICAgIGNvbnN0IHQgPSB0aGlzLngsIG4gPSB0aGlzLnksIGkgPSB0aGlzLno7XG4gICAgbGV0IHMgPSBNYXRoLnNxcnQodCAqIHQgKyBuICogbiArIGkgKiBpKTtcbiAgICByZXR1cm4gcyA+IDAgPyAocyA9IDEgLyBzLCBlLnggPSB0ICogcywgZS55ID0gbiAqIHMsIGUueiA9IGkgKiBzKSA6IChlLnggPSAxLCBlLnkgPSAwLCBlLnogPSAwKSwgZTtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMueCwgdCA9IHRoaXMueSwgbiA9IHRoaXMuejtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGUgKiBlICsgdCAqIHQgKyBuICogbik7XG4gIH1cbiAgbGVuZ3RoU3F1YXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb3QodGhpcyk7XG4gIH1cbiAgZGlzdGFuY2VUbyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgcyA9IGUueCwgbyA9IGUueSwgciA9IGUuejtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChzIC0gdCkgKiAocyAtIHQpICsgKG8gLSBuKSAqIChvIC0gbikgKyAociAtIGkpICogKHIgLSBpKSk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy54LCBuID0gdGhpcy55LCBpID0gdGhpcy56LCBzID0gZS54LCBvID0gZS55LCByID0gZS56O1xuICAgIHJldHVybiAocyAtIHQpICogKHMgLSB0KSArIChvIC0gbikgKiAobyAtIG4pICsgKHIgLSBpKSAqIChyIC0gaSk7XG4gIH1cbiAgc2NhbGUoZSwgdCkge1xuICAgIHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBiKCkpO1xuICAgIGNvbnN0IG4gPSB0aGlzLngsIGkgPSB0aGlzLnksIHMgPSB0aGlzLno7XG4gICAgcmV0dXJuIHQueCA9IGUgKiBuLCB0LnkgPSBlICogaSwgdC56ID0gZSAqIHMsIHQ7XG4gIH1cbiAgdm11bChlLCB0KSB7XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBiKCkpLCB0LnggPSBlLnggKiB0aGlzLngsIHQueSA9IGUueSAqIHRoaXMueSwgdC56ID0gZS56ICogdGhpcy56LCB0O1xuICB9XG4gIGFkZFNjYWxlZFZlY3RvcihlLCB0LCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IG5ldyBiKCkpLCBuLnggPSB0aGlzLnggKyBlICogdC54LCBuLnkgPSB0aGlzLnkgKyBlICogdC55LCBuLnogPSB0aGlzLnogKyBlICogdC56LCBuO1xuICB9XG4gIGRvdChlKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIGUueCArIHRoaXMueSAqIGUueSArIHRoaXMueiAqIGUuejtcbiAgfVxuICBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDAgJiYgdGhpcy56ID09PSAwO1xuICB9XG4gIG5lZ2F0ZShlKSB7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBiKCkpLCBlLnggPSAtdGhpcy54LCBlLnkgPSAtdGhpcy55LCBlLnogPSAtdGhpcy56LCBlO1xuICB9XG4gIHRhbmdlbnRzKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5sZW5ndGgoKTtcbiAgICBpZiAobiA+IDApIHtcbiAgICAgIGNvbnN0IGkgPSBYdSwgcyA9IDEgLyBuO1xuICAgICAgaS5zZXQodGhpcy54ICogcywgdGhpcy55ICogcywgdGhpcy56ICogcyk7XG4gICAgICBjb25zdCBvID0ganU7XG4gICAgICBNYXRoLmFicyhpLngpIDwgMC45ID8gKG8uc2V0KDEsIDAsIDApLCBpLmNyb3NzKG8sIGUpKSA6IChvLnNldCgwLCAxLCAwKSwgaS5jcm9zcyhvLCBlKSksIGkuY3Jvc3MoZSwgdCk7XG4gICAgfSBlbHNlXG4gICAgICBlLnNldCgxLCAwLCAwKSwgdC5zZXQoMCwgMSwgMCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMueH0sJHt0aGlzLnl9LCR7dGhpcy56fWA7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnpdO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLngsIHRoaXMueSA9IGUueSwgdGhpcy56ID0gZS56LCB0aGlzO1xuICB9XG4gIGxlcnAoZSwgdCwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLngsIHMgPSB0aGlzLnksIG8gPSB0aGlzLno7XG4gICAgbi54ID0gaSArIChlLnggLSBpKSAqIHQsIG4ueSA9IHMgKyAoZS55IC0gcykgKiB0LCBuLnogPSBvICsgKGUueiAtIG8pICogdDtcbiAgfVxuICBhbG1vc3RFcXVhbHMoZSwgdCkge1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgJiYgKHQgPSAxZS02KSwgIShNYXRoLmFicyh0aGlzLnggLSBlLngpID4gdCB8fCBNYXRoLmFicyh0aGlzLnkgLSBlLnkpID4gdCB8fCBNYXRoLmFicyh0aGlzLnogLSBlLnopID4gdCk7XG4gIH1cbiAgYWxtb3N0WmVybyhlKSB7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDFlLTYpLCAhKE1hdGguYWJzKHRoaXMueCkgPiBlIHx8IE1hdGguYWJzKHRoaXMueSkgPiBlIHx8IE1hdGguYWJzKHRoaXMueikgPiBlKTtcbiAgfVxuICBpc0FudGlwYXJhbGxlbFRvKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGUoSXIpLCBJci5hbG1vc3RFcXVhbHMoZSwgdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBiKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuICB9XG59XG5iLlpFUk8gPSBuZXcgYigwLCAwLCAwKTtcbmIuVU5JVF9YID0gbmV3IGIoMSwgMCwgMCk7XG5iLlVOSVRfWSA9IG5ldyBiKDAsIDEsIDApO1xuYi5VTklUX1ogPSBuZXcgYigwLCAwLCAxKTtcbmNvbnN0IFh1ID0gbmV3IGIoKSwganUgPSBuZXcgYigpLCBJciA9IG5ldyBiKCk7XG5jbGFzcyB2dCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHRoaXMubG93ZXJCb3VuZCA9IG5ldyBiKCksIHRoaXMudXBwZXJCb3VuZCA9IG5ldyBiKCksIGUubG93ZXJCb3VuZCAmJiB0aGlzLmxvd2VyQm91bmQuY29weShlLmxvd2VyQm91bmQpLCBlLnVwcGVyQm91bmQgJiYgdGhpcy51cHBlckJvdW5kLmNvcHkoZS51cHBlckJvdW5kKTtcbiAgfVxuICBzZXRGcm9tUG9pbnRzKGUsIHQsIG4sIGkpIHtcbiAgICBjb25zdCBzID0gdGhpcy5sb3dlckJvdW5kLCBvID0gdGhpcy51cHBlckJvdW5kLCByID0gbjtcbiAgICBzLmNvcHkoZVswXSksIHIgJiYgci52bXVsdChzLCBzKSwgby5jb3B5KHMpO1xuICAgIGZvciAobGV0IGwgPSAxOyBsIDwgZS5sZW5ndGg7IGwrKykge1xuICAgICAgbGV0IGEgPSBlW2xdO1xuICAgICAgciAmJiAoci52bXVsdChhLCB6ciksIGEgPSB6ciksIGEueCA+IG8ueCAmJiAoby54ID0gYS54KSwgYS54IDwgcy54ICYmIChzLnggPSBhLngpLCBhLnkgPiBvLnkgJiYgKG8ueSA9IGEueSksIGEueSA8IHMueSAmJiAocy55ID0gYS55KSwgYS56ID4gby56ICYmIChvLnogPSBhLnopLCBhLnogPCBzLnogJiYgKHMueiA9IGEueik7XG4gICAgfVxuICAgIHJldHVybiB0ICYmICh0LnZhZGQocywgcyksIHQudmFkZChvLCBvKSksIGkgJiYgKHMueCAtPSBpLCBzLnkgLT0gaSwgcy56IC09IGksIG8ueCArPSBpLCBvLnkgKz0gaSwgby56ICs9IGkpLCB0aGlzO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHJldHVybiB0aGlzLmxvd2VyQm91bmQuY29weShlLmxvd2VyQm91bmQpLCB0aGlzLnVwcGVyQm91bmQuY29weShlLnVwcGVyQm91bmQpLCB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdnQoKS5jb3B5KHRoaXMpO1xuICB9XG4gIGV4dGVuZChlKSB7XG4gICAgdGhpcy5sb3dlckJvdW5kLnggPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueCwgZS5sb3dlckJvdW5kLngpLCB0aGlzLnVwcGVyQm91bmQueCA9IE1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC54LCBlLnVwcGVyQm91bmQueCksIHRoaXMubG93ZXJCb3VuZC55ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnksIGUubG93ZXJCb3VuZC55KSwgdGhpcy51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueSwgZS51cHBlckJvdW5kLnkpLCB0aGlzLmxvd2VyQm91bmQueiA9IE1hdGgubWluKHRoaXMubG93ZXJCb3VuZC56LCBlLmxvd2VyQm91bmQueiksIHRoaXMudXBwZXJCb3VuZC56ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLnosIGUudXBwZXJCb3VuZC56KTtcbiAgfVxuICBvdmVybGFwcyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubG93ZXJCb3VuZCwgbiA9IHRoaXMudXBwZXJCb3VuZCwgaSA9IGUubG93ZXJCb3VuZCwgcyA9IGUudXBwZXJCb3VuZCwgbyA9IGkueCA8PSBuLnggJiYgbi54IDw9IHMueCB8fCB0LnggPD0gcy54ICYmIHMueCA8PSBuLngsIHIgPSBpLnkgPD0gbi55ICYmIG4ueSA8PSBzLnkgfHwgdC55IDw9IHMueSAmJiBzLnkgPD0gbi55LCBsID0gaS56IDw9IG4ueiAmJiBuLnogPD0gcy56IHx8IHQueiA8PSBzLnogJiYgcy56IDw9IG4uejtcbiAgICByZXR1cm4gbyAmJiByICYmIGw7XG4gIH1cbiAgdm9sdW1lKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmxvd2VyQm91bmQsIHQgPSB0aGlzLnVwcGVyQm91bmQ7XG4gICAgcmV0dXJuICh0LnggLSBlLngpICogKHQueSAtIGUueSkgKiAodC56IC0gZS56KTtcbiAgfVxuICBjb250YWlucyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubG93ZXJCb3VuZCwgbiA9IHRoaXMudXBwZXJCb3VuZCwgaSA9IGUubG93ZXJCb3VuZCwgcyA9IGUudXBwZXJCb3VuZDtcbiAgICByZXR1cm4gdC54IDw9IGkueCAmJiBuLnggPj0gcy54ICYmIHQueSA8PSBpLnkgJiYgbi55ID49IHMueSAmJiB0LnogPD0gaS56ICYmIG4ueiA+PSBzLno7XG4gIH1cbiAgZ2V0Q29ybmVycyhlLCB0LCBuLCBpLCBzLCBvLCByLCBsKSB7XG4gICAgY29uc3QgYSA9IHRoaXMubG93ZXJCb3VuZCwgYyA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICBlLmNvcHkoYSksIHQuc2V0KGMueCwgYS55LCBhLnopLCBuLnNldChjLngsIGMueSwgYS56KSwgaS5zZXQoYS54LCBjLnksIGMueiksIHMuc2V0KGMueCwgYS55LCBjLnopLCBvLnNldChhLngsIGMueSwgYS56KSwgci5zZXQoYS54LCBhLnksIGMueiksIGwuY29weShjKTtcbiAgfVxuICB0b0xvY2FsRnJhbWUoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBCciwgaSA9IG5bMF0sIHMgPSBuWzFdLCBvID0gblsyXSwgciA9IG5bM10sIGwgPSBuWzRdLCBhID0gbls1XSwgYyA9IG5bNl0sIGQgPSBuWzddO1xuICAgIHRoaXMuZ2V0Q29ybmVycyhpLCBzLCBvLCByLCBsLCBhLCBjLCBkKTtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSAhPT0gODsgdSsrKSB7XG4gICAgICBjb25zdCBtID0gblt1XTtcbiAgICAgIGUucG9pbnRUb0xvY2FsKG0sIG0pO1xuICAgIH1cbiAgICByZXR1cm4gdC5zZXRGcm9tUG9pbnRzKG4pO1xuICB9XG4gIHRvV29ybGRGcmFtZShlLCB0KSB7XG4gICAgY29uc3QgbiA9IEJyLCBpID0gblswXSwgcyA9IG5bMV0sIG8gPSBuWzJdLCByID0gblszXSwgbCA9IG5bNF0sIGEgPSBuWzVdLCBjID0gbls2XSwgZCA9IG5bN107XG4gICAgdGhpcy5nZXRDb3JuZXJzKGksIHMsIG8sIHIsIGwsIGEsIGMsIGQpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1ICE9PSA4OyB1KyspIHtcbiAgICAgIGNvbnN0IG0gPSBuW3VdO1xuICAgICAgZS5wb2ludFRvV29ybGQobSwgbSk7XG4gICAgfVxuICAgIHJldHVybiB0LnNldEZyb21Qb2ludHMobik7XG4gIH1cbiAgb3ZlcmxhcHNSYXkoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGlvbjogdCxcbiAgICAgIGZyb206IG5cbiAgICB9ID0gZSwgaSA9IDEgLyB0LngsIHMgPSAxIC8gdC55LCBvID0gMSAvIHQueiwgciA9ICh0aGlzLmxvd2VyQm91bmQueCAtIG4ueCkgKiBpLCBsID0gKHRoaXMudXBwZXJCb3VuZC54IC0gbi54KSAqIGksIGEgPSAodGhpcy5sb3dlckJvdW5kLnkgLSBuLnkpICogcywgYyA9ICh0aGlzLnVwcGVyQm91bmQueSAtIG4ueSkgKiBzLCBkID0gKHRoaXMubG93ZXJCb3VuZC56IC0gbi56KSAqIG8sIHUgPSAodGhpcy51cHBlckJvdW5kLnogLSBuLnopICogbywgbSA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHIsIGwpLCBNYXRoLm1pbihhLCBjKSksIE1hdGgubWluKGQsIHUpKSwgZyA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHIsIGwpLCBNYXRoLm1heChhLCBjKSksIE1hdGgubWF4KGQsIHUpKTtcbiAgICByZXR1cm4gIShnIDwgMCB8fCBtID4gZyk7XG4gIH1cbn1cbmNvbnN0IHpyID0gbmV3IGIoKSwgQnIgPSBbbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKV07XG5jbGFzcyBOciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWF0cml4ID0gW107XG4gIH1cbiAgZ2V0KGUsIHQpIHtcbiAgICBsZXQge1xuICAgICAgaW5kZXg6IG5cbiAgICB9ID0gZSwge1xuICAgICAgaW5kZXg6IGlcbiAgICB9ID0gdDtcbiAgICBpZiAoaSA+IG4pIHtcbiAgICAgIGNvbnN0IHMgPSBpO1xuICAgICAgaSA9IG4sIG4gPSBzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXRyaXhbKG4gKiAobiArIDEpID4+IDEpICsgaSAtIDFdO1xuICB9XG4gIHNldChlLCB0LCBuKSB7XG4gICAgbGV0IHtcbiAgICAgIGluZGV4OiBpXG4gICAgfSA9IGUsIHtcbiAgICAgIGluZGV4OiBzXG4gICAgfSA9IHQ7XG4gICAgaWYgKHMgPiBpKSB7XG4gICAgICBjb25zdCBvID0gcztcbiAgICAgIHMgPSBpLCBpID0gbztcbiAgICB9XG4gICAgdGhpcy5tYXRyaXhbKGkgKiAoaSArIDEpID4+IDEpICsgcyAtIDFdID0gbiA/IDEgOiAwO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGZvciAobGV0IGUgPSAwLCB0ID0gdGhpcy5tYXRyaXgubGVuZ3RoOyBlICE9PSB0OyBlKyspXG4gICAgICB0aGlzLm1hdHJpeFtlXSA9IDA7XG4gIH1cbiAgc2V0TnVtT2JqZWN0cyhlKSB7XG4gICAgdGhpcy5tYXRyaXgubGVuZ3RoID0gZSAqIChlIC0gMSkgPj4gMTtcbiAgfVxufVxuY2xhc3MgYm8ge1xuICBhZGRFdmVudExpc3RlbmVyKGUsIHQpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMCAmJiAodGhpcy5fbGlzdGVuZXJzID0ge30pO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgcmV0dXJuIG5bZV0gPT09IHZvaWQgMCAmJiAobltlXSA9IFtdKSwgbltlXS5pbmNsdWRlcyh0KSB8fCBuW2VdLnB1c2godCksIHRoaXM7XG4gIH1cbiAgaGFzRXZlbnRMaXN0ZW5lcihlLCB0KSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgcmV0dXJuICEhKG5bZV0gIT09IHZvaWQgMCAmJiBuW2VdLmluY2x1ZGVzKHQpKTtcbiAgfVxuICBoYXNBbnlFdmVudExpc3RlbmVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzID09PSB2b2lkIDAgPyAhMSA6IHRoaXMuX2xpc3RlbmVyc1tlXSAhPT0gdm9pZCAwO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgdCkge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgaWYgKG5bZV0gPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGkgPSBuW2VdLmluZGV4T2YodCk7XG4gICAgcmV0dXJuIGkgIT09IC0xICYmIG5bZV0uc3BsaWNlKGksIDEpLCB0aGlzO1xuICB9XG4gIGRpc3BhdGNoRXZlbnQoZSkge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnNbZS50eXBlXTtcbiAgICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgICBlLnRhcmdldCA9IHRoaXM7XG4gICAgICBmb3IgKGxldCBpID0gMCwgcyA9IG4ubGVuZ3RoOyBpIDwgczsgaSsrKVxuICAgICAgICBuW2ldLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBqZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGkpIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIG4gPT09IHZvaWQgMCAmJiAobiA9IDApLCBpID09PSB2b2lkIDAgJiYgKGkgPSAxKSwgdGhpcy54ID0gZSwgdGhpcy55ID0gdCwgdGhpcy56ID0gbiwgdGhpcy53ID0gaTtcbiAgfVxuICBzZXQoZSwgdCwgbiwgaSkge1xuICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzLnkgPSB0LCB0aGlzLnogPSBuLCB0aGlzLncgPSBpLCB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnh9LCR7dGhpcy55fSwke3RoaXMuen0sJHt0aGlzLnd9YDtcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53XTtcbiAgfVxuICBzZXRGcm9tQXhpc0FuZ2xlKGUsIHQpIHtcbiAgICBjb25zdCBuID0gTWF0aC5zaW4odCAqIDAuNSk7XG4gICAgcmV0dXJuIHRoaXMueCA9IGUueCAqIG4sIHRoaXMueSA9IGUueSAqIG4sIHRoaXMueiA9IGUueiAqIG4sIHRoaXMudyA9IE1hdGguY29zKHQgKiAwLjUpLCB0aGlzO1xuICB9XG4gIHRvQXhpc0FuZ2xlKGUpIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgYigpKSwgdGhpcy5ub3JtYWxpemUoKTtcbiAgICBjb25zdCB0ID0gMiAqIE1hdGguYWNvcyh0aGlzLncpLCBuID0gTWF0aC5zcXJ0KDEgLSB0aGlzLncgKiB0aGlzLncpO1xuICAgIHJldHVybiBuIDwgMWUtMyA/IChlLnggPSB0aGlzLngsIGUueSA9IHRoaXMueSwgZS56ID0gdGhpcy56KSA6IChlLnggPSB0aGlzLnggLyBuLCBlLnkgPSB0aGlzLnkgLyBuLCBlLnogPSB0aGlzLnogLyBuKSwgW2UsIHRdO1xuICB9XG4gIHNldEZyb21WZWN0b3JzKGUsIHQpIHtcbiAgICBpZiAoZS5pc0FudGlwYXJhbGxlbFRvKHQpKSB7XG4gICAgICBjb25zdCBuID0gWXUsIGkgPSBadTtcbiAgICAgIGUudGFuZ2VudHMobiwgaSksIHRoaXMuc2V0RnJvbUF4aXNBbmdsZShuLCBNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbiA9IGUuY3Jvc3ModCk7XG4gICAgICB0aGlzLnggPSBuLngsIHRoaXMueSA9IG4ueSwgdGhpcy56ID0gbi56LCB0aGlzLncgPSBNYXRoLnNxcnQoZS5sZW5ndGgoKSAqKiAyICogdC5sZW5ndGgoKSAqKiAyKSArIGUuZG90KHQpLCB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBtdWx0KGUsIHQpIHtcbiAgICB0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgamUoKSk7XG4gICAgY29uc3QgbiA9IHRoaXMueCwgaSA9IHRoaXMueSwgcyA9IHRoaXMueiwgbyA9IHRoaXMudywgciA9IGUueCwgbCA9IGUueSwgYSA9IGUueiwgYyA9IGUudztcbiAgICByZXR1cm4gdC54ID0gbiAqIGMgKyBvICogciArIGkgKiBhIC0gcyAqIGwsIHQueSA9IGkgKiBjICsgbyAqIGwgKyBzICogciAtIG4gKiBhLCB0LnogPSBzICogYyArIG8gKiBhICsgbiAqIGwgLSBpICogciwgdC53ID0gbyAqIGMgLSBuICogciAtIGkgKiBsIC0gcyAqIGEsIHQ7XG4gIH1cbiAgaW52ZXJzZShlKSB7XG4gICAgZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IGplKCkpO1xuICAgIGNvbnN0IHQgPSB0aGlzLngsIG4gPSB0aGlzLnksIGkgPSB0aGlzLnosIHMgPSB0aGlzLnc7XG4gICAgdGhpcy5jb25qdWdhdGUoZSk7XG4gICAgY29uc3QgbyA9IDEgLyAodCAqIHQgKyBuICogbiArIGkgKiBpICsgcyAqIHMpO1xuICAgIHJldHVybiBlLnggKj0gbywgZS55ICo9IG8sIGUueiAqPSBvLCBlLncgKj0gbywgZTtcbiAgfVxuICBjb25qdWdhdGUoZSkge1xuICAgIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgamUoKSksIGUueCA9IC10aGlzLngsIGUueSA9IC10aGlzLnksIGUueiA9IC10aGlzLnosIGUudyA9IHRoaXMudywgZTtcbiAgfVxuICBub3JtYWxpemUoKSB7XG4gICAgbGV0IGUgPSBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KTtcbiAgICByZXR1cm4gZSA9PT0gMCA/ICh0aGlzLnggPSAwLCB0aGlzLnkgPSAwLCB0aGlzLnogPSAwLCB0aGlzLncgPSAwKSA6IChlID0gMSAvIGUsIHRoaXMueCAqPSBlLCB0aGlzLnkgKj0gZSwgdGhpcy56ICo9IGUsIHRoaXMudyAqPSBlKSwgdGhpcztcbiAgfVxuICBub3JtYWxpemVGYXN0KCkge1xuICAgIGNvbnN0IGUgPSAoMyAtICh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpKSAvIDI7XG4gICAgcmV0dXJuIGUgPT09IDAgPyAodGhpcy54ID0gMCwgdGhpcy55ID0gMCwgdGhpcy56ID0gMCwgdGhpcy53ID0gMCkgOiAodGhpcy54ICo9IGUsIHRoaXMueSAqPSBlLCB0aGlzLnogKj0gZSwgdGhpcy53ICo9IGUpLCB0aGlzO1xuICB9XG4gIHZtdWx0KGUsIHQpIHtcbiAgICB0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgYigpKTtcbiAgICBjb25zdCBuID0gZS54LCBpID0gZS55LCBzID0gZS56LCBvID0gdGhpcy54LCByID0gdGhpcy55LCBsID0gdGhpcy56LCBhID0gdGhpcy53LCBjID0gYSAqIG4gKyByICogcyAtIGwgKiBpLCBkID0gYSAqIGkgKyBsICogbiAtIG8gKiBzLCB1ID0gYSAqIHMgKyBvICogaSAtIHIgKiBuLCBtID0gLW8gKiBuIC0gciAqIGkgLSBsICogcztcbiAgICByZXR1cm4gdC54ID0gYyAqIGEgKyBtICogLW8gKyBkICogLWwgLSB1ICogLXIsIHQueSA9IGQgKiBhICsgbSAqIC1yICsgdSAqIC1vIC0gYyAqIC1sLCB0LnogPSB1ICogYSArIG0gKiAtbCArIGMgKiAtciAtIGQgKiAtbywgdDtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICByZXR1cm4gdGhpcy54ID0gZS54LCB0aGlzLnkgPSBlLnksIHRoaXMueiA9IGUueiwgdGhpcy53ID0gZS53LCB0aGlzO1xuICB9XG4gIHRvRXVsZXIoZSwgdCkge1xuICAgIHQgPT09IHZvaWQgMCAmJiAodCA9IFwiWVpYXCIpO1xuICAgIGxldCBuLCBpLCBzO1xuICAgIGNvbnN0IG8gPSB0aGlzLngsIHIgPSB0aGlzLnksIGwgPSB0aGlzLnosIGEgPSB0aGlzLnc7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFwiWVpYXCI6XG4gICAgICAgIGNvbnN0IGMgPSBvICogciArIGwgKiBhO1xuICAgICAgICBpZiAoYyA+IDAuNDk5ICYmIChuID0gMiAqIE1hdGguYXRhbjIobywgYSksIGkgPSBNYXRoLlBJIC8gMiwgcyA9IDApLCBjIDwgLTAuNDk5ICYmIChuID0gLTIgKiBNYXRoLmF0YW4yKG8sIGEpLCBpID0gLU1hdGguUEkgLyAyLCBzID0gMCksIG4gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IGQgPSBvICogbywgdSA9IHIgKiByLCBtID0gbCAqIGw7XG4gICAgICAgICAgbiA9IE1hdGguYXRhbjIoMiAqIHIgKiBhIC0gMiAqIG8gKiBsLCAxIC0gMiAqIHUgLSAyICogbSksIGkgPSBNYXRoLmFzaW4oMiAqIGMpLCBzID0gTWF0aC5hdGFuMigyICogbyAqIGEgLSAyICogciAqIGwsIDEgLSAyICogZCAtIDIgKiBtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXVsZXIgb3JkZXIgJHt0fSBub3Qgc3VwcG9ydGVkIHlldC5gKTtcbiAgICB9XG4gICAgZS55ID0gbiwgZS56ID0gaSwgZS54ID0gcztcbiAgfVxuICBzZXRGcm9tRXVsZXIoZSwgdCwgbiwgaSkge1xuICAgIGkgPT09IHZvaWQgMCAmJiAoaSA9IFwiWFlaXCIpO1xuICAgIGNvbnN0IHMgPSBNYXRoLmNvcyhlIC8gMiksIG8gPSBNYXRoLmNvcyh0IC8gMiksIHIgPSBNYXRoLmNvcyhuIC8gMiksIGwgPSBNYXRoLnNpbihlIC8gMiksIGEgPSBNYXRoLnNpbih0IC8gMiksIGMgPSBNYXRoLnNpbihuIC8gMik7XG4gICAgcmV0dXJuIGkgPT09IFwiWFlaXCIgPyAodGhpcy54ID0gbCAqIG8gKiByICsgcyAqIGEgKiBjLCB0aGlzLnkgPSBzICogYSAqIHIgLSBsICogbyAqIGMsIHRoaXMueiA9IHMgKiBvICogYyArIGwgKiBhICogciwgdGhpcy53ID0gcyAqIG8gKiByIC0gbCAqIGEgKiBjKSA6IGkgPT09IFwiWVhaXCIgPyAodGhpcy54ID0gbCAqIG8gKiByICsgcyAqIGEgKiBjLCB0aGlzLnkgPSBzICogYSAqIHIgLSBsICogbyAqIGMsIHRoaXMueiA9IHMgKiBvICogYyAtIGwgKiBhICogciwgdGhpcy53ID0gcyAqIG8gKiByICsgbCAqIGEgKiBjKSA6IGkgPT09IFwiWlhZXCIgPyAodGhpcy54ID0gbCAqIG8gKiByIC0gcyAqIGEgKiBjLCB0aGlzLnkgPSBzICogYSAqIHIgKyBsICogbyAqIGMsIHRoaXMueiA9IHMgKiBvICogYyArIGwgKiBhICogciwgdGhpcy53ID0gcyAqIG8gKiByIC0gbCAqIGEgKiBjKSA6IGkgPT09IFwiWllYXCIgPyAodGhpcy54ID0gbCAqIG8gKiByIC0gcyAqIGEgKiBjLCB0aGlzLnkgPSBzICogYSAqIHIgKyBsICogbyAqIGMsIHRoaXMueiA9IHMgKiBvICogYyAtIGwgKiBhICogciwgdGhpcy53ID0gcyAqIG8gKiByICsgbCAqIGEgKiBjKSA6IGkgPT09IFwiWVpYXCIgPyAodGhpcy54ID0gbCAqIG8gKiByICsgcyAqIGEgKiBjLCB0aGlzLnkgPSBzICogYSAqIHIgKyBsICogbyAqIGMsIHRoaXMueiA9IHMgKiBvICogYyAtIGwgKiBhICogciwgdGhpcy53ID0gcyAqIG8gKiByIC0gbCAqIGEgKiBjKSA6IGkgPT09IFwiWFpZXCIgJiYgKHRoaXMueCA9IGwgKiBvICogciAtIHMgKiBhICogYywgdGhpcy55ID0gcyAqIGEgKiByIC0gbCAqIG8gKiBjLCB0aGlzLnogPSBzICogbyAqIGMgKyBsICogYSAqIHIsIHRoaXMudyA9IHMgKiBvICogciArIGwgKiBhICogYyksIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBqZSh0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuICB9XG4gIHNsZXJwKGUsIHQsIG4pIHtcbiAgICBuID09PSB2b2lkIDAgJiYgKG4gPSBuZXcgamUoKSk7XG4gICAgY29uc3QgaSA9IHRoaXMueCwgcyA9IHRoaXMueSwgbyA9IHRoaXMueiwgciA9IHRoaXMudztcbiAgICBsZXQgbCA9IGUueCwgYSA9IGUueSwgYyA9IGUueiwgZCA9IGUudywgdSwgbSwgZywgcCwgZjtcbiAgICByZXR1cm4gbSA9IGkgKiBsICsgcyAqIGEgKyBvICogYyArIHIgKiBkLCBtIDwgMCAmJiAobSA9IC1tLCBsID0gLWwsIGEgPSAtYSwgYyA9IC1jLCBkID0gLWQpLCAxIC0gbSA+IDFlLTYgPyAodSA9IE1hdGguYWNvcyhtKSwgZyA9IE1hdGguc2luKHUpLCBwID0gTWF0aC5zaW4oKDEgLSB0KSAqIHUpIC8gZywgZiA9IE1hdGguc2luKHQgKiB1KSAvIGcpIDogKHAgPSAxIC0gdCwgZiA9IHQpLCBuLnggPSBwICogaSArIGYgKiBsLCBuLnkgPSBwICogcyArIGYgKiBhLCBuLnogPSBwICogbyArIGYgKiBjLCBuLncgPSBwICogciArIGYgKiBkLCBuO1xuICB9XG4gIGludGVncmF0ZShlLCB0LCBuLCBpKSB7XG4gICAgaSA9PT0gdm9pZCAwICYmIChpID0gbmV3IGplKCkpO1xuICAgIGNvbnN0IHMgPSBlLnggKiBuLngsIG8gPSBlLnkgKiBuLnksIHIgPSBlLnogKiBuLnosIGwgPSB0aGlzLngsIGEgPSB0aGlzLnksIGMgPSB0aGlzLnosIGQgPSB0aGlzLncsIHUgPSB0ICogMC41O1xuICAgIHJldHVybiBpLnggKz0gdSAqIChzICogZCArIG8gKiBjIC0gciAqIGEpLCBpLnkgKz0gdSAqIChvICogZCArIHIgKiBsIC0gcyAqIGMpLCBpLnogKz0gdSAqIChyICogZCArIHMgKiBhIC0gbyAqIGwpLCBpLncgKz0gdSAqICgtcyAqIGwgLSBvICogYSAtIHIgKiBjKSwgaTtcbiAgfVxufVxuY29uc3QgWXUgPSBuZXcgYigpLCBadSA9IG5ldyBiKCksICR1ID0ge1xuICBTUEhFUkU6IDEsXG4gIFBMQU5FOiAyLFxuICBCT1g6IDQsXG4gIENPTVBPVU5EOiA4LFxuICBDT05WRVhQT0xZSEVEUk9OOiAxNixcbiAgSEVJR0hURklFTEQ6IDMyLFxuICBQQVJUSUNMRTogNjQsXG4gIENZTElOREVSOiAxMjgsXG4gIFRSSU1FU0g6IDI1NlxufTtcbmNsYXNzIGxlIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwgdGhpcy5pZCA9IGxlLmlkQ291bnRlcisrLCB0aGlzLnR5cGUgPSBlLnR5cGUgfHwgMCwgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDAsIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBlLmNvbGxpc2lvblJlc3BvbnNlID8gZS5jb2xsaXNpb25SZXNwb25zZSA6ICEwLCB0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gZS5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gdm9pZCAwID8gZS5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IDEsIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IGUuY29sbGlzaW9uRmlsdGVyTWFzayAhPT0gdm9pZCAwID8gZS5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTEsIHRoaXMubWF0ZXJpYWwgPSBlLm1hdGVyaWFsID8gZS5tYXRlcmlhbCA6IG51bGwsIHRoaXMuYm9keSA9IG51bGw7XG4gIH1cbiAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7XG4gICAgdGhyb3cgYGNvbXB1dGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAke3RoaXMudHlwZX1gO1xuICB9XG4gIHZvbHVtZSgpIHtcbiAgICB0aHJvdyBgdm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7XG4gIH1cbiAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKGUsIHQpIHtcbiAgICB0aHJvdyBgY2FsY3VsYXRlTG9jYWxJbmVydGlhKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7XG4gIH1cbiAgY2FsY3VsYXRlV29ybGRBQUJCKGUsIHQsIG4sIGkpIHtcbiAgICB0aHJvdyBgY2FsY3VsYXRlV29ybGRBQUJCKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7XG4gIH1cbn1cbmxlLmlkQ291bnRlciA9IDA7XG5sZS50eXBlcyA9ICR1O1xuY2xhc3MgUGUge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgZSA9PT0gdm9pZCAwICYmIChlID0ge30pLCB0aGlzLnBvc2l0aW9uID0gbmV3IGIoKSwgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IGplKCksIGUucG9zaXRpb24gJiYgdGhpcy5wb3NpdGlvbi5jb3B5KGUucG9zaXRpb24pLCBlLnF1YXRlcm5pb24gJiYgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoZS5xdWF0ZXJuaW9uKTtcbiAgfVxuICBwb2ludFRvTG9jYWwoZSwgdCkge1xuICAgIHJldHVybiBQZS5wb2ludFRvTG9jYWxGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIGUsIHQpO1xuICB9XG4gIHBvaW50VG9Xb3JsZChlLCB0KSB7XG4gICAgcmV0dXJuIFBlLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgZSwgdCk7XG4gIH1cbiAgdmVjdG9yVG9Xb3JsZEZyYW1lKGUsIHQpIHtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IGIoKSksIHRoaXMucXVhdGVybmlvbi52bXVsdChlLCB0KSwgdDtcbiAgfVxuICBzdGF0aWMgcG9pbnRUb0xvY2FsRnJhbWUoZSwgdCwgbiwgaSkge1xuICAgIHJldHVybiBpID09PSB2b2lkIDAgJiYgKGkgPSBuZXcgYigpKSwgbi52c3ViKGUsIGkpLCB0LmNvbmp1Z2F0ZShPciksIE9yLnZtdWx0KGksIGkpLCBpO1xuICB9XG4gIHN0YXRpYyBwb2ludFRvV29ybGRGcmFtZShlLCB0LCBuLCBpKSB7XG4gICAgcmV0dXJuIGkgPT09IHZvaWQgMCAmJiAoaSA9IG5ldyBiKCkpLCB0LnZtdWx0KG4sIGkpLCBpLnZhZGQoZSwgaSksIGk7XG4gIH1cbiAgc3RhdGljIHZlY3RvclRvV29ybGRGcmFtZShlLCB0LCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IG5ldyBiKCkpLCBlLnZtdWx0KHQsIG4pLCBuO1xuICB9XG4gIHN0YXRpYyB2ZWN0b3JUb0xvY2FsRnJhbWUoZSwgdCwgbiwgaSkge1xuICAgIHJldHVybiBpID09PSB2b2lkIDAgJiYgKGkgPSBuZXcgYigpKSwgdC53ICo9IC0xLCB0LnZtdWx0KG4sIGkpLCB0LncgKj0gLTEsIGk7XG4gIH1cbn1cbmNvbnN0IE9yID0gbmV3IGplKCk7XG5jbGFzcyB3biBleHRlbmRzIGxlIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KTtcbiAgICBjb25zdCB7XG4gICAgICB2ZXJ0aWNlczogdCA9IFtdLFxuICAgICAgZmFjZXM6IG4gPSBbXSxcbiAgICAgIG5vcm1hbHM6IGkgPSBbXSxcbiAgICAgIGF4ZXM6IHMsXG4gICAgICBib3VuZGluZ1NwaGVyZVJhZGl1czogb1xuICAgIH0gPSBlO1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6IGxlLnR5cGVzLkNPTlZFWFBPTFlIRURST05cbiAgICB9KSwgdGhpcy52ZXJ0aWNlcyA9IHQsIHRoaXMuZmFjZXMgPSBuLCB0aGlzLmZhY2VOb3JtYWxzID0gaSwgdGhpcy5mYWNlTm9ybWFscy5sZW5ndGggPT09IDAgJiYgdGhpcy5jb21wdXRlTm9ybWFscygpLCBvID8gdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IG8gOiB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCksIHRoaXMud29ybGRWZXJ0aWNlcyA9IFtdLCB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9ICEwLCB0aGlzLndvcmxkRmFjZU5vcm1hbHMgPSBbXSwgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSAhMCwgdGhpcy51bmlxdWVBeGVzID0gcyA/IHMuc2xpY2UoKSA6IG51bGwsIHRoaXMudW5pcXVlRWRnZXMgPSBbXSwgdGhpcy5jb21wdXRlRWRnZXMoKTtcbiAgfVxuICBjb21wdXRlRWRnZXMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZmFjZXMsIHQgPSB0aGlzLnZlcnRpY2VzLCBuID0gdGhpcy51bmlxdWVFZGdlcztcbiAgICBuLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgaSA9IG5ldyBiKCk7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgIT09IGUubGVuZ3RoOyBzKyspIHtcbiAgICAgIGNvbnN0IG8gPSBlW3NdLCByID0gby5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBsID0gMDsgbCAhPT0gcjsgbCsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSAobCArIDEpICUgcjtcbiAgICAgICAgdFtvW2xdXS52c3ViKHRbb1thXV0sIGkpLCBpLm5vcm1hbGl6ZSgpO1xuICAgICAgICBsZXQgYyA9ICExO1xuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCAhPT0gbi5sZW5ndGg7IGQrKylcbiAgICAgICAgICBpZiAobltkXS5hbG1vc3RFcXVhbHMoaSkgfHwgbltkXS5hbG1vc3RFcXVhbHMoaSkpIHtcbiAgICAgICAgICAgIGMgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgYyB8fCBuLnB1c2goaS5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcHV0ZU5vcm1hbHMoKSB7XG4gICAgdGhpcy5mYWNlTm9ybWFscy5sZW5ndGggPSB0aGlzLmZhY2VzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWNlc1tlXS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbZV1baV1dKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVydGV4ICR7dGhpcy5mYWNlc1tlXVtpXX0gbm90IGZvdW5kIWApO1xuICAgICAgY29uc3QgdCA9IHRoaXMuZmFjZU5vcm1hbHNbZV0gfHwgbmV3IGIoKTtcbiAgICAgIHRoaXMuZ2V0RmFjZU5vcm1hbChlLCB0KSwgdC5uZWdhdGUodCksIHRoaXMuZmFjZU5vcm1hbHNbZV0gPSB0O1xuICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tlXVswXV07XG4gICAgICBpZiAodC5kb3QobikgPCAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYC5mYWNlTm9ybWFsc1ske2V9XSA9IFZlYzMoJHt0LnRvU3RyaW5nKCl9KSBsb29rcyBsaWtlIGl0IHBvaW50cyBpbnRvIHRoZSBzaGFwZT8gVGhlIHZlcnRpY2VzIGZvbGxvdy4gTWFrZSBzdXJlIHRoZXkgYXJlIG9yZGVyZWQgQ0NXIGFyb3VuZCB0aGUgbm9ybWFsLCB1c2luZyB0aGUgcmlnaHQgaGFuZCBydWxlLmApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZXNbZV0ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgY29uc29sZS53YXJuKGAudmVydGljZXNbJHt0aGlzLmZhY2VzW2VdW2ldfV0gPSBWZWMzKCR7dGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW2VdW2ldXS50b1N0cmluZygpfSlgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RmFjZU5vcm1hbChlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZmFjZXNbZV0sIGkgPSB0aGlzLnZlcnRpY2VzW25bMF1dLCBzID0gdGhpcy52ZXJ0aWNlc1tuWzFdXSwgbyA9IHRoaXMudmVydGljZXNbblsyXV07XG4gICAgd24uY29tcHV0ZU5vcm1hbChpLCBzLCBvLCB0KTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZU5vcm1hbChlLCB0LCBuLCBpKSB7XG4gICAgY29uc3QgcyA9IG5ldyBiKCksIG8gPSBuZXcgYigpO1xuICAgIHQudnN1YihlLCBvKSwgbi52c3ViKHQsIHMpLCBzLmNyb3NzKG8sIGkpLCBpLmlzWmVybygpIHx8IGkubm9ybWFsaXplKCk7XG4gIH1cbiAgY2xpcEFnYWluc3RIdWxsKGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEpIHtcbiAgICBjb25zdCBjID0gbmV3IGIoKTtcbiAgICBsZXQgZCA9IC0xLCB1ID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgZm9yIChsZXQgZyA9IDA7IGcgPCBuLmZhY2VzLmxlbmd0aDsgZysrKSB7XG4gICAgICBjLmNvcHkobi5mYWNlTm9ybWFsc1tnXSksIHMudm11bHQoYywgYyk7XG4gICAgICBjb25zdCBwID0gYy5kb3Qobyk7XG4gICAgICBwID4gdSAmJiAodSA9IHAsIGQgPSBnKTtcbiAgICB9XG4gICAgY29uc3QgbSA9IFtdO1xuICAgIGZvciAobGV0IGcgPSAwOyBnIDwgbi5mYWNlc1tkXS5sZW5ndGg7IGcrKykge1xuICAgICAgY29uc3QgcCA9IG4udmVydGljZXNbbi5mYWNlc1tkXVtnXV0sIGYgPSBuZXcgYigpO1xuICAgICAgZi5jb3B5KHApLCBzLnZtdWx0KGYsIGYpLCBpLnZhZGQoZiwgZiksIG0ucHVzaChmKTtcbiAgICB9XG4gICAgZCA+PSAwICYmIHRoaXMuY2xpcEZhY2VBZ2FpbnN0SHVsbChvLCBlLCB0LCBtLCByLCBsLCBhKTtcbiAgfVxuICBmaW5kU2VwYXJhdGluZ0F4aXMoZSwgdCwgbiwgaSwgcywgbywgciwgbCkge1xuICAgIGNvbnN0IGEgPSBuZXcgYigpLCBjID0gbmV3IGIoKSwgZCA9IG5ldyBiKCksIHUgPSBuZXcgYigpLCBtID0gbmV3IGIoKSwgZyA9IG5ldyBiKCk7XG4gICAgbGV0IHAgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGNvbnN0IGYgPSB0aGlzO1xuICAgIGlmIChmLnVuaXF1ZUF4ZXMpXG4gICAgICBmb3IgKGxldCB2ID0gMDsgdiAhPT0gZi51bmlxdWVBeGVzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIG4udm11bHQoZi51bmlxdWVBeGVzW3ZdLCBhKTtcbiAgICAgICAgY29uc3QgXyA9IGYudGVzdFNlcEF4aXMoYSwgZSwgdCwgbiwgaSwgcyk7XG4gICAgICAgIGlmIChfID09PSAhMSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIF8gPCBwICYmIChwID0gXywgby5jb3B5KGEpKTtcbiAgICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHYgPSByID8gci5sZW5ndGggOiBmLmZhY2VzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IF8gPSAwOyBfIDwgdjsgXysrKSB7XG4gICAgICAgIGNvbnN0IHcgPSByID8gcltfXSA6IF87XG4gICAgICAgIGEuY29weShmLmZhY2VOb3JtYWxzW3ddKSwgbi52bXVsdChhLCBhKTtcbiAgICAgICAgY29uc3QgeCA9IGYudGVzdFNlcEF4aXMoYSwgZSwgdCwgbiwgaSwgcyk7XG4gICAgICAgIGlmICh4ID09PSAhMSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIHggPCBwICYmIChwID0geCwgby5jb3B5KGEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUudW5pcXVlQXhlcylcbiAgICAgIGZvciAobGV0IHYgPSAwOyB2ICE9PSBlLnVuaXF1ZUF4ZXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgcy52bXVsdChlLnVuaXF1ZUF4ZXNbdl0sIGMpO1xuICAgICAgICBjb25zdCBfID0gZi50ZXN0U2VwQXhpcyhjLCBlLCB0LCBuLCBpLCBzKTtcbiAgICAgICAgaWYgKF8gPT09ICExKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgXyA8IHAgJiYgKHAgPSBfLCBvLmNvcHkoYykpO1xuICAgICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdiA9IGwgPyBsLmxlbmd0aCA6IGUuZmFjZXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgXyA9IDA7IF8gPCB2OyBfKyspIHtcbiAgICAgICAgY29uc3QgdyA9IGwgPyBsW19dIDogXztcbiAgICAgICAgYy5jb3B5KGUuZmFjZU5vcm1hbHNbd10pLCBzLnZtdWx0KGMsIGMpO1xuICAgICAgICBjb25zdCB4ID0gZi50ZXN0U2VwQXhpcyhjLCBlLCB0LCBuLCBpLCBzKTtcbiAgICAgICAgaWYgKHggPT09ICExKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgeCA8IHAgJiYgKHAgPSB4LCBvLmNvcHkoYykpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB2ID0gMDsgdiAhPT0gZi51bmlxdWVFZGdlcy5sZW5ndGg7IHYrKykge1xuICAgICAgbi52bXVsdChmLnVuaXF1ZUVkZ2VzW3ZdLCB1KTtcbiAgICAgIGZvciAobGV0IF8gPSAwOyBfICE9PSBlLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgXysrKVxuICAgICAgICBpZiAocy52bXVsdChlLnVuaXF1ZUVkZ2VzW19dLCBtKSwgdS5jcm9zcyhtLCBnKSwgIWcuYWxtb3N0WmVybygpKSB7XG4gICAgICAgICAgZy5ub3JtYWxpemUoKTtcbiAgICAgICAgICBjb25zdCB3ID0gZi50ZXN0U2VwQXhpcyhnLCBlLCB0LCBuLCBpLCBzKTtcbiAgICAgICAgICBpZiAodyA9PT0gITEpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgdyA8IHAgJiYgKHAgPSB3LCBvLmNvcHkoZykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpLnZzdWIodCwgZCksIGQuZG90KG8pID4gMCAmJiBvLm5lZ2F0ZShvKSwgITA7XG4gIH1cbiAgdGVzdFNlcEF4aXMoZSwgdCwgbiwgaSwgcywgbykge1xuICAgIGNvbnN0IHIgPSB0aGlzO1xuICAgIHduLnByb2plY3QociwgZSwgbiwgaSwgQXMpLCB3bi5wcm9qZWN0KHQsIGUsIHMsIG8sIENzKTtcbiAgICBjb25zdCBsID0gQXNbMF0sIGEgPSBBc1sxXSwgYyA9IENzWzBdLCBkID0gQ3NbMV07XG4gICAgaWYgKGwgPCBkIHx8IGMgPCBhKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHUgPSBsIC0gZCwgbSA9IGMgLSBhO1xuICAgIHJldHVybiB1IDwgbSA/IHUgOiBtO1xuICB9XG4gIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShlLCB0KSB7XG4gICAgY29uc3QgbiA9IG5ldyBiKCksIGkgPSBuZXcgYigpO1xuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihpLCBuKTtcbiAgICBjb25zdCBzID0gbi54IC0gaS54LCBvID0gbi55IC0gaS55LCByID0gbi56IC0gaS56O1xuICAgIHQueCA9IDEgLyAxMiAqIGUgKiAoMiAqIG8gKiAyICogbyArIDIgKiByICogMiAqIHIpLCB0LnkgPSAxIC8gMTIgKiBlICogKDIgKiBzICogMiAqIHMgKyAyICogciAqIDIgKiByKSwgdC56ID0gMSAvIDEyICogZSAqICgyICogbyAqIDIgKiBvICsgMiAqIHMgKiAyICogcyk7XG4gIH1cbiAgZ2V0UGxhbmVDb25zdGFudE9mRmFjZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZmFjZXNbZV0sIG4gPSB0aGlzLmZhY2VOb3JtYWxzW2VdLCBpID0gdGhpcy52ZXJ0aWNlc1t0WzBdXTtcbiAgICByZXR1cm4gLW4uZG90KGkpO1xuICB9XG4gIGNsaXBGYWNlQWdhaW5zdEh1bGwoZSwgdCwgbiwgaSwgcywgbywgcikge1xuICAgIGNvbnN0IGwgPSBuZXcgYigpLCBhID0gbmV3IGIoKSwgYyA9IG5ldyBiKCksIGQgPSBuZXcgYigpLCB1ID0gbmV3IGIoKSwgbSA9IG5ldyBiKCksIGcgPSBuZXcgYigpLCBwID0gbmV3IGIoKSwgZiA9IHRoaXMsIHYgPSBbXSwgXyA9IGksIHcgPSB2O1xuICAgIGxldCB4ID0gLTEsIE0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGZvciAobGV0IEYgPSAwOyBGIDwgZi5mYWNlcy5sZW5ndGg7IEYrKykge1xuICAgICAgbC5jb3B5KGYuZmFjZU5vcm1hbHNbRl0pLCBuLnZtdWx0KGwsIGwpO1xuICAgICAgY29uc3QgUCA9IGwuZG90KGUpO1xuICAgICAgUCA8IE0gJiYgKE0gPSBQLCB4ID0gRik7XG4gICAgfVxuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBFID0gZi5mYWNlc1t4XTtcbiAgICBFLmNvbm5lY3RlZEZhY2VzID0gW107XG4gICAgZm9yIChsZXQgRiA9IDA7IEYgPCBmLmZhY2VzLmxlbmd0aDsgRisrKVxuICAgICAgZm9yIChsZXQgUCA9IDA7IFAgPCBmLmZhY2VzW0ZdLmxlbmd0aDsgUCsrKVxuICAgICAgICBFLmluZGV4T2YoZi5mYWNlc1tGXVtQXSkgIT09IC0xICYmIEYgIT09IHggJiYgRS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKEYpID09PSAtMSAmJiBFLmNvbm5lY3RlZEZhY2VzLnB1c2goRik7XG4gICAgY29uc3QgUiA9IEUubGVuZ3RoO1xuICAgIGZvciAobGV0IEYgPSAwOyBGIDwgUjsgRisrKSB7XG4gICAgICBjb25zdCBQID0gZi52ZXJ0aWNlc1tFW0ZdXSwgRyA9IGYudmVydGljZXNbRVsoRiArIDEpICUgUl1dO1xuICAgICAgUC52c3ViKEcsIGEpLCBjLmNvcHkoYSksIG4udm11bHQoYywgYyksIHQudmFkZChjLCBjKSwgZC5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbeF0pLCBuLnZtdWx0KGQsIGQpLCB0LnZhZGQoZCwgZCksIGMuY3Jvc3MoZCwgdSksIHUubmVnYXRlKHUpLCBtLmNvcHkoUCksIG4udm11bHQobSwgbSksIHQudmFkZChtLCBtKTtcbiAgICAgIGNvbnN0IHogPSBFLmNvbm5lY3RlZEZhY2VzW0ZdO1xuICAgICAgZy5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbel0pO1xuICAgICAgY29uc3QgTCA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZSh6KTtcbiAgICAgIHAuY29weShnKSwgbi52bXVsdChwLCBwKTtcbiAgICAgIGNvbnN0IEkgPSBMIC0gcC5kb3QodCk7XG4gICAgICBmb3IgKHRoaXMuY2xpcEZhY2VBZ2FpbnN0UGxhbmUoXywgdywgcCwgSSk7IF8ubGVuZ3RoOyApXG4gICAgICAgIF8uc2hpZnQoKTtcbiAgICAgIGZvciAoOyB3Lmxlbmd0aDsgKVxuICAgICAgICBfLnB1c2gody5zaGlmdCgpKTtcbiAgICB9XG4gICAgZy5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbeF0pO1xuICAgIGNvbnN0IHkgPSB0aGlzLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UoeCk7XG4gICAgcC5jb3B5KGcpLCBuLnZtdWx0KHAsIHApO1xuICAgIGNvbnN0IEEgPSB5IC0gcC5kb3QodCk7XG4gICAgZm9yIChsZXQgRiA9IDA7IEYgPCBfLmxlbmd0aDsgRisrKSB7XG4gICAgICBsZXQgUCA9IHAuZG90KF9bRl0pICsgQTtcbiAgICAgIGlmIChQIDw9IHMgJiYgKFAgPSBzKSwgUCA8PSBvKSB7XG4gICAgICAgIGNvbnN0IEcgPSBfW0ZdO1xuICAgICAgICBpZiAoUCA8PSAxZS02KSB7XG4gICAgICAgICAgY29uc3QgeiA9IHtcbiAgICAgICAgICAgIHBvaW50OiBHLFxuICAgICAgICAgICAgbm9ybWFsOiBwLFxuICAgICAgICAgICAgZGVwdGg6IFBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHIucHVzaCh6KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGlwRmFjZUFnYWluc3RQbGFuZShlLCB0LCBuLCBpKSB7XG4gICAgbGV0IHMsIG87XG4gICAgY29uc3QgciA9IGUubGVuZ3RoO1xuICAgIGlmIChyIDwgMilcbiAgICAgIHJldHVybiB0O1xuICAgIGxldCBsID0gZVtlLmxlbmd0aCAtIDFdLCBhID0gZVswXTtcbiAgICBzID0gbi5kb3QobCkgKyBpO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcjsgYysrKSB7XG4gICAgICBpZiAoYSA9IGVbY10sIG8gPSBuLmRvdChhKSArIGksIHMgPCAwKVxuICAgICAgICBpZiAobyA8IDApIHtcbiAgICAgICAgICBjb25zdCBkID0gbmV3IGIoKTtcbiAgICAgICAgICBkLmNvcHkoYSksIHQucHVzaChkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkID0gbmV3IGIoKTtcbiAgICAgICAgICBsLmxlcnAoYSwgcyAvIChzIC0gbyksIGQpLCB0LnB1c2goZCk7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG8gPCAwKSB7XG4gICAgICAgIGNvbnN0IGQgPSBuZXcgYigpO1xuICAgICAgICBsLmxlcnAoYSwgcyAvIChzIC0gbyksIGQpLCB0LnB1c2goZCksIHQucHVzaChhKTtcbiAgICAgIH1cbiAgICAgIGwgPSBhLCBzID0gbztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgY29tcHV0ZVdvcmxkVmVydGljZXMoZSwgdCkge1xuICAgIGZvciAoOyB0aGlzLndvcmxkVmVydGljZXMubGVuZ3RoIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IClcbiAgICAgIHRoaXMud29ybGRWZXJ0aWNlcy5wdXNoKG5ldyBiKCkpO1xuICAgIGNvbnN0IG4gPSB0aGlzLnZlcnRpY2VzLCBpID0gdGhpcy53b3JsZFZlcnRpY2VzO1xuICAgIGZvciAobGV0IHMgPSAwOyBzICE9PSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgcysrKVxuICAgICAgdC52bXVsdChuW3NdLCBpW3NdKSwgZS52YWRkKGlbc10sIGlbc10pO1xuICAgIHRoaXMud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlID0gITE7XG4gIH1cbiAgY29tcHV0ZUxvY2FsQUFCQihlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMudmVydGljZXM7XG4gICAgZS5zZXQoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSksIHQuc2V0KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcyA9IG5baV07XG4gICAgICBzLnggPCBlLnggPyBlLnggPSBzLnggOiBzLnggPiB0LnggJiYgKHQueCA9IHMueCksIHMueSA8IGUueSA/IGUueSA9IHMueSA6IHMueSA+IHQueSAmJiAodC55ID0gcy55KSwgcy56IDwgZS56ID8gZS56ID0gcy56IDogcy56ID4gdC56ICYmICh0LnogPSBzLnopO1xuICAgIH1cbiAgfVxuICBjb21wdXRlV29ybGRGYWNlTm9ybWFscyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoO1xuICAgIGZvciAoOyB0aGlzLndvcmxkRmFjZU5vcm1hbHMubGVuZ3RoIDwgdDsgKVxuICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzLnB1c2gobmV3IGIoKSk7XG4gICAgY29uc3QgbiA9IHRoaXMuZmFjZU5vcm1hbHMsIGkgPSB0aGlzLndvcmxkRmFjZU5vcm1hbHM7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgIT09IHQ7IHMrKylcbiAgICAgIGUudm11bHQobltzXSwgaVtzXSk7XG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSAhMTtcbiAgfVxuICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgY29uc3QgdCA9IHRoaXMudmVydGljZXM7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gIT09IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNvbnN0IGkgPSB0W25dLmxlbmd0aFNxdWFyZWQoKTtcbiAgICAgIGkgPiBlICYmIChlID0gaSk7XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQoZSk7XG4gIH1cbiAgY2FsY3VsYXRlV29ybGRBQUJCKGUsIHQsIG4sIGkpIHtcbiAgICBjb25zdCBzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBsZXQgbywgciwgbCwgYSwgYywgZCwgdSA9IG5ldyBiKCk7XG4gICAgZm9yIChsZXQgbSA9IDA7IG0gPCBzLmxlbmd0aDsgbSsrKSB7XG4gICAgICB1LmNvcHkoc1ttXSksIHQudm11bHQodSwgdSksIGUudmFkZCh1LCB1KTtcbiAgICAgIGNvbnN0IGcgPSB1O1xuICAgICAgKG8gPT09IHZvaWQgMCB8fCBnLnggPCBvKSAmJiAobyA9IGcueCksIChhID09PSB2b2lkIDAgfHwgZy54ID4gYSkgJiYgKGEgPSBnLngpLCAociA9PT0gdm9pZCAwIHx8IGcueSA8IHIpICYmIChyID0gZy55KSwgKGMgPT09IHZvaWQgMCB8fCBnLnkgPiBjKSAmJiAoYyA9IGcueSksIChsID09PSB2b2lkIDAgfHwgZy56IDwgbCkgJiYgKGwgPSBnLnopLCAoZCA9PT0gdm9pZCAwIHx8IGcueiA+IGQpICYmIChkID0gZy56KTtcbiAgICB9XG4gICAgbi5zZXQobywgciwgbCksIGkuc2V0KGEsIGMsIGQpO1xuICB9XG4gIHZvbHVtZSgpIHtcbiAgICByZXR1cm4gNCAqIE1hdGguUEkgKiB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzIC8gMztcbiAgfVxuICBnZXRBdmVyYWdlUG9pbnRMb2NhbChlKSB7XG4gICAgZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IGIoKSk7XG4gICAgY29uc3QgdCA9IHRoaXMudmVydGljZXM7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgICAgZS52YWRkKHRbbl0sIGUpO1xuICAgIHJldHVybiBlLnNjYWxlKDEgLyB0Lmxlbmd0aCwgZSksIGU7XG4gIH1cbiAgdHJhbnNmb3JtQWxsUG9pbnRzKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsIGkgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGlmICh0KSB7XG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8IG47IHMrKykge1xuICAgICAgICBjb25zdCBvID0gaVtzXTtcbiAgICAgICAgdC52bXVsdChvLCBvKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7IHMrKykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5mYWNlTm9ybWFsc1tzXTtcbiAgICAgICAgdC52bXVsdChvLCBvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUpXG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8IG47IHMrKykge1xuICAgICAgICBjb25zdCBvID0gaVtzXTtcbiAgICAgICAgby52YWRkKGUsIG8pO1xuICAgICAgfVxuICB9XG4gIHBvaW50SXNJbnNpZGUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnZlcnRpY2VzLCBuID0gdGhpcy5mYWNlcywgaSA9IHRoaXMuZmFjZU5vcm1hbHMsIHMgPSBudWxsLCBvID0gbmV3IGIoKTtcbiAgICB0aGlzLmdldEF2ZXJhZ2VQb2ludExvY2FsKG8pO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdGhpcy5mYWNlcy5sZW5ndGg7IHIrKykge1xuICAgICAgbGV0IGwgPSBpW3JdO1xuICAgICAgY29uc3QgYSA9IHRbbltyXVswXV0sIGMgPSBuZXcgYigpO1xuICAgICAgZS52c3ViKGEsIGMpO1xuICAgICAgY29uc3QgZCA9IGwuZG90KGMpLCB1ID0gbmV3IGIoKTtcbiAgICAgIG8udnN1YihhLCB1KTtcbiAgICAgIGNvbnN0IG0gPSBsLmRvdCh1KTtcbiAgICAgIGlmIChkIDwgMCAmJiBtID4gMCB8fCBkID4gMCAmJiBtIDwgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gcyA/IDEgOiAtMTtcbiAgfVxuICBzdGF0aWMgcHJvamVjdChlLCB0LCBuLCBpLCBzKSB7XG4gICAgY29uc3QgbyA9IGUudmVydGljZXMubGVuZ3RoLCByID0gS3U7XG4gICAgbGV0IGwgPSAwLCBhID0gMDtcbiAgICBjb25zdCBjID0gSnUsIGQgPSBlLnZlcnRpY2VzO1xuICAgIGMuc2V0WmVybygpLCBQZS52ZWN0b3JUb0xvY2FsRnJhbWUobiwgaSwgdCwgciksIFBlLnBvaW50VG9Mb2NhbEZyYW1lKG4sIGksIGMsIGMpO1xuICAgIGNvbnN0IHUgPSBjLmRvdChyKTtcbiAgICBhID0gbCA9IGRbMF0uZG90KHIpO1xuICAgIGZvciAobGV0IG0gPSAxOyBtIDwgbzsgbSsrKSB7XG4gICAgICBjb25zdCBnID0gZFttXS5kb3Qocik7XG4gICAgICBnID4gbCAmJiAobCA9IGcpLCBnIDwgYSAmJiAoYSA9IGcpO1xuICAgIH1cbiAgICBpZiAoYSAtPSB1LCBsIC09IHUsIGEgPiBsKSB7XG4gICAgICBjb25zdCBtID0gYTtcbiAgICAgIGEgPSBsLCBsID0gbTtcbiAgICB9XG4gICAgc1swXSA9IGwsIHNbMV0gPSBhO1xuICB9XG59XG5jb25zdCBBcyA9IFtdLCBDcyA9IFtdO1xubmV3IGIoKTtcbmNvbnN0IEt1ID0gbmV3IGIoKSwgSnUgPSBuZXcgYigpO1xuY2xhc3MgV3MgZXh0ZW5kcyBsZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiBsZS50eXBlcy5CT1hcbiAgICB9KSwgdGhpcy5oYWxmRXh0ZW50cyA9IGUsIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbnVsbCwgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKSwgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuICB9XG4gIHVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbigpIHtcbiAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50cy54LCB0ID0gdGhpcy5oYWxmRXh0ZW50cy55LCBuID0gdGhpcy5oYWxmRXh0ZW50cy56LCBpID0gYiwgcyA9IFtuZXcgaSgtZSwgLXQsIC1uKSwgbmV3IGkoZSwgLXQsIC1uKSwgbmV3IGkoZSwgdCwgLW4pLCBuZXcgaSgtZSwgdCwgLW4pLCBuZXcgaSgtZSwgLXQsIG4pLCBuZXcgaShlLCAtdCwgbiksIG5ldyBpKGUsIHQsIG4pLCBuZXcgaSgtZSwgdCwgbildLCBvID0gW1xuICAgICAgWzMsIDIsIDEsIDBdLFxuICAgICAgWzQsIDUsIDYsIDddLFxuICAgICAgWzUsIDQsIDAsIDFdLFxuICAgICAgWzIsIDMsIDcsIDZdLFxuICAgICAgWzAsIDQsIDcsIDNdLFxuICAgICAgWzEsIDIsIDYsIDVdXG4gICAgXSwgciA9IFtuZXcgaSgwLCAwLCAxKSwgbmV3IGkoMCwgMSwgMCksIG5ldyBpKDEsIDAsIDApXSwgbCA9IG5ldyB3bih7XG4gICAgICB2ZXJ0aWNlczogcyxcbiAgICAgIGZhY2VzOiBvLFxuICAgICAgYXhlczogclxuICAgIH0pO1xuICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbCwgbC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gIH1cbiAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKGUsIHQpIHtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IGIoKSksIFdzLmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgZSwgdCksIHQ7XG4gIH1cbiAgc3RhdGljIGNhbGN1bGF0ZUluZXJ0aWEoZSwgdCwgbikge1xuICAgIGNvbnN0IGkgPSBlO1xuICAgIG4ueCA9IDEgLyAxMiAqIHQgKiAoMiAqIGkueSAqIDIgKiBpLnkgKyAyICogaS56ICogMiAqIGkueiksIG4ueSA9IDEgLyAxMiAqIHQgKiAoMiAqIGkueCAqIDIgKiBpLnggKyAyICogaS56ICogMiAqIGkueiksIG4ueiA9IDEgLyAxMiAqIHQgKiAoMiAqIGkueSAqIDIgKiBpLnkgKyAyICogaS54ICogMiAqIGkueCk7XG4gIH1cbiAgZ2V0U2lkZU5vcm1hbHMoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBlLCBpID0gdGhpcy5oYWxmRXh0ZW50cztcbiAgICBpZiAoblswXS5zZXQoaS54LCAwLCAwKSwgblsxXS5zZXQoMCwgaS55LCAwKSwgblsyXS5zZXQoMCwgMCwgaS56KSwgblszXS5zZXQoLWkueCwgMCwgMCksIG5bNF0uc2V0KDAsIC1pLnksIDApLCBuWzVdLnNldCgwLCAwLCAtaS56KSwgdCAhPT0gdm9pZCAwKVxuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgIT09IG4ubGVuZ3RoOyBzKyspXG4gICAgICAgIHQudm11bHQobltzXSwgbltzXSk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgdm9sdW1lKCkge1xuICAgIHJldHVybiA4ICogdGhpcy5oYWxmRXh0ZW50cy54ICogdGhpcy5oYWxmRXh0ZW50cy55ICogdGhpcy5oYWxmRXh0ZW50cy56O1xuICB9XG4gIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkge1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLmxlbmd0aCgpO1xuICB9XG4gIGZvckVhY2hXb3JsZENvcm5lcihlLCB0LCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuaGFsZkV4dGVudHMsIHMgPSBbW2kueCwgaS55LCBpLnpdLCBbLWkueCwgaS55LCBpLnpdLCBbLWkueCwgLWkueSwgaS56XSwgWy1pLngsIC1pLnksIC1pLnpdLCBbaS54LCAtaS55LCAtaS56XSwgW2kueCwgaS55LCAtaS56XSwgWy1pLngsIGkueSwgLWkuel0sIFtpLngsIC1pLnksIGkuel1dO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKylcbiAgICAgIGhuLnNldChzW29dWzBdLCBzW29dWzFdLCBzW29dWzJdKSwgdC52bXVsdChobiwgaG4pLCBlLnZhZGQoaG4sIGhuKSwgbihobi54LCBobi55LCBobi56KTtcbiAgfVxuICBjYWxjdWxhdGVXb3JsZEFBQkIoZSwgdCwgbiwgaSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgIFB0WzBdLnNldChzLngsIHMueSwgcy56KSwgUHRbMV0uc2V0KC1zLngsIHMueSwgcy56KSwgUHRbMl0uc2V0KC1zLngsIC1zLnksIHMueiksIFB0WzNdLnNldCgtcy54LCAtcy55LCAtcy56KSwgUHRbNF0uc2V0KHMueCwgLXMueSwgLXMueiksIFB0WzVdLnNldChzLngsIHMueSwgLXMueiksIFB0WzZdLnNldCgtcy54LCBzLnksIC1zLnopLCBQdFs3XS5zZXQocy54LCAtcy55LCBzLnopO1xuICAgIGNvbnN0IG8gPSBQdFswXTtcbiAgICB0LnZtdWx0KG8sIG8pLCBlLnZhZGQobywgbyksIGkuY29weShvKSwgbi5jb3B5KG8pO1xuICAgIGZvciAobGV0IHIgPSAxOyByIDwgODsgcisrKSB7XG4gICAgICBjb25zdCBsID0gUHRbcl07XG4gICAgICB0LnZtdWx0KGwsIGwpLCBlLnZhZGQobCwgbCk7XG4gICAgICBjb25zdCBhID0gbC54LCBjID0gbC55LCBkID0gbC56O1xuICAgICAgYSA+IGkueCAmJiAoaS54ID0gYSksIGMgPiBpLnkgJiYgKGkueSA9IGMpLCBkID4gaS56ICYmIChpLnogPSBkKSwgYSA8IG4ueCAmJiAobi54ID0gYSksIGMgPCBuLnkgJiYgKG4ueSA9IGMpLCBkIDwgbi56ICYmIChuLnogPSBkKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGhuID0gbmV3IGIoKSwgUHQgPSBbbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKSwgbmV3IGIoKV0sIFZzID0ge1xuICBEWU5BTUlDOiAxLFxuICBTVEFUSUM6IDIsXG4gIEtJTkVNQVRJQzogNFxufSwgSHMgPSB7XG4gIEFXQUtFOiAwLFxuICBTTEVFUFk6IDEsXG4gIFNMRUVQSU5HOiAyXG59O1xuY2xhc3MgaWUgZXh0ZW5kcyBibyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHN1cGVyKCksIHRoaXMuaWQgPSBpZS5pZENvdW50ZXIrKywgdGhpcy5pbmRleCA9IC0xLCB0aGlzLndvcmxkID0gbnVsbCwgdGhpcy52bGFtYmRhID0gbmV3IGIoKSwgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IHR5cGVvZiBlLmNvbGxpc2lvbkZpbHRlckdyb3VwID09IFwibnVtYmVyXCIgPyBlLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMSwgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mIGUuY29sbGlzaW9uRmlsdGVyTWFzayA9PSBcIm51bWJlclwiID8gZS5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTEsIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0eXBlb2YgZS5jb2xsaXNpb25SZXNwb25zZSA9PSBcImJvb2xlYW5cIiA/IGUuY29sbGlzaW9uUmVzcG9uc2UgOiAhMCwgdGhpcy5wb3NpdGlvbiA9IG5ldyBiKCksIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBiKCksIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSBuZXcgYigpLCB0aGlzLmluaXRQb3NpdGlvbiA9IG5ldyBiKCksIGUucG9zaXRpb24gJiYgKHRoaXMucG9zaXRpb24uY29weShlLnBvc2l0aW9uKSwgdGhpcy5wcmV2aW91c1Bvc2l0aW9uLmNvcHkoZS5wb3NpdGlvbiksIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24uY29weShlLnBvc2l0aW9uKSwgdGhpcy5pbml0UG9zaXRpb24uY29weShlLnBvc2l0aW9uKSksIHRoaXMudmVsb2NpdHkgPSBuZXcgYigpLCBlLnZlbG9jaXR5ICYmIHRoaXMudmVsb2NpdHkuY29weShlLnZlbG9jaXR5KSwgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgYigpLCB0aGlzLmZvcmNlID0gbmV3IGIoKTtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGUubWFzcyA9PSBcIm51bWJlclwiID8gZS5tYXNzIDogMDtcbiAgICB0aGlzLm1hc3MgPSB0LCB0aGlzLmludk1hc3MgPSB0ID4gMCA/IDEgLyB0IDogMCwgdGhpcy5tYXRlcmlhbCA9IGUubWF0ZXJpYWwgfHwgbnVsbCwgdGhpcy5saW5lYXJEYW1waW5nID0gdHlwZW9mIGUubGluZWFyRGFtcGluZyA9PSBcIm51bWJlclwiID8gZS5saW5lYXJEYW1waW5nIDogMC4wMSwgdGhpcy50eXBlID0gdCA8PSAwID8gaWUuU1RBVElDIDogaWUuRFlOQU1JQywgdHlwZW9mIGUudHlwZSA9PSB0eXBlb2YgaWUuU1RBVElDICYmICh0aGlzLnR5cGUgPSBlLnR5cGUpLCB0aGlzLmFsbG93U2xlZXAgPSB0eXBlb2YgZS5hbGxvd1NsZWVwIDwgXCJ1XCIgPyBlLmFsbG93U2xlZXAgOiAhMCwgdGhpcy5zbGVlcFN0YXRlID0gaWUuQVdBS0UsIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mIGUuc2xlZXBTcGVlZExpbWl0IDwgXCJ1XCIgPyBlLnNsZWVwU3BlZWRMaW1pdCA6IDAuMSwgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IHR5cGVvZiBlLnNsZWVwVGltZUxpbWl0IDwgXCJ1XCIgPyBlLnNsZWVwVGltZUxpbWl0IDogMSwgdGhpcy50aW1lTGFzdFNsZWVweSA9IDAsIHRoaXMud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9ICExLCB0aGlzLnRvcnF1ZSA9IG5ldyBiKCksIHRoaXMucXVhdGVybmlvbiA9IG5ldyBqZSgpLCB0aGlzLmluaXRRdWF0ZXJuaW9uID0gbmV3IGplKCksIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uID0gbmV3IGplKCksIHRoaXMuaW50ZXJwb2xhdGVkUXVhdGVybmlvbiA9IG5ldyBqZSgpLCBlLnF1YXRlcm5pb24gJiYgKHRoaXMucXVhdGVybmlvbi5jb3B5KGUucXVhdGVybmlvbiksIHRoaXMuaW5pdFF1YXRlcm5pb24uY29weShlLnF1YXRlcm5pb24pLCB0aGlzLnByZXZpb3VzUXVhdGVybmlvbi5jb3B5KGUucXVhdGVybmlvbiksIHRoaXMuaW50ZXJwb2xhdGVkUXVhdGVybmlvbi5jb3B5KGUucXVhdGVybmlvbikpLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBiKCksIGUuYW5ndWxhclZlbG9jaXR5ICYmIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNvcHkoZS5hbmd1bGFyVmVsb2NpdHkpLCB0aGlzLmluaXRBbmd1bGFyVmVsb2NpdHkgPSBuZXcgYigpLCB0aGlzLnNoYXBlcyA9IFtdLCB0aGlzLnNoYXBlT2Zmc2V0cyA9IFtdLCB0aGlzLnNoYXBlT3JpZW50YXRpb25zID0gW10sIHRoaXMuaW5lcnRpYSA9IG5ldyBiKCksIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBiKCksIHRoaXMuaW52SW5lcnRpYVdvcmxkID0gbmV3IEx0KCksIHRoaXMuaW52TWFzc1NvbHZlID0gMCwgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgYigpLCB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlID0gbmV3IEx0KCksIHRoaXMuZml4ZWRSb3RhdGlvbiA9IHR5cGVvZiBlLmZpeGVkUm90YXRpb24gPCBcInVcIiA/IGUuZml4ZWRSb3RhdGlvbiA6ICExLCB0aGlzLmFuZ3VsYXJEYW1waW5nID0gdHlwZW9mIGUuYW5ndWxhckRhbXBpbmcgPCBcInVcIiA/IGUuYW5ndWxhckRhbXBpbmcgOiAwLjAxLCB0aGlzLmxpbmVhckZhY3RvciA9IG5ldyBiKDEsIDEsIDEpLCBlLmxpbmVhckZhY3RvciAmJiB0aGlzLmxpbmVhckZhY3Rvci5jb3B5KGUubGluZWFyRmFjdG9yKSwgdGhpcy5hbmd1bGFyRmFjdG9yID0gbmV3IGIoMSwgMSwgMSksIGUuYW5ndWxhckZhY3RvciAmJiB0aGlzLmFuZ3VsYXJGYWN0b3IuY29weShlLmFuZ3VsYXJGYWN0b3IpLCB0aGlzLmFhYmIgPSBuZXcgdnQoKSwgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSAhMCwgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDAsIHRoaXMud2xhbWJkYSA9IG5ldyBiKCksIHRoaXMuaXNUcmlnZ2VyID0gQm9vbGVhbihlLmlzVHJpZ2dlciksIGUuc2hhcGUgJiYgdGhpcy5hZGRTaGFwZShlLnNoYXBlKSwgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICB9XG4gIHdha2VVcCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zbGVlcFN0YXRlO1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IGllLkFXQUtFLCB0aGlzLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSAhMSwgZSA9PT0gaWUuU0xFRVBJTkcgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGllLndha2V1cEV2ZW50KTtcbiAgfVxuICBzbGVlcCgpIHtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBpZS5TTEVFUElORywgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCksIHRoaXMuYW5ndWxhclZlbG9jaXR5LnNldCgwLCAwLCAwKSwgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gITE7XG4gIH1cbiAgc2xlZXBUaWNrKGUpIHtcbiAgICBpZiAodGhpcy5hbGxvd1NsZWVwKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zbGVlcFN0YXRlLCBuID0gdGhpcy52ZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCksIGkgPSB0aGlzLnNsZWVwU3BlZWRMaW1pdCAqKiAyO1xuICAgICAgdCA9PT0gaWUuQVdBS0UgJiYgbiA8IGkgPyAodGhpcy5zbGVlcFN0YXRlID0gaWUuU0xFRVBZLCB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gZSwgdGhpcy5kaXNwYXRjaEV2ZW50KGllLnNsZWVweUV2ZW50KSkgOiB0ID09PSBpZS5TTEVFUFkgJiYgbiA+IGkgPyB0aGlzLndha2VVcCgpIDogdCA9PT0gaWUuU0xFRVBZICYmIGUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ID4gdGhpcy5zbGVlcFRpbWVMaW1pdCAmJiAodGhpcy5zbGVlcCgpLCB0aGlzLmRpc3BhdGNoRXZlbnQoaWUuc2xlZXBFdmVudCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCkge1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9PT0gaWUuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBpZS5LSU5FTUFUSUMgPyAodGhpcy5pbnZNYXNzU29sdmUgPSAwLCB0aGlzLmludkluZXJ0aWFTb2x2ZS5zZXRaZXJvKCksIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpKSA6ICh0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcywgdGhpcy5pbnZJbmVydGlhU29sdmUuY29weSh0aGlzLmludkluZXJ0aWEpLCB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpKTtcbiAgfVxuICBwb2ludFRvTG9jYWxGcmFtZShlLCB0KSB7XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBiKCkpLCBlLnZzdWIodGhpcy5wb3NpdGlvbiwgdCksIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdCh0LCB0KSwgdDtcbiAgfVxuICB2ZWN0b3JUb0xvY2FsRnJhbWUoZSwgdCkge1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgYigpKSwgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KGUsIHQpLCB0O1xuICB9XG4gIHBvaW50VG9Xb3JsZEZyYW1lKGUsIHQpIHtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IGIoKSksIHRoaXMucXVhdGVybmlvbi52bXVsdChlLCB0KSwgdC52YWRkKHRoaXMucG9zaXRpb24sIHQpLCB0O1xuICB9XG4gIHZlY3RvclRvV29ybGRGcmFtZShlLCB0KSB7XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBiKCkpLCB0aGlzLnF1YXRlcm5pb24udm11bHQoZSwgdCksIHQ7XG4gIH1cbiAgYWRkU2hhcGUoZSwgdCwgbikge1xuICAgIGNvbnN0IGkgPSBuZXcgYigpLCBzID0gbmV3IGplKCk7XG4gICAgcmV0dXJuIHQgJiYgaS5jb3B5KHQpLCBuICYmIHMuY29weShuKSwgdGhpcy5zaGFwZXMucHVzaChlKSwgdGhpcy5zaGFwZU9mZnNldHMucHVzaChpKSwgdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5wdXNoKHMpLCB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCksIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKSwgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSAhMCwgZS5ib2R5ID0gdGhpcywgdGhpcztcbiAgfVxuICByZW1vdmVTaGFwZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2hhcGVzLmluZGV4T2YoZSk7XG4gICAgcmV0dXJuIHQgPT09IC0xID8gKGNvbnNvbGUud2FybihcIlNoYXBlIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgYm9keVwiKSwgdGhpcykgOiAodGhpcy5zaGFwZXMuc3BsaWNlKHQsIDEpLCB0aGlzLnNoYXBlT2Zmc2V0cy5zcGxpY2UodCwgMSksIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMuc3BsaWNlKHQsIDEpLCB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCksIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKSwgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSAhMCwgZS5ib2R5ID0gbnVsbCwgdGhpcyk7XG4gIH1cbiAgdXBkYXRlQm91bmRpbmdSYWRpdXMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuc2hhcGVzLCB0ID0gdGhpcy5zaGFwZU9mZnNldHMsIG4gPSBlLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgIT09IG47IHMrKykge1xuICAgICAgY29uc3QgbyA9IGVbc107XG4gICAgICBvLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgICBjb25zdCByID0gdFtzXS5sZW5ndGgoKSwgbCA9IG8uYm91bmRpbmdTcGhlcmVSYWRpdXM7XG4gICAgICByICsgbCA+IGkgJiYgKGkgPSByICsgbCk7XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBpO1xuICB9XG4gIHVwZGF0ZUFBQkIoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuc2hhcGVzLCB0ID0gdGhpcy5zaGFwZU9mZnNldHMsIG4gPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zLCBpID0gZS5sZW5ndGgsIHMgPSBRdSwgbyA9IGVkLCByID0gdGhpcy5xdWF0ZXJuaW9uLCBsID0gdGhpcy5hYWJiLCBhID0gdGQ7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgIT09IGk7IGMrKykge1xuICAgICAgY29uc3QgZCA9IGVbY107XG4gICAgICByLnZtdWx0KHRbY10sIHMpLCBzLnZhZGQodGhpcy5wb3NpdGlvbiwgcyksIHIubXVsdChuW2NdLCBvKSwgZC5jYWxjdWxhdGVXb3JsZEFBQkIocywgbywgYS5sb3dlckJvdW5kLCBhLnVwcGVyQm91bmQpLCBjID09PSAwID8gbC5jb3B5KGEpIDogbC5leHRlbmQoYSk7XG4gICAgfVxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gITE7XG4gIH1cbiAgdXBkYXRlSW5lcnRpYVdvcmxkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5pbnZJbmVydGlhO1xuICAgIGlmICghKHQueCA9PT0gdC55ICYmIHQueSA9PT0gdC56ICYmICFlKSkge1xuICAgICAgY29uc3QgbiA9IG5kLCBpID0gaWQ7XG4gICAgICBuLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKSwgbi50cmFuc3Bvc2UoaSksIG4uc2NhbGUodCwgbiksIG4ubW11bHQoaSwgdGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgIH1cbiAgfVxuICBhcHBseUZvcmNlKGUsIHQpIHtcbiAgICBpZiAodCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IGIoKSksIHRoaXMudHlwZSAhPT0gaWUuRFlOQU1JQylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPT09IGllLlNMRUVQSU5HICYmIHRoaXMud2FrZVVwKCk7XG4gICAgY29uc3QgbiA9IHJkO1xuICAgIHQuY3Jvc3MoZSwgbiksIHRoaXMuZm9yY2UudmFkZChlLCB0aGlzLmZvcmNlKSwgdGhpcy50b3JxdWUudmFkZChuLCB0aGlzLnRvcnF1ZSk7XG4gIH1cbiAgYXBwbHlMb2NhbEZvcmNlKGUsIHQpIHtcbiAgICBpZiAodCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IGIoKSksIHRoaXMudHlwZSAhPT0gaWUuRFlOQU1JQylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gb2QsIGkgPSBhZDtcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShlLCBuKSwgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUodCwgaSksIHRoaXMuYXBwbHlGb3JjZShuLCBpKTtcbiAgfVxuICBhcHBseVRvcnF1ZShlKSB7XG4gICAgdGhpcy50eXBlID09PSBpZS5EWU5BTUlDICYmICh0aGlzLnNsZWVwU3RhdGUgPT09IGllLlNMRUVQSU5HICYmIHRoaXMud2FrZVVwKCksIHRoaXMudG9ycXVlLnZhZGQoZSwgdGhpcy50b3JxdWUpKTtcbiAgfVxuICBhcHBseUltcHVsc2UoZSwgdCkge1xuICAgIGlmICh0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgYigpKSwgdGhpcy50eXBlICE9PSBpZS5EWU5BTUlDKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9PT0gaWUuU0xFRVBJTkcgJiYgdGhpcy53YWtlVXAoKTtcbiAgICBjb25zdCBuID0gdCwgaSA9IGxkO1xuICAgIGkuY29weShlKSwgaS5zY2FsZSh0aGlzLmludk1hc3MsIGkpLCB0aGlzLnZlbG9jaXR5LnZhZGQoaSwgdGhpcy52ZWxvY2l0eSk7XG4gICAgY29uc3QgcyA9IGNkO1xuICAgIG4uY3Jvc3MoZSwgcyksIHRoaXMuaW52SW5lcnRpYVdvcmxkLnZtdWx0KHMsIHMpLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eS52YWRkKHMsIHRoaXMuYW5ndWxhclZlbG9jaXR5KTtcbiAgfVxuICBhcHBseUxvY2FsSW1wdWxzZShlLCB0KSB7XG4gICAgaWYgKHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBiKCkpLCB0aGlzLnR5cGUgIT09IGllLkRZTkFNSUMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IGhkLCBpID0gdWQ7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUoZSwgbiksIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHQsIGkpLCB0aGlzLmFwcGx5SW1wdWxzZShuLCBpKTtcbiAgfVxuICB1cGRhdGVNYXNzUHJvcGVydGllcygpIHtcbiAgICBjb25zdCBlID0gZGQ7XG4gICAgdGhpcy5pbnZNYXNzID0gdGhpcy5tYXNzID4gMCA/IDEgLyB0aGlzLm1hc3MgOiAwO1xuICAgIGNvbnN0IHQgPSB0aGlzLmluZXJ0aWEsIG4gPSB0aGlzLmZpeGVkUm90YXRpb247XG4gICAgdGhpcy51cGRhdGVBQUJCKCksIGUuc2V0KCh0aGlzLmFhYmIudXBwZXJCb3VuZC54IC0gdGhpcy5hYWJiLmxvd2VyQm91bmQueCkgLyAyLCAodGhpcy5hYWJiLnVwcGVyQm91bmQueSAtIHRoaXMuYWFiYi5sb3dlckJvdW5kLnkpIC8gMiwgKHRoaXMuYWFiYi51cHBlckJvdW5kLnogLSB0aGlzLmFhYmIubG93ZXJCb3VuZC56KSAvIDIpLCBXcy5jYWxjdWxhdGVJbmVydGlhKGUsIHRoaXMubWFzcywgdCksIHRoaXMuaW52SW5lcnRpYS5zZXQodC54ID4gMCAmJiAhbiA/IDEgLyB0LnggOiAwLCB0LnkgPiAwICYmICFuID8gMSAvIHQueSA6IDAsIHQueiA+IDAgJiYgIW4gPyAxIC8gdC56IDogMCksIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKCEwKTtcbiAgfVxuICBnZXRWZWxvY2l0eUF0V29ybGRQb2ludChlLCB0KSB7XG4gICAgY29uc3QgbiA9IG5ldyBiKCk7XG4gICAgcmV0dXJuIGUudnN1Yih0aGlzLnBvc2l0aW9uLCBuKSwgdGhpcy5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MobiwgdCksIHRoaXMudmVsb2NpdHkudmFkZCh0LCB0KSwgdDtcbiAgfVxuICBpbnRlZ3JhdGUoZSwgdCwgbikge1xuICAgIGlmICh0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weSh0aGlzLnBvc2l0aW9uKSwgdGhpcy5wcmV2aW91c1F1YXRlcm5pb24uY29weSh0aGlzLnF1YXRlcm5pb24pLCAhKHRoaXMudHlwZSA9PT0gaWUuRFlOQU1JQyB8fCB0aGlzLnR5cGUgPT09IGllLktJTkVNQVRJQykgfHwgdGhpcy5zbGVlcFN0YXRlID09PSBpZS5TTEVFUElORylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy52ZWxvY2l0eSwgcyA9IHRoaXMuYW5ndWxhclZlbG9jaXR5LCBvID0gdGhpcy5wb3NpdGlvbiwgciA9IHRoaXMuZm9yY2UsIGwgPSB0aGlzLnRvcnF1ZSwgYSA9IHRoaXMucXVhdGVybmlvbiwgYyA9IHRoaXMuaW52TWFzcywgZCA9IHRoaXMuaW52SW5lcnRpYVdvcmxkLCB1ID0gdGhpcy5saW5lYXJGYWN0b3IsIG0gPSBjICogZTtcbiAgICBpLnggKz0gci54ICogbSAqIHUueCwgaS55ICs9IHIueSAqIG0gKiB1LnksIGkueiArPSByLnogKiBtICogdS56O1xuICAgIGNvbnN0IGcgPSBkLmVsZW1lbnRzLCBwID0gdGhpcy5hbmd1bGFyRmFjdG9yLCBmID0gbC54ICogcC54LCB2ID0gbC55ICogcC55LCBfID0gbC56ICogcC56O1xuICAgIHMueCArPSBlICogKGdbMF0gKiBmICsgZ1sxXSAqIHYgKyBnWzJdICogXyksIHMueSArPSBlICogKGdbM10gKiBmICsgZ1s0XSAqIHYgKyBnWzVdICogXyksIHMueiArPSBlICogKGdbNl0gKiBmICsgZ1s3XSAqIHYgKyBnWzhdICogXyksIG8ueCArPSBpLnggKiBlLCBvLnkgKz0gaS55ICogZSwgby56ICs9IGkueiAqIGUsIGEuaW50ZWdyYXRlKHRoaXMuYW5ndWxhclZlbG9jaXR5LCBlLCB0aGlzLmFuZ3VsYXJGYWN0b3IsIGEpLCB0ICYmIChuID8gYS5ub3JtYWxpemVGYXN0KCkgOiBhLm5vcm1hbGl6ZSgpKSwgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSAhMCwgdGhpcy51cGRhdGVJbmVydGlhV29ybGQoKTtcbiAgfVxufVxuaWUuaWRDb3VudGVyID0gMDtcbmllLkNPTExJREVfRVZFTlRfTkFNRSA9IFwiY29sbGlkZVwiO1xuaWUuRFlOQU1JQyA9IFZzLkRZTkFNSUM7XG5pZS5TVEFUSUMgPSBWcy5TVEFUSUM7XG5pZS5LSU5FTUFUSUMgPSBWcy5LSU5FTUFUSUM7XG5pZS5BV0FLRSA9IEhzLkFXQUtFO1xuaWUuU0xFRVBZID0gSHMuU0xFRVBZO1xuaWUuU0xFRVBJTkcgPSBIcy5TTEVFUElORztcbmllLndha2V1cEV2ZW50ID0ge1xuICB0eXBlOiBcIndha2V1cFwiXG59O1xuaWUuc2xlZXB5RXZlbnQgPSB7XG4gIHR5cGU6IFwic2xlZXB5XCJcbn07XG5pZS5zbGVlcEV2ZW50ID0ge1xuICB0eXBlOiBcInNsZWVwXCJcbn07XG5jb25zdCBRdSA9IG5ldyBiKCksIGVkID0gbmV3IGplKCksIHRkID0gbmV3IHZ0KCksIG5kID0gbmV3IEx0KCksIGlkID0gbmV3IEx0KCksIHNkID0gbmV3IEx0KCksIHJkID0gbmV3IGIoKSwgb2QgPSBuZXcgYigpLCBhZCA9IG5ldyBiKCksIGxkID0gbmV3IGIoKSwgY2QgPSBuZXcgYigpLCBoZCA9IG5ldyBiKCksIHVkID0gbmV3IGIoKSwgZGQgPSBuZXcgYigpO1xuY2xhc3MgZmQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndvcmxkID0gbnVsbCwgdGhpcy51c2VCb3VuZGluZ0JveGVzID0gITEsIHRoaXMuZGlydHkgPSAhMDtcbiAgfVxuICBjb2xsaXNpb25QYWlycyhlLCB0LCBuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhXCIpO1xuICB9XG4gIG5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGUsIHQpIHtcbiAgICByZXR1cm4gISgoZS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIHQuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDAgfHwgKHQuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBlLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwIHx8ICgoZS50eXBlICYgaWUuU1RBVElDKSAhPT0gMCB8fCBlLnNsZWVwU3RhdGUgPT09IGllLlNMRUVQSU5HKSAmJiAoKHQudHlwZSAmIGllLlNUQVRJQykgIT09IDAgfHwgdC5zbGVlcFN0YXRlID09PSBpZS5TTEVFUElORykpO1xuICB9XG4gIGludGVyc2VjdGlvblRlc3QoZSwgdCwgbiwgaSkge1xuICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA/IHRoaXMuZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UoZSwgdCwgbiwgaSkgOiB0aGlzLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKGUsIHQsIG4sIGkpO1xuICB9XG4gIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKGUsIHQsIG4sIGkpIHtcbiAgICBjb25zdCBzID0gcGQ7XG4gICAgdC5wb3NpdGlvbi52c3ViKGUucG9zaXRpb24sIHMpO1xuICAgIGNvbnN0IG8gPSAoZS5ib3VuZGluZ1JhZGl1cyArIHQuYm91bmRpbmdSYWRpdXMpICoqIDI7XG4gICAgcy5sZW5ndGhTcXVhcmVkKCkgPCBvICYmIChuLnB1c2goZSksIGkucHVzaCh0KSk7XG4gIH1cbiAgZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UoZSwgdCwgbiwgaSkge1xuICAgIGUuYWFiYk5lZWRzVXBkYXRlICYmIGUudXBkYXRlQUFCQigpLCB0LmFhYmJOZWVkc1VwZGF0ZSAmJiB0LnVwZGF0ZUFBQkIoKSwgZS5hYWJiLm92ZXJsYXBzKHQuYWFiYikgJiYgKG4ucHVzaChlKSwgaS5wdXNoKHQpKTtcbiAgfVxuICBtYWtlUGFpcnNVbmlxdWUoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBtZCwgaSA9IGdkLCBzID0gX2QsIG8gPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCByID0gMDsgciAhPT0gbzsgcisrKVxuICAgICAgaVtyXSA9IGVbcl0sIHNbcl0gPSB0W3JdO1xuICAgIGUubGVuZ3RoID0gMCwgdC5sZW5ndGggPSAwO1xuICAgIGZvciAobGV0IHIgPSAwOyByICE9PSBvOyByKyspIHtcbiAgICAgIGNvbnN0IGwgPSBpW3JdLmlkLCBhID0gc1tyXS5pZCwgYyA9IGwgPCBhID8gYCR7bH0sJHthfWAgOiBgJHthfSwke2x9YDtcbiAgICAgIG5bY10gPSByLCBuLmtleXMucHVzaChjKTtcbiAgICB9XG4gICAgZm9yIChsZXQgciA9IDA7IHIgIT09IG4ua2V5cy5sZW5ndGg7IHIrKykge1xuICAgICAgY29uc3QgbCA9IG4ua2V5cy5wb3AoKSwgYSA9IG5bbF07XG4gICAgICBlLnB1c2goaVthXSksIHQucHVzaChzW2FdKSwgZGVsZXRlIG5bbF07XG4gICAgfVxuICB9XG4gIHNldFdvcmxkKGUpIHtcbiAgfVxuICBzdGF0aWMgYm91bmRpbmdTcGhlcmVDaGVjayhlLCB0KSB7XG4gICAgY29uc3QgbiA9IG5ldyBiKCk7XG4gICAgZS5wb3NpdGlvbi52c3ViKHQucG9zaXRpb24sIG4pO1xuICAgIGNvbnN0IGkgPSBlLnNoYXBlc1swXSwgcyA9IHQuc2hhcGVzWzBdO1xuICAgIHJldHVybiBNYXRoLnBvdyhpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgcy5ib3VuZGluZ1NwaGVyZVJhZGl1cywgMikgPiBuLmxlbmd0aFNxdWFyZWQoKTtcbiAgfVxuICBhYWJiUXVlcnkoZSwgdCwgbikge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCIuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuXCIpLCBbXTtcbiAgfVxufVxuY29uc3QgcGQgPSBuZXcgYigpO1xubmV3IGIoKTtcbm5ldyBqZSgpO1xubmV3IGIoKTtcbmNvbnN0IG1kID0ge1xuICBrZXlzOiBbXVxufSwgZ2QgPSBbXSwgX2QgPSBbXTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbmNsYXNzIHdvIGV4dGVuZHMgZmQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG4gIGNvbGxpc2lvblBhaXJzKGUsIHQsIG4pIHtcbiAgICBjb25zdCBpID0gZS5ib2RpZXMsIHMgPSBpLmxlbmd0aDtcbiAgICBsZXQgbywgcjtcbiAgICBmb3IgKGxldCBsID0gMDsgbCAhPT0gczsgbCsrKVxuICAgICAgZm9yIChsZXQgYSA9IDA7IGEgIT09IGw7IGErKylcbiAgICAgICAgbyA9IGlbbF0sIHIgPSBpW2FdLCB0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKG8sIHIpICYmIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChvLCByLCB0LCBuKTtcbiAgfVxuICBhYWJiUXVlcnkoZSwgdCwgbikge1xuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IFtdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGUuYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzID0gZS5ib2RpZXNbaV07XG4gICAgICBzLmFhYmJOZWVkc1VwZGF0ZSAmJiBzLnVwZGF0ZUFBQkIoKSwgcy5hYWJiLm92ZXJsYXBzKHQpICYmIG4ucHVzaChzKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbn1cbmNsYXNzIFhpIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yYXlGcm9tV29ybGQgPSBuZXcgYigpLCB0aGlzLnJheVRvV29ybGQgPSBuZXcgYigpLCB0aGlzLmhpdE5vcm1hbFdvcmxkID0gbmV3IGIoKSwgdGhpcy5oaXRQb2ludFdvcmxkID0gbmV3IGIoKSwgdGhpcy5oYXNIaXQgPSAhMSwgdGhpcy5zaGFwZSA9IG51bGwsIHRoaXMuYm9keSA9IG51bGwsIHRoaXMuaGl0RmFjZUluZGV4ID0gLTEsIHRoaXMuZGlzdGFuY2UgPSAtMSwgdGhpcy5zaG91bGRTdG9wID0gITE7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5yYXlGcm9tV29ybGQuc2V0WmVybygpLCB0aGlzLnJheVRvV29ybGQuc2V0WmVybygpLCB0aGlzLmhpdE5vcm1hbFdvcmxkLnNldFplcm8oKSwgdGhpcy5oaXRQb2ludFdvcmxkLnNldFplcm8oKSwgdGhpcy5oYXNIaXQgPSAhMSwgdGhpcy5zaGFwZSA9IG51bGwsIHRoaXMuYm9keSA9IG51bGwsIHRoaXMuaGl0RmFjZUluZGV4ID0gLTEsIHRoaXMuZGlzdGFuY2UgPSAtMSwgdGhpcy5zaG91bGRTdG9wID0gITE7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5zaG91bGRTdG9wID0gITA7XG4gIH1cbiAgc2V0KGUsIHQsIG4sIGksIHMsIG8sIHIpIHtcbiAgICB0aGlzLnJheUZyb21Xb3JsZC5jb3B5KGUpLCB0aGlzLnJheVRvV29ybGQuY29weSh0KSwgdGhpcy5oaXROb3JtYWxXb3JsZC5jb3B5KG4pLCB0aGlzLmhpdFBvaW50V29ybGQuY29weShpKSwgdGhpcy5zaGFwZSA9IHMsIHRoaXMuYm9keSA9IG8sIHRoaXMuZGlzdGFuY2UgPSByO1xuICB9XG59XG5sZXQgTW8sIFNvLCBFbywgVG8sIEFvLCBDbywgTG87XG5jb25zdCBxcyA9IHtcbiAgQ0xPU0VTVDogMSxcbiAgQU5ZOiAyLFxuICBBTEw6IDRcbn07XG5NbyA9IGxlLnR5cGVzLlNQSEVSRTtcblNvID0gbGUudHlwZXMuUExBTkU7XG5FbyA9IGxlLnR5cGVzLkJPWDtcblRvID0gbGUudHlwZXMuQ1lMSU5ERVI7XG5BbyA9IGxlLnR5cGVzLkNPTlZFWFBPTFlIRURST047XG5DbyA9IGxlLnR5cGVzLkhFSUdIVEZJRUxEO1xuTG8gPSBsZS50eXBlcy5UUklNRVNIO1xuY2xhc3MgWGUge1xuICBnZXQgW01vXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0U3BoZXJlO1xuICB9XG4gIGdldCBbU29dKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RQbGFuZTtcbiAgfVxuICBnZXQgW0VvXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0Qm94O1xuICB9XG4gIGdldCBbVG9dKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RDb252ZXg7XG4gIH1cbiAgZ2V0IFtBb10oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleDtcbiAgfVxuICBnZXQgW0NvXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0SGVpZ2h0ZmllbGQ7XG4gIH1cbiAgZ2V0IFtMb10oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdFRyaW1lc2g7XG4gIH1cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBiKCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgYigpKSwgdGhpcy5mcm9tID0gZS5jbG9uZSgpLCB0aGlzLnRvID0gdC5jbG9uZSgpLCB0aGlzLmRpcmVjdGlvbiA9IG5ldyBiKCksIHRoaXMucHJlY2lzaW9uID0gMWUtNCwgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gITAsIHRoaXMuc2tpcEJhY2tmYWNlcyA9ICExLCB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMSwgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xLCB0aGlzLm1vZGUgPSBYZS5BTlksIHRoaXMucmVzdWx0ID0gbmV3IFhpKCksIHRoaXMuaGFzSGl0ID0gITEsIHRoaXMuY2FsbGJhY2sgPSAobikgPT4ge1xuICAgIH07XG4gIH1cbiAgaW50ZXJzZWN0V29ybGQoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLm1vZGUgPSB0Lm1vZGUgfHwgWGUuQU5ZLCB0aGlzLnJlc3VsdCA9IHQucmVzdWx0IHx8IG5ldyBYaSgpLCB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIXQuc2tpcEJhY2tmYWNlcywgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mIHQuY29sbGlzaW9uRmlsdGVyTWFzayA8IFwidVwiID8gdC5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTEsIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2YgdC5jb2xsaXNpb25GaWx0ZXJHcm91cCA8IFwidVwiID8gdC5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IC0xLCB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0eXBlb2YgdC5jaGVja0NvbGxpc2lvblJlc3BvbnNlIDwgXCJ1XCIgPyB0LmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgOiAhMCwgdC5mcm9tICYmIHRoaXMuZnJvbS5jb3B5KHQuZnJvbSksIHQudG8gJiYgdGhpcy50by5jb3B5KHQudG8pLCB0aGlzLmNhbGxiYWNrID0gdC5jYWxsYmFjayB8fCAoKCkgPT4ge1xuICAgIH0pLCB0aGlzLmhhc0hpdCA9ICExLCB0aGlzLnJlc3VsdC5yZXNldCgpLCB0aGlzLnVwZGF0ZURpcmVjdGlvbigpLCB0aGlzLmdldEFBQkIoVXIpLCBMcy5sZW5ndGggPSAwLCBlLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KGUsIFVyLCBMcyksIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKExzKSwgdGhpcy5oYXNIaXQ7XG4gIH1cbiAgaW50ZXJzZWN0Qm9keShlLCB0KSB7XG4gICAgdCAmJiAodGhpcy5yZXN1bHQgPSB0LCB0aGlzLnVwZGF0ZURpcmVjdGlvbigpKTtcbiAgICBjb25zdCBuID0gdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlO1xuICAgIGlmIChuICYmICFlLmNvbGxpc2lvblJlc3BvbnNlIHx8ICh0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgZS5jb2xsaXNpb25GaWx0ZXJNYXNrKSA9PT0gMCB8fCAoZS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHZkLCBzID0geGQ7XG4gICAgZm9yIChsZXQgbyA9IDAsIHIgPSBlLnNoYXBlcy5sZW5ndGg7IG8gPCByOyBvKyspIHtcbiAgICAgIGNvbnN0IGwgPSBlLnNoYXBlc1tvXTtcbiAgICAgIGlmICghKG4gJiYgIWwuY29sbGlzaW9uUmVzcG9uc2UpICYmIChlLnF1YXRlcm5pb24ubXVsdChlLnNoYXBlT3JpZW50YXRpb25zW29dLCBzKSwgZS5xdWF0ZXJuaW9uLnZtdWx0KGUuc2hhcGVPZmZzZXRzW29dLCBpKSwgaS52YWRkKGUucG9zaXRpb24sIGkpLCB0aGlzLmludGVyc2VjdFNoYXBlKGwsIHMsIGksIGUpLCB0aGlzLnJlc3VsdC5zaG91bGRTdG9wKSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGludGVyc2VjdEJvZGllcyhlLCB0KSB7XG4gICAgdCAmJiAodGhpcy5yZXN1bHQgPSB0LCB0aGlzLnVwZGF0ZURpcmVjdGlvbigpKTtcbiAgICBmb3IgKGxldCBuID0gMCwgaSA9IGUubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBuIDwgaTsgbisrKVxuICAgICAgdGhpcy5pbnRlcnNlY3RCb2R5KGVbbl0pO1xuICB9XG4gIHVwZGF0ZURpcmVjdGlvbigpIHtcbiAgICB0aGlzLnRvLnZzdWIodGhpcy5mcm9tLCB0aGlzLmRpcmVjdGlvbiksIHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICB9XG4gIGludGVyc2VjdFNoYXBlKGUsIHQsIG4sIGkpIHtcbiAgICBjb25zdCBzID0gdGhpcy5mcm9tO1xuICAgIGlmIChQZChzLCB0aGlzLmRpcmVjdGlvbiwgbikgPiBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzW2UudHlwZV07XG4gICAgciAmJiByLmNhbGwodGhpcywgZSwgdCwgbiwgaSwgZSk7XG4gIH1cbiAgX2ludGVyc2VjdEJveChlLCB0LCBuLCBpLCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleChlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgdCwgbiwgaSwgcyk7XG4gIH1cbiAgX2ludGVyc2VjdFBsYW5lKGUsIHQsIG4sIGksIHMpIHtcbiAgICBjb25zdCBvID0gdGhpcy5mcm9tLCByID0gdGhpcy50bywgbCA9IHRoaXMuZGlyZWN0aW9uLCBhID0gbmV3IGIoMCwgMCwgMSk7XG4gICAgdC52bXVsdChhLCBhKTtcbiAgICBjb25zdCBjID0gbmV3IGIoKTtcbiAgICBvLnZzdWIobiwgYyk7XG4gICAgY29uc3QgZCA9IGMuZG90KGEpO1xuICAgIHIudnN1YihuLCBjKTtcbiAgICBjb25zdCB1ID0gYy5kb3QoYSk7XG4gICAgaWYgKGQgKiB1ID4gMCB8fCBvLmRpc3RhbmNlVG8ocikgPCBkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG0gPSBhLmRvdChsKTtcbiAgICBpZiAoTWF0aC5hYnMobSkgPCB0aGlzLnByZWNpc2lvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBnID0gbmV3IGIoKSwgcCA9IG5ldyBiKCksIGYgPSBuZXcgYigpO1xuICAgIG8udnN1YihuLCBnKTtcbiAgICBjb25zdCB2ID0gLWEuZG90KGcpIC8gbTtcbiAgICBsLnNjYWxlKHYsIHApLCBvLnZhZGQocCwgZiksIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKGEsIGYsIHMsIGksIC0xKTtcbiAgfVxuICBnZXRBQUJCKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsb3dlckJvdW5kOiB0LFxuICAgICAgdXBwZXJCb3VuZDogblxuICAgIH0gPSBlLCBpID0gdGhpcy50bywgcyA9IHRoaXMuZnJvbTtcbiAgICB0LnggPSBNYXRoLm1pbihpLngsIHMueCksIHQueSA9IE1hdGgubWluKGkueSwgcy55KSwgdC56ID0gTWF0aC5taW4oaS56LCBzLnopLCBuLnggPSBNYXRoLm1heChpLngsIHMueCksIG4ueSA9IE1hdGgubWF4KGkueSwgcy55KSwgbi56ID0gTWF0aC5tYXgoaS56LCBzLnopO1xuICB9XG4gIF9pbnRlcnNlY3RIZWlnaHRmaWVsZChlLCB0LCBuLCBpLCBzKSB7XG4gICAgZS5kYXRhLCBlLmVsZW1lbnRTaXplO1xuICAgIGNvbnN0IG8gPSB5ZDtcbiAgICBvLmZyb20uY29weSh0aGlzLmZyb20pLCBvLnRvLmNvcHkodGhpcy50byksIFBlLnBvaW50VG9Mb2NhbEZyYW1lKG4sIHQsIG8uZnJvbSwgby5mcm9tKSwgUGUucG9pbnRUb0xvY2FsRnJhbWUobiwgdCwgby50bywgby50byksIG8udXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgY29uc3QgciA9IGJkO1xuICAgIGxldCBsLCBhLCBjLCBkO1xuICAgIGwgPSBhID0gMCwgYyA9IGQgPSBlLmRhdGEubGVuZ3RoIC0gMTtcbiAgICBjb25zdCB1ID0gbmV3IHZ0KCk7XG4gICAgby5nZXRBQUJCKHUpLCBlLmdldEluZGV4T2ZQb3NpdGlvbih1Lmxvd2VyQm91bmQueCwgdS5sb3dlckJvdW5kLnksIHIsICEwKSwgbCA9IE1hdGgubWF4KGwsIHJbMF0pLCBhID0gTWF0aC5tYXgoYSwgclsxXSksIGUuZ2V0SW5kZXhPZlBvc2l0aW9uKHUudXBwZXJCb3VuZC54LCB1LnVwcGVyQm91bmQueSwgciwgITApLCBjID0gTWF0aC5taW4oYywgclswXSArIDEpLCBkID0gTWF0aC5taW4oZCwgclsxXSArIDEpO1xuICAgIGZvciAobGV0IG0gPSBsOyBtIDwgYzsgbSsrKVxuICAgICAgZm9yIChsZXQgZyA9IGE7IGcgPCBkOyBnKyspIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnNob3VsZFN0b3ApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZS5nZXRBYWJiQXRJbmRleChtLCBnLCB1KSwgISF1Lm92ZXJsYXBzUmF5KG8pKSB7XG4gICAgICAgICAgaWYgKGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIobSwgZywgITEpLCBQZS5wb2ludFRvV29ybGRGcmFtZShuLCB0LCBlLnBpbGxhck9mZnNldCwgTmkpLCB0aGlzLl9pbnRlcnNlY3RDb252ZXgoZS5waWxsYXJDb252ZXgsIHQsIE5pLCBpLCBzLCBHciksIHRoaXMucmVzdWx0LnNob3VsZFN0b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihtLCBnLCAhMCksIFBlLnBvaW50VG9Xb3JsZEZyYW1lKG4sIHQsIGUucGlsbGFyT2Zmc2V0LCBOaSksIHRoaXMuX2ludGVyc2VjdENvbnZleChlLnBpbGxhckNvbnZleCwgdCwgTmksIGksIHMsIEdyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIF9pbnRlcnNlY3RTcGhlcmUoZSwgdCwgbiwgaSwgcykge1xuICAgIGNvbnN0IG8gPSB0aGlzLmZyb20sIHIgPSB0aGlzLnRvLCBsID0gZS5yYWRpdXMsIGEgPSAoci54IC0gby54KSAqKiAyICsgKHIueSAtIG8ueSkgKiogMiArIChyLnogLSBvLnopICoqIDIsIGMgPSAyICogKChyLnggLSBvLngpICogKG8ueCAtIG4ueCkgKyAoci55IC0gby55KSAqIChvLnkgLSBuLnkpICsgKHIueiAtIG8ueikgKiAoby56IC0gbi56KSksIGQgPSAoby54IC0gbi54KSAqKiAyICsgKG8ueSAtIG4ueSkgKiogMiArIChvLnogLSBuLnopICoqIDIgLSBsICoqIDIsIHUgPSBjICoqIDIgLSA0ICogYSAqIGQsIG0gPSB3ZCwgZyA9IE1kO1xuICAgIGlmICghKHUgPCAwKSlcbiAgICAgIGlmICh1ID09PSAwKVxuICAgICAgICBvLmxlcnAociwgdSwgbSksIG0udnN1YihuLCBnKSwgZy5ub3JtYWxpemUoKSwgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24oZywgbSwgcywgaSwgLTEpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHAgPSAoLWMgLSBNYXRoLnNxcnQodSkpIC8gKDIgKiBhKSwgZiA9ICgtYyArIE1hdGguc3FydCh1KSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAocCA+PSAwICYmIHAgPD0gMSAmJiAoby5sZXJwKHIsIHAsIG0pLCBtLnZzdWIobiwgZyksIGcubm9ybWFsaXplKCksIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKGcsIG0sIHMsIGksIC0xKSksIHRoaXMucmVzdWx0LnNob3VsZFN0b3ApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmID49IDAgJiYgZiA8PSAxICYmIChvLmxlcnAociwgZiwgbSksIG0udnN1YihuLCBnKSwgZy5ub3JtYWxpemUoKSwgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24oZywgbSwgcywgaSwgLTEpKTtcbiAgICAgIH1cbiAgfVxuICBfaW50ZXJzZWN0Q29udmV4KGUsIHQsIG4sIGksIHMsIG8pIHtcbiAgICBjb25zdCByID0gU2QsIGwgPSBrciwgYSA9IG8gJiYgby5mYWNlTGlzdCB8fCBudWxsLCBjID0gZS5mYWNlcywgZCA9IGUudmVydGljZXMsIHUgPSBlLmZhY2VOb3JtYWxzLCBtID0gdGhpcy5kaXJlY3Rpb24sIGcgPSB0aGlzLmZyb20sIHAgPSB0aGlzLnRvLCBmID0gZy5kaXN0YW5jZVRvKHApLCB2ID0gYSA/IGEubGVuZ3RoIDogYy5sZW5ndGgsIF8gPSB0aGlzLnJlc3VsdDtcbiAgICBmb3IgKGxldCB3ID0gMDsgIV8uc2hvdWxkU3RvcCAmJiB3IDwgdjsgdysrKSB7XG4gICAgICBjb25zdCB4ID0gYSA/IGFbd10gOiB3LCBNID0gY1t4XSwgRSA9IHVbeF0sIFIgPSB0LCB5ID0gbjtcbiAgICAgIGwuY29weShkW01bMF1dKSwgUi52bXVsdChsLCBsKSwgbC52YWRkKHksIGwpLCBsLnZzdWIoZywgbCksIFIudm11bHQoRSwgcik7XG4gICAgICBjb25zdCBBID0gbS5kb3Qocik7XG4gICAgICBpZiAoTWF0aC5hYnMoQSkgPCB0aGlzLnByZWNpc2lvbilcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBGID0gci5kb3QobCkgLyBBO1xuICAgICAgaWYgKCEoRiA8IDApKSB7XG4gICAgICAgIG0uc2NhbGUoRiwgaHQpLCBodC52YWRkKGcsIGh0KSwgQ3QuY29weShkW01bMF1dKSwgUi52bXVsdChDdCwgQ3QpLCB5LnZhZGQoQ3QsIEN0KTtcbiAgICAgICAgZm9yIChsZXQgUCA9IDE7ICFfLnNob3VsZFN0b3AgJiYgUCA8IE0ubGVuZ3RoIC0gMTsgUCsrKSB7XG4gICAgICAgICAgSXQuY29weShkW01bUF1dKSwgenQuY29weShkW01bUCArIDFdXSksIFIudm11bHQoSXQsIEl0KSwgUi52bXVsdCh6dCwgenQpLCB5LnZhZGQoSXQsIEl0KSwgeS52YWRkKHp0LCB6dCk7XG4gICAgICAgICAgY29uc3QgRyA9IGh0LmRpc3RhbmNlVG8oZyk7XG4gICAgICAgICAgIShYZS5wb2ludEluVHJpYW5nbGUoaHQsIEN0LCBJdCwgenQpIHx8IFhlLnBvaW50SW5UcmlhbmdsZShodCwgSXQsIEN0LCB6dCkpIHx8IEcgPiBmIHx8IHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHIsIGh0LCBzLCBpLCB4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaW50ZXJzZWN0VHJpbWVzaChlLCB0LCBuLCBpLCBzLCBvKSB7XG4gICAgY29uc3QgciA9IEVkLCBsID0gRmQsIGEgPSBEZCwgYyA9IGtyLCBkID0gVGQsIHUgPSBBZCwgbSA9IENkLCBnID0gUmQsIHAgPSBMZCwgZiA9IGUuaW5kaWNlcztcbiAgICBlLnZlcnRpY2VzO1xuICAgIGNvbnN0IHYgPSB0aGlzLmZyb20sIF8gPSB0aGlzLnRvLCB3ID0gdGhpcy5kaXJlY3Rpb247XG4gICAgYS5wb3NpdGlvbi5jb3B5KG4pLCBhLnF1YXRlcm5pb24uY29weSh0KSwgUGUudmVjdG9yVG9Mb2NhbEZyYW1lKG4sIHQsIHcsIGQpLCBQZS5wb2ludFRvTG9jYWxGcmFtZShuLCB0LCB2LCB1KSwgUGUucG9pbnRUb0xvY2FsRnJhbWUobiwgdCwgXywgbSksIG0ueCAqPSBlLnNjYWxlLngsIG0ueSAqPSBlLnNjYWxlLnksIG0ueiAqPSBlLnNjYWxlLnosIHUueCAqPSBlLnNjYWxlLngsIHUueSAqPSBlLnNjYWxlLnksIHUueiAqPSBlLnNjYWxlLnosIG0udnN1Yih1LCBkKSwgZC5ub3JtYWxpemUoKTtcbiAgICBjb25zdCB4ID0gdS5kaXN0YW5jZVNxdWFyZWQobSk7XG4gICAgZS50cmVlLnJheVF1ZXJ5KHRoaXMsIGEsIGwpO1xuICAgIGZvciAobGV0IE0gPSAwLCBFID0gbC5sZW5ndGg7ICF0aGlzLnJlc3VsdC5zaG91bGRTdG9wICYmIE0gIT09IEU7IE0rKykge1xuICAgICAgY29uc3QgUiA9IGxbTV07XG4gICAgICBlLmdldE5vcm1hbChSLCByKSwgZS5nZXRWZXJ0ZXgoZltSICogM10sIEN0KSwgQ3QudnN1Yih1LCBjKTtcbiAgICAgIGNvbnN0IHkgPSBkLmRvdChyKSwgQSA9IHIuZG90KGMpIC8geTtcbiAgICAgIGlmIChBIDwgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBkLnNjYWxlKEEsIGh0KSwgaHQudmFkZCh1LCBodCksIGUuZ2V0VmVydGV4KGZbUiAqIDMgKyAxXSwgSXQpLCBlLmdldFZlcnRleChmW1IgKiAzICsgMl0sIHp0KTtcbiAgICAgIGNvbnN0IEYgPSBodC5kaXN0YW5jZVNxdWFyZWQodSk7XG4gICAgICAhKFhlLnBvaW50SW5UcmlhbmdsZShodCwgSXQsIEN0LCB6dCkgfHwgWGUucG9pbnRJblRyaWFuZ2xlKGh0LCBDdCwgSXQsIHp0KSkgfHwgRiA+IHggfHwgKFBlLnZlY3RvclRvV29ybGRGcmFtZSh0LCByLCBwKSwgUGUucG9pbnRUb1dvcmxkRnJhbWUobiwgdCwgaHQsIGcpLCB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihwLCBnLCBzLCBpLCBSKSk7XG4gICAgfVxuICAgIGwubGVuZ3RoID0gMDtcbiAgfVxuICByZXBvcnRJbnRlcnNlY3Rpb24oZSwgdCwgbiwgaSwgcykge1xuICAgIGNvbnN0IG8gPSB0aGlzLmZyb20sIHIgPSB0aGlzLnRvLCBsID0gby5kaXN0YW5jZVRvKHQpLCBhID0gdGhpcy5yZXN1bHQ7XG4gICAgaWYgKCEodGhpcy5za2lwQmFja2ZhY2VzICYmIGUuZG90KHRoaXMuZGlyZWN0aW9uKSA+IDApKVxuICAgICAgc3dpdGNoIChhLmhpdEZhY2VJbmRleCA9IHR5cGVvZiBzIDwgXCJ1XCIgPyBzIDogLTEsIHRoaXMubW9kZSkge1xuICAgICAgICBjYXNlIFhlLkFMTDpcbiAgICAgICAgICB0aGlzLmhhc0hpdCA9ICEwLCBhLnNldChvLCByLCBlLCB0LCBuLCBpLCBsKSwgYS5oYXNIaXQgPSAhMCwgdGhpcy5jYWxsYmFjayhhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYZS5DTE9TRVNUOlxuICAgICAgICAgIChsIDwgYS5kaXN0YW5jZSB8fCAhYS5oYXNIaXQpICYmICh0aGlzLmhhc0hpdCA9ICEwLCBhLmhhc0hpdCA9ICEwLCBhLnNldChvLCByLCBlLCB0LCBuLCBpLCBsKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWGUuQU5ZOlxuICAgICAgICAgIHRoaXMuaGFzSGl0ID0gITAsIGEuaGFzSGl0ID0gITAsIGEuc2V0KG8sIHIsIGUsIHQsIG4sIGksIGwpLCBhLnNob3VsZFN0b3AgPSAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICBzdGF0aWMgcG9pbnRJblRyaWFuZ2xlKGUsIHQsIG4sIGkpIHtcbiAgICBpLnZzdWIodCwgeG4pLCBuLnZzdWIodCwgaWkpLCBlLnZzdWIodCwgUnMpO1xuICAgIGNvbnN0IHMgPSB4bi5kb3QoeG4pLCBvID0geG4uZG90KGlpKSwgciA9IHhuLmRvdChScyksIGwgPSBpaS5kb3QoaWkpLCBhID0gaWkuZG90KFJzKTtcbiAgICBsZXQgYywgZDtcbiAgICByZXR1cm4gKGMgPSBsICogciAtIG8gKiBhKSA+PSAwICYmIChkID0gcyAqIGEgLSBvICogcikgPj0gMCAmJiBjICsgZCA8IHMgKiBsIC0gbyAqIG87XG4gIH1cbn1cblhlLkNMT1NFU1QgPSBxcy5DTE9TRVNUO1xuWGUuQU5ZID0gcXMuQU5ZO1xuWGUuQUxMID0gcXMuQUxMO1xuY29uc3QgVXIgPSBuZXcgdnQoKSwgTHMgPSBbXSwgaWkgPSBuZXcgYigpLCBScyA9IG5ldyBiKCksIHZkID0gbmV3IGIoKSwgeGQgPSBuZXcgamUoKSwgaHQgPSBuZXcgYigpLCBDdCA9IG5ldyBiKCksIEl0ID0gbmV3IGIoKSwgenQgPSBuZXcgYigpO1xubmV3IGIoKTtcbm5ldyBYaSgpO1xuY29uc3QgR3IgPSB7XG4gIGZhY2VMaXN0OiBbMF1cbn0sIE5pID0gbmV3IGIoKSwgeWQgPSBuZXcgWGUoKSwgYmQgPSBbXSwgd2QgPSBuZXcgYigpLCBNZCA9IG5ldyBiKCksIFNkID0gbmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xuY29uc3Qga3IgPSBuZXcgYigpLCBFZCA9IG5ldyBiKCksIFRkID0gbmV3IGIoKSwgQWQgPSBuZXcgYigpLCBDZCA9IG5ldyBiKCksIExkID0gbmV3IGIoKSwgUmQgPSBuZXcgYigpO1xubmV3IHZ0KCk7XG5jb25zdCBGZCA9IFtdLCBEZCA9IG5ldyBQZSgpLCB4biA9IG5ldyBiKCksIE9pID0gbmV3IGIoKTtcbmZ1bmN0aW9uIFBkKGgsIGUsIHQpIHtcbiAgdC52c3ViKGgsIHhuKTtcbiAgY29uc3QgbiA9IHhuLmRvdChlKTtcbiAgcmV0dXJuIGUuc2NhbGUobiwgT2kpLCBPaS52YWRkKGgsIE9pKSwgdC5kaXN0YW5jZVRvKE9pKTtcbn1cbmNsYXNzIElkIHtcbiAgc3RhdGljIGRlZmF1bHRzKGUsIHQpIHtcbiAgICBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSk7XG4gICAgZm9yIChsZXQgbiBpbiB0KVxuICAgICAgbiBpbiBlIHx8IChlW25dID0gdFtuXSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cbmNsYXNzIFdyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zcGF0aWFsID0gbmV3IGIoKSwgdGhpcy5yb3RhdGlvbmFsID0gbmV3IGIoKTtcbiAgfVxuICBtdWx0aXBseUVsZW1lbnQoZSkge1xuICAgIHJldHVybiBlLnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyBlLnJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7XG4gIH1cbiAgbXVsdGlwbHlWZWN0b3JzKGUsIHQpIHtcbiAgICByZXR1cm4gZS5kb3QodGhpcy5zcGF0aWFsKSArIHQuZG90KHRoaXMucm90YXRpb25hbCk7XG4gIH1cbn1cbmNsYXNzIG1pIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgaSkge1xuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IC0xZTYpLCBpID09PSB2b2lkIDAgJiYgKGkgPSAxZTYpLCB0aGlzLmlkID0gbWkuaWRDb3VudGVyKyssIHRoaXMubWluRm9yY2UgPSBuLCB0aGlzLm1heEZvcmNlID0gaSwgdGhpcy5iaSA9IGUsIHRoaXMuYmogPSB0LCB0aGlzLmEgPSAwLCB0aGlzLmIgPSAwLCB0aGlzLmVwcyA9IDAsIHRoaXMuamFjb2JpYW5FbGVtZW50QSA9IG5ldyBXcigpLCB0aGlzLmphY29iaWFuRWxlbWVudEIgPSBuZXcgV3IoKSwgdGhpcy5lbmFibGVkID0gITAsIHRoaXMubXVsdGlwbGllciA9IDAsIHRoaXMuc2V0U3Bvb2tQYXJhbXMoMWU3LCA0LCAxIC8gNjApO1xuICB9XG4gIHNldFNwb29rUGFyYW1zKGUsIHQsIG4pIHtcbiAgICBjb25zdCBpID0gdCwgcyA9IGUsIG8gPSBuO1xuICAgIHRoaXMuYSA9IDQgLyAobyAqICgxICsgNCAqIGkpKSwgdGhpcy5iID0gNCAqIGkgLyAoMSArIDQgKiBpKSwgdGhpcy5lcHMgPSA0IC8gKG8gKiBvICogcyAqICgxICsgNCAqIGkpKTtcbiAgfVxuICBjb21wdXRlQihlLCB0LCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuY29tcHV0ZUdXKCksIHMgPSB0aGlzLmNvbXB1dGVHcSgpLCBvID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtcyAqIGUgLSBpICogdCAtIG8gKiBuO1xuICB9XG4gIGNvbXB1dGVHcSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLCB0ID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLCBuID0gdGhpcy5iaSwgaSA9IHRoaXMuYmosIHMgPSBuLnBvc2l0aW9uLCBvID0gaS5wb3NpdGlvbjtcbiAgICByZXR1cm4gZS5zcGF0aWFsLmRvdChzKSArIHQuc3BhdGlhbC5kb3Qobyk7XG4gIH1cbiAgY29tcHV0ZUdXKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsIHQgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsIG4gPSB0aGlzLmJpLCBpID0gdGhpcy5iaiwgcyA9IG4udmVsb2NpdHksIG8gPSBpLnZlbG9jaXR5LCByID0gbi5hbmd1bGFyVmVsb2NpdHksIGwgPSBpLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICByZXR1cm4gZS5tdWx0aXBseVZlY3RvcnMocywgcikgKyB0Lm11bHRpcGx5VmVjdG9ycyhvLCBsKTtcbiAgfVxuICBjb21wdXRlR1dsYW1iZGEoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSwgdCA9IHRoaXMuamFjb2JpYW5FbGVtZW50QiwgbiA9IHRoaXMuYmksIGkgPSB0aGlzLmJqLCBzID0gbi52bGFtYmRhLCBvID0gaS52bGFtYmRhLCByID0gbi53bGFtYmRhLCBsID0gaS53bGFtYmRhO1xuICAgIHJldHVybiBlLm11bHRpcGx5VmVjdG9ycyhzLCByKSArIHQubXVsdGlwbHlWZWN0b3JzKG8sIGwpO1xuICB9XG4gIGNvbXB1dGVHaU1mKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsIHQgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsIG4gPSB0aGlzLmJpLCBpID0gdGhpcy5iaiwgcyA9IG4uZm9yY2UsIG8gPSBuLnRvcnF1ZSwgciA9IGkuZm9yY2UsIGwgPSBpLnRvcnF1ZSwgYSA9IG4uaW52TWFzc1NvbHZlLCBjID0gaS5pbnZNYXNzU29sdmU7XG4gICAgcmV0dXJuIHMuc2NhbGUoYSwgVnIpLCByLnNjYWxlKGMsIEhyKSwgbi5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChvLCBxciksIGkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQobCwgWHIpLCBlLm11bHRpcGx5VmVjdG9ycyhWciwgcXIpICsgdC5tdWx0aXBseVZlY3RvcnMoSHIsIFhyKTtcbiAgfVxuICBjb21wdXRlR2lNR3QoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSwgdCA9IHRoaXMuamFjb2JpYW5FbGVtZW50QiwgbiA9IHRoaXMuYmksIGkgPSB0aGlzLmJqLCBzID0gbi5pbnZNYXNzU29sdmUsIG8gPSBpLmludk1hc3NTb2x2ZSwgciA9IG4uaW52SW5lcnRpYVdvcmxkU29sdmUsIGwgPSBpLmludkluZXJ0aWFXb3JsZFNvbHZlO1xuICAgIGxldCBhID0gcyArIG87XG4gICAgcmV0dXJuIHIudm11bHQoZS5yb3RhdGlvbmFsLCBVaSksIGEgKz0gVWkuZG90KGUucm90YXRpb25hbCksIGwudm11bHQodC5yb3RhdGlvbmFsLCBVaSksIGEgKz0gVWkuZG90KHQucm90YXRpb25hbCksIGE7XG4gIH1cbiAgYWRkVG9XbGFtYmRhKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLCBuID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLCBpID0gdGhpcy5iaSwgcyA9IHRoaXMuYmosIG8gPSB6ZDtcbiAgICBpLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGkuaW52TWFzc1NvbHZlICogZSwgdC5zcGF0aWFsLCBpLnZsYW1iZGEpLCBzLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKHMuaW52TWFzc1NvbHZlICogZSwgbi5zcGF0aWFsLCBzLnZsYW1iZGEpLCBpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHQucm90YXRpb25hbCwgbyksIGkud2xhbWJkYS5hZGRTY2FsZWRWZWN0b3IoZSwgbywgaS53bGFtYmRhKSwgcy5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChuLnJvdGF0aW9uYWwsIG8pLCBzLndsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGUsIG8sIHMud2xhbWJkYSk7XG4gIH1cbiAgY29tcHV0ZUMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpTUd0KCkgKyB0aGlzLmVwcztcbiAgfVxufVxubWkuaWRDb3VudGVyID0gMDtcbmNvbnN0IFZyID0gbmV3IGIoKSwgSHIgPSBuZXcgYigpLCBxciA9IG5ldyBiKCksIFhyID0gbmV3IGIoKSwgVWkgPSBuZXcgYigpLCB6ZCA9IG5ldyBiKCk7XG5jbGFzcyBCZCBleHRlbmRzIG1pIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IDFlNiksIHN1cGVyKGUsIHQsIDAsIG4pLCB0aGlzLnJlc3RpdHV0aW9uID0gMCwgdGhpcy5yaSA9IG5ldyBiKCksIHRoaXMucmogPSBuZXcgYigpLCB0aGlzLm5pID0gbmV3IGIoKTtcbiAgfVxuICBjb21wdXRlQihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuYSwgbiA9IHRoaXMuYiwgaSA9IHRoaXMuYmksIHMgPSB0aGlzLmJqLCBvID0gdGhpcy5yaSwgciA9IHRoaXMucmosIGwgPSBOZCwgYSA9IE9kLCBjID0gaS52ZWxvY2l0eSwgZCA9IGkuYW5ndWxhclZlbG9jaXR5O1xuICAgIGkuZm9yY2UsIGkudG9ycXVlO1xuICAgIGNvbnN0IHUgPSBzLnZlbG9jaXR5LCBtID0gcy5hbmd1bGFyVmVsb2NpdHk7XG4gICAgcy5mb3JjZSwgcy50b3JxdWU7XG4gICAgY29uc3QgZyA9IFVkLCBwID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLCBmID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLCB2ID0gdGhpcy5uaTtcbiAgICBvLmNyb3NzKHYsIGwpLCByLmNyb3NzKHYsIGEpLCB2Lm5lZ2F0ZShwLnNwYXRpYWwpLCBsLm5lZ2F0ZShwLnJvdGF0aW9uYWwpLCBmLnNwYXRpYWwuY29weSh2KSwgZi5yb3RhdGlvbmFsLmNvcHkoYSksIGcuY29weShzLnBvc2l0aW9uKSwgZy52YWRkKHIsIGcpLCBnLnZzdWIoaS5wb3NpdGlvbiwgZyksIGcudnN1YihvLCBnKTtcbiAgICBjb25zdCBfID0gdi5kb3QoZyksIHcgPSB0aGlzLnJlc3RpdHV0aW9uICsgMSwgeCA9IHcgKiB1LmRvdCh2KSAtIHcgKiBjLmRvdCh2KSArIG0uZG90KGEpIC0gZC5kb3QobCksIE0gPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgcmV0dXJuIC1fICogdCAtIHggKiBuIC0gZSAqIE07XG4gIH1cbiAgZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCgpIHtcbiAgICBjb25zdCBlID0gR2QsIHQgPSBrZCwgbiA9IFdkLCBpID0gVmQsIHMgPSBIZDtcbiAgICByZXR1cm4gdGhpcy5iaS5wb3NpdGlvbi52YWRkKHRoaXMucmksIG4pLCB0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaiwgaSksIHRoaXMuYmkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQobiwgZSksIHRoaXMuYmouZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoaSwgdCksIGUudnN1Yih0LCBzKSwgdGhpcy5uaS5kb3Qocyk7XG4gIH1cbn1cbmNvbnN0IE5kID0gbmV3IGIoKSwgT2QgPSBuZXcgYigpLCBVZCA9IG5ldyBiKCksIEdkID0gbmV3IGIoKSwga2QgPSBuZXcgYigpLCBXZCA9IG5ldyBiKCksIFZkID0gbmV3IGIoKSwgSGQgPSBuZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbmNsYXNzIGpyIGV4dGVuZHMgbWkge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgc3VwZXIoZSwgdCwgLW4sIG4pLCB0aGlzLnJpID0gbmV3IGIoKSwgdGhpcy5yaiA9IG5ldyBiKCksIHRoaXMudCA9IG5ldyBiKCk7XG4gIH1cbiAgY29tcHV0ZUIoZSkge1xuICAgIHRoaXMuYTtcbiAgICBjb25zdCB0ID0gdGhpcy5iO1xuICAgIHRoaXMuYmksIHRoaXMuYmo7XG4gICAgY29uc3QgbiA9IHRoaXMucmksIGkgPSB0aGlzLnJqLCBzID0gcWQsIG8gPSBYZCwgciA9IHRoaXMudDtcbiAgICBuLmNyb3NzKHIsIHMpLCBpLmNyb3NzKHIsIG8pO1xuICAgIGNvbnN0IGwgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsIGEgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG4gICAgci5uZWdhdGUobC5zcGF0aWFsKSwgcy5uZWdhdGUobC5yb3RhdGlvbmFsKSwgYS5zcGF0aWFsLmNvcHkociksIGEucm90YXRpb25hbC5jb3B5KG8pO1xuICAgIGNvbnN0IGMgPSB0aGlzLmNvbXB1dGVHVygpLCBkID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtYyAqIHQgLSBlICogZDtcbiAgfVxufVxuY29uc3QgcWQgPSBuZXcgYigpLCBYZCA9IG5ldyBiKCk7XG5jbGFzcyBNbiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBuID0gSWQuZGVmYXVsdHMobiwge1xuICAgICAgZnJpY3Rpb246IDAuMyxcbiAgICAgIHJlc3RpdHV0aW9uOiAwLjMsXG4gICAgICBjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6IDFlNyxcbiAgICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IDMsXG4gICAgICBmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXG4gICAgICBmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjogM1xuICAgIH0pLCB0aGlzLmlkID0gTW4uaWRDb3VudGVyKyssIHRoaXMubWF0ZXJpYWxzID0gW2UsIHRdLCB0aGlzLmZyaWN0aW9uID0gbi5mcmljdGlvbiwgdGhpcy5yZXN0aXR1dGlvbiA9IG4ucmVzdGl0dXRpb24sIHRoaXMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzID0gbi5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsIHRoaXMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiA9IG4uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiwgdGhpcy5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzID0gbi5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLCB0aGlzLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uID0gbi5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjtcbiAgfVxufVxuTW4uaWRDb3VudGVyID0gMDtcbmNsYXNzIFNuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KTtcbiAgICBsZXQgdCA9IFwiXCI7XG4gICAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGUsIGUgPSB7fSksIHRoaXMubmFtZSA9IHQsIHRoaXMuaWQgPSBTbi5pZENvdW50ZXIrKywgdGhpcy5mcmljdGlvbiA9IHR5cGVvZiBlLmZyaWN0aW9uIDwgXCJ1XCIgPyBlLmZyaWN0aW9uIDogLTEsIHRoaXMucmVzdGl0dXRpb24gPSB0eXBlb2YgZS5yZXN0aXR1dGlvbiA8IFwidVwiID8gZS5yZXN0aXR1dGlvbiA6IC0xO1xuICB9XG59XG5Tbi5pZENvdW50ZXIgPSAwO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBYZSgpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoMSwgMCwgMCksIG5ldyBiKDAsIDEsIDApLCBuZXcgYigwLCAwLCAxKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xuY2xhc3MgamQgZXh0ZW5kcyB3biB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGkpIHtcbiAgICBpZiAoZSA9PT0gdm9pZCAwICYmIChlID0gMSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDEpLCBuID09PSB2b2lkIDAgJiYgKG4gPSAxKSwgaSA9PT0gdm9pZCAwICYmIChpID0gOCksIGUgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN5bGluZGVyIHJhZGl1c1RvcCBjYW5ub3QgYmUgbmVnYXRpdmUuXCIpO1xuICAgIGlmICh0IDwgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjeWxpbmRlciByYWRpdXNCb3R0b20gY2Fubm90IGJlIG5lZ2F0aXZlLlwiKTtcbiAgICBjb25zdCBzID0gaSwgbyA9IFtdLCByID0gW10sIGwgPSBbXSwgYSA9IFtdLCBjID0gW10sIGQgPSBNYXRoLmNvcywgdSA9IE1hdGguc2luO1xuICAgIG8ucHVzaChuZXcgYigtdCAqIHUoMCksIC1uICogMC41LCB0ICogZCgwKSkpLCBhLnB1c2goMCksIG8ucHVzaChuZXcgYigtZSAqIHUoMCksIG4gKiAwLjUsIGUgKiBkKDApKSksIGMucHVzaCgxKTtcbiAgICBmb3IgKGxldCBnID0gMDsgZyA8IHM7IGcrKykge1xuICAgICAgY29uc3QgcCA9IDIgKiBNYXRoLlBJIC8gcyAqIChnICsgMSksIGYgPSAyICogTWF0aC5QSSAvIHMgKiAoZyArIDAuNSk7XG4gICAgICBnIDwgcyAtIDEgPyAoby5wdXNoKG5ldyBiKC10ICogdShwKSwgLW4gKiAwLjUsIHQgKiBkKHApKSksIGEucHVzaCgyICogZyArIDIpLCBvLnB1c2gobmV3IGIoLWUgKiB1KHApLCBuICogMC41LCBlICogZChwKSkpLCBjLnB1c2goMiAqIGcgKyAzKSwgbC5wdXNoKFsyICogZywgMiAqIGcgKyAxLCAyICogZyArIDMsIDIgKiBnICsgMl0pKSA6IGwucHVzaChbMiAqIGcsIDIgKiBnICsgMSwgMSwgMF0pLCAocyAlIDIgPT09IDEgfHwgZyA8IHMgLyAyKSAmJiByLnB1c2gobmV3IGIoLXUoZiksIDAsIGQoZikpKTtcbiAgICB9XG4gICAgbC5wdXNoKGEpLCByLnB1c2gobmV3IGIoMCwgMSwgMCkpO1xuICAgIGNvbnN0IG0gPSBbXTtcbiAgICBmb3IgKGxldCBnID0gMDsgZyA8IGMubGVuZ3RoOyBnKyspXG4gICAgICBtLnB1c2goY1tjLmxlbmd0aCAtIGcgLSAxXSk7XG4gICAgbC5wdXNoKG0pLCBzdXBlcih7XG4gICAgICB2ZXJ0aWNlczogbyxcbiAgICAgIGZhY2VzOiBsLFxuICAgICAgYXhlczogclxuICAgIH0pLCB0aGlzLnR5cGUgPSBsZS50eXBlcy5DWUxJTkRFUiwgdGhpcy5yYWRpdXNUb3AgPSBlLCB0aGlzLnJhZGl1c0JvdHRvbSA9IHQsIHRoaXMuaGVpZ2h0ID0gbiwgdGhpcy5udW1TZWdtZW50cyA9IGk7XG4gIH1cbn1cbmNsYXNzIHNpIGV4dGVuZHMgbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiBsZS50eXBlcy5QTEFORVxuICAgIH0pLCB0aGlzLndvcmxkTm9ybWFsID0gbmV3IGIoKSwgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gITAsIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG4gIGNvbXB1dGVXb3JsZE5vcm1hbChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMud29ybGROb3JtYWw7XG4gICAgdC5zZXQoMCwgMCwgMSksIGUudm11bHQodCwgdCksIHRoaXMud29ybGROb3JtYWxOZWVkc1VwZGF0ZSA9ICExO1xuICB9XG4gIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShlLCB0KSB7XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBiKCkpLCB0O1xuICB9XG4gIHZvbHVtZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgfVxuICBjYWxjdWxhdGVXb3JsZEFBQkIoZSwgdCwgbiwgaSkge1xuICAgIGp0LnNldCgwLCAwLCAxKSwgdC52bXVsdChqdCwganQpO1xuICAgIGNvbnN0IHMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG4uc2V0KC1zLCAtcywgLXMpLCBpLnNldChzLCBzLCBzKSwganQueCA9PT0gMSA/IGkueCA9IGUueCA6IGp0LnggPT09IC0xICYmIChuLnggPSBlLngpLCBqdC55ID09PSAxID8gaS55ID0gZS55IDoganQueSA9PT0gLTEgJiYgKG4ueSA9IGUueSksIGp0LnogPT09IDEgPyBpLnogPSBlLnogOiBqdC56ID09PSAtMSAmJiAobi56ID0gZS56KTtcbiAgfVxuICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgfVxufVxuY29uc3QganQgPSBuZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyB2dCgpO1xubmV3IGIoKTtcbm5ldyB2dCgpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xubmV3IGIoKTtcbm5ldyB2dCgpO1xubmV3IGIoKTtcbm5ldyBQZSgpO1xubmV3IHZ0KCk7XG5jbGFzcyBZZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG4gIH1cbiAgc29sdmUoZSwgdCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGFkZEVxdWF0aW9uKGUpIHtcbiAgICBlLmVuYWJsZWQgJiYgIWUuYmkuaXNUcmlnZ2VyICYmICFlLmJqLmlzVHJpZ2dlciAmJiB0aGlzLmVxdWF0aW9ucy5wdXNoKGUpO1xuICB9XG4gIHJlbW92ZUVxdWF0aW9uKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5lcXVhdGlvbnMsIG4gPSB0LmluZGV4T2YoZSk7XG4gICAgbiAhPT0gLTEgJiYgdC5zcGxpY2UobiwgMSk7XG4gIH1cbiAgcmVtb3ZlQWxsRXF1YXRpb25zKCkge1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gIH1cbn1cbmNsYXNzIFpkIGV4dGVuZHMgWWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLml0ZXJhdGlvbnMgPSAxMCwgdGhpcy50b2xlcmFuY2UgPSAxZS03O1xuICB9XG4gIHNvbHZlKGUsIHQpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgY29uc3QgaSA9IHRoaXMuaXRlcmF0aW9ucywgcyA9IHRoaXMudG9sZXJhbmNlICogdGhpcy50b2xlcmFuY2UsIG8gPSB0aGlzLmVxdWF0aW9ucywgciA9IG8ubGVuZ3RoLCBsID0gdC5ib2RpZXMsIGEgPSBsLmxlbmd0aCwgYyA9IGU7XG4gICAgbGV0IGQsIHUsIG0sIGcsIHAsIGY7XG4gICAgaWYgKHIgIT09IDApXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCAhPT0gYTsgeCsrKVxuICAgICAgICBsW3hdLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICBjb25zdCB2ID0gS2QsIF8gPSBKZCwgdyA9ICRkO1xuICAgIHYubGVuZ3RoID0gciwgXy5sZW5ndGggPSByLCB3Lmxlbmd0aCA9IHI7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggIT09IHI7IHgrKykge1xuICAgICAgY29uc3QgTSA9IG9beF07XG4gICAgICB3W3hdID0gMCwgX1t4XSA9IE0uY29tcHV0ZUIoYyksIHZbeF0gPSAxIC8gTS5jb21wdXRlQygpO1xuICAgIH1cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgZm9yIChsZXQgRSA9IDA7IEUgIT09IGE7IEUrKykge1xuICAgICAgICBjb25zdCBSID0gbFtFXSwgeSA9IFIudmxhbWJkYSwgQSA9IFIud2xhbWJkYTtcbiAgICAgICAgeS5zZXQoMCwgMCwgMCksIEEuc2V0KDAsIDAsIDApO1xuICAgICAgfVxuICAgICAgZm9yIChuID0gMDsgbiAhPT0gaTsgbisrKSB7XG4gICAgICAgIGcgPSAwO1xuICAgICAgICBmb3IgKGxldCBFID0gMDsgRSAhPT0gcjsgRSsrKSB7XG4gICAgICAgICAgY29uc3QgUiA9IG9bRV07XG4gICAgICAgICAgZCA9IF9bRV0sIHUgPSB2W0VdLCBmID0gd1tFXSwgcCA9IFIuY29tcHV0ZUdXbGFtYmRhKCksIG0gPSB1ICogKGQgLSBwIC0gUi5lcHMgKiBmKSwgZiArIG0gPCBSLm1pbkZvcmNlID8gbSA9IFIubWluRm9yY2UgLSBmIDogZiArIG0gPiBSLm1heEZvcmNlICYmIChtID0gUi5tYXhGb3JjZSAtIGYpLCB3W0VdICs9IG0sIGcgKz0gbSA+IDAgPyBtIDogLW0sIFIuYWRkVG9XbGFtYmRhKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnICogZyA8IHMpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBFID0gMDsgRSAhPT0gYTsgRSsrKSB7XG4gICAgICAgIGNvbnN0IFIgPSBsW0VdLCB5ID0gUi52ZWxvY2l0eSwgQSA9IFIuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICBSLnZsYW1iZGEudm11bChSLmxpbmVhckZhY3RvciwgUi52bGFtYmRhKSwgeS52YWRkKFIudmxhbWJkYSwgeSksIFIud2xhbWJkYS52bXVsKFIuYW5ndWxhckZhY3RvciwgUi53bGFtYmRhKSwgQS52YWRkKFIud2xhbWJkYSwgQSk7XG4gICAgICB9XG4gICAgICBsZXQgeCA9IG8ubGVuZ3RoO1xuICAgICAgY29uc3QgTSA9IDEgLyBjO1xuICAgICAgZm9yICg7IHgtLTsgKVxuICAgICAgICBvW3hdLm11bHRpcGxpZXIgPSB3W3hdICogTTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbn1cbmNvbnN0ICRkID0gW10sIEtkID0gW10sIEpkID0gW107XG5pZS5TVEFUSUM7XG5jbGFzcyBRZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub2JqZWN0cyA9IFtdLCB0aGlzLnR5cGUgPSBPYmplY3Q7XG4gIH1cbiAgcmVsZWFzZSgpIHtcbiAgICBjb25zdCBlID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCAhPT0gZTsgdCsrKVxuICAgICAgdGhpcy5vYmplY3RzLnB1c2godCA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSB0ID8gdm9pZCAwIDogYXJndW1lbnRzW3RdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0cy5sZW5ndGggPT09IDAgPyB0aGlzLmNvbnN0cnVjdE9iamVjdCgpIDogdGhpcy5vYmplY3RzLnBvcCgpO1xuICB9XG4gIGNvbnN0cnVjdE9iamVjdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCFcIik7XG4gIH1cbiAgcmVzaXplKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vYmplY3RzO1xuICAgIGZvciAoOyB0Lmxlbmd0aCA+IGU7IClcbiAgICAgIHQucG9wKCk7XG4gICAgZm9yICg7IHQubGVuZ3RoIDwgZTsgKVxuICAgICAgdC5wdXNoKHRoaXMuY29uc3RydWN0T2JqZWN0KCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBlZiBleHRlbmRzIFFkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gYjtcbiAgfVxuICBjb25zdHJ1Y3RPYmplY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBiKCk7XG4gIH1cbn1cbmNvbnN0IFVlID0ge1xuICBzcGhlcmVTcGhlcmU6IGxlLnR5cGVzLlNQSEVSRSxcbiAgc3BoZXJlUGxhbmU6IGxlLnR5cGVzLlNQSEVSRSB8IGxlLnR5cGVzLlBMQU5FLFxuICBib3hCb3g6IGxlLnR5cGVzLkJPWCB8IGxlLnR5cGVzLkJPWCxcbiAgc3BoZXJlQm94OiBsZS50eXBlcy5TUEhFUkUgfCBsZS50eXBlcy5CT1gsXG4gIHBsYW5lQm94OiBsZS50eXBlcy5QTEFORSB8IGxlLnR5cGVzLkJPWCxcbiAgY29udmV4Q29udmV4OiBsZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OLFxuICBzcGhlcmVDb252ZXg6IGxlLnR5cGVzLlNQSEVSRSB8IGxlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sXG4gIHBsYW5lQ29udmV4OiBsZS50eXBlcy5QTEFORSB8IGxlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sXG4gIGJveENvbnZleDogbGUudHlwZXMuQk9YIHwgbGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTixcbiAgc3BoZXJlSGVpZ2h0ZmllbGQ6IGxlLnR5cGVzLlNQSEVSRSB8IGxlLnR5cGVzLkhFSUdIVEZJRUxELFxuICBib3hIZWlnaHRmaWVsZDogbGUudHlwZXMuQk9YIHwgbGUudHlwZXMuSEVJR0hURklFTEQsXG4gIGNvbnZleEhlaWdodGZpZWxkOiBsZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OIHwgbGUudHlwZXMuSEVJR0hURklFTEQsXG4gIHNwaGVyZVBhcnRpY2xlOiBsZS50eXBlcy5QQVJUSUNMRSB8IGxlLnR5cGVzLlNQSEVSRSxcbiAgcGxhbmVQYXJ0aWNsZTogbGUudHlwZXMuUExBTkUgfCBsZS50eXBlcy5QQVJUSUNMRSxcbiAgYm94UGFydGljbGU6IGxlLnR5cGVzLkJPWCB8IGxlLnR5cGVzLlBBUlRJQ0xFLFxuICBjb252ZXhQYXJ0aWNsZTogbGUudHlwZXMuUEFSVElDTEUgfCBsZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OLFxuICBjeWxpbmRlckN5bGluZGVyOiBsZS50eXBlcy5DWUxJTkRFUixcbiAgc3BoZXJlQ3lsaW5kZXI6IGxlLnR5cGVzLlNQSEVSRSB8IGxlLnR5cGVzLkNZTElOREVSLFxuICBwbGFuZUN5bGluZGVyOiBsZS50eXBlcy5QTEFORSB8IGxlLnR5cGVzLkNZTElOREVSLFxuICBib3hDeWxpbmRlcjogbGUudHlwZXMuQk9YIHwgbGUudHlwZXMuQ1lMSU5ERVIsXG4gIGNvbnZleEN5bGluZGVyOiBsZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OIHwgbGUudHlwZXMuQ1lMSU5ERVIsXG4gIGhlaWdodGZpZWxkQ3lsaW5kZXI6IGxlLnR5cGVzLkhFSUdIVEZJRUxEIHwgbGUudHlwZXMuQ1lMSU5ERVIsXG4gIHBhcnRpY2xlQ3lsaW5kZXI6IGxlLnR5cGVzLlBBUlRJQ0xFIHwgbGUudHlwZXMuQ1lMSU5ERVIsXG4gIHNwaGVyZVRyaW1lc2g6IGxlLnR5cGVzLlNQSEVSRSB8IGxlLnR5cGVzLlRSSU1FU0gsXG4gIHBsYW5lVHJpbWVzaDogbGUudHlwZXMuUExBTkUgfCBsZS50eXBlcy5UUklNRVNIXG59O1xuY2xhc3MgdGYge1xuICBnZXQgW1VlLnNwaGVyZVNwaGVyZV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJlU3BoZXJlO1xuICB9XG4gIGdldCBbVWUuc3BoZXJlUGxhbmVdKCkge1xuICAgIHJldHVybiB0aGlzLnNwaGVyZVBsYW5lO1xuICB9XG4gIGdldCBbVWUuYm94Qm94XSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3hCb3g7XG4gIH1cbiAgZ2V0IFtVZS5zcGhlcmVCb3hdKCkge1xuICAgIHJldHVybiB0aGlzLnNwaGVyZUJveDtcbiAgfVxuICBnZXQgW1VlLnBsYW5lQm94XSgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGFuZUJveDtcbiAgfVxuICBnZXQgW1VlLmNvbnZleENvbnZleF0oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udmV4Q29udmV4O1xuICB9XG4gIGdldCBbVWUuc3BoZXJlQ29udmV4XSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGhlcmVDb252ZXg7XG4gIH1cbiAgZ2V0IFtVZS5wbGFuZUNvbnZleF0oKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXg7XG4gIH1cbiAgZ2V0IFtVZS5ib3hDb252ZXhdKCkge1xuICAgIHJldHVybiB0aGlzLmJveENvbnZleDtcbiAgfVxuICBnZXQgW1VlLnNwaGVyZUhlaWdodGZpZWxkXSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGhlcmVIZWlnaHRmaWVsZDtcbiAgfVxuICBnZXQgW1VlLmJveEhlaWdodGZpZWxkXSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3hIZWlnaHRmaWVsZDtcbiAgfVxuICBnZXQgW1VlLmNvbnZleEhlaWdodGZpZWxkXSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb252ZXhIZWlnaHRmaWVsZDtcbiAgfVxuICBnZXQgW1VlLnNwaGVyZVBhcnRpY2xlXSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGhlcmVQYXJ0aWNsZTtcbiAgfVxuICBnZXQgW1VlLnBsYW5lUGFydGljbGVdKCkge1xuICAgIHJldHVybiB0aGlzLnBsYW5lUGFydGljbGU7XG4gIH1cbiAgZ2V0IFtVZS5ib3hQYXJ0aWNsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94UGFydGljbGU7XG4gIH1cbiAgZ2V0IFtVZS5jb252ZXhQYXJ0aWNsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udmV4UGFydGljbGU7XG4gIH1cbiAgZ2V0IFtVZS5jeWxpbmRlckN5bGluZGVyXSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXg7XG4gIH1cbiAgZ2V0IFtVZS5zcGhlcmVDeWxpbmRlcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJlQ29udmV4O1xuICB9XG4gIGdldCBbVWUucGxhbmVDeWxpbmRlcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXg7XG4gIH1cbiAgZ2V0IFtVZS5ib3hDeWxpbmRlcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94Q29udmV4O1xuICB9XG4gIGdldCBbVWUuY29udmV4Q3lsaW5kZXJdKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleDtcbiAgfVxuICBnZXQgW1VlLmhlaWdodGZpZWxkQ3lsaW5kZXJdKCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodGZpZWxkQ3lsaW5kZXI7XG4gIH1cbiAgZ2V0IFtVZS5wYXJ0aWNsZUN5bGluZGVyXSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0aWNsZUN5bGluZGVyO1xuICB9XG4gIGdldCBbVWUuc3BoZXJlVHJpbWVzaF0oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJlVHJpbWVzaDtcbiAgfVxuICBnZXQgW1VlLnBsYW5lVHJpbWVzaF0oKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhbmVUcmltZXNoO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmNvbnRhY3RQb2ludFBvb2wgPSBbXSwgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IFtdLCB0aGlzLnJlc3VsdCA9IFtdLCB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gW10sIHRoaXMudjNwb29sID0gbmV3IGVmKCksIHRoaXMud29ybGQgPSBlLCB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSBlLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwsIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSAhMTtcbiAgfVxuICBjcmVhdGVDb250YWN0RXF1YXRpb24oZSwgdCwgbiwgaSwgcywgbykge1xuICAgIGxldCByO1xuICAgIHRoaXMuY29udGFjdFBvaW50UG9vbC5sZW5ndGggPyAociA9IHRoaXMuY29udGFjdFBvaW50UG9vbC5wb3AoKSwgci5iaSA9IGUsIHIuYmogPSB0KSA6IHIgPSBuZXcgQmQoZSwgdCksIHIuZW5hYmxlZCA9IGUuY29sbGlzaW9uUmVzcG9uc2UgJiYgdC5jb2xsaXNpb25SZXNwb25zZSAmJiBuLmNvbGxpc2lvblJlc3BvbnNlICYmIGkuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgY29uc3QgbCA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcbiAgICByLnJlc3RpdHV0aW9uID0gbC5yZXN0aXR1dGlvbiwgci5zZXRTcG9va1BhcmFtcyhsLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcywgbC5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uLCB0aGlzLndvcmxkLmR0KTtcbiAgICBjb25zdCBhID0gbi5tYXRlcmlhbCB8fCBlLm1hdGVyaWFsLCBjID0gaS5tYXRlcmlhbCB8fCB0Lm1hdGVyaWFsO1xuICAgIHJldHVybiBhICYmIGMgJiYgYS5yZXN0aXR1dGlvbiA+PSAwICYmIGMucmVzdGl0dXRpb24gPj0gMCAmJiAoci5yZXN0aXR1dGlvbiA9IGEucmVzdGl0dXRpb24gKiBjLnJlc3RpdHV0aW9uKSwgci5zaSA9IHMgfHwgbiwgci5zaiA9IG8gfHwgaSwgcjtcbiAgfVxuICBjcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KGUsIHQpIHtcbiAgICBjb25zdCBuID0gZS5iaSwgaSA9IGUuYmosIHMgPSBlLnNpLCBvID0gZS5zaiwgciA9IHRoaXMud29ybGQsIGwgPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XG4gICAgbGV0IGEgPSBsLmZyaWN0aW9uO1xuICAgIGNvbnN0IGMgPSBzLm1hdGVyaWFsIHx8IG4ubWF0ZXJpYWwsIGQgPSBvLm1hdGVyaWFsIHx8IGkubWF0ZXJpYWw7XG4gICAgaWYgKGMgJiYgZCAmJiBjLmZyaWN0aW9uID49IDAgJiYgZC5mcmljdGlvbiA+PSAwICYmIChhID0gYy5mcmljdGlvbiAqIGQuZnJpY3Rpb24pLCBhID4gMCkge1xuICAgICAgY29uc3QgdSA9IGEgKiAoci5mcmljdGlvbkdyYXZpdHkgfHwgci5ncmF2aXR5KS5sZW5ndGgoKTtcbiAgICAgIGxldCBtID0gbi5pbnZNYXNzICsgaS5pbnZNYXNzO1xuICAgICAgbSA+IDAgJiYgKG0gPSAxIC8gbSk7XG4gICAgICBjb25zdCBnID0gdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCwgcCA9IGcubGVuZ3RoID8gZy5wb3AoKSA6IG5ldyBqcihuLCBpLCB1ICogbSksIGYgPSBnLmxlbmd0aCA/IGcucG9wKCkgOiBuZXcganIobiwgaSwgdSAqIG0pO1xuICAgICAgcmV0dXJuIHAuYmkgPSBmLmJpID0gbiwgcC5iaiA9IGYuYmogPSBpLCBwLm1pbkZvcmNlID0gZi5taW5Gb3JjZSA9IC11ICogbSwgcC5tYXhGb3JjZSA9IGYubWF4Rm9yY2UgPSB1ICogbSwgcC5yaS5jb3B5KGUucmkpLCBwLnJqLmNvcHkoZS5yaiksIGYucmkuY29weShlLnJpKSwgZi5yai5jb3B5KGUucmopLCBlLm5pLnRhbmdlbnRzKHAudCwgZi50KSwgcC5zZXRTcG9va1BhcmFtcyhsLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGwuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHIuZHQpLCBmLnNldFNwb29rUGFyYW1zKGwuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgbC5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiwgci5kdCksIHAuZW5hYmxlZCA9IGYuZW5hYmxlZCA9IGUuZW5hYmxlZCwgdC5wdXNoKHAsIGYpLCAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UoZSkge1xuICAgIGxldCB0ID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgaWYgKCF0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QodCwgdGhpcy5mcmljdGlvblJlc3VsdCkgfHwgZSA9PT0gMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdLCBpID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgIG1uLnNldFplcm8oKSwgcW4uc2V0WmVybygpLCBYbi5zZXRaZXJvKCk7XG4gICAgY29uc3QgcyA9IHQuYmk7XG4gICAgdC5iajtcbiAgICBmb3IgKGxldCByID0gMDsgciAhPT0gZTsgcisrKVxuICAgICAgdCA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDEgLSByXSwgdC5iaSAhPT0gcyA/IChtbi52YWRkKHQubmksIG1uKSwgcW4udmFkZCh0LnJpLCBxbiksIFhuLnZhZGQodC5yaiwgWG4pKSA6IChtbi52c3ViKHQubmksIG1uKSwgcW4udmFkZCh0LnJqLCBxbiksIFhuLnZhZGQodC5yaSwgWG4pKTtcbiAgICBjb25zdCBvID0gMSAvIGU7XG4gICAgcW4uc2NhbGUobywgbi5yaSksIFhuLnNjYWxlKG8sIG4ucmopLCBpLnJpLmNvcHkobi5yaSksIGkucmouY29weShuLnJqKSwgbW4ubm9ybWFsaXplKCksIG1uLnRhbmdlbnRzKG4udCwgaS50KTtcbiAgfVxuICBnZXRDb250YWN0cyhlLCB0LCBuLCBpLCBzLCBvLCByKSB7XG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gcywgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IHIsIHRoaXMucmVzdWx0ID0gaSwgdGhpcy5mcmljdGlvblJlc3VsdCA9IG87XG4gICAgY29uc3QgbCA9IHJmLCBhID0gb2YsIGMgPSBuZiwgZCA9IHNmO1xuICAgIGZvciAobGV0IHUgPSAwLCBtID0gZS5sZW5ndGg7IHUgIT09IG07IHUrKykge1xuICAgICAgY29uc3QgZyA9IGVbdV0sIHAgPSB0W3VdO1xuICAgICAgbGV0IGYgPSBudWxsO1xuICAgICAgZy5tYXRlcmlhbCAmJiBwLm1hdGVyaWFsICYmIChmID0gbi5nZXRDb250YWN0TWF0ZXJpYWwoZy5tYXRlcmlhbCwgcC5tYXRlcmlhbCkgfHwgbnVsbCk7XG4gICAgICBjb25zdCB2ID0gZy50eXBlICYgaWUuS0lORU1BVElDICYmIHAudHlwZSAmIGllLlNUQVRJQyB8fCBnLnR5cGUgJiBpZS5TVEFUSUMgJiYgcC50eXBlICYgaWUuS0lORU1BVElDIHx8IGcudHlwZSAmIGllLktJTkVNQVRJQyAmJiBwLnR5cGUgJiBpZS5LSU5FTUFUSUM7XG4gICAgICBmb3IgKGxldCBfID0gMDsgXyA8IGcuc2hhcGVzLmxlbmd0aDsgXysrKSB7XG4gICAgICAgIGcucXVhdGVybmlvbi5tdWx0KGcuc2hhcGVPcmllbnRhdGlvbnNbX10sIGwpLCBnLnF1YXRlcm5pb24udm11bHQoZy5zaGFwZU9mZnNldHNbX10sIGMpLCBjLnZhZGQoZy5wb3NpdGlvbiwgYyk7XG4gICAgICAgIGNvbnN0IHcgPSBnLnNoYXBlc1tfXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBwLnNoYXBlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIHAucXVhdGVybmlvbi5tdWx0KHAuc2hhcGVPcmllbnRhdGlvbnNbeF0sIGEpLCBwLnF1YXRlcm5pb24udm11bHQocC5zaGFwZU9mZnNldHNbeF0sIGQpLCBkLnZhZGQocC5wb3NpdGlvbiwgZCk7XG4gICAgICAgICAgY29uc3QgTSA9IHAuc2hhcGVzW3hdO1xuICAgICAgICAgIGlmICghKHcuY29sbGlzaW9uRmlsdGVyTWFzayAmIE0uY29sbGlzaW9uRmlsdGVyR3JvdXAgJiYgTS5jb2xsaXNpb25GaWx0ZXJNYXNrICYgdy5jb2xsaXNpb25GaWx0ZXJHcm91cCkgfHwgYy5kaXN0YW5jZVRvKGQpID4gdy5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIE0uYm91bmRpbmdTcGhlcmVSYWRpdXMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBsZXQgRSA9IG51bGw7XG4gICAgICAgICAgdy5tYXRlcmlhbCAmJiBNLm1hdGVyaWFsICYmIChFID0gbi5nZXRDb250YWN0TWF0ZXJpYWwody5tYXRlcmlhbCwgTS5tYXRlcmlhbCkgfHwgbnVsbCksIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IEUgfHwgZiB8fCBuLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgICAgICAgY29uc3QgUiA9IHcudHlwZSB8IE0udHlwZSwgeSA9IHRoaXNbUl07XG4gICAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICAgIGxldCBBID0gITE7XG4gICAgICAgICAgICB3LnR5cGUgPCBNLnR5cGUgPyBBID0geS5jYWxsKHRoaXMsIHcsIE0sIGMsIGQsIGwsIGEsIGcsIHAsIHcsIE0sIHYpIDogQSA9IHkuY2FsbCh0aGlzLCBNLCB3LCBkLCBjLCBhLCBsLCBwLCBnLCB3LCBNLCB2KSwgQSAmJiB2ICYmIChuLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQody5pZCwgTS5pZCksIG4uYm9keU92ZXJsYXBLZWVwZXIuc2V0KGcuaWQsIHAuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3BoZXJlU3BoZXJlKGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEsIGMsIGQpIHtcbiAgICBpZiAoZClcbiAgICAgIHJldHVybiBuLmRpc3RhbmNlU3F1YXJlZChpKSA8IChlLnJhZGl1cyArIHQucmFkaXVzKSAqKiAyO1xuICAgIGNvbnN0IHUgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLCBsLCBlLCB0LCBhLCBjKTtcbiAgICBpLnZzdWIobiwgdS5uaSksIHUubmkubm9ybWFsaXplKCksIHUucmkuY29weSh1Lm5pKSwgdS5yai5jb3B5KHUubmkpLCB1LnJpLnNjYWxlKGUucmFkaXVzLCB1LnJpKSwgdS5yai5zY2FsZSgtdC5yYWRpdXMsIHUucmopLCB1LnJpLnZhZGQobiwgdS5yaSksIHUucmkudnN1YihyLnBvc2l0aW9uLCB1LnJpKSwgdS5yai52YWRkKGksIHUucmopLCB1LnJqLnZzdWIobC5wb3NpdGlvbiwgdS5yaiksIHRoaXMucmVzdWx0LnB1c2godSksIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdCh1LCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgfVxuICBzcGhlcmVQbGFuZShlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjLCBkKSB7XG4gICAgY29uc3QgdSA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsIGwsIGUsIHQsIGEsIGMpO1xuICAgIGlmICh1Lm5pLnNldCgwLCAwLCAxKSwgby52bXVsdCh1Lm5pLCB1Lm5pKSwgdS5uaS5uZWdhdGUodS5uaSksIHUubmkubm9ybWFsaXplKCksIHUubmkuc2NhbGUoZS5yYWRpdXMsIHUucmkpLCBuLnZzdWIoaSwgR2kpLCB1Lm5pLnNjYWxlKHUubmkuZG90KEdpKSwgWXIpLCBHaS52c3ViKFlyLCB1LnJqKSwgLUdpLmRvdCh1Lm5pKSA8PSBlLnJhZGl1cykge1xuICAgICAgaWYgKGQpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGNvbnN0IG0gPSB1LnJpLCBnID0gdS5yajtcbiAgICAgIG0udmFkZChuLCBtKSwgbS52c3ViKHIucG9zaXRpb24sIG0pLCBnLnZhZGQoaSwgZyksIGcudnN1YihsLnBvc2l0aW9uLCBnKSwgdGhpcy5yZXN1bHQucHVzaCh1KSwgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHUsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgIH1cbiAgfVxuICBib3hCb3goZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIHJldHVybiBlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IGUubWF0ZXJpYWwsIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gdC5tYXRlcmlhbCwgZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBlLmNvbGxpc2lvblJlc3BvbnNlLCB0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHQuY29sbGlzaW9uUmVzcG9uc2UsIHRoaXMuY29udmV4Q29udmV4KGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCB0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgbiwgaSwgcywgbywgciwgbCwgZSwgdCwgZCk7XG4gIH1cbiAgc3BoZXJlQm94KGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEsIGMsIGQpIHtcbiAgICBjb25zdCB1ID0gdGhpcy52M3Bvb2wsIG0gPSBEZjtcbiAgICBuLnZzdWIoaSwga2kpLCB0LmdldFNpZGVOb3JtYWxzKG0sIG8pO1xuICAgIGNvbnN0IGcgPSBlLnJhZGl1cztcbiAgICBsZXQgcCA9ICExO1xuICAgIGNvbnN0IGYgPSBJZiwgdiA9IHpmLCBfID0gQmY7XG4gICAgbGV0IHcgPSBudWxsLCB4ID0gMCwgTSA9IDAsIEUgPSAwLCBSID0gbnVsbDtcbiAgICBmb3IgKGxldCBEID0gMCwgcSA9IG0ubGVuZ3RoOyBEICE9PSBxICYmIHAgPT09ICExOyBEKyspIHtcbiAgICAgIGNvbnN0IGsgPSBMZjtcbiAgICAgIGsuY29weShtW0RdKTtcbiAgICAgIGNvbnN0IE4gPSBrLmxlbmd0aCgpO1xuICAgICAgay5ub3JtYWxpemUoKTtcbiAgICAgIGNvbnN0IEggPSBraS5kb3Qoayk7XG4gICAgICBpZiAoSCA8IE4gKyBnICYmIEggPiAwKSB7XG4gICAgICAgIGNvbnN0IEogPSBSZiwgViA9IEZmO1xuICAgICAgICBKLmNvcHkobVsoRCArIDEpICUgM10pLCBWLmNvcHkobVsoRCArIDIpICUgM10pO1xuICAgICAgICBjb25zdCBlZSA9IEoubGVuZ3RoKCksIGNlID0gVi5sZW5ndGgoKTtcbiAgICAgICAgSi5ub3JtYWxpemUoKSwgVi5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgZ2UgPSBraS5kb3QoSiksICQgPSBraS5kb3QoVik7XG4gICAgICAgIGlmIChnZSA8IGVlICYmIGdlID4gLWVlICYmICQgPCBjZSAmJiAkID4gLWNlKSB7XG4gICAgICAgICAgY29uc3QgRGUgPSBNYXRoLmFicyhIIC0gTiAtIGcpO1xuICAgICAgICAgIGlmICgoUiA9PT0gbnVsbCB8fCBEZSA8IFIpICYmIChSID0gRGUsIE0gPSBnZSwgRSA9ICQsIHcgPSBOLCBmLmNvcHkoayksIHYuY29weShKKSwgXy5jb3B5KFYpLCB4KyssIGQpKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh4KSB7XG4gICAgICBwID0gITA7XG4gICAgICBjb25zdCBEID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ociwgbCwgZSwgdCwgYSwgYyk7XG4gICAgICBmLnNjYWxlKC1nLCBELnJpKSwgRC5uaS5jb3B5KGYpLCBELm5pLm5lZ2F0ZShELm5pKSwgZi5zY2FsZSh3LCBmKSwgdi5zY2FsZShNLCB2KSwgZi52YWRkKHYsIGYpLCBfLnNjYWxlKEUsIF8pLCBmLnZhZGQoXywgRC5yaiksIEQucmkudmFkZChuLCBELnJpKSwgRC5yaS52c3ViKHIucG9zaXRpb24sIEQucmkpLCBELnJqLnZhZGQoaSwgRC5yaiksIEQucmoudnN1YihsLnBvc2l0aW9uLCBELnJqKSwgdGhpcy5yZXN1bHQucHVzaChEKSwgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KEQsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgIH1cbiAgICBsZXQgeSA9IHUuZ2V0KCk7XG4gICAgY29uc3QgQSA9IFBmO1xuICAgIGZvciAobGV0IEQgPSAwOyBEICE9PSAyICYmICFwOyBEKyspXG4gICAgICBmb3IgKGxldCBxID0gMDsgcSAhPT0gMiAmJiAhcDsgcSsrKVxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayAhPT0gMiAmJiAhcDsgaysrKVxuICAgICAgICAgIGlmICh5LnNldCgwLCAwLCAwKSwgRCA/IHkudmFkZChtWzBdLCB5KSA6IHkudnN1YihtWzBdLCB5KSwgcSA/IHkudmFkZChtWzFdLCB5KSA6IHkudnN1YihtWzFdLCB5KSwgayA/IHkudmFkZChtWzJdLCB5KSA6IHkudnN1YihtWzJdLCB5KSwgaS52YWRkKHksIEEpLCBBLnZzdWIobiwgQSksIEEubGVuZ3RoU3F1YXJlZCgpIDwgZyAqIGcpIHtcbiAgICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICBwID0gITA7XG4gICAgICAgICAgICBjb25zdCBOID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ociwgbCwgZSwgdCwgYSwgYyk7XG4gICAgICAgICAgICBOLnJpLmNvcHkoQSksIE4ucmkubm9ybWFsaXplKCksIE4ubmkuY29weShOLnJpKSwgTi5yaS5zY2FsZShnLCBOLnJpKSwgTi5yai5jb3B5KHkpLCBOLnJpLnZhZGQobiwgTi5yaSksIE4ucmkudnN1YihyLnBvc2l0aW9uLCBOLnJpKSwgTi5yai52YWRkKGksIE4ucmopLCBOLnJqLnZzdWIobC5wb3NpdGlvbiwgTi5yaiksIHRoaXMucmVzdWx0LnB1c2goTiksIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChOLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgdS5yZWxlYXNlKHkpLCB5ID0gbnVsbDtcbiAgICBjb25zdCBGID0gdS5nZXQoKSwgUCA9IHUuZ2V0KCksIEcgPSB1LmdldCgpLCB6ID0gdS5nZXQoKSwgTCA9IHUuZ2V0KCksIEkgPSBtLmxlbmd0aDtcbiAgICBmb3IgKGxldCBEID0gMDsgRCAhPT0gSSAmJiAhcDsgRCsrKVxuICAgICAgZm9yIChsZXQgcSA9IDA7IHEgIT09IEkgJiYgIXA7IHErKylcbiAgICAgICAgaWYgKEQgJSAzICE9PSBxICUgMykge1xuICAgICAgICAgIG1bcV0uY3Jvc3MobVtEXSwgRiksIEYubm9ybWFsaXplKCksIG1bRF0udmFkZChtW3FdLCBQKSwgRy5jb3B5KG4pLCBHLnZzdWIoUCwgRyksIEcudnN1YihpLCBHKTtcbiAgICAgICAgICBjb25zdCBrID0gRy5kb3QoRik7XG4gICAgICAgICAgRi5zY2FsZShrLCB6KTtcbiAgICAgICAgICBsZXQgTiA9IDA7XG4gICAgICAgICAgZm9yICg7IE4gPT09IEQgJSAzIHx8IE4gPT09IHEgJSAzOyApXG4gICAgICAgICAgICBOKys7XG4gICAgICAgICAgTC5jb3B5KG4pLCBMLnZzdWIoeiwgTCksIEwudnN1YihQLCBMKSwgTC52c3ViKGksIEwpO1xuICAgICAgICAgIGNvbnN0IEggPSBNYXRoLmFicyhrKSwgSiA9IEwubGVuZ3RoKCk7XG4gICAgICAgICAgaWYgKEggPCBtW05dLmxlbmd0aCgpICYmIEogPCBnKSB7XG4gICAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgcCA9ICEwO1xuICAgICAgICAgICAgY29uc3QgViA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsIGwsIGUsIHQsIGEsIGMpO1xuICAgICAgICAgICAgUC52YWRkKHosIFYucmopLCBWLnJqLmNvcHkoVi5yaiksIEwubmVnYXRlKFYubmkpLCBWLm5pLm5vcm1hbGl6ZSgpLCBWLnJpLmNvcHkoVi5yaiksIFYucmkudmFkZChpLCBWLnJpKSwgVi5yaS52c3ViKG4sIFYucmkpLCBWLnJpLm5vcm1hbGl6ZSgpLCBWLnJpLnNjYWxlKGcsIFYucmkpLCBWLnJpLnZhZGQobiwgVi5yaSksIFYucmkudnN1YihyLnBvc2l0aW9uLCBWLnJpKSwgVi5yai52YWRkKGksIFYucmopLCBWLnJqLnZzdWIobC5wb3NpdGlvbiwgVi5yaiksIHRoaXMucmVzdWx0LnB1c2goViksIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChWLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB1LnJlbGVhc2UoRiwgUCwgRywgeiwgTCk7XG4gIH1cbiAgcGxhbmVCb3goZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIHJldHVybiB0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHQubWF0ZXJpYWwsIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gdC5jb2xsaXNpb25SZXNwb25zZSwgdC5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uaWQgPSB0LmlkLCB0aGlzLnBsYW5lQ29udmV4KGUsIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBuLCBpLCBzLCBvLCByLCBsLCBlLCB0LCBkKTtcbiAgfVxuICBjb252ZXhDb252ZXgoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCwgdSwgbSkge1xuICAgIGNvbnN0IGcgPSBLZjtcbiAgICBpZiAoIShuLmRpc3RhbmNlVG8oaSkgPiBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgdC5ib3VuZGluZ1NwaGVyZVJhZGl1cykgJiYgZS5maW5kU2VwYXJhdGluZ0F4aXModCwgbiwgcywgaSwgbywgZywgdSwgbSkpIHtcbiAgICAgIGNvbnN0IHAgPSBbXSwgZiA9IEpmO1xuICAgICAgZS5jbGlwQWdhaW5zdEh1bGwobiwgcywgdCwgaSwgbywgZywgLTEwMCwgMTAwLCBwKTtcbiAgICAgIGxldCB2ID0gMDtcbiAgICAgIGZvciAobGV0IF8gPSAwOyBfICE9PSBwLmxlbmd0aDsgXysrKSB7XG4gICAgICAgIGlmIChkKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsIGwsIGUsIHQsIGEsIGMpLCB4ID0gdy5yaSwgTSA9IHcucmo7XG4gICAgICAgIGcubmVnYXRlKHcubmkpLCBwW19dLm5vcm1hbC5uZWdhdGUoZiksIGYuc2NhbGUocFtfXS5kZXB0aCwgZiksIHBbX10ucG9pbnQudmFkZChmLCB4KSwgTS5jb3B5KHBbX10ucG9pbnQpLCB4LnZzdWIobiwgeCksIE0udnN1YihpLCBNKSwgeC52YWRkKG4sIHgpLCB4LnZzdWIoci5wb3NpdGlvbiwgeCksIE0udmFkZChpLCBNKSwgTS52c3ViKGwucG9zaXRpb24sIE0pLCB0aGlzLnJlc3VsdC5wdXNoKHcpLCB2KyssIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gfHwgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHcsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiB2ICYmIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSh2KTtcbiAgICB9XG4gIH1cbiAgc3BoZXJlQ29udmV4KGUsIHQsIG4sIGksIHMsIG8sIHIsIGwsIGEsIGMsIGQpIHtcbiAgICBjb25zdCB1ID0gdGhpcy52M3Bvb2w7XG4gICAgbi52c3ViKGksIE5mKTtcbiAgICBjb25zdCBtID0gdC5mYWNlTm9ybWFscywgZyA9IHQuZmFjZXMsIHAgPSB0LnZlcnRpY2VzLCBmID0gZS5yYWRpdXM7XG4gICAgbGV0IHYgPSAhMTtcbiAgICBmb3IgKGxldCBfID0gMDsgXyAhPT0gcC5sZW5ndGg7IF8rKykge1xuICAgICAgY29uc3QgdyA9IHBbX10sIHggPSBrZjtcbiAgICAgIG8udm11bHQodywgeCksIGkudmFkZCh4LCB4KTtcbiAgICAgIGNvbnN0IE0gPSBHZjtcbiAgICAgIGlmICh4LnZzdWIobiwgTSksIE0ubGVuZ3RoU3F1YXJlZCgpIDwgZiAqIGYpIHtcbiAgICAgICAgaWYgKGQpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB2ID0gITA7XG4gICAgICAgIGNvbnN0IEUgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLCBsLCBlLCB0LCBhLCBjKTtcbiAgICAgICAgRS5yaS5jb3B5KE0pLCBFLnJpLm5vcm1hbGl6ZSgpLCBFLm5pLmNvcHkoRS5yaSksIEUucmkuc2NhbGUoZiwgRS5yaSksIHgudnN1YihpLCBFLnJqKSwgRS5yaS52YWRkKG4sIEUucmkpLCBFLnJpLnZzdWIoci5wb3NpdGlvbiwgRS5yaSksIEUucmoudmFkZChpLCBFLnJqKSwgRS5yai52c3ViKGwucG9zaXRpb24sIEUucmopLCB0aGlzLnJlc3VsdC5wdXNoKEUpLCB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoRSwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgXyA9IDAsIHcgPSBnLmxlbmd0aDsgXyAhPT0gdyAmJiB2ID09PSAhMTsgXysrKSB7XG4gICAgICBjb25zdCB4ID0gbVtfXSwgTSA9IGdbX10sIEUgPSBXZjtcbiAgICAgIG8udm11bHQoeCwgRSk7XG4gICAgICBjb25zdCBSID0gVmY7XG4gICAgICBvLnZtdWx0KHBbTVswXV0sIFIpLCBSLnZhZGQoaSwgUik7XG4gICAgICBjb25zdCB5ID0gSGY7XG4gICAgICBFLnNjYWxlKC1mLCB5KSwgbi52YWRkKHksIHkpO1xuICAgICAgY29uc3QgQSA9IHFmO1xuICAgICAgeS52c3ViKFIsIEEpO1xuICAgICAgY29uc3QgRiA9IEEuZG90KEUpLCBQID0gWGY7XG4gICAgICBpZiAobi52c3ViKFIsIFApLCBGIDwgMCAmJiBQLmRvdChFKSA+IDApIHtcbiAgICAgICAgY29uc3QgRyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB6ID0gMCwgTCA9IE0ubGVuZ3RoOyB6ICE9PSBMOyB6KyspIHtcbiAgICAgICAgICBjb25zdCBJID0gdS5nZXQoKTtcbiAgICAgICAgICBvLnZtdWx0KHBbTVt6XV0sIEkpLCBpLnZhZGQoSSwgSSksIEcucHVzaChJKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ2YoRywgRSwgbikpIHtcbiAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB2ID0gITA7XG4gICAgICAgICAgY29uc3QgeiA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsIGwsIGUsIHQsIGEsIGMpO1xuICAgICAgICAgIEUuc2NhbGUoLWYsIHoucmkpLCBFLm5lZ2F0ZSh6Lm5pKTtcbiAgICAgICAgICBjb25zdCBMID0gdS5nZXQoKTtcbiAgICAgICAgICBFLnNjYWxlKC1GLCBMKTtcbiAgICAgICAgICBjb25zdCBJID0gdS5nZXQoKTtcbiAgICAgICAgICBFLnNjYWxlKC1mLCBJKSwgbi52c3ViKGksIHoucmopLCB6LnJqLnZhZGQoSSwgei5yaiksIHoucmoudmFkZChMLCB6LnJqKSwgei5yai52YWRkKGksIHoucmopLCB6LnJqLnZzdWIobC5wb3NpdGlvbiwgei5yaiksIHoucmkudmFkZChuLCB6LnJpKSwgei5yaS52c3ViKHIucG9zaXRpb24sIHoucmkpLCB1LnJlbGVhc2UoTCksIHUucmVsZWFzZShJKSwgdGhpcy5yZXN1bHQucHVzaCh6KSwgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHosIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgIGZvciAobGV0IEQgPSAwLCBxID0gRy5sZW5ndGg7IEQgIT09IHE7IEQrKylcbiAgICAgICAgICAgIHUucmVsZWFzZShHW0RdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGZvciAobGV0IHogPSAwOyB6ICE9PSBNLmxlbmd0aDsgeisrKSB7XG4gICAgICAgICAgICBjb25zdCBMID0gdS5nZXQoKSwgSSA9IHUuZ2V0KCk7XG4gICAgICAgICAgICBvLnZtdWx0KHBbTVsoeiArIDEpICUgTS5sZW5ndGhdXSwgTCksIG8udm11bHQocFtNWyh6ICsgMikgJSBNLmxlbmd0aF1dLCBJKSwgaS52YWRkKEwsIEwpLCBpLnZhZGQoSSwgSSk7XG4gICAgICAgICAgICBjb25zdCBEID0gT2Y7XG4gICAgICAgICAgICBJLnZzdWIoTCwgRCk7XG4gICAgICAgICAgICBjb25zdCBxID0gVWY7XG4gICAgICAgICAgICBELnVuaXQocSk7XG4gICAgICAgICAgICBjb25zdCBrID0gdS5nZXQoKSwgTiA9IHUuZ2V0KCk7XG4gICAgICAgICAgICBuLnZzdWIoTCwgTik7XG4gICAgICAgICAgICBjb25zdCBIID0gTi5kb3QocSk7XG4gICAgICAgICAgICBxLnNjYWxlKEgsIGspLCBrLnZhZGQoTCwgayk7XG4gICAgICAgICAgICBjb25zdCBKID0gdS5nZXQoKTtcbiAgICAgICAgICAgIGlmIChrLnZzdWIobiwgSiksIEggPiAwICYmIEggKiBIIDwgRC5sZW5ndGhTcXVhcmVkKCkgJiYgSi5sZW5ndGhTcXVhcmVkKCkgPCBmICogZikge1xuICAgICAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIGNvbnN0IFYgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLCBsLCBlLCB0LCBhLCBjKTtcbiAgICAgICAgICAgICAgay52c3ViKGksIFYucmopLCBrLnZzdWIobiwgVi5uaSksIFYubmkubm9ybWFsaXplKCksIFYubmkuc2NhbGUoZiwgVi5yaSksIFYucmoudmFkZChpLCBWLnJqKSwgVi5yai52c3ViKGwucG9zaXRpb24sIFYucmopLCBWLnJpLnZhZGQobiwgVi5yaSksIFYucmkudnN1YihyLnBvc2l0aW9uLCBWLnJpKSwgdGhpcy5yZXN1bHQucHVzaChWKSwgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KFYsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBlZSA9IDAsIGNlID0gRy5sZW5ndGg7IGVlICE9PSBjZTsgZWUrKylcbiAgICAgICAgICAgICAgICB1LnJlbGVhc2UoR1tlZV0pO1xuICAgICAgICAgICAgICB1LnJlbGVhc2UoTCksIHUucmVsZWFzZShJKSwgdS5yZWxlYXNlKGspLCB1LnJlbGVhc2UoSiksIHUucmVsZWFzZShOKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdS5yZWxlYXNlKEwpLCB1LnJlbGVhc2UoSSksIHUucmVsZWFzZShrKSwgdS5yZWxlYXNlKEopLCB1LnJlbGVhc2UoTik7XG4gICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB6ID0gMCwgTCA9IEcubGVuZ3RoOyB6ICE9PSBMOyB6KyspXG4gICAgICAgICAgdS5yZWxlYXNlKEdbel0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwbGFuZUNvbnZleChlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjLCBkKSB7XG4gICAgY29uc3QgdSA9IGpmLCBtID0gWWY7XG4gICAgbS5zZXQoMCwgMCwgMSksIHMudm11bHQobSwgbSk7XG4gICAgbGV0IGcgPSAwO1xuICAgIGNvbnN0IHAgPSBaZjtcbiAgICBmb3IgKGxldCBmID0gMDsgZiAhPT0gdC52ZXJ0aWNlcy5sZW5ndGg7IGYrKylcbiAgICAgIGlmICh1LmNvcHkodC52ZXJ0aWNlc1tmXSksIG8udm11bHQodSwgdSksIGkudmFkZCh1LCB1KSwgdS52c3ViKG4sIHApLCBtLmRvdChwKSA8PSAwKSB7XG4gICAgICAgIGlmIChkKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY29uc3QgXyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsIGwsIGUsIHQsIGEsIGMpLCB3ID0gJGY7XG4gICAgICAgIG0uc2NhbGUobS5kb3QocCksIHcpLCB1LnZzdWIodywgdyksIHcudnN1YihuLCBfLnJpKSwgXy5uaS5jb3B5KG0pLCB1LnZzdWIoaSwgXy5yaiksIF8ucmkudmFkZChuLCBfLnJpKSwgXy5yaS52c3ViKHIucG9zaXRpb24sIF8ucmkpLCBfLnJqLnZhZGQoaSwgXy5yaiksIF8ucmoudnN1YihsLnBvc2l0aW9uLCBfLnJqKSwgdGhpcy5yZXN1bHQucHVzaChfKSwgZysrLCB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uIHx8IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChfLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgIH1cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIGcgJiYgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKGcpO1xuICB9XG4gIGJveENvbnZleChlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjLCBkKSB7XG4gICAgcmV0dXJuIGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gZS5tYXRlcmlhbCwgZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBlLmNvbGxpc2lvblJlc3BvbnNlLCB0aGlzLmNvbnZleENvbnZleChlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgdCwgbiwgaSwgcywgbywgciwgbCwgZSwgdCwgZCk7XG4gIH1cbiAgc3BoZXJlSGVpZ2h0ZmllbGQoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIGNvbnN0IHUgPSB0LmRhdGEsIG0gPSBlLnJhZGl1cywgZyA9IHQuZWxlbWVudFNpemUsIHAgPSBocCwgZiA9IGNwO1xuICAgIFBlLnBvaW50VG9Mb2NhbEZyYW1lKGksIG8sIG4sIGYpO1xuICAgIGxldCB2ID0gTWF0aC5mbG9vcigoZi54IC0gbSkgLyBnKSAtIDEsIF8gPSBNYXRoLmNlaWwoKGYueCArIG0pIC8gZykgKyAxLCB3ID0gTWF0aC5mbG9vcigoZi55IC0gbSkgLyBnKSAtIDEsIHggPSBNYXRoLmNlaWwoKGYueSArIG0pIC8gZykgKyAxO1xuICAgIGlmIChfIDwgMCB8fCB4IDwgMCB8fCB2ID4gdS5sZW5ndGggfHwgdyA+IHVbMF0ubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIHYgPCAwICYmICh2ID0gMCksIF8gPCAwICYmIChfID0gMCksIHcgPCAwICYmICh3ID0gMCksIHggPCAwICYmICh4ID0gMCksIHYgPj0gdS5sZW5ndGggJiYgKHYgPSB1Lmxlbmd0aCAtIDEpLCBfID49IHUubGVuZ3RoICYmIChfID0gdS5sZW5ndGggLSAxKSwgeCA+PSB1WzBdLmxlbmd0aCAmJiAoeCA9IHVbMF0ubGVuZ3RoIC0gMSksIHcgPj0gdVswXS5sZW5ndGggJiYgKHcgPSB1WzBdLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IE0gPSBbXTtcbiAgICB0LmdldFJlY3RNaW5NYXgodiwgdywgXywgeCwgTSk7XG4gICAgY29uc3QgRSA9IE1bMF0sIFIgPSBNWzFdO1xuICAgIGlmIChmLnogLSBtID4gUiB8fCBmLnogKyBtIDwgRSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB5ID0gdGhpcy5yZXN1bHQ7XG4gICAgZm9yIChsZXQgQSA9IHY7IEEgPCBfOyBBKyspXG4gICAgICBmb3IgKGxldCBGID0gdzsgRiA8IHg7IEYrKykge1xuICAgICAgICBjb25zdCBQID0geS5sZW5ndGg7XG4gICAgICAgIGxldCBHID0gITE7XG4gICAgICAgIGlmICh0LmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKEEsIEYsICExKSwgUGUucG9pbnRUb1dvcmxkRnJhbWUoaSwgbywgdC5waWxsYXJPZmZzZXQsIHApLCBuLmRpc3RhbmNlVG8ocCkgPCB0LnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgJiYgKEcgPSB0aGlzLnNwaGVyZUNvbnZleChlLCB0LnBpbGxhckNvbnZleCwgbiwgcCwgcywgbywgciwgbCwgZSwgdCwgZCkpLCBkICYmIEcgfHwgKHQuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoQSwgRiwgITApLCBQZS5wb2ludFRvV29ybGRGcmFtZShpLCBvLCB0LnBpbGxhck9mZnNldCwgcCksIG4uZGlzdGFuY2VUbyhwKSA8IHQucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyAmJiAoRyA9IHRoaXMuc3BoZXJlQ29udmV4KGUsIHQucGlsbGFyQ29udmV4LCBuLCBwLCBzLCBvLCByLCBsLCBlLCB0LCBkKSksIGQgJiYgRykpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBpZiAoeS5sZW5ndGggLSBQID4gMilcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbiAgYm94SGVpZ2h0ZmllbGQoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIHJldHVybiBlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IGUubWF0ZXJpYWwsIGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gZS5jb2xsaXNpb25SZXNwb25zZSwgdGhpcy5jb252ZXhIZWlnaHRmaWVsZChlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgdCwgbiwgaSwgcywgbywgciwgbCwgZSwgdCwgZCk7XG4gIH1cbiAgY29udmV4SGVpZ2h0ZmllbGQoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIGNvbnN0IHUgPSB0LmRhdGEsIG0gPSB0LmVsZW1lbnRTaXplLCBnID0gZS5ib3VuZGluZ1NwaGVyZVJhZGl1cywgcCA9IGFwLCBmID0gbHAsIHYgPSBvcDtcbiAgICBQZS5wb2ludFRvTG9jYWxGcmFtZShpLCBvLCBuLCB2KTtcbiAgICBsZXQgXyA9IE1hdGguZmxvb3IoKHYueCAtIGcpIC8gbSkgLSAxLCB3ID0gTWF0aC5jZWlsKCh2LnggKyBnKSAvIG0pICsgMSwgeCA9IE1hdGguZmxvb3IoKHYueSAtIGcpIC8gbSkgLSAxLCBNID0gTWF0aC5jZWlsKCh2LnkgKyBnKSAvIG0pICsgMTtcbiAgICBpZiAodyA8IDAgfHwgTSA8IDAgfHwgXyA+IHUubGVuZ3RoIHx8IHggPiB1WzBdLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBfIDwgMCAmJiAoXyA9IDApLCB3IDwgMCAmJiAodyA9IDApLCB4IDwgMCAmJiAoeCA9IDApLCBNIDwgMCAmJiAoTSA9IDApLCBfID49IHUubGVuZ3RoICYmIChfID0gdS5sZW5ndGggLSAxKSwgdyA+PSB1Lmxlbmd0aCAmJiAodyA9IHUubGVuZ3RoIC0gMSksIE0gPj0gdVswXS5sZW5ndGggJiYgKE0gPSB1WzBdLmxlbmd0aCAtIDEpLCB4ID49IHVbMF0ubGVuZ3RoICYmICh4ID0gdVswXS5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBFID0gW107XG4gICAgdC5nZXRSZWN0TWluTWF4KF8sIHgsIHcsIE0sIEUpO1xuICAgIGNvbnN0IFIgPSBFWzBdLCB5ID0gRVsxXTtcbiAgICBpZiAoISh2LnogLSBnID4geSB8fCB2LnogKyBnIDwgUikpXG4gICAgICBmb3IgKGxldCBBID0gXzsgQSA8IHc7IEErKylcbiAgICAgICAgZm9yIChsZXQgRiA9IHg7IEYgPCBNOyBGKyspIHtcbiAgICAgICAgICBsZXQgUCA9ICExO1xuICAgICAgICAgIGlmICh0LmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKEEsIEYsICExKSwgUGUucG9pbnRUb1dvcmxkRnJhbWUoaSwgbywgdC5waWxsYXJPZmZzZXQsIHApLCBuLmRpc3RhbmNlVG8ocCkgPCB0LnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgJiYgKFAgPSB0aGlzLmNvbnZleENvbnZleChlLCB0LnBpbGxhckNvbnZleCwgbiwgcCwgcywgbywgciwgbCwgbnVsbCwgbnVsbCwgZCwgZiwgbnVsbCkpLCBkICYmIFAgfHwgKHQuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoQSwgRiwgITApLCBQZS5wb2ludFRvV29ybGRGcmFtZShpLCBvLCB0LnBpbGxhck9mZnNldCwgcCksIG4uZGlzdGFuY2VUbyhwKSA8IHQucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyAmJiAoUCA9IHRoaXMuY29udmV4Q29udmV4KGUsIHQucGlsbGFyQ29udmV4LCBuLCBwLCBzLCBvLCByLCBsLCBudWxsLCBudWxsLCBkLCBmLCBudWxsKSksIGQgJiYgUCkpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgfVxuICBzcGhlcmVQYXJ0aWNsZShlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjLCBkKSB7XG4gICAgY29uc3QgdSA9IG5wO1xuICAgIGlmICh1LnNldCgwLCAwLCAxKSwgaS52c3ViKG4sIHUpLCB1Lmxlbmd0aFNxdWFyZWQoKSA8PSBlLnJhZGl1cyAqIGUucmFkaXVzKSB7XG4gICAgICBpZiAoZClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgY29uc3QgZyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGwsIHIsIHQsIGUsIGEsIGMpO1xuICAgICAgdS5ub3JtYWxpemUoKSwgZy5yai5jb3B5KHUpLCBnLnJqLnNjYWxlKGUucmFkaXVzLCBnLnJqKSwgZy5uaS5jb3B5KHUpLCBnLm5pLm5lZ2F0ZShnLm5pKSwgZy5yaS5zZXQoMCwgMCwgMCksIHRoaXMucmVzdWx0LnB1c2goZyksIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChnLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgcGxhbmVQYXJ0aWNsZShlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjLCBkKSB7XG4gICAgY29uc3QgdSA9IFFmO1xuICAgIHUuc2V0KDAsIDAsIDEpLCByLnF1YXRlcm5pb24udm11bHQodSwgdSk7XG4gICAgY29uc3QgbSA9IGVwO1xuICAgIGlmIChpLnZzdWIoci5wb3NpdGlvbiwgbSksIHUuZG90KG0pIDw9IDApIHtcbiAgICAgIGlmIChkKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBjb25zdCBwID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24obCwgciwgdCwgZSwgYSwgYyk7XG4gICAgICBwLm5pLmNvcHkodSksIHAubmkubmVnYXRlKHAubmkpLCBwLnJpLnNldCgwLCAwLCAwKTtcbiAgICAgIGNvbnN0IGYgPSB0cDtcbiAgICAgIHUuc2NhbGUodS5kb3QoaSksIGYpLCBpLnZzdWIoZiwgZiksIHAucmouY29weShmKSwgdGhpcy5yZXN1bHQucHVzaChwKSwgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHAsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgIH1cbiAgfVxuICBib3hQYXJ0aWNsZShlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjLCBkKSB7XG4gICAgcmV0dXJuIGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gZS5tYXRlcmlhbCwgZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBlLmNvbGxpc2lvblJlc3BvbnNlLCB0aGlzLmNvbnZleFBhcnRpY2xlKGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBlLCB0LCBkKTtcbiAgfVxuICBjb252ZXhQYXJ0aWNsZShlLCB0LCBuLCBpLCBzLCBvLCByLCBsLCBhLCBjLCBkKSB7XG4gICAgbGV0IHUgPSAtMTtcbiAgICBjb25zdCBtID0gc3AsIGcgPSBycDtcbiAgICBsZXQgcCA9IG51bGw7XG4gICAgY29uc3QgZiA9IGlwO1xuICAgIGlmIChmLmNvcHkoaSksIGYudnN1YihuLCBmKSwgcy5jb25qdWdhdGUoWnIpLCBaci52bXVsdChmLCBmKSwgZS5wb2ludElzSW5zaWRlKGYpKSB7XG4gICAgICBlLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSAmJiBlLmNvbXB1dGVXb3JsZFZlcnRpY2VzKG4sIHMpLCBlLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSAmJiBlLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHMpO1xuICAgICAgZm9yIChsZXQgdiA9IDAsIF8gPSBlLmZhY2VzLmxlbmd0aDsgdiAhPT0gXzsgdisrKSB7XG4gICAgICAgIGNvbnN0IHcgPSBbZS53b3JsZFZlcnRpY2VzW2UuZmFjZXNbdl1bMF1dXSwgeCA9IGUud29ybGRGYWNlTm9ybWFsc1t2XTtcbiAgICAgICAgaS52c3ViKHdbMF0sICRyKTtcbiAgICAgICAgY29uc3QgTSA9IC14LmRvdCgkcik7XG4gICAgICAgIGlmIChwID09PSBudWxsIHx8IE1hdGguYWJzKE0pIDwgTWF0aC5hYnMocCkpIHtcbiAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBwID0gTSwgdSA9IHYsIG0uY29weSh4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHUgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihsLCByLCB0LCBlLCBhLCBjKTtcbiAgICAgICAgbS5zY2FsZShwLCBnKSwgZy52YWRkKGksIGcpLCBnLnZzdWIobiwgZyksIHYucmouY29weShnKSwgbS5uZWdhdGUodi5uaSksIHYucmkuc2V0KDAsIDAsIDApO1xuICAgICAgICBjb25zdCBfID0gdi5yaSwgdyA9IHYucmo7XG4gICAgICAgIF8udmFkZChpLCBfKSwgXy52c3ViKGwucG9zaXRpb24sIF8pLCB3LnZhZGQobiwgdyksIHcudnN1YihyLnBvc2l0aW9uLCB3KSwgdGhpcy5yZXN1bHQucHVzaCh2KSwgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHYsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGNvbnNvbGUud2FybihcIlBvaW50IGZvdW5kIGluc2lkZSBjb252ZXgsIGJ1dCBkaWQgbm90IGZpbmQgcGVuZXRyYXRpbmcgZmFjZSFcIik7XG4gICAgfVxuICB9XG4gIGhlaWdodGZpZWxkQ3lsaW5kZXIoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHQsIGUsIGksIG4sIG8sIHMsIGwsIHIsIGEsIGMsIGQpO1xuICB9XG4gIHBhcnRpY2xlQ3lsaW5kZXIoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIHJldHVybiB0aGlzLmNvbnZleFBhcnRpY2xlKHQsIGUsIGksIG4sIG8sIHMsIGwsIHIsIGEsIGMsIGQpO1xuICB9XG4gIHNwaGVyZVRyaW1lc2goZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIGNvbnN0IHUgPSBwZiwgbSA9IG1mLCBnID0gZ2YsIHAgPSBfZiwgZiA9IHZmLCB2ID0geGYsIF8gPSBNZiwgdyA9IGZmLCB4ID0gdWYsIE0gPSBTZjtcbiAgICBQZS5wb2ludFRvTG9jYWxGcmFtZShpLCBvLCBuLCBmKTtcbiAgICBjb25zdCBFID0gZS5yYWRpdXM7XG4gICAgXy5sb3dlckJvdW5kLnNldChmLnggLSBFLCBmLnkgLSBFLCBmLnogLSBFKSwgXy51cHBlckJvdW5kLnNldChmLnggKyBFLCBmLnkgKyBFLCBmLnogKyBFKSwgdC5nZXRUcmlhbmdsZXNJbkFBQkIoXywgTSk7XG4gICAgY29uc3QgUiA9IGRmLCB5ID0gZS5yYWRpdXMgKiBlLnJhZGl1cztcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IE0ubGVuZ3RoOyB6KyspXG4gICAgICBmb3IgKGxldCBMID0gMDsgTCA8IDM7IEwrKylcbiAgICAgICAgaWYgKHQuZ2V0VmVydGV4KHQuaW5kaWNlc1tNW3pdICogMyArIExdLCBSKSwgUi52c3ViKGYsIHgpLCB4Lmxlbmd0aFNxdWFyZWQoKSA8PSB5KSB7XG4gICAgICAgICAgaWYgKHcuY29weShSKSwgUGUucG9pbnRUb1dvcmxkRnJhbWUoaSwgbywgdywgUiksIFIudnN1YihuLCB4KSwgZClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBsZXQgSSA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsIGwsIGUsIHQsIGEsIGMpO1xuICAgICAgICAgIEkubmkuY29weSh4KSwgSS5uaS5ub3JtYWxpemUoKSwgSS5yaS5jb3B5KEkubmkpLCBJLnJpLnNjYWxlKGUucmFkaXVzLCBJLnJpKSwgSS5yaS52YWRkKG4sIEkucmkpLCBJLnJpLnZzdWIoci5wb3NpdGlvbiwgSS5yaSksIEkucmouY29weShSKSwgSS5yai52c3ViKGwucG9zaXRpb24sIEkucmopLCB0aGlzLnJlc3VsdC5wdXNoKEkpLCB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoSSwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IE0ubGVuZ3RoOyB6KyspXG4gICAgICBmb3IgKGxldCBMID0gMDsgTCA8IDM7IEwrKykge1xuICAgICAgICB0LmdldFZlcnRleCh0LmluZGljZXNbTVt6XSAqIDMgKyBMXSwgdSksIHQuZ2V0VmVydGV4KHQuaW5kaWNlc1tNW3pdICogMyArIChMICsgMSkgJSAzXSwgbSksIG0udnN1Yih1LCBnKSwgZi52c3ViKG0sIHYpO1xuICAgICAgICBjb25zdCBJID0gdi5kb3QoZyk7XG4gICAgICAgIGYudnN1Yih1LCB2KTtcbiAgICAgICAgbGV0IEQgPSB2LmRvdChnKTtcbiAgICAgICAgaWYgKEQgPiAwICYmIEkgPCAwICYmIChmLnZzdWIodSwgdiksIHAuY29weShnKSwgcC5ub3JtYWxpemUoKSwgRCA9IHYuZG90KHApLCBwLnNjYWxlKEQsIHYpLCB2LnZhZGQodSwgdiksIHYuZGlzdGFuY2VUbyhmKSA8IGUucmFkaXVzKSkge1xuICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLCBsLCBlLCB0LCBhLCBjKTtcbiAgICAgICAgICB2LnZzdWIoZiwgay5uaSksIGsubmkubm9ybWFsaXplKCksIGsubmkuc2NhbGUoZS5yYWRpdXMsIGsucmkpLCBrLnJpLnZhZGQobiwgay5yaSksIGsucmkudnN1YihyLnBvc2l0aW9uLCBrLnJpKSwgUGUucG9pbnRUb1dvcmxkRnJhbWUoaSwgbywgdiwgdiksIHYudnN1YihsLnBvc2l0aW9uLCBrLnJqKSwgUGUudmVjdG9yVG9Xb3JsZEZyYW1lKG8sIGsubmksIGsubmkpLCBQZS52ZWN0b3JUb1dvcmxkRnJhbWUobywgay5yaSwgay5yaSksIHRoaXMucmVzdWx0LnB1c2goayksIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChrLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNvbnN0IEEgPSB5ZiwgRiA9IGJmLCBQID0gd2YsIEcgPSBoZjtcbiAgICBmb3IgKGxldCB6ID0gMCwgTCA9IE0ubGVuZ3RoOyB6ICE9PSBMOyB6KyspIHtcbiAgICAgIHQuZ2V0VHJpYW5nbGVWZXJ0aWNlcyhNW3pdLCBBLCBGLCBQKSwgdC5nZXROb3JtYWwoTVt6XSwgRyksIGYudnN1YihBLCB2KTtcbiAgICAgIGxldCBJID0gdi5kb3QoRyk7XG4gICAgICBpZiAoRy5zY2FsZShJLCB2KSwgZi52c3ViKHYsIHYpLCBJID0gdi5kaXN0YW5jZVRvKGYpLCBYZS5wb2ludEluVHJpYW5nbGUodiwgQSwgRiwgUCkgJiYgSSA8IGUucmFkaXVzKSB7XG4gICAgICAgIGlmIChkKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgbGV0IEQgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLCBsLCBlLCB0LCBhLCBjKTtcbiAgICAgICAgdi52c3ViKGYsIEQubmkpLCBELm5pLm5vcm1hbGl6ZSgpLCBELm5pLnNjYWxlKGUucmFkaXVzLCBELnJpKSwgRC5yaS52YWRkKG4sIEQucmkpLCBELnJpLnZzdWIoci5wb3NpdGlvbiwgRC5yaSksIFBlLnBvaW50VG9Xb3JsZEZyYW1lKGksIG8sIHYsIHYpLCB2LnZzdWIobC5wb3NpdGlvbiwgRC5yaiksIFBlLnZlY3RvclRvV29ybGRGcmFtZShvLCBELm5pLCBELm5pKSwgUGUudmVjdG9yVG9Xb3JsZEZyYW1lKG8sIEQucmksIEQucmkpLCB0aGlzLnJlc3VsdC5wdXNoKEQpLCB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoRCwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIE0ubGVuZ3RoID0gMDtcbiAgfVxuICBwbGFuZVRyaW1lc2goZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYywgZCkge1xuICAgIGNvbnN0IHUgPSBuZXcgYigpLCBtID0gYWY7XG4gICAgbS5zZXQoMCwgMCwgMSksIHMudm11bHQobSwgbSk7XG4gICAgZm9yIChsZXQgZyA9IDA7IGcgPCB0LnZlcnRpY2VzLmxlbmd0aCAvIDM7IGcrKykge1xuICAgICAgdC5nZXRWZXJ0ZXgoZywgdSk7XG4gICAgICBjb25zdCBwID0gbmV3IGIoKTtcbiAgICAgIHAuY29weSh1KSwgUGUucG9pbnRUb1dvcmxkRnJhbWUoaSwgbywgcCwgdSk7XG4gICAgICBjb25zdCBmID0gbGY7XG4gICAgICBpZiAodS52c3ViKG4sIGYpLCBtLmRvdChmKSA8PSAwKSB7XG4gICAgICAgIGlmIChkKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY29uc3QgXyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsIGwsIGUsIHQsIGEsIGMpO1xuICAgICAgICBfLm5pLmNvcHkobSk7XG4gICAgICAgIGNvbnN0IHcgPSBjZjtcbiAgICAgICAgbS5zY2FsZShmLmRvdChtKSwgdyksIHUudnN1Yih3LCB3KSwgXy5yaS5jb3B5KHcpLCBfLnJpLnZzdWIoci5wb3NpdGlvbiwgXy5yaSksIF8ucmouY29weSh1KSwgXy5yai52c3ViKGwucG9zaXRpb24sIF8ucmopLCB0aGlzLnJlc3VsdC5wdXNoKF8pLCB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoXywgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBtbiA9IG5ldyBiKCksIHFuID0gbmV3IGIoKSwgWG4gPSBuZXcgYigpLCBuZiA9IG5ldyBiKCksIHNmID0gbmV3IGIoKSwgcmYgPSBuZXcgamUoKSwgb2YgPSBuZXcgamUoKSwgYWYgPSBuZXcgYigpLCBsZiA9IG5ldyBiKCksIGNmID0gbmV3IGIoKSwgaGYgPSBuZXcgYigpLCB1ZiA9IG5ldyBiKCk7XG5uZXcgYigpO1xuY29uc3QgZGYgPSBuZXcgYigpLCBmZiA9IG5ldyBiKCksIHBmID0gbmV3IGIoKSwgbWYgPSBuZXcgYigpLCBnZiA9IG5ldyBiKCksIF9mID0gbmV3IGIoKSwgdmYgPSBuZXcgYigpLCB4ZiA9IG5ldyBiKCksIHlmID0gbmV3IGIoKSwgYmYgPSBuZXcgYigpLCB3ZiA9IG5ldyBiKCksIE1mID0gbmV3IHZ0KCksIFNmID0gW10sIEdpID0gbmV3IGIoKSwgWXIgPSBuZXcgYigpLCBFZiA9IG5ldyBiKCksIFRmID0gbmV3IGIoKSwgQWYgPSBuZXcgYigpO1xuZnVuY3Rpb24gQ2YoaCwgZSwgdCkge1xuICBsZXQgbiA9IG51bGw7XG4gIGNvbnN0IGkgPSBoLmxlbmd0aDtcbiAgZm9yIChsZXQgcyA9IDA7IHMgIT09IGk7IHMrKykge1xuICAgIGNvbnN0IG8gPSBoW3NdLCByID0gRWY7XG4gICAgaFsocyArIDEpICUgaV0udnN1YihvLCByKTtcbiAgICBjb25zdCBsID0gVGY7XG4gICAgci5jcm9zcyhlLCBsKTtcbiAgICBjb25zdCBhID0gQWY7XG4gICAgdC52c3ViKG8sIGEpO1xuICAgIGNvbnN0IGMgPSBsLmRvdChhKTtcbiAgICBpZiAobiA9PT0gbnVsbCB8fCBjID4gMCAmJiBuID09PSAhMCB8fCBjIDw9IDAgJiYgbiA9PT0gITEpIHtcbiAgICAgIG4gPT09IG51bGwgJiYgKG4gPSBjID4gMCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5jb25zdCBraSA9IG5ldyBiKCksIExmID0gbmV3IGIoKSwgUmYgPSBuZXcgYigpLCBGZiA9IG5ldyBiKCksIERmID0gW25ldyBiKCksIG5ldyBiKCksIG5ldyBiKCksIG5ldyBiKCksIG5ldyBiKCksIG5ldyBiKCldLCBQZiA9IG5ldyBiKCksIElmID0gbmV3IGIoKSwgemYgPSBuZXcgYigpLCBCZiA9IG5ldyBiKCksIE5mID0gbmV3IGIoKSwgT2YgPSBuZXcgYigpLCBVZiA9IG5ldyBiKCksIEdmID0gbmV3IGIoKSwga2YgPSBuZXcgYigpLCBXZiA9IG5ldyBiKCksIFZmID0gbmV3IGIoKSwgSGYgPSBuZXcgYigpLCBxZiA9IG5ldyBiKCksIFhmID0gbmV3IGIoKTtcbm5ldyBiKCk7XG5uZXcgYigpO1xuY29uc3QgamYgPSBuZXcgYigpLCBZZiA9IG5ldyBiKCksIFpmID0gbmV3IGIoKSwgJGYgPSBuZXcgYigpLCBLZiA9IG5ldyBiKCksIEpmID0gbmV3IGIoKSwgUWYgPSBuZXcgYigpLCBlcCA9IG5ldyBiKCksIHRwID0gbmV3IGIoKSwgbnAgPSBuZXcgYigpLCBaciA9IG5ldyBqZSgpLCBpcCA9IG5ldyBiKCk7XG5uZXcgYigpO1xuY29uc3Qgc3AgPSBuZXcgYigpLCAkciA9IG5ldyBiKCksIHJwID0gbmV3IGIoKSwgb3AgPSBuZXcgYigpLCBhcCA9IG5ldyBiKCksIGxwID0gWzBdLCBjcCA9IG5ldyBiKCksIGhwID0gbmV3IGIoKTtcbmNsYXNzIEtyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gW10sIHRoaXMucHJldmlvdXMgPSBbXTtcbiAgfVxuICBnZXRLZXkoZSwgdCkge1xuICAgIGlmICh0IDwgZSkge1xuICAgICAgY29uc3QgbiA9IHQ7XG4gICAgICB0ID0gZSwgZSA9IG47XG4gICAgfVxuICAgIHJldHVybiBlIDw8IDE2IHwgdDtcbiAgfVxuICBzZXQoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldEtleShlLCB0KSwgaSA9IHRoaXMuY3VycmVudDtcbiAgICBsZXQgcyA9IDA7XG4gICAgZm9yICg7IG4gPiBpW3NdOyApXG4gICAgICBzKys7XG4gICAgaWYgKG4gIT09IGlbc10pIHtcbiAgICAgIGZvciAobGV0IG8gPSBpLmxlbmd0aCAtIDE7IG8gPj0gczsgby0tKVxuICAgICAgICBpW28gKyAxXSA9IGlbb107XG4gICAgICBpW3NdID0gbjtcbiAgICB9XG4gIH1cbiAgdGljaygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucHJldmlvdXMsIHRoaXMucHJldmlvdXMgPSBlLCB0aGlzLmN1cnJlbnQubGVuZ3RoID0gMDtcbiAgfVxuICBnZXREaWZmKGUsIHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5jdXJyZW50LCBpID0gdGhpcy5wcmV2aW91cywgcyA9IG4ubGVuZ3RoLCBvID0gaS5sZW5ndGg7XG4gICAgbGV0IHIgPSAwO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgczsgbCsrKSB7XG4gICAgICBsZXQgYSA9ICExO1xuICAgICAgY29uc3QgYyA9IG5bbF07XG4gICAgICBmb3IgKDsgYyA+IGlbcl07IClcbiAgICAgICAgcisrO1xuICAgICAgYSA9IGMgPT09IGlbcl0sIGEgfHwgSnIoZSwgYyk7XG4gICAgfVxuICAgIHIgPSAwO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgbzsgbCsrKSB7XG4gICAgICBsZXQgYSA9ICExO1xuICAgICAgY29uc3QgYyA9IGlbbF07XG4gICAgICBmb3IgKDsgYyA+IG5bcl07IClcbiAgICAgICAgcisrO1xuICAgICAgYSA9IG5bcl0gPT09IGMsIGEgfHwgSnIodCwgYyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBKcihoLCBlKSB7XG4gIGgucHVzaCgoZSAmIDQyOTQ5MDE3NjApID4+IDE2LCBlICYgNjU1MzUpO1xufVxuY29uc3QgRnMgPSAoaCwgZSkgPT4gaCA8IGUgPyBgJHtofS0ke2V9YCA6IGAke2V9LSR7aH1gO1xuY2xhc3MgdXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBrZXlzOiBbXVxuICAgIH07XG4gIH1cbiAgZ2V0KGUsIHQpIHtcbiAgICBjb25zdCBuID0gRnMoZSwgdCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtuXTtcbiAgfVxuICBzZXQoZSwgdCwgbikge1xuICAgIGNvbnN0IGkgPSBGcyhlLCB0KTtcbiAgICB0aGlzLmdldChlLCB0KSB8fCB0aGlzLmRhdGEua2V5cy5wdXNoKGkpLCB0aGlzLmRhdGFbaV0gPSBuO1xuICB9XG4gIGRlbGV0ZShlLCB0KSB7XG4gICAgY29uc3QgbiA9IEZzKGUsIHQpLCBpID0gdGhpcy5kYXRhLmtleXMuaW5kZXhPZihuKTtcbiAgICBpICE9PSAtMSAmJiB0aGlzLmRhdGEua2V5cy5zcGxpY2UoaSwgMSksIGRlbGV0ZSB0aGlzLmRhdGFbbl07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YSwgdCA9IGUua2V5cztcbiAgICBmb3IgKDsgdC5sZW5ndGggPiAwOyApIHtcbiAgICAgIGNvbnN0IG4gPSB0LnBvcCgpO1xuICAgICAgZGVsZXRlIGVbbl07XG4gICAgfVxuICB9XG59XG5jbGFzcyBkcCBleHRlbmRzIGJvIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwgc3VwZXIoKSwgdGhpcy5kdCA9IC0xLCB0aGlzLmFsbG93U2xlZXAgPSAhIWUuYWxsb3dTbGVlcCwgdGhpcy5jb250YWN0cyA9IFtdLCB0aGlzLmZyaWN0aW9uRXF1YXRpb25zID0gW10sIHRoaXMucXVhdE5vcm1hbGl6ZVNraXAgPSBlLnF1YXROb3JtYWxpemVTa2lwICE9PSB2b2lkIDAgPyBlLnF1YXROb3JtYWxpemVTa2lwIDogMCwgdGhpcy5xdWF0Tm9ybWFsaXplRmFzdCA9IGUucXVhdE5vcm1hbGl6ZUZhc3QgIT09IHZvaWQgMCA/IGUucXVhdE5vcm1hbGl6ZUZhc3QgOiAhMSwgdGhpcy50aW1lID0gMCwgdGhpcy5zdGVwbnVtYmVyID0gMCwgdGhpcy5kZWZhdWx0X2R0ID0gMSAvIDYwLCB0aGlzLm5leHRJZCA9IDAsIHRoaXMuZ3Jhdml0eSA9IG5ldyBiKCksIGUuZ3Jhdml0eSAmJiB0aGlzLmdyYXZpdHkuY29weShlLmdyYXZpdHkpLCBlLmZyaWN0aW9uR3Jhdml0eSAmJiAodGhpcy5mcmljdGlvbkdyYXZpdHkgPSBuZXcgYigpLCB0aGlzLmZyaWN0aW9uR3Jhdml0eS5jb3B5KGUuZnJpY3Rpb25HcmF2aXR5KSksIHRoaXMuYnJvYWRwaGFzZSA9IGUuYnJvYWRwaGFzZSAhPT0gdm9pZCAwID8gZS5icm9hZHBoYXNlIDogbmV3IHdvKCksIHRoaXMuYm9kaWVzID0gW10sIHRoaXMuaGFzQWN0aXZlQm9kaWVzID0gITEsIHRoaXMuc29sdmVyID0gZS5zb2x2ZXIgIT09IHZvaWQgMCA/IGUuc29sdmVyIDogbmV3IFpkKCksIHRoaXMuY29uc3RyYWludHMgPSBbXSwgdGhpcy5uYXJyb3dwaGFzZSA9IG5ldyB0Zih0aGlzKSwgdGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgTnIoKSwgdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IG5ldyBOcigpLCB0aGlzLmJvZHlPdmVybGFwS2VlcGVyID0gbmV3IEtyKCksIHRoaXMuc2hhcGVPdmVybGFwS2VlcGVyID0gbmV3IEtyKCksIHRoaXMuY29udGFjdG1hdGVyaWFscyA9IFtdLCB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlID0gbmV3IHVwKCksIHRoaXMuZGVmYXVsdE1hdGVyaWFsID0gbmV3IFNuKFwiZGVmYXVsdFwiKSwgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IE1uKHRoaXMuZGVmYXVsdE1hdGVyaWFsLCB0aGlzLmRlZmF1bHRNYXRlcmlhbCwge1xuICAgICAgZnJpY3Rpb246IDAuMyxcbiAgICAgIHJlc3RpdHV0aW9uOiAwXG4gICAgfSksIHRoaXMuZG9Qcm9maWxpbmcgPSAhMSwgdGhpcy5wcm9maWxlID0ge1xuICAgICAgc29sdmU6IDAsXG4gICAgICBtYWtlQ29udGFjdENvbnN0cmFpbnRzOiAwLFxuICAgICAgYnJvYWRwaGFzZTogMCxcbiAgICAgIGludGVncmF0ZTogMCxcbiAgICAgIG5hcnJvd3BoYXNlOiAwXG4gICAgfSwgdGhpcy5hY2N1bXVsYXRvciA9IDAsIHRoaXMuc3Vic3lzdGVtcyA9IFtdLCB0aGlzLmFkZEJvZHlFdmVudCA9IHtcbiAgICAgIHR5cGU6IFwiYWRkQm9keVwiLFxuICAgICAgYm9keTogbnVsbFxuICAgIH0sIHRoaXMucmVtb3ZlQm9keUV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJyZW1vdmVCb2R5XCIsXG4gICAgICBib2R5OiBudWxsXG4gICAgfSwgdGhpcy5pZFRvQm9keU1hcCA9IHt9LCB0aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQodGhpcyk7XG4gIH1cbiAgZ2V0Q29udGFjdE1hdGVyaWFsKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQoZS5pZCwgdC5pZCk7XG4gIH1cbiAgY29sbGlzaW9uTWF0cml4VGljaygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cztcbiAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gdGhpcy5jb2xsaXNpb25NYXRyaXgsIHRoaXMuY29sbGlzaW9uTWF0cml4ID0gZSwgdGhpcy5jb2xsaXNpb25NYXRyaXgucmVzZXQoKSwgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci50aWNrKCksIHRoaXMuc2hhcGVPdmVybGFwS2VlcGVyLnRpY2soKTtcbiAgfVxuICBhZGRDb25zdHJhaW50KGUpIHtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goZSk7XG4gIH1cbiAgcmVtb3ZlQ29uc3RyYWludChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihlKTtcbiAgICB0ICE9PSAtMSAmJiB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZSh0LCAxKTtcbiAgfVxuICByYXlUZXN0KGUsIHQsIG4pIHtcbiAgICBuIGluc3RhbmNlb2YgWGkgPyB0aGlzLnJheWNhc3RDbG9zZXN0KGUsIHQsIHtcbiAgICAgIHNraXBCYWNrZmFjZXM6ICEwXG4gICAgfSwgbikgOiB0aGlzLnJheWNhc3RBbGwoZSwgdCwge1xuICAgICAgc2tpcEJhY2tmYWNlczogITBcbiAgICB9LCBuKTtcbiAgfVxuICByYXljYXN0QWxsKGUsIHQsIG4sIGkpIHtcbiAgICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0ge30pLCBuLm1vZGUgPSBYZS5BTEwsIG4uZnJvbSA9IGUsIG4udG8gPSB0LCBuLmNhbGxiYWNrID0gaSwgRHMuaW50ZXJzZWN0V29ybGQodGhpcywgbik7XG4gIH1cbiAgcmF5Y2FzdEFueShlLCB0LCBuLCBpKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IHt9KSwgbi5tb2RlID0gWGUuQU5ZLCBuLmZyb20gPSBlLCBuLnRvID0gdCwgbi5yZXN1bHQgPSBpLCBEcy5pbnRlcnNlY3RXb3JsZCh0aGlzLCBuKTtcbiAgfVxuICByYXljYXN0Q2xvc2VzdChlLCB0LCBuLCBpKSB7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IHt9KSwgbi5tb2RlID0gWGUuQ0xPU0VTVCwgbi5mcm9tID0gZSwgbi50byA9IHQsIG4ucmVzdWx0ID0gaSwgRHMuaW50ZXJzZWN0V29ybGQodGhpcywgbik7XG4gIH1cbiAgYWRkQm9keShlKSB7XG4gICAgdGhpcy5ib2RpZXMuaW5jbHVkZXMoZSkgfHwgKGUuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGgsIHRoaXMuYm9kaWVzLnB1c2goZSksIGUud29ybGQgPSB0aGlzLCBlLmluaXRQb3NpdGlvbi5jb3B5KGUucG9zaXRpb24pLCBlLmluaXRWZWxvY2l0eS5jb3B5KGUudmVsb2NpdHkpLCBlLnRpbWVMYXN0U2xlZXB5ID0gdGhpcy50aW1lLCBlIGluc3RhbmNlb2YgaWUgJiYgKGUuaW5pdEFuZ3VsYXJWZWxvY2l0eS5jb3B5KGUuYW5ndWxhclZlbG9jaXR5KSwgZS5pbml0UXVhdGVybmlvbi5jb3B5KGUucXVhdGVybmlvbikpLCB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXROdW1PYmplY3RzKHRoaXMuYm9kaWVzLmxlbmd0aCksIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBlLCB0aGlzLmlkVG9Cb2R5TWFwW2UuaWRdID0gZSwgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuYWRkQm9keUV2ZW50KSk7XG4gIH1cbiAgcmVtb3ZlQm9keShlKSB7XG4gICAgZS53b3JsZCA9IG51bGw7XG4gICAgY29uc3QgdCA9IHRoaXMuYm9kaWVzLmxlbmd0aCAtIDEsIG4gPSB0aGlzLmJvZGllcywgaSA9IG4uaW5kZXhPZihlKTtcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIG4uc3BsaWNlKGksIDEpO1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgIT09IG4ubGVuZ3RoOyBzKyspXG4gICAgICAgIG5bc10uaW5kZXggPSBzO1xuICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyh0KSwgdGhpcy5yZW1vdmVCb2R5RXZlbnQuYm9keSA9IGUsIGRlbGV0ZSB0aGlzLmlkVG9Cb2R5TWFwW2UuaWRdLCB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5yZW1vdmVCb2R5RXZlbnQpO1xuICAgIH1cbiAgfVxuICBnZXRCb2R5QnlJZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRUb0JvZHlNYXBbZV07XG4gIH1cbiAgZ2V0U2hhcGVCeUlkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICBjb25zdCBpID0gdFtuXS5zaGFwZXM7XG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGkubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgY29uc3QgbyA9IGlbc107XG4gICAgICAgIGlmIChvLmlkID09PSBlKVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhZGRDb250YWN0TWF0ZXJpYWwoZSkge1xuICAgIHRoaXMuY29udGFjdG1hdGVyaWFscy5wdXNoKGUpLCB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLnNldChlLm1hdGVyaWFsc1swXS5pZCwgZS5tYXRlcmlhbHNbMV0uaWQsIGUpO1xuICB9XG4gIHJlbW92ZUNvbnRhY3RNYXRlcmlhbChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFjdG1hdGVyaWFscy5pbmRleE9mKGUpO1xuICAgIHQgIT09IC0xICYmICh0aGlzLmNvbnRhY3RtYXRlcmlhbHMuc3BsaWNlKHQsIDEpLCB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLmRlbGV0ZShlLm1hdGVyaWFsc1swXS5pZCwgZS5tYXRlcmlhbHNbMV0uaWQpKTtcbiAgfVxuICBmaXhlZFN0ZXAoZSwgdCkge1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IDEgLyA2MCksIHQgPT09IHZvaWQgMCAmJiAodCA9IDEwKTtcbiAgICBjb25zdCBuID0gWmUubm93KCkgLyAxZTM7XG4gICAgaWYgKCF0aGlzLmxhc3RDYWxsVGltZSlcbiAgICAgIHRoaXMuc3RlcChlLCB2b2lkIDAsIHQpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgaSA9IG4gLSB0aGlzLmxhc3RDYWxsVGltZTtcbiAgICAgIHRoaXMuc3RlcChlLCBpLCB0KTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q2FsbFRpbWUgPSBuO1xuICB9XG4gIHN0ZXAoZSwgdCwgbikge1xuICAgIGlmIChuID09PSB2b2lkIDAgJiYgKG4gPSAxMCksIHQgPT09IHZvaWQgMClcbiAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGUpLCB0aGlzLnRpbWUgKz0gZTtcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gdDtcbiAgICAgIGNvbnN0IGkgPSBaZS5ub3coKTtcbiAgICAgIGxldCBzID0gMDtcbiAgICAgIGZvciAoOyB0aGlzLmFjY3VtdWxhdG9yID49IGUgJiYgcyA8IG4gJiYgKHRoaXMuaW50ZXJuYWxTdGVwKGUpLCB0aGlzLmFjY3VtdWxhdG9yIC09IGUsIHMrKywgIShaZS5ub3coKSAtIGkgPiBlICogMWUzKSk7IClcbiAgICAgICAgO1xuICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IHRoaXMuYWNjdW11bGF0b3IgJSBlO1xuICAgICAgY29uc3QgbyA9IHRoaXMuYWNjdW11bGF0b3IgLyBlO1xuICAgICAgZm9yIChsZXQgciA9IDA7IHIgIT09IHRoaXMuYm9kaWVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmJvZGllc1tyXTtcbiAgICAgICAgbC5wcmV2aW91c1Bvc2l0aW9uLmxlcnAobC5wb3NpdGlvbiwgbywgbC5pbnRlcnBvbGF0ZWRQb3NpdGlvbiksIGwucHJldmlvdXNRdWF0ZXJuaW9uLnNsZXJwKGwucXVhdGVybmlvbiwgbywgbC5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uKSwgbC5wcmV2aW91c1F1YXRlcm5pb24ubm9ybWFsaXplKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWUgKz0gdDtcbiAgICB9XG4gIH1cbiAgaW50ZXJuYWxTdGVwKGUpIHtcbiAgICB0aGlzLmR0ID0gZTtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250YWN0cywgbiA9IF9wLCBpID0gdnAsIHMgPSB0aGlzLmJvZGllcy5sZW5ndGgsIG8gPSB0aGlzLmJvZGllcywgciA9IHRoaXMuc29sdmVyLCBsID0gdGhpcy5ncmF2aXR5LCBhID0gdGhpcy5kb1Byb2ZpbGluZywgYyA9IHRoaXMucHJvZmlsZSwgZCA9IGllLkRZTkFNSUM7XG4gICAgbGV0IHUgPSAtMSAvIDA7XG4gICAgY29uc3QgbSA9IHRoaXMuY29uc3RyYWludHMsIGcgPSBncDtcbiAgICBsLmxlbmd0aCgpO1xuICAgIGNvbnN0IHAgPSBsLngsIGYgPSBsLnksIHYgPSBsLno7XG4gICAgbGV0IF8gPSAwO1xuICAgIGZvciAoYSAmJiAodSA9IFplLm5vdygpKSwgXyA9IDA7IF8gIT09IHM7IF8rKykge1xuICAgICAgY29uc3QgeiA9IG9bX107XG4gICAgICBpZiAoei50eXBlID09PSBkKSB7XG4gICAgICAgIGNvbnN0IEwgPSB6LmZvcmNlLCBJID0gei5tYXNzO1xuICAgICAgICBMLnggKz0gSSAqIHAsIEwueSArPSBJICogZiwgTC56ICs9IEkgKiB2O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB6ID0gMCwgTCA9IHRoaXMuc3Vic3lzdGVtcy5sZW5ndGg7IHogIT09IEw7IHorKylcbiAgICAgIHRoaXMuc3Vic3lzdGVtc1t6XS51cGRhdGUoKTtcbiAgICBhICYmICh1ID0gWmUubm93KCkpLCBuLmxlbmd0aCA9IDAsIGkubGVuZ3RoID0gMCwgdGhpcy5icm9hZHBoYXNlLmNvbGxpc2lvblBhaXJzKHRoaXMsIG4sIGkpLCBhICYmIChjLmJyb2FkcGhhc2UgPSBaZS5ub3coKSAtIHUpO1xuICAgIGxldCB3ID0gbS5sZW5ndGg7XG4gICAgZm9yIChfID0gMDsgXyAhPT0gdzsgXysrKSB7XG4gICAgICBjb25zdCB6ID0gbVtfXTtcbiAgICAgIGlmICghei5jb2xsaWRlQ29ubmVjdGVkKVxuICAgICAgICBmb3IgKGxldCBMID0gbi5sZW5ndGggLSAxOyBMID49IDA7IEwgLT0gMSlcbiAgICAgICAgICAoei5ib2R5QSA9PT0gbltMXSAmJiB6LmJvZHlCID09PSBpW0xdIHx8IHouYm9keUIgPT09IG5bTF0gJiYgei5ib2R5QSA9PT0gaVtMXSkgJiYgKG4uc3BsaWNlKEwsIDEpLCBpLnNwbGljZShMLCAxKSk7XG4gICAgfVxuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4VGljaygpLCBhICYmICh1ID0gWmUubm93KCkpO1xuICAgIGNvbnN0IHggPSBtcCwgTSA9IHQubGVuZ3RoO1xuICAgIGZvciAoXyA9IDA7IF8gIT09IE07IF8rKylcbiAgICAgIHgucHVzaCh0W19dKTtcbiAgICB0Lmxlbmd0aCA9IDA7XG4gICAgY29uc3QgRSA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO1xuICAgIGZvciAoXyA9IDA7IF8gIT09IEU7IF8rKylcbiAgICAgIGcucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW19dKTtcbiAgICBmb3IgKHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMCwgdGhpcy5uYXJyb3dwaGFzZS5nZXRDb250YWN0cyhcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdGhpcyxcbiAgICAgIHQsXG4gICAgICB4LFxuICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgIGdcbiAgICApLCBhICYmIChjLm5hcnJvd3BoYXNlID0gWmUubm93KCkgLSB1KSwgYSAmJiAodSA9IFplLm5vdygpKSwgXyA9IDA7IF8gPCB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDsgXysrKVxuICAgICAgci5hZGRFcXVhdGlvbih0aGlzLmZyaWN0aW9uRXF1YXRpb25zW19dKTtcbiAgICBjb25zdCBSID0gdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogIT09IFI7IHorKykge1xuICAgICAgY29uc3QgTCA9IHRbel0sIEkgPSBMLmJpLCBEID0gTC5iaiwgcSA9IEwuc2ksIGsgPSBMLnNqO1xuICAgICAgbGV0IE47XG4gICAgICBpZiAoSS5tYXRlcmlhbCAmJiBELm1hdGVyaWFsID8gTiA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKEkubWF0ZXJpYWwsIEQubWF0ZXJpYWwpIHx8IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCA6IE4gPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwsIE4uZnJpY3Rpb24sIEkubWF0ZXJpYWwgJiYgRC5tYXRlcmlhbCAmJiAoSS5tYXRlcmlhbC5mcmljdGlvbiA+PSAwICYmIEQubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCAmJiBJLm1hdGVyaWFsLmZyaWN0aW9uICogRC5tYXRlcmlhbC5mcmljdGlvbiwgSS5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwICYmIEQubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCAmJiAoTC5yZXN0aXR1dGlvbiA9IEkubWF0ZXJpYWwucmVzdGl0dXRpb24gKiBELm1hdGVyaWFsLnJlc3RpdHV0aW9uKSksIHIuYWRkRXF1YXRpb24oTCksIEkuYWxsb3dTbGVlcCAmJiBJLnR5cGUgPT09IGllLkRZTkFNSUMgJiYgSS5zbGVlcFN0YXRlID09PSBpZS5TTEVFUElORyAmJiBELnNsZWVwU3RhdGUgPT09IGllLkFXQUtFICYmIEQudHlwZSAhPT0gaWUuU1RBVElDKSB7XG4gICAgICAgIGNvbnN0IEggPSBELnZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKSArIEQuYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKSwgSiA9IEQuc2xlZXBTcGVlZExpbWl0ICoqIDI7XG4gICAgICAgIEggPj0gSiAqIDIgJiYgKEkud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChELmFsbG93U2xlZXAgJiYgRC50eXBlID09PSBpZS5EWU5BTUlDICYmIEQuc2xlZXBTdGF0ZSA9PT0gaWUuU0xFRVBJTkcgJiYgSS5zbGVlcFN0YXRlID09PSBpZS5BV0FLRSAmJiBJLnR5cGUgIT09IGllLlNUQVRJQykge1xuICAgICAgICBjb25zdCBIID0gSS52ZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCkgKyBJLmFuZ3VsYXJWZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCksIEogPSBJLnNsZWVwU3BlZWRMaW1pdCAqKiAyO1xuICAgICAgICBIID49IEogKiAyICYmIChELndha2VVcEFmdGVyTmFycm93cGhhc2UgPSAhMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoSSwgRCwgITApLCB0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzLmdldChJLCBEKSB8fCAocmkuYm9keSA9IEQsIHJpLmNvbnRhY3QgPSBMLCBJLmRpc3BhdGNoRXZlbnQocmkpLCByaS5ib2R5ID0gSSwgRC5kaXNwYXRjaEV2ZW50KHJpKSksIHRoaXMuYm9keU92ZXJsYXBLZWVwZXIuc2V0KEkuaWQsIEQuaWQpLCB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQocS5pZCwgay5pZCk7XG4gICAgfVxuICAgIGZvciAodGhpcy5lbWl0Q29udGFjdEV2ZW50cygpLCBhICYmIChjLm1ha2VDb250YWN0Q29uc3RyYWludHMgPSBaZS5ub3coKSAtIHUsIHUgPSBaZS5ub3coKSksIF8gPSAwOyBfICE9PSBzOyBfKyspIHtcbiAgICAgIGNvbnN0IHogPSBvW19dO1xuICAgICAgei53YWtlVXBBZnRlck5hcnJvd3BoYXNlICYmICh6Lndha2VVcCgpLCB6Lndha2VVcEFmdGVyTmFycm93cGhhc2UgPSAhMSk7XG4gICAgfVxuICAgIGZvciAodyA9IG0ubGVuZ3RoLCBfID0gMDsgXyAhPT0gdzsgXysrKSB7XG4gICAgICBjb25zdCB6ID0gbVtfXTtcbiAgICAgIHoudXBkYXRlKCk7XG4gICAgICBmb3IgKGxldCBMID0gMCwgSSA9IHouZXF1YXRpb25zLmxlbmd0aDsgTCAhPT0gSTsgTCsrKSB7XG4gICAgICAgIGNvbnN0IEQgPSB6LmVxdWF0aW9uc1tMXTtcbiAgICAgICAgci5hZGRFcXVhdGlvbihEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgci5zb2x2ZShlLCB0aGlzKSwgYSAmJiAoYy5zb2x2ZSA9IFplLm5vdygpIC0gdSksIHIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG4gICAgY29uc3QgeSA9IE1hdGgucG93O1xuICAgIGZvciAoXyA9IDA7IF8gIT09IHM7IF8rKykge1xuICAgICAgY29uc3QgeiA9IG9bX107XG4gICAgICBpZiAoei50eXBlICYgZCkge1xuICAgICAgICBjb25zdCBMID0geSgxIC0gei5saW5lYXJEYW1waW5nLCBlKSwgSSA9IHoudmVsb2NpdHk7XG4gICAgICAgIEkuc2NhbGUoTCwgSSk7XG4gICAgICAgIGNvbnN0IEQgPSB6LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgaWYgKEQpIHtcbiAgICAgICAgICBjb25zdCBxID0geSgxIC0gei5hbmd1bGFyRGFtcGluZywgZSk7XG4gICAgICAgICAgRC5zY2FsZShxLCBEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQocHApLCBhICYmICh1ID0gWmUubm93KCkpO1xuICAgIGNvbnN0IEYgPSB0aGlzLnN0ZXBudW1iZXIgJSAodGhpcy5xdWF0Tm9ybWFsaXplU2tpcCArIDEpID09PSAwLCBQID0gdGhpcy5xdWF0Tm9ybWFsaXplRmFzdDtcbiAgICBmb3IgKF8gPSAwOyBfICE9PSBzOyBfKyspXG4gICAgICBvW19dLmludGVncmF0ZShlLCBGLCBQKTtcbiAgICB0aGlzLmNsZWFyRm9yY2VzKCksIHRoaXMuYnJvYWRwaGFzZS5kaXJ0eSA9ICEwLCBhICYmIChjLmludGVncmF0ZSA9IFplLm5vdygpIC0gdSksIHRoaXMuc3RlcG51bWJlciArPSAxLCB0aGlzLmRpc3BhdGNoRXZlbnQoZnApO1xuICAgIGxldCBHID0gITA7XG4gICAgaWYgKHRoaXMuYWxsb3dTbGVlcClcbiAgICAgIGZvciAoRyA9ICExLCBfID0gMDsgXyAhPT0gczsgXysrKSB7XG4gICAgICAgIGNvbnN0IHogPSBvW19dO1xuICAgICAgICB6LnNsZWVwVGljayh0aGlzLnRpbWUpLCB6LnNsZWVwU3RhdGUgIT09IGllLlNMRUVQSU5HICYmIChHID0gITApO1xuICAgICAgfVxuICAgIHRoaXMuaGFzQWN0aXZlQm9kaWVzID0gRztcbiAgfVxuICBlbWl0Q29udGFjdEV2ZW50cygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKFwiYmVnaW5Db250YWN0XCIpLCB0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKFwiZW5kQ29udGFjdFwiKTtcbiAgICBpZiAoKGUgfHwgdCkgJiYgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKFl0LCBadCksIGUpIHtcbiAgICAgIGZvciAobGV0IHMgPSAwLCBvID0gWXQubGVuZ3RoOyBzIDwgbzsgcyArPSAyKVxuICAgICAgICBvaS5ib2R5QSA9IHRoaXMuZ2V0Qm9keUJ5SWQoWXRbc10pLCBvaS5ib2R5QiA9IHRoaXMuZ2V0Qm9keUJ5SWQoWXRbcyArIDFdKSwgdGhpcy5kaXNwYXRjaEV2ZW50KG9pKTtcbiAgICAgIG9pLmJvZHlBID0gb2kuYm9keUIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodCkge1xuICAgICAgZm9yIChsZXQgcyA9IDAsIG8gPSBadC5sZW5ndGg7IHMgPCBvOyBzICs9IDIpXG4gICAgICAgIGFpLmJvZHlBID0gdGhpcy5nZXRCb2R5QnlJZChadFtzXSksIGFpLmJvZHlCID0gdGhpcy5nZXRCb2R5QnlJZChadFtzICsgMV0pLCB0aGlzLmRpc3BhdGNoRXZlbnQoYWkpO1xuICAgICAgYWkuYm9keUEgPSBhaS5ib2R5QiA9IG51bGw7XG4gICAgfVxuICAgIFl0Lmxlbmd0aCA9IFp0Lmxlbmd0aCA9IDA7XG4gICAgY29uc3QgbiA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcihcImJlZ2luU2hhcGVDb250YWN0XCIpLCBpID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKFwiZW5kU2hhcGVDb250YWN0XCIpO1xuICAgIGlmICgobiB8fCBpKSAmJiB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5nZXREaWZmKFl0LCBadCksIG4pIHtcbiAgICAgIGZvciAobGV0IHMgPSAwLCBvID0gWXQubGVuZ3RoOyBzIDwgbzsgcyArPSAyKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmdldFNoYXBlQnlJZChZdFtzXSksIGwgPSB0aGlzLmdldFNoYXBlQnlJZChZdFtzICsgMV0pO1xuICAgICAgICAkdC5zaGFwZUEgPSByLCAkdC5zaGFwZUIgPSBsLCByICYmICgkdC5ib2R5QSA9IHIuYm9keSksIGwgJiYgKCR0LmJvZHlCID0gbC5ib2R5KSwgdGhpcy5kaXNwYXRjaEV2ZW50KCR0KTtcbiAgICAgIH1cbiAgICAgICR0LmJvZHlBID0gJHQuYm9keUIgPSAkdC5zaGFwZUEgPSAkdC5zaGFwZUIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoaSkge1xuICAgICAgZm9yIChsZXQgcyA9IDAsIG8gPSBadC5sZW5ndGg7IHMgPCBvOyBzICs9IDIpIHtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0U2hhcGVCeUlkKFp0W3NdKSwgbCA9IHRoaXMuZ2V0U2hhcGVCeUlkKFp0W3MgKyAxXSk7XG4gICAgICAgIEt0LnNoYXBlQSA9IHIsIEt0LnNoYXBlQiA9IGwsIHIgJiYgKEt0LmJvZHlBID0gci5ib2R5KSwgbCAmJiAoS3QuYm9keUIgPSBsLmJvZHkpLCB0aGlzLmRpc3BhdGNoRXZlbnQoS3QpO1xuICAgICAgfVxuICAgICAgS3QuYm9keUEgPSBLdC5ib2R5QiA9IEt0LnNoYXBlQSA9IEt0LnNoYXBlQiA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNsZWFyRm9yY2VzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmJvZGllcywgdCA9IGUubGVuZ3RoO1xuICAgIGZvciAobGV0IG4gPSAwOyBuICE9PSB0OyBuKyspIHtcbiAgICAgIGNvbnN0IGkgPSBlW25dO1xuICAgICAgaS5mb3JjZSwgaS50b3JxdWUsIGkuZm9yY2Uuc2V0KDAsIDAsIDApLCBpLnRvcnF1ZS5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICB9XG59XG5uZXcgdnQoKTtcbmNvbnN0IERzID0gbmV3IFhlKCksIFplID0gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSB8fCB7fTtcbmlmICghWmUubm93KSB7XG4gIGxldCBoID0gRGF0ZS5ub3coKTtcbiAgWmUudGltaW5nICYmIFplLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgJiYgKGggPSBaZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSwgWmUubm93ID0gKCkgPT4gRGF0ZS5ub3coKSAtIGg7XG59XG5uZXcgYigpO1xuY29uc3QgZnAgPSB7XG4gIHR5cGU6IFwicG9zdFN0ZXBcIlxufSwgcHAgPSB7XG4gIHR5cGU6IFwicHJlU3RlcFwiXG59LCByaSA9IHtcbiAgdHlwZTogaWUuQ09MTElERV9FVkVOVF9OQU1FLFxuICBib2R5OiBudWxsLFxuICBjb250YWN0OiBudWxsXG59LCBtcCA9IFtdLCBncCA9IFtdLCBfcCA9IFtdLCB2cCA9IFtdLCBZdCA9IFtdLCBadCA9IFtdLCBvaSA9IHtcbiAgdHlwZTogXCJiZWdpbkNvbnRhY3RcIixcbiAgYm9keUE6IG51bGwsXG4gIGJvZHlCOiBudWxsXG59LCBhaSA9IHtcbiAgdHlwZTogXCJlbmRDb250YWN0XCIsXG4gIGJvZHlBOiBudWxsLFxuICBib2R5QjogbnVsbFxufSwgJHQgPSB7XG4gIHR5cGU6IFwiYmVnaW5TaGFwZUNvbnRhY3RcIixcbiAgYm9keUE6IG51bGwsXG4gIGJvZHlCOiBudWxsLFxuICBzaGFwZUE6IG51bGwsXG4gIHNoYXBlQjogbnVsbFxufSwgS3QgPSB7XG4gIHR5cGU6IFwiZW5kU2hhcGVDb250YWN0XCIsXG4gIGJvZHlBOiBudWxsLFxuICBib2R5QjogbnVsbCxcbiAgc2hhcGVBOiBudWxsLFxuICBzaGFwZUI6IG51bGxcbn07XG5jbGFzcyBRciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIChlID0gZS5ub3RhdGlvbiksIHRoaXMuc2V0ID0gW10sIHRoaXMuc2V0a2V5cyA9IFtdLCB0aGlzLnNldGlkID0gMCwgdGhpcy5ncm91cHMgPSBbXSwgdGhpcy50b3RhbERpY2UgPSAwLCB0aGlzLm9wID0gXCJcIiwgdGhpcy5jb25zdGFudCA9IG51bGwsIHRoaXMucmVzdWx0ID0gW10sIHRoaXMuZXJyb3IgPSAhMSwgdGhpcy5ib29zdCA9IDEsIHRoaXMubm90YXRpb24gPSBcIlwiLCB0aGlzLnZlY3RvcnMgPSBbXSwgKCFlIHx8IGUgPT0gXCIwXCIpICYmICh0aGlzLmVycm9yID0gITApLCB0aGlzLnBhcnNlTm90YXRpb24oZSk7XG4gIH1cbiAgcGFyc2VOb3RhdGlvbihlKSB7XG4gICAgaWYgKGUpIHtcbiAgICAgIGxldCB1ID0gZS5zcGxpdChcIiFcIikubGVuZ3RoIC0gMSB8fCAwO1xuICAgICAgdSA+IDAgJiYgKHRoaXMuYm9vc3QgPSBNYXRoLm1pbihNYXRoLm1heCh1LCAwKSwgMykgKiA0KSwgZSA9IGUuc3BsaXQoXCIhXCIpLmpvaW4oXCJcIiksIGUgPSBlLnNwbGl0KFwiIFwiKS5qb2luKFwiXCIpO1xuICAgICAgbGV0IG0gPSBlLnNwbGl0KFwiKFwiKS5sZW5ndGggLSAxLCBnID0gZS5zcGxpdChcIilcIikubGVuZ3RoIC0gMTtcbiAgICAgIG0gIT0gZyAmJiAodGhpcy5lcnJvciA9ICEwKTtcbiAgICB9XG4gICAgY29uc3QgdCA9IHRoaXMubm90YXRpb24ubGVuZ3RoID4gMCA/IFwiK1wiIDogXCJcIjtcbiAgICB0aGlzLm5vdGF0aW9uICs9IHQgKyBlO1xuICAgIGxldCBuID0gZS5zcGxpdChcIkBcIiksIGkgPSBuWzBdLCBzID0gbmV3IFJlZ0V4cCgvKFxcK3xcXC18XFwqfFxcL3xcXCV8XFxefCl7MCwxfSgpKFxcZCopKFthLXpdK1xcZCt8W2Etel0rfCkoPzpcXHsoW2Etel0rKSguKj98KVxcfXwpKCkvLCBcImlcIiksIG8gPSBuZXcgUmVnRXhwKC8oXFxiKSooXFwtXFxkK3xcXGQrKShcXGIpKi8sIFwiZ2lcIiksIHIsIGwgPSAwLCBhID0gMzAsIGMgPSAwLCBkID0gMDtcbiAgICBmb3IgKDsgIXRoaXMuZXJyb3IgJiYgaS5sZW5ndGggPiAwICYmIChyID0gcy5leGVjKGkpKSAhPT0gbnVsbCAmJiBsIDwgYTsgKSB7XG4gICAgICBsKyssIGkgPSBpLnN1YnN0cmluZyhyWzBdLmxlbmd0aCk7XG4gICAgICBsZXQgdSA9IHJbMV0sIG0gPSByWzJdICYmIHJbMl0ubGVuZ3RoID4gMCwgZyA9IHJbM10sIHAgPSByWzRdLCBmID0gcls1XSB8fCBcIlwiLCB2ID0gcls2XSB8fCBcIlwiLCBfID0gcls3XSAmJiByWzddLmxlbmd0aCA+IDAsIHcgPSAhMDtcbiAgICAgIG0gJiYgKGMgKz0gclsyXS5sZW5ndGgpLCB2ID0gdi5zcGxpdChcIixcIiksICghdiB8fCB2Lmxlbmd0aCA8IDEpICYmICh2ID0gXCJcIiksIHYuc2hpZnQoKSwgbCA9PSAxICYmIGkubGVuZ3RoID09IDAgJiYgIXAgJiYgdSAmJiBnID8gKHAgPSBcImQyMFwiLCB0aGlzLm9wID0gdSwgdGhpcy5jb25zdGFudCA9IHBhcnNlSW50KGcpLCBnID0gMSkgOiBsID4gMSAmJiBpLmxlbmd0aCA9PSAwICYmICFwICYmICh0aGlzLm9wID0gdSwgdGhpcy5jb25zdGFudCA9IHBhcnNlSW50KGcpLCB3ID0gITEpLCB3ICYmIHRoaXMuYWRkU2V0KGcsIHAsIGQsIGMsIGYsIHYsIHUpLCBfICYmIChjIC09IHJbN10ubGVuZ3RoLCBkICs9IHJbN10ubGVuZ3RoKTtcbiAgICB9XG4gICAgIXRoaXMuZXJyb3IgJiYgblsxXSAmJiAociA9IG5bMV0ubWF0Y2gobykpICE9PSBudWxsICYmIHRoaXMucmVzdWx0LnB1c2goLi4ucik7XG4gIH1cbiAgc3RyaW5naWZ5KGUgPSAhMCkge1xuICAgIGxldCB0ID0gXCJcIjtcbiAgICBpZiAodGhpcy5zZXQubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybiB0O1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdGhpcy5zZXQubGVuZ3RoOyBuKyspIHtcbiAgICAgIGxldCBpID0gdGhpcy5zZXRbbl07XG4gICAgICB0ICs9IG4gPiAwICYmIGkub3AgPyBpLm9wIDogXCJcIiwgdCArPSBpLm51bSArIGkudHlwZSwgaS5mdW5jICYmICh0ICs9IFwie1wiLCB0ICs9IGkuZnVuYyA/IGkuZnVuYyA6IFwiXCIsIHQgKz0gaS5hcmdzID8gXCIsXCIgKyAoQXJyYXkuaXNBcnJheShpLmFyZ3MpID8gaS5hcmdzLmpvaW4oXCIsXCIpIDogaS5hcmdzKSA6IFwiXCIsIHQgKz0gXCJ9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdCArPSB0aGlzLmNvbnN0YW50ID8gdGhpcy5vcCArIFwiXCIgKyBNYXRoLmFicyh0aGlzLmNvbnN0YW50KSA6IFwiXCIsIGUgJiYgdGhpcy5yZXN1bHQgJiYgdGhpcy5yZXN1bHQubGVuZ3RoID4gMCAmJiAodCArPSBcIkBcIiArIHRoaXMucmVzdWx0LmpvaW4oXCIsXCIpKSwgdGhpcy5ib29zdCA+IDEgJiYgKHQgKz0gXCIhXCIucmVwZWF0KHRoaXMuYm9vc3QgLyA0KSksIHQ7XG4gIH1cbiAgYWRkU2V0KGUsIHQsIG4gPSAwLCBpID0gMCwgcyA9IFwiXCIsIG8gPSBcIlwiLCByID0gXCIrXCIpIHtcbiAgICBlID0gTWF0aC5hYnMocGFyc2VJbnQoZSB8fCAxKSk7XG4gICAgbGV0IGwgPSByICsgXCJcIiArIHQgKyBuICsgaSArIHMgKyBvLCBhID0gdGhpcy5zZXRrZXlzW2xdICE9IG51bGwsIGMgPSB7fTtcbiAgICBhICYmIChjID0gdGhpcy5zZXRbdGhpcy5zZXRrZXlzW2xdIC0gMV0pLCBlID4gMCAmJiAoYy5udW0gPSBhID8gZSArIGMubnVtIDogZSwgYy50eXBlID0gdCwgYy5zaWQgPSB0aGlzLnNldGlkLCBjLmdpZCA9IG4sIGMuZ2x2bCA9IGksIHMgJiYgKGMuZnVuYyA9IHMpLCBvICYmIChjLmFyZ3MgPSBvKSwgciAmJiAoYy5vcCA9IHIpLCBhID8gdGhpcy5zZXRbdGhpcy5zZXRrZXlzW2xdIC0gMV0gPSBjIDogdGhpcy5zZXRrZXlzW2xdID0gdGhpcy5zZXQucHVzaChjKSksIGEgfHwgKyt0aGlzLnNldGlkO1xuICB9XG4gIHN0YXRpYyBtZXJnZU5vdGF0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZSxcbiAgICAgIGNvbnN0YW50OiBlLmNvbnN0YW50ICsgdC5jb25zdGFudCxcbiAgICAgIG5vdGF0aW9uOiBlLm5vdGF0aW9uICsgXCIrXCIgKyB0Lm5vdGF0aW9uLFxuICAgICAgc2V0OiBbXG4gICAgICAgIC4uLmUuc2V0LFxuICAgICAgICAuLi50LnNldFxuICAgICAgXSxcbiAgICAgIHRvdGFsRGljZTogZS52ZWN0b3JzLmxlbmd0aCArIHQudmVjdG9ycy5sZW5ndGgsXG4gICAgICB2ZWN0b3JzOiBbXG4gICAgICAgIC4uLmUudmVjdG9ycyxcbiAgICAgICAgLi4udC52ZWN0b3JzXG4gICAgICBdXG4gICAgfTtcbiAgfVxufVxuY29uc3QgUHMgPSB7XG4gIGQyOiB7XG4gICAgbmFtZTogXCJkMlwiLFxuICAgIGxhYmVsczogW1wiMVwiLCBcIjJcIl0sXG4gICAgdmFsdWVzOiBbMSwgMl0sXG4gICAgaW5lcnRpYTogOCxcbiAgICBtYXNzOiA0MDAsXG4gICAgc2NhbGU6IDAuOSxcbiAgICBzeXN0ZW06IFwiZHdlaXJkXCJcbiAgfSxcbiAgZGM6IHtcbiAgICB0eXBlOiBcImQyXCIsXG4gICAgbmFtZTogXCJDb2luXCIsXG4gICAgbGFiZWxzOiBbXG4gICAgICBcInRleHR1cmVzL3NpbHZlcmNvaW4vdGFpbC5wbmdcIixcbiAgICAgIFwidGV4dHVyZXMvc2lsdmVyY29pbi9oZWFkcy5wbmdcIlxuICAgIF0sXG4gICAgc2V0QnVtcE1hcHM6IFtcbiAgICAgIFwidGV4dHVyZXMvc2lsdmVyY29pbi90YWlsX2J1bXAucG5nXCIsXG4gICAgICBcInRleHR1cmVzL3NpbHZlcmNvaW4vaGVhZHNfYnVtcC5wbmdcIlxuICAgIF0sXG4gICAgdmFsdWVzOiBbMCwgMV0sXG4gICAgaW5lcnRpYTogOCxcbiAgICBtYXNzOiA0MDAsXG4gICAgc2NhbGU6IDAuOSxcbiAgICBjb2xvcnNldDogXCJjb2luX3NpbHZlclwiXG4gIH0sXG4gIGQxOiB7XG4gICAgbmFtZTogXCJPbmUtc2lkZWQgRGljZVwiLFxuICAgIHR5cGU6IFwiZDZcIixcbiAgICBsYWJlbHM6IFtcIjFcIl0sXG4gICAgdmFsdWVzOiBbMSwgMV0sXG4gICAgc2NhbGU6IDAuOSxcbiAgICBzeXN0ZW06IFwiZHdlaXJkXCJcbiAgfSxcbiAgZDM6IHtcbiAgICBuYW1lOiBcIlRocmVlLVNpZGVkIERpY2VcIixcbiAgICB0eXBlOiBcImQ2XCIsXG4gICAgbGFiZWxzOiBbXCIxXCIsIFwiMlwiLCBcIjNcIl0sXG4gICAgdmFsdWVzOiBbMSwgM10sXG4gICAgc2NhbGU6IDAuOSxcbiAgICBzeXN0ZW06IFwiZHdlaXJkXCJcbiAgfSxcbiAgZGY6IHtcbiAgICBuYW1lOiBcIkZ1ZGdlIERpY2VcIixcbiAgICB0eXBlOiBcImQ2XCIsXG4gICAgbGFiZWxzOiBbXCItXCIsIFwiMFwiLCBcIitcIl0sXG4gICAgdmFsdWVzOiBbLTEsIDFdLFxuICAgIHNjYWxlOiAwLjksXG4gICAgc3lzdGVtOiBcImR3ZWlyZFwiXG4gIH0sXG4gIGQ0OiB7XG4gICAgbmFtZTogXCJGb3VyLVNpZGVkIERpY2VcIixcbiAgICBsYWJlbHM6IFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIl0sXG4gICAgdmFsdWVzOiBbMSwgNF0sXG4gICAgaW5lcnRpYTogNSxcbiAgICBzY2FsZTogMS4yXG4gIH0sXG4gIGQ2OiB7XG4gICAgbmFtZTogXCJTaXgtU2lkZWQgRGljZSAoTnVtYmVycylcIixcbiAgICBsYWJlbHM6IFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiXSxcbiAgICB2YWx1ZXM6IFsxLCA2XSxcbiAgICBzY2FsZTogMC45XG4gIH0sXG4gIGRwaXA6IHtcbiAgICBuYW1lOiBcIlNpeC1TaWRlZCBEaWNlIChQaXBzKVwiLFxuICAgIHR5cGU6IFwiZDZcIixcbiAgICBsYWJlbHM6IFtcbiAgICAgIGAgICBcbiBcXHUyQjI0IFxuICAgYCxcbiAgICAgIGBcXHUyQjI0ICBcbiAgIFxuICBcXHUyQjI0YCxcbiAgICAgIGBcXHUyQjI0ICBcbiBcXHUyQjI0IFxuICBcXHUyQjI0YCxcbiAgICAgIGBcXHUyQjI0IFxcdTJCMjRcbiAgIFxuXFx1MkIyNCBcXHUyQjI0YCxcbiAgICAgIGBcXHUyQjI0IFxcdTJCMjRcbiBcXHUyQjI0IFxuXFx1MkIyNCBcXHUyQjI0YCxcbiAgICAgIGBcXHUyQjI0IFxcdTJCMjRcblxcdTJCMjQgXFx1MkIyNFxuXFx1MkIyNCBcXHUyQjI0YFxuICAgIF0sXG4gICAgdmFsdWVzOiBbMSwgNl0sXG4gICAgc2NhbGU6IDAuOSxcbiAgICBmb250OiBcIm1vbm9zcGFjZVwiXG4gIH0sXG4gIGRzZXg6IHtcbiAgICBuYW1lOiBcIlNleC1TaWRlZCBFbW9qaSBEaWNlXCIsXG4gICAgdHlwZTogXCJkNlwiLFxuICAgIGxhYmVsczogW1wiXFx1ezFGMzQ2fVwiLCBcIlxcdXsxRjM1MX1cIiwgXCJcXHV7MUY0NEN9XCIsIFwiXFx1ezFGNEE2fVwiLCBcIlxcdXsxRjY0Rn1cIiwgXCJcXHV7MUY0QTV9XCJdLFxuICAgIHZhbHVlczogWzEsIDZdLFxuICAgIHNjYWxlOiAwLjksXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwiZHdlaXJkXCJcbiAgfSxcbiAgZHBva2VyOiB7XG4gICAgbmFtZTogXCJQb2tlciBEaWNlICg5LUFjZSlcIixcbiAgICB0eXBlOiBcImQ2XCIsXG4gICAgbGFiZWxzOiBbXCJBXCIsIFwiOVwiLCBcIjEwXCIsIFwiSlwiLCBcIlFcIiwgXCJLXCJdLFxuICAgIHZhbHVlczogWzEsIDZdLFxuICAgIHNjYWxlOiAwLjksXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwiZHdlaXJkXCIsXG4gICAgZm9udDogXCJUaW1lcyBOZXcgUm9tYW5cIlxuICB9LFxuICBkc3BhbnBva2VyOiB7XG4gICAgbmFtZTogXCJTcGFuaXNoIFBva2VyIERpY2UgKDctQWNlKVwiLFxuICAgIHR5cGU6IFwiZDhcIixcbiAgICBsYWJlbHM6IFtcIkFcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIkpcIiwgXCJRXCIsIFwiS1wiXSxcbiAgICB2YWx1ZXM6IFsxLCA4XSxcbiAgICBkaXNwbGF5OiBcImxhYmVsc1wiLFxuICAgIHN5c3RlbTogXCJkd2VpcmRcIixcbiAgICBmb250OiBcIlRpbWVzIE5ldyBSb21hblwiXG4gIH0sXG4gIGRpc290b3BlOiB7XG4gICAgbmFtZTogXCJSYWRpb2FjdGl2ZSBUd2VsdmUtU2lkZWQgRGljZVwiLFxuICAgIHR5cGU6IFwiZDEyXCIsXG4gICAgbGFiZWxzOiBbXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcXHUyNjIyXFx1RkUwRlwiXSxcbiAgICB2YWx1ZXM6IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxXSxcbiAgICBtYXNzOiAzNTAsXG4gICAgaW5lcnRpYTogOCxcbiAgICBzY2FsZTogMC45LFxuICAgIHN5c3RlbTogXCJkd2VpcmRcIlxuICB9LFxuICBkc3VpdDoge1xuICAgIG5hbWU6IFwiRm91ci1TdWl0ZWQgRGljZVwiLFxuICAgIHR5cGU6IFwiZDRcIixcbiAgICBsYWJlbHM6IFtcIlxcdTI2NjBcXHVGRTBGXCIsIFwiXFx1MjY2NVxcdUZFMEZcIiwgXCJcXHUyNjY2XFx1RkUwRlwiLCBcIlxcdTI2NjNcXHVGRTBGXCJdLFxuICAgIHZhbHVlczogWzEsIDRdLFxuICAgIGluZXJ0aWE6IDUsXG4gICAgc2NhbGU6IDEuMixcbiAgICBkaXNwbGF5OiBcImxhYmVsc1wiLFxuICAgIHN5c3RlbTogXCJkd2VpcmRcIlxuICB9LFxuICBkODoge1xuICAgIG5hbWU6IFwiRWlnaHQtU2lkZWQgRGljZVwiLFxuICAgIGxhYmVsczogW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIl0sXG4gICAgdmFsdWVzOiBbMSwgOF1cbiAgfSxcbiAgZDEwOiB7XG4gICAgbmFtZTogXCJUZW4tU2lkZWQgRGljZSAoU2luZ2xlIERpZ2l0KVwiLFxuICAgIGxhYmVsczogW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMFwiXSxcbiAgICB2YWx1ZXM6IFsxLCAxMF0sXG4gICAgbWFzczogMzUwLFxuICAgIGluZXJ0aWE6IDksXG4gICAgc2NhbGU6IDAuOVxuICB9LFxuICBkMTAwOiB7XG4gICAgbmFtZTogXCJUZW4tU2lkZWQgRGljZSAoVGVucyBEaWdpdClcIixcbiAgICB0eXBlOiBcImQxMFwiLFxuICAgIGxhYmVsczogW1wiMTBcIiwgXCIyMFwiLCBcIjMwXCIsIFwiNDBcIiwgXCI1MFwiLCBcIjYwXCIsIFwiNzBcIiwgXCI4MFwiLCBcIjkwXCIsIFwiMDBcIl0sXG4gICAgdmFsdWVzOiBbMTAsIDEwMCwgMTBdLFxuICAgIG1hc3M6IDM1MCxcbiAgICBpbmVydGlhOiA5LFxuICAgIHNjYWxlOiAwLjlcbiAgfSxcbiAgZDEyOiB7XG4gICAgbmFtZTogXCJUd2VsdmUtU2lkZWQgRGljZVwiLFxuICAgIGxhYmVsczogW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdLFxuICAgIHZhbHVlczogWzEsIDEyXSxcbiAgICBtYXNzOiAzNTAsXG4gICAgaW5lcnRpYTogOCxcbiAgICBzY2FsZTogMC45XG4gIH0sXG4gIGQyMDoge1xuICAgIG5hbWU6IFwiVHdlbnR5LVNpZGVkIERpY2VcIixcbiAgICBsYWJlbHM6IFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiLCBcIjEzXCIsIFwiMTRcIiwgXCIxNVwiLCBcIjE2XCIsIFwiMTdcIiwgXCIxOFwiLCBcIjE5XCIsIFwiMjBcIl0sXG4gICAgdmFsdWVzOiBbMSwgMjBdLFxuICAgIG1hc3M6IDQwMCxcbiAgICBpbmVydGlhOiA2XG4gIH0sXG4gIGRhYmk6IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBSUEc6IEFiaWxpdHkgRGljZVwiLFxuICAgIHR5cGU6IFwiZDhcIixcbiAgICBsYWJlbHM6IFtcInNcIiwgXCJhXCIsIGBzXG5hYCwgYHNcbnNgLCBcImFcIiwgXCJzXCIsIGBhXG5hYCwgXCJcIl0sXG4gICAgdmFsdWVzOiBbMSwgOF0sXG4gICAgZm9udDogXCJTV1JQRy1TeW1ib2wtUmVndWxhclwiLFxuICAgIGNvbG9yOiBcIiMwMEZGMDBcIixcbiAgICBjb2xvcnNldDogXCJzd3JwZ19hYmlcIixcbiAgICBkaXNwbGF5OiBcImxhYmVsc1wiLFxuICAgIHN5c3RlbTogXCJzd3JwZ1wiXG4gIH0sXG4gIGRkaWY6IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBSUEc6IERpZmZpY3VsdHkgRGljZVwiLFxuICAgIHR5cGU6IFwiZDhcIixcbiAgICBsYWJlbHM6IFtcInRcIiwgXCJmXCIsIGBmXG50YCwgXCJ0XCIsIFwiXCIsIGB0XG50YCwgYGZcbmZgLCBcInRcIl0sXG4gICAgdmFsdWVzOiBbMSwgOF0sXG4gICAgZm9udDogXCJTV1JQRy1TeW1ib2wtUmVndWxhclwiLFxuICAgIGNvbG9yOiBcIiM4MDAwRkNcIixcbiAgICBjb2xvcnNldDogXCJzd3JwZ19kaWZcIixcbiAgICBkaXNwbGF5OiBcImxhYmVsc1wiLFxuICAgIHN5c3RlbTogXCJzd3JwZ1wiXG4gIH0sXG4gIGRwcm86IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBSUEc6IFByb2ZpY2llbmN5IERpY2VcIixcbiAgICB0eXBlOiBcImQxMlwiLFxuICAgIGxhYmVsczogW2BhXG5hYCwgXCJhXCIsIGBhXG5hYCwgXCJ4XCIsIFwic1wiLCBgc1xuYWAsIFwic1wiLCBgc1xuYWAsIGBzXG5zYCwgYHNcbmFgLCBgc1xuc2AsIFwiXCJdLFxuICAgIHZhbHVlczogWzEsIDEyXSxcbiAgICBtYXNzOiAzNTAsXG4gICAgaW5lcnRpYTogOCxcbiAgICBzY2FsZTogMC45LFxuICAgIGZvbnQ6IFwiU1dSUEctU3ltYm9sLVJlZ3VsYXJcIixcbiAgICBjb2xvcjogXCIjRkZGRjAwXCIsXG4gICAgY29sb3JzZXQ6IFwic3dycGdfcHJvXCIsXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwic3dycGdcIlxuICB9LFxuICBkY2hhOiB7XG4gICAgbmFtZTogXCJTdGFyIFdhcnMgUlBHOiBDaGFsbGVuZ2UgRGljZVwiLFxuICAgIHR5cGU6IFwiZDEyXCIsXG4gICAgbGFiZWxzOiBbYHRcbnRgLCBcInRcIiwgYHRcbnRgLCBcInRcIiwgYHRcbmZgLCBcImZcIiwgYHRcbmZgLCBcImZcIiwgYGZcbmZgLCBcInlcIiwgYGZcbmZgLCBcIlwiXSxcbiAgICB2YWx1ZXM6IFsxLCAxMl0sXG4gICAgbWFzczogMzUwLFxuICAgIGluZXJ0aWE6IDgsXG4gICAgc2NhbGU6IDAuOSxcbiAgICBmb250OiBcIlNXUlBHLVN5bWJvbC1SZWd1bGFyXCIsXG4gICAgY29sb3I6IFwiI0ZGMDAwMFwiLFxuICAgIGNvbG9yc2V0OiBcInN3cnBnX2NoYVwiLFxuICAgIGRpc3BsYXk6IFwibGFiZWxzXCIsXG4gICAgc3lzdGVtOiBcInN3cnBnXCJcbiAgfSxcbiAgZGZvcjoge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIFJQRzogRm9yY2UgRGljZVwiLFxuICAgIHR5cGU6IFwiZDEyXCIsXG4gICAgbGFiZWxzOiBbXCJ6XCIsIGBaXG5aYCwgXCJ6XCIsIGBaXG5aYCwgXCJ6XCIsIGBaXG5aYCwgXCJ6XCIsIFwiWlwiLCBcInpcIiwgXCJaXCIsIFwielwiLCBgelxuemBdLFxuICAgIHZhbHVlczogWzEsIDEyXSxcbiAgICBtYXNzOiAzNTAsXG4gICAgaW5lcnRpYTogOCxcbiAgICBzY2FsZTogMC45LFxuICAgIGZvbnQ6IFwiU1dSUEctU3ltYm9sLVJlZ3VsYXJcIixcbiAgICBjb2xvcjogXCIjRkZGRkZGXCIsXG4gICAgY29sb3JzZXQ6IFwic3dycGdfZm9yXCIsXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwic3dycGdcIlxuICB9LFxuICBkYm9vOiB7XG4gICAgbmFtZTogXCJTdGFyIFdhcnMgUlBHOiBCb29zdCBEaWNlXCIsXG4gICAgdHlwZTogXCJkNlwiLFxuICAgIGxhYmVsczogW2BzICBcbiAgYWAsIGBhICBcbiAgYWAsIFwic1wiLCBcImFcIiwgXCJcIiwgXCJcIl0sXG4gICAgdmFsdWVzOiBbMSwgNl0sXG4gICAgc2NhbGU6IDAuOSxcbiAgICBmb250OiBcIlNXUlBHLVN5bWJvbC1SZWd1bGFyXCIsXG4gICAgY29sb3I6IFwiIzAwRkZGRlwiLFxuICAgIGNvbG9yc2V0OiBcInN3cnBnX2Jvb1wiLFxuICAgIGRpc3BsYXk6IFwibGFiZWxzXCIsXG4gICAgc3lzdGVtOiBcInN3cnBnXCJcbiAgfSxcbiAgZHNldDoge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIFJQRzogU2V0YmFjayBEaWNlXCIsXG4gICAgdHlwZTogXCJkNlwiLFxuICAgIGxhYmVsczogW1wiXCIsIFwidFwiLCBcImZcIl0sXG4gICAgdmFsdWVzOiBbMSwgM10sXG4gICAgc2NhbGU6IDAuOSxcbiAgICBmb250OiBcIlNXUlBHLVN5bWJvbC1SZWd1bGFyXCIsXG4gICAgY29sb3I6IFwiIzExMTExMVwiLFxuICAgIGNvbG9yc2V0OiBcInN3cnBnX3NldFwiLFxuICAgIGRpc3BsYXk6IFwibGFiZWxzXCIsXG4gICAgc3lzdGVtOiBcInN3cnBnXCJcbiAgfSxcbiAgc3dhcjoge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIEFybWFkYTogUmVkIEF0dGFjayBEaWNlXCIsXG4gICAgdHlwZTogXCJkOFwiLFxuICAgIGxhYmVsczogW1wiRlwiLCBcIkZcIiwgYEZcbkZgLCBcIkVcIiwgXCJFXCIsIFwiR1wiLCBcIlwiLCBcIlwiXSxcbiAgICB2YWx1ZXM6IFsxLCA4XSxcbiAgICBmb250OiBcIkFybWFkYS1TeW1ib2wtUmVndWxhclwiLFxuICAgIGNvbG9yOiBcIiNGRjAwMDBcIixcbiAgICBjb2xvcnNldDogXCJzd2FfcmVkXCIsXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwic3dhcm1hZGFcIlxuICB9LFxuICBzd2FiOiB7XG4gICAgbmFtZTogXCJTdGFyIFdhcnMgQXJtYWRhOiBCbHVlIEF0dGFjayBEaWNlXCIsXG4gICAgdHlwZTogXCJkOFwiLFxuICAgIGxhYmVsczogW1wiRlwiLCBcIkZcIiwgXCJGXCIsIFwiRlwiLCBcIkVcIiwgXCJFXCIsIFwiR1wiLCBcIkdcIl0sXG4gICAgdmFsdWVzOiBbMSwgOF0sXG4gICAgZm9udDogXCJBcm1hZGEtU3ltYm9sLVJlZ3VsYXJcIixcbiAgICBjb2xvcjogXCIjMDAwMEZGXCIsXG4gICAgY29sb3JzZXQ6IFwic3dhX2JsdWVcIixcbiAgICBkaXNwbGF5OiBcImxhYmVsc1wiLFxuICAgIHN5c3RlbTogXCJzd2FybWFkYVwiXG4gIH0sXG4gIHN3YWs6IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBBcm1hZGE6IEJsYWNrIEF0dGFjayBEaWNlXCIsXG4gICAgdHlwZTogXCJkOFwiLFxuICAgIGxhYmVsczogW1wiRlwiLCBcIkZcIiwgXCJGXCIsIFwiRlwiLCBgRlxuRWAsIGBGXG5FYCwgXCJcIiwgXCJcIl0sXG4gICAgdmFsdWVzOiBbMSwgOF0sXG4gICAgZm9udDogXCJBcm1hZGEtU3ltYm9sLVJlZ3VsYXJcIixcbiAgICBjb2xvcjogXCIjMTExMTExXCIsXG4gICAgY29sb3JzZXQ6IFwic3dhX2JsYWNrXCIsXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwic3dhcm1hZGFcIlxuICB9LFxuICB4d2F0azoge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIFgtV2luZzogUmVkIEF0dGFjayBEaWNlXCIsXG4gICAgdHlwZTogXCJkOFwiLFxuICAgIGxhYmVsczogW1wiY1wiLCBcImRcIiwgXCJkXCIsIFwiZFwiLCBcImZcIiwgXCJmXCIsIFwiXCIsIFwiXCJdLFxuICAgIHZhbHVlczogWzEsIDhdLFxuICAgIGZvbnQ6IFwiWFdpbmctU3ltYm9sLVJlZ3VsYXJcIixcbiAgICBjb2xvcjogXCIjRkYwMDAwXCIsXG4gICAgY29sb3JzZXQ6IFwieHdpbmdfcmVkXCIsXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwieHdpbmdcIlxuICB9LFxuICB4d2RlZjoge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIFgtV2luZzogR3JlZW4gRGVmZW5zZSBEaWNlXCIsXG4gICAgdHlwZTogXCJkOFwiLFxuICAgIGxhYmVsczogW1wiZVwiLCBcImVcIiwgXCJlXCIsIFwiZlwiLCBcImZcIiwgXCJcIiwgXCJcIiwgXCJcIl0sXG4gICAgdmFsdWVzOiBbMSwgOF0sXG4gICAgZm9udDogXCJYV2luZy1TeW1ib2wtUmVndWxhclwiLFxuICAgIGNvbG9yOiBcIiMwMEZGMDBcIixcbiAgICBjb2xvcnNldDogXCJ4d2luZ19ncmVlblwiLFxuICAgIGRpc3BsYXk6IFwibGFiZWxzXCIsXG4gICAgc3lzdGVtOiBcInh3aW5nXCJcbiAgfSxcbiAgc3dsYXI6IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBMZWdpb246IFJlZCBBdHRhY2sgRGljZVwiLFxuICAgIHR5cGU6IFwiZDhcIixcbiAgICBsYWJlbHM6IFtcImhcIiwgXCJoXCIsIFwiaFwiLCBcImhcIiwgXCJoXCIsIFwiY1wiLCBcIm9cIiwgXCJcIl0sXG4gICAgdmFsdWVzOiBbMSwgOF0sXG4gICAgZm9udDogXCJMZWdpb24tU3ltYm9sLVJlZ3VsYXJcIixcbiAgICBjb2xvcjogXCIjRkYwMDAwXCIsXG4gICAgY29sb3JzZXQ6IFwic3dsX2F0a3JlZFwiLFxuICAgIGRpc3BsYXk6IFwibGFiZWxzXCIsXG4gICAgc3lzdGVtOiBcImxlZ2lvblwiXG4gIH0sXG4gIHN3bGFiOiB7XG4gICAgbmFtZTogXCJTdGFyIFdhcnMgTGVnaW9uOiBCbGFjayBBdHRhY2sgRGljZVwiLFxuICAgIHR5cGU6IFwiZDhcIixcbiAgICBsYWJlbHM6IFtcImhcIiwgXCJoXCIsIFwiaFwiLCBcIlwiLCBcIlwiLCBcImNcIiwgXCJvXCIsIFwiXCJdLFxuICAgIHZhbHVlczogWzEsIDhdLFxuICAgIGZvbnQ6IFwiTGVnaW9uLVN5bWJvbC1SZWd1bGFyXCIsXG4gICAgY29sb3I6IFwiIzExMTExMVwiLFxuICAgIGNvbG9yc2V0OiBcInN3bF9hdGtibGFja1wiLFxuICAgIGRpc3BsYXk6IFwibGFiZWxzXCIsXG4gICAgc3lzdGVtOiBcImxlZ2lvblwiXG4gIH0sXG4gIHN3bGF3OiB7XG4gICAgbmFtZTogXCJTdGFyIFdhcnMgTGVnaW9uOiBXaGl0ZSBBdHRhY2sgRGljZVwiLFxuICAgIHR5cGU6IFwiZDhcIixcbiAgICBsYWJlbHM6IFtcImhcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJjXCIsIFwib1wiLCBcIlwiXSxcbiAgICB2YWx1ZXM6IFsxLCA4XSxcbiAgICBmb250OiBcIkxlZ2lvbi1TeW1ib2wtUmVndWxhclwiLFxuICAgIGNvbG9yOiBcIiNGRkZGRkZcIixcbiAgICBjb2xvcnNldDogXCJzd2xfYXRrd2hpdGVcIixcbiAgICBkaXNwbGF5OiBcImxhYmVsc1wiLFxuICAgIHN5c3RlbTogXCJsZWdpb25cIlxuICB9LFxuICBzd2xkcjoge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIExlZ2lvbjogUmVkIERlZmVuc2UgRGljZVwiLFxuICAgIHR5cGU6IFwiZDZcIixcbiAgICBsYWJlbHM6IFtcInNcIiwgXCJzXCIsIFwic1wiLCBcImRcIiwgXCJcIiwgXCJcIl0sXG4gICAgdmFsdWVzOiBbMSwgNl0sXG4gICAgc2NhbGU6IDAuOSxcbiAgICBmb250OiBcIkxlZ2lvbi1TeW1ib2wtUmVndWxhclwiLFxuICAgIGNvbG9yOiBcIiNGRjAwMDBcIixcbiAgICBjb2xvcnNldDogXCJzd2xfZGVmcmVkXCIsXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwibGVnaW9uXCJcbiAgfSxcbiAgc3dsZHc6IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBMZWdpb246IFdoaXRlIERlZmVuc2UgRGljZVwiLFxuICAgIHR5cGU6IFwiZDZcIixcbiAgICBsYWJlbHM6IFtcInNcIiwgXCJcIiwgXCJcIiwgXCJkXCIsIFwiXCIsIFwiXCJdLFxuICAgIHZhbHVlczogWzEsIDZdLFxuICAgIHNjYWxlOiAwLjksXG4gICAgZm9udDogXCJMZWdpb24tU3ltYm9sLVJlZ3VsYXJcIixcbiAgICBjb2xvcjogXCIjRkZGRkZGXCIsXG4gICAgY29sb3JzZXQ6IFwic3dsX2RlZndoaXRlXCIsXG4gICAgZGlzcGxheTogXCJsYWJlbHNcIixcbiAgICBzeXN0ZW06IFwibGVnaW9uXCJcbiAgfVxufSwgd3QgPSB7XG4gIGQ0OiB7XG4gICAgdmVydGljZXM6IFtbMSwgMSwgMV0sIFstMSwgLTEsIDFdLCBbLTEsIDEsIC0xXSwgWzEsIC0xLCAtMV1dLFxuICAgIGZhY2VzOiBbWzEsIDAsIDIsIDFdLCBbMCwgMSwgMywgMl0sIFswLCAzLCAyLCAzXSwgWzEsIDIsIDMsIDRdXVxuICB9LFxuICBkNjoge1xuICAgIHZlcnRpY2VzOiBbWy0xLCAtMSwgLTFdLCBbMSwgLTEsIC0xXSwgWzEsIDEsIC0xXSwgWy0xLCAxLCAtMV0sIFstMSwgLTEsIDFdLCBbMSwgLTEsIDFdLCBbMSwgMSwgMV0sIFstMSwgMSwgMV1dLFxuICAgIGZhY2VzOiBbWzAsIDMsIDIsIDEsIDFdLCBbMSwgMiwgNiwgNSwgMl0sIFswLCAxLCA1LCA0LCAzXSwgWzMsIDcsIDYsIDIsIDRdLCBbMCwgNCwgNywgMywgNV0sIFs0LCA1LCA2LCA3LCA2XV1cbiAgfSxcbiAgZDg6IHtcbiAgICB2ZXJ0aWNlczogW1sxLCAwLCAwXSwgWy0xLCAwLCAwXSwgWzAsIDEsIDBdLCBbMCwgLTEsIDBdLCBbMCwgMCwgMV0sIFswLCAwLCAtMV1dLFxuICAgIGZhY2VzOiBbWzAsIDIsIDQsIDFdLCBbMCwgNCwgMywgMl0sIFswLCAzLCA1LCAzXSwgWzAsIDUsIDIsIDRdLCBbMSwgMywgNCwgNV0sIFsxLCA0LCAyLCA2XSwgWzEsIDIsIDUsIDddLCBbMSwgNSwgMywgOF1dXG4gIH0sXG4gIGQxMDoge1xuICAgIHZlcnRpY2VzOiBbWzEsIDAsIC0wLjEwNV0sIFswLjgwOSwgMC41ODc3LCAwLjEwNV0sIFswLjMwOSwgMC45NTEsIC0wLjEwNV0sIFstMC4zMDksIDAuOTUxLCAwLjEwNV0sIFstMC44MDksIDAuNTg3NywgLTAuMTA1XSwgWy0xLCAwLCAwLjEwNV0sIFstMC44MDksIC0wLjU4NywgLTAuMTA1XSwgWy0wLjMwOSwgLTAuOTUxLCAwLjEwNV0sIFswLjMwOSwgLTAuOTUxLCAtMC4xMDVdLCBbMC44MDksIC0wLjU4NzcsIDAuMTA1XSwgWzAsIDAsIC0xXSwgWzAsIDAsIDFdXSxcbiAgICBmYWNlczogW1s1LCA2LCA3LCAxMSwgMF0sIFs0LCAzLCAyLCAxMCwgMV0sIFsxLCAyLCAzLCAxMSwgMl0sIFswLCA5LCA4LCAxMCwgM10sIFs3LCA4LCA5LCAxMSwgNF0sIFs4LCA3LCA2LCAxMCwgNV0sIFs5LCAwLCAxLCAxMSwgNl0sIFsyLCAxLCAwLCAxMCwgN10sIFszLCA0LCA1LCAxMSwgOF0sIFs2LCA1LCA0LCAxMCwgOV1dXG4gIH0sXG4gIGQxMjoge1xuICAgIHZlcnRpY2VzOiBbWzAsIDAuNjE4LCAxLjYxOF0sIFswLCAwLjYxOCwgLTEuNjE4XSwgWzAsIC0wLjYxOCwgMS42MThdLCBbMCwgLTAuNjE4LCAtMS42MThdLCBbMS42MTgsIDAsIDAuNjE4XSwgWzEuNjE4LCAwLCAtMC42MThdLCBbLTEuNjE4LCAwLCAwLjYxOF0sIFstMS42MTgsIDAsIC0wLjYxOF0sIFswLjYxOCwgMS42MTgsIDBdLCBbMC42MTgsIC0xLjYxOCwgMF0sIFstMC42MTgsIDEuNjE4LCAwXSwgWy0wLjYxOCwgLTEuNjE4LCAwXSwgWzEsIDEsIDFdLCBbMSwgMSwgLTFdLCBbMSwgLTEsIDFdLCBbMSwgLTEsIC0xXSwgWy0xLCAxLCAxXSwgWy0xLCAxLCAtMV0sIFstMSwgLTEsIDFdLCBbLTEsIC0xLCAtMV1dLFxuICAgIGZhY2VzOiBbWzIsIDE0LCA0LCAxMiwgMCwgMV0sIFsxNSwgOSwgMTEsIDE5LCAzLCAyXSwgWzE2LCAxMCwgMTcsIDcsIDYsIDNdLCBbNiwgNywgMTksIDExLCAxOCwgNF0sIFs2LCAxOCwgMiwgMCwgMTYsIDVdLCBbMTgsIDExLCA5LCAxNCwgMiwgNl0sIFsxLCAxNywgMTAsIDgsIDEzLCA3XSwgWzEsIDEzLCA1LCAxNSwgMywgOF0sIFsxMywgOCwgMTIsIDQsIDUsIDldLCBbNSwgNCwgMTQsIDksIDE1LCAxMF0sIFswLCAxMiwgOCwgMTAsIDE2LCAxMV0sIFszLCAxOSwgNywgMTcsIDEsIDEyXV1cbiAgfSxcbiAgZDIwOiB7XG4gICAgdmVydGljZXM6IFtbLTEsIDEuNjE4LCAwXSwgWzEsIDEuNjE4LCAwXSwgWy0xLCAtMS42MTgsIDBdLCBbMSwgLTEuNjE4LCAwXSwgWzAsIC0xLCAxLjYxOF0sIFswLCAxLCAxLjYxOF0sIFswLCAtMSwgLTEuNjE4XSwgWzAsIDEsIC0xLjYxOF0sIFsxLjYxOCwgMCwgLTFdLCBbMS42MTgsIDAsIDFdLCBbLTEuNjE4LCAwLCAtMV0sIFstMS42MTgsIDAsIDFdXSxcbiAgICBmYWNlczogW1swLCAxMSwgNSwgMV0sIFswLCA1LCAxLCAyXSwgWzAsIDEsIDcsIDNdLCBbMCwgNywgMTAsIDRdLCBbMCwgMTAsIDExLCA1XSwgWzEsIDUsIDksIDZdLCBbNSwgMTEsIDQsIDddLCBbMTEsIDEwLCAyLCA4XSwgWzEwLCA3LCA2LCA5XSwgWzcsIDEsIDgsIDEwXSwgWzMsIDksIDQsIDExXSwgWzMsIDQsIDIsIDEyXSwgWzMsIDIsIDYsIDEzXSwgWzMsIDYsIDgsIDE0XSwgWzMsIDgsIDksIDE1XSwgWzQsIDksIDUsIDE2XSwgWzIsIDQsIDExLCAxN10sIFs2LCAyLCAxMCwgMThdLCBbOCwgNiwgNywgMTldLCBbOSwgOCwgMSwgMjBdXVxuICB9XG59LCB4cCA9IHtcbiAgbmFtZTogXCJcIixcbiAgc2NhbGU6IDEsXG4gIGZvbnQ6IFwiQXJpYWxcIixcbiAgY29sb3I6IFwiXCIsXG4gIGxhYmVsczogW10sXG4gIHZhbHVlTWFwOiBbXSxcbiAgdmFsdWVzOiBbXSxcbiAgbm9ybWFsczogW10sXG4gIG1hc3M6IDMwMCxcbiAgaW5lcnRpYTogMTMsXG4gIGdlb21ldHJ5OiBudWxsLFxuICBkaXNwbGF5OiBcInZhbHVlc1wiLFxuICBzeXN0ZW06IFwiZDIwXCJcbn07XG5jbGFzcyB5cCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBpZiAoIVBzLmhhc093blByb3BlcnR5KGUpKVxuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJkaWNlIHR5cGUgdW5hdmFpbGFibGVcIik7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB4cCwgUHNbZV0pLCB0aGlzLnNoYXBlID0gUHNbZV0udHlwZSB8fCBlLCB0aGlzLnR5cGUgPSBlLCB0aGlzLnNldExhYmVscyh0aGlzLmxhYmVscyksIHRoaXMuc2V0VmFsdWVzKHRoaXMudmFsdWVzWzBdLCB0aGlzLnZhbHVlc1sxXSwgdGhpcy52YWx1ZXNbMl0pLCB0aGlzLnNldFZhbHVlTWFwKHRoaXMudmFsdWVNYXApLCB0aGlzLmJ1bXBNYXBzICYmIHRoaXMuc2V0QnVtcE1hcHModGhpcy5idW1wTWFwcyk7XG4gIH1cbiAgc2V0VmFsdWVzKGUgPSAxLCB0ID0gMjAsIG4gPSAxKSB7XG4gICAgdGhpcy52YWx1ZXMgPSB0aGlzLnJhbmdlKGUsIHQsIG4pO1xuICB9XG4gIHNldFZhbHVlTWFwKGUpIHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMudmFsdWVzLmxlbmd0aDsgdCsrKSB7XG4gICAgICBsZXQgbiA9IHRoaXMudmFsdWVzW3RdO1xuICAgICAgZVtuXSAhPSBudWxsICYmICh0aGlzLnZhbHVlTWFwW25dID0gZVtuXSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRmFjZXMoZSwgdCA9IFwibGFiZWxzXCIpIHtcbiAgICBsZXQgbjtcbiAgICBpZiAodCA9PSBcImxhYmVsc1wiID8gbiA9IHRoaXMubGFiZWxzIDogbiA9IHRoaXMubm9ybWFscywgbi51bnNoaWZ0KFwiXCIpLCBbXCJkMlwiLCBcImQxMFwiXS5pbmNsdWRlcyh0aGlzLnNoYXBlKSB8fCBuLnVuc2hpZnQoXCJcIiksIHRoaXMuc2hhcGUgPT0gXCJkNFwiKSB7XG4gICAgICBsZXQgaSA9IGVbMF0sIHMgPSBlWzFdLCBvID0gZVsyXSwgciA9IGVbM107XG4gICAgICB0aGlzLmxhYmVscyA9IFtcbiAgICAgICAgW1tdLCBbMCwgMCwgMF0sIFtzLCByLCBvXSwgW2ksIG8sIHJdLCBbcywgaSwgcl0sIFtpLCBzLCBvXV0sXG4gICAgICAgIFtbXSwgWzAsIDAsIDBdLCBbcywgbywgcl0sIFtvLCBpLCByXSwgW3MsIHIsIGldLCBbbywgcywgaV1dLFxuICAgICAgICBbW10sIFswLCAwLCAwXSwgW3IsIG8sIHNdLCBbbywgciwgaV0sIFtyLCBzLCBpXSwgW28sIGksIHNdXSxcbiAgICAgICAgW1tdLCBbMCwgMCwgMF0sIFtyLCBzLCBvXSwgW2ksIHIsIG9dLCBbciwgaSwgc10sIFtpLCBvLCBzXV1cbiAgICAgIF07XG4gICAgfSBlbHNlXG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShuLCBlKTtcbiAgfVxuICBzZXRMYWJlbHMoZSkge1xuICAgIHRoaXMubG9hZFRleHR1cmVzKGUsIHRoaXMucmVnaXN0ZXJGYWNlcy5iaW5kKHRoaXMpLCBcImxhYmVsc1wiKTtcbiAgfVxuICBzZXRCdW1wTWFwcyhlKSB7XG4gICAgdGhpcy5sb2FkVGV4dHVyZXMoZSwgdGhpcy5yZWdpc3RlckZhY2VzLmJpbmQodGhpcyksIFwiYnVtcFwiKTtcbiAgfVxuICBsb2FkVGV4dHVyZXMoZSwgdCwgbikge1xuICAgIGxldCBpID0gMCwgcyA9IGUubGVuZ3RoLCBvID0gL1xcLihQTkd8SlBHfEdJRnxXRUJQKSQvaSwgciA9IEFycmF5KGUubGVuZ3RoKSwgbCA9ICExO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgczsgYSsrKSB7XG4gICAgICBpZiAoZVthXSA9PSBcIlwiIHx8ICFlW2FdLm1hdGNoKG8pKSB7XG4gICAgICAgIHJbYV0gPSBlW2FdLCArK2k7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbCA9ICEwLCByW2FdID0gbmV3IEltYWdlKCksIHJbYV0ub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICsraSA+PSBzICYmIHQociwgbik7XG4gICAgICB9LCByW2FdLnNyYyA9IGVbYV07XG4gICAgfVxuICAgIGwgfHwgdChyLCBuKTtcbiAgfVxuICByYW5nZShlLCB0LCBuID0gMSkge1xuICAgIGZvciAodmFyIGkgPSBbZV0sIHMgPSBlOyBzIDwgdDsgKVxuICAgICAgaS5wdXNoKHMgKz0gbiB8fCAxKTtcbiAgICByZXR1cm4gaTtcbiAgfVxufVxuY29uc3QgYnAgPSB7XG4gIG5vbmU6IHtcbiAgICBuYW1lOiBcIlBsYXN0aWNcIlxuICB9LFxuICBwZXJmZWN0bWV0YWw6IHtcbiAgICBuYW1lOiBcIlBlcmZlY3QgTWV0YWxcIixcbiAgICBjb2xvcjogMTQ1NDAyNTMsXG4gICAgcm91Z2huZXNzOiAwLFxuICAgIG1ldGFsbmVzczogMSxcbiAgICBlbnZNYXBJbnRlbnNpdHk6IDFcbiAgfSxcbiAgbWV0YWw6IHtcbiAgICBuYW1lOiBcIk1ldGFsXCIsXG4gICAgY29sb3I6IDE0NTQwMjUzLFxuICAgIHJvdWdobmVzczogMC41LFxuICAgIG1ldGFsbmVzczogMC42LFxuICAgIGVudk1hcEludGVuc2l0eTogMVxuICB9LFxuICB3b29kOiB7XG4gICAgbmFtZTogXCJXb29kXCIsXG4gICAgY29sb3I6IDE0NTQwMjUzLFxuICAgIHJvdWdobmVzczogMC45LFxuICAgIG1ldGFsbmVzczogMCxcbiAgICBlbnZNYXBJbnRlbnNpdHk6IDFcbiAgfSxcbiAgZ2xhc3M6IHtcbiAgICBuYW1lOiBcIkdsYXNzXCIsXG4gICAgY29sb3I6IDE0NTQwMjUzLFxuICAgIHJvdWdobmVzczogMC4xLFxuICAgIG1ldGFsbmVzczogMCxcbiAgICBlbnZNYXBJbnRlbnNpdHk6IDFcbiAgfVxufSwgd3AgPSB7XG4gIGJhc2VTY2FsZTogMTAwLFxuICBidW1wTWFwcGluZzogITBcbn0sIFluID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5nZW9tZXRyaWVzID0ge30sIHRoaXMubWF0ZXJpYWxzX2NhY2hlID0ge30sIHRoaXMuY2FjaGVfaGl0cyA9IDAsIHRoaXMuY2FjaGVfbWlzc2VzID0gMCwgdGhpcy5sYWJlbF9jb2xvciA9IFwiXCIsIHRoaXMuZGljZV9jb2xvciA9IFwiXCIsIHRoaXMuZWRnZV9jb2xvciA9IFwiXCIsIHRoaXMubGFiZWxfb3V0bGluZSA9IFwiXCIsIHRoaXMuZGljZV90ZXh0dXJlID0gXCJcIiwgdGhpcy5kaWNlX21hdGVyaWFsID0gXCJcIiwgdGhpcy5tYXRlcmlhbF9vcHRpb25zID0ge1xuICAgICAgc3BlY3VsYXI6IDE2Nzc3MjE1LFxuICAgICAgY29sb3I6IDExOTA4NTMzLFxuICAgICAgc2hpbmluZXNzOiA1LFxuICAgICAgZmxhdFNoYWRpbmc6ICEwXG4gICAgfSwgT2JqZWN0LmFzc2lnbih0aGlzLCB3cCwgZSk7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGUgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZSksIGUuc2NhbGUgJiYgdGhpcy5zY2FsZUdlb21ldHJ5KCk7XG4gIH1cbiAgc2V0QnVtcE1hcHBpbmcoZSkge1xuICAgIHRoaXMuYnVtcE1hcHBpbmcgPSBlLCB0aGlzLm1hdGVyaWFsc19jYWNoZSA9IHt9O1xuICB9XG4gIGNyZWF0ZShlKSB7XG4gICAgbGV0IHQgPSB0aGlzLmdldChlKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbiA9IHRoaXMuZ2VvbWV0cmllc1tlXTtcbiAgICBpZiAobiB8fCAobiA9IHRoaXMuY3JlYXRlR2VvbWV0cnkodC5zaGFwZSwgdC5zY2FsZSAqIHRoaXMuYmFzZVNjYWxlKSwgdGhpcy5nZW9tZXRyaWVzW2VdID0gbiksICFuKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5zZXRNYXRlcmlhbEluZm8oKTtcbiAgICBsZXQgaSA9IG5ldyBOdChuLCB0aGlzLmNyZWF0ZU1hdGVyaWFscyh0LCB0aGlzLmJhc2VTY2FsZSAvIDIsIDEpKTtcbiAgICBzd2l0Y2ggKGkucmVzdWx0ID0gW10sIGkuc2hhcGUgPSB0LnNoYXBlLCBpLnJlcm9sbHMgPSAwLCBpLnJlc3VsdFJlYXNvbiA9IFwibmF0dXJhbFwiLCBpLm1hc3MgPSB0Lm1hc3MsIGkuZ2V0RmFjZVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgcyA9IHRoaXMucmVzdWx0UmVhc29uLCBvID0gbmV3IE8oMCwgMCwgdGhpcy5zaGFwZSA9PSBcImQ0XCIgPyAtMSA6IDEpLCByLCBsID0gTWF0aC5QSSAqIDIsIGEgPSB0aGlzLmdlb21ldHJ5LmdldEF0dHJpYnV0ZShcIm5vcm1hbFwiKS5hcnJheTtcbiAgICAgIGZvciAobGV0IHAgPSAwLCBmID0gdGhpcy5nZW9tZXRyeS5ncm91cHMubGVuZ3RoOyBwIDwgZjsgKytwKSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5nZW9tZXRyeS5ncm91cHNbcF07XG4gICAgICAgIGlmICh2Lm1hdGVyaWFsSW5kZXggPT0gMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IF8gPSBwICogOSwgeCA9IG5ldyBPKGFbX10sIGFbXyArIDFdLCBhW18gKyAyXSkuY2xvbmUoKS5hcHBseVF1YXRlcm5pb24odGhpcy5ib2R5LnF1YXRlcm5pb24pLmFuZ2xlVG8obyk7XG4gICAgICAgIHggPCBsICYmIChsID0geCwgciA9IHYpO1xuICAgICAgfVxuICAgICAgbGV0IGMgPSByLm1hdGVyaWFsSW5kZXggLSAxLCBkID0gMjtcbiAgICAgIGNvbnN0IHUgPSBZbi5kaWNlW3RoaXMubm90YXRpb24udHlwZV07XG4gICAgICBpZiAodGhpcy5zaGFwZSA9PSBcImQ0XCIpIHtcbiAgICAgICAgbGV0IHAgPSBjIC0gMSA9PSAwID8gNSA6IGM7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBjLCBsYWJlbDogdS5sYWJlbHNbYyAtIDFdW3BdWzBdLCByZWFzb246IHMgfTtcbiAgICAgIH1cbiAgICAgIFtcImQxMFwiLCBcImQyXCJdLmluY2x1ZGVzKHRoaXMuc2hhcGUpICYmIChjICs9IDEsIGQgLT0gMSk7XG4gICAgICBsZXQgbSA9IHUudmFsdWVzWyhjIC0gMSkgJSB1LnZhbHVlcy5sZW5ndGhdLCBnID0gdS5sYWJlbHNbKGMgLSAxKSAlICh1LmxhYmVscy5sZW5ndGggLSAyKSArIGRdO1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IG0sIGxhYmVsOiBnLCByZWFzb246IHMgfTtcbiAgICB9LCBpLnN0b3JlUm9sbGVkVmFsdWUgPSBmdW5jdGlvbihzKSB7XG4gICAgICB0aGlzLnJlc3VsdFJlYXNvbiA9IHMgfHwgdGhpcy5yZXN1bHRSZWFzb24sIHRoaXMucmVzdWx0LnB1c2godGhpcy5nZXRGYWNlVmFsdWUoKSk7XG4gICAgfSwgaS5nZXRMYXN0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXN1bHQgfHwgdGhpcy5yZXN1bHQubGVuZ3RoIDwgMSA/IHsgdmFsdWU6IHZvaWQgMCwgbGFiZWw6IFwiXCIsIHJlYXNvbjogXCJcIiB9IDogdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgfSwgaS5pZ25vcmVMYXN0VmFsdWUgPSBmdW5jdGlvbihzKSB7XG4gICAgICBsZXQgbyA9IHRoaXMuZ2V0TGFzdFZhbHVlKCk7XG4gICAgICBvLnZhbHVlICE9PSB2b2lkIDAgJiYgKG8uaWdub3JlID0gcywgdGhpcy5zZXRMYXN0VmFsdWUobykpO1xuICAgIH0sIGkuc2V0TGFzdFZhbHVlID0gZnVuY3Rpb24ocykge1xuICAgICAgaWYgKCEoIXRoaXMucmVzdWx0IHx8IHRoaXMucmVzdWx0Lmxlbmd0aCA8IDEpICYmICEoIXMgfHwgcy5sZW5ndGggPCAxKSlcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDFdID0gcztcbiAgICB9LCB0LmNvbG9yICYmIChpLm1hdGVyaWFsWzBdLmNvbG9yID0gbmV3IEFlKHQuY29sb3IpLCBpLm1hdGVyaWFsWzBdLmVtaXNzaXZlID0gbmV3IEFlKHQuY29sb3IpLCBpLm1hdGVyaWFsWzBdLmVtaXNzaXZlSW50ZW5zaXR5ID0gMSwgaS5tYXRlcmlhbFswXS5uZWVkc1VwZGF0ZSA9ICEwKSwgdC52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmZpeG1hdGVyaWFscyhpLCAxKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4bWF0ZXJpYWxzKGksIDIpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5maXhtYXRlcmlhbHMoaSwgMyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgZ2V0KGUpIHtcbiAgICBsZXQgdDtcbiAgICByZXR1cm4gWW4uZGljZS5oYXNPd25Qcm9wZXJ0eShlKSA/IHQgPSBZbi5kaWNlW2VdIDogKHQgPSBuZXcgeXAoZSksIFluLmRpY2VbZV0gPSB0KSwgdDtcbiAgfVxuICBnZXRHZW9tZXRyeShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cmllc1tlXTtcbiAgfVxuICBzY2FsZUdlb21ldHJ5KCkge1xuICB9XG4gIGNyZWF0ZU1hdGVyaWFscyhlLCB0LCBuLCBpID0gITAsIHMgPSAwKSB7XG4gICAgbGV0IG8gPSBbXSwgciA9IGUubGFiZWxzO1xuICAgIGUuc2hhcGUgPT0gXCJkNFwiICYmIChyID0gZS5sYWJlbHNbc10sIHQgPSB0aGlzLmJhc2VTY2FsZSAvIDIsIG4gPSB0aGlzLmJhc2VTY2FsZSAqIDIpO1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgci5sZW5ndGg7ICsrbCkge1xuICAgICAgdmFyIGE7XG4gICAgICB0aGlzLmRpY2VfbWF0ZXJpYWwgIT0gXCJub25lXCIgPyAoYSA9IG5ldyBVdShicFt0aGlzLmRpY2VfbWF0ZXJpYWxdKSwgYS5lbnZNYXBJbnRlbnNpdHkgPSAwKSA6IGEgPSBuZXcgR3UodGhpcy5tYXRlcmlhbF9vcHRpb25zKTtcbiAgICAgIGxldCBjO1xuICAgICAgaWYgKGwgPT0gMCkge1xuICAgICAgICBsZXQgZCA9IHsgbmFtZTogXCJub25lXCIgfTtcbiAgICAgICAgdGhpcy5kaWNlX3RleHR1cmVfcmFuZC5jb21wb3NpdGUgIT0gXCJzb3VyY2Utb3ZlclwiICYmIChkID0gdGhpcy5kaWNlX3RleHR1cmVfcmFuZCksIGMgPSB0aGlzLmNyZWF0ZVRleHRNYXRlcmlhbChlLCByLCBsLCB0LCBuLCBkLCB0aGlzLmxhYmVsX2NvbG9yX3JhbmQsIHRoaXMubGFiZWxfb3V0bGluZV9yYW5kLCB0aGlzLmVkZ2VfY29sb3JfcmFuZCwgaSksIGEubWFwID0gYy5jb21wb3NpdGU7XG4gICAgICB9IGVsc2UgaWYgKGMgPSB0aGlzLmNyZWF0ZVRleHRNYXRlcmlhbChlLCByLCBsLCB0LCBuLCB0aGlzLmRpY2VfdGV4dHVyZV9yYW5kLCB0aGlzLmxhYmVsX2NvbG9yX3JhbmQsIHRoaXMubGFiZWxfb3V0bGluZV9yYW5kLCB0aGlzLmRpY2VfY29sb3JfcmFuZCwgaSksIGEubWFwID0gYy5jb21wb3NpdGUsIHRoaXMuYnVtcE1hcHBpbmcpIHtcbiAgICAgICAge1xuICAgICAgICAgIGxldCBkID0gMC43NTtcbiAgICAgICAgICB0ID4gMzUgJiYgKGQgPSAxKSwgdCA+IDQwICYmIChkID0gMi41KSwgdCA+IDQ1ICYmIChkID0gNCksIGEuYnVtcFNjYWxlID0gZDtcbiAgICAgICAgfVxuICAgICAgICBjLmJ1bXAgJiYgKGEuYnVtcE1hcCA9IGMuYnVtcCksIGUuc2hhcGUgIT0gXCJkNFwiICYmIGUubm9ybWFsc1tsXSAmJiAoYS5idW1wTWFwID0gbmV3IF90KGUubm9ybWFsc1tsXSksIGEuYnVtcFNjYWxlID0gNCwgYS5idW1wTWFwLm5lZWRzVXBkYXRlID0gITApO1xuICAgICAgfVxuICAgICAgYS5vcGFjaXR5ID0gMSwgYS50cmFuc3BhcmVudCA9ICEwLCBhLmRlcHRoVGVzdCA9ICExLCBhLm5lZWRVcGRhdGUgPSAhMCwgby5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuICBjcmVhdGVUZXh0TWF0ZXJpYWwoZSwgdCwgbiwgaSwgcywgbywgciwgbCwgYSwgYykge1xuICAgIGlmICh0W25dID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBvID0gbyB8fCB0aGlzLmRpY2VfdGV4dHVyZV9yYW5kLCByID0gciB8fCB0aGlzLmxhYmVsX2NvbG9yX3JhbmQsIGwgPSBsIHx8IHRoaXMubGFiZWxfb3V0bGluZV9yYW5kLCBhID0gYSB8fCB0aGlzLmRpY2VfY29sb3JfcmFuZCwgYyA9IGMgPT0gbnVsbCA/ICEwIDogYztcbiAgICBsZXQgZCA9IHRbbl0sIHUgPSAhMSwgbSA9IGQ7XG4gICAgZCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgPyBtID0gZC5zcmMgOiBkIGluc3RhbmNlb2YgQXJyYXkgJiYgZC5mb3JFYWNoKCh5KSA9PiB7XG4gICAgICBtICs9IHkuc3JjO1xuICAgIH0pO1xuICAgIGxldCBnID0gZS50eXBlICsgbSArIG4gKyBvLm5hbWUgKyByICsgbCArIGE7XG4gICAgaWYgKGUuc2hhcGUgPT0gXCJkNFwiICYmIChnID0gZS50eXBlICsgbSArIG8ubmFtZSArIHIgKyBsICsgYSksIGMgJiYgdGhpcy5tYXRlcmlhbHNfY2FjaGVbZ10gIT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlX2hpdHMrKywgdGhpcy5tYXRlcmlhbHNfY2FjaGVbZ107XG4gICAgbGV0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCBmID0gcC5nZXRDb250ZXh0KFwiMmRcIiwgeyBhbHBoYTogITAgfSk7XG4gICAgZi5nbG9iYWxBbHBoYSA9IDAsIGYuY2xlYXJSZWN0KDAsIDAsIHAud2lkdGgsIHAuaGVpZ2h0KTtcbiAgICBsZXQgdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIF8gPSB2LmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiAhMCB9KTtcbiAgICBfLmdsb2JhbEFscGhhID0gMCwgXy5jbGVhclJlY3QoMCwgMCwgdi53aWR0aCwgdi5oZWlnaHQpO1xuICAgIGxldCB3O1xuICAgIGlmIChlLnNoYXBlID09IFwiZDRcIiA/IHcgPSB0aGlzLmNhbGNfdGV4dHVyZV9zaXplKGkgKyBzKSAqIDQgOiB3ID0gdGhpcy5jYWxjX3RleHR1cmVfc2l6ZShpICsgaSAqIDIgKiBzKSAqIDQsIHAud2lkdGggPSBwLmhlaWdodCA9IHcsIHYud2lkdGggPSB2LmhlaWdodCA9IHcsIGYuZmlsbFN0eWxlID0gYSwgZi5maWxsUmVjdCgwLCAwLCBwLndpZHRoLCBwLmhlaWdodCksIF8uZmlsbFN0eWxlID0gXCIjRkZGRkZGXCIsIF8uZmlsbFJlY3QoMCwgMCwgdi53aWR0aCwgdi5oZWlnaHQpLCBvLnRleHR1cmUgJiYgby5uYW1lICE9IFwiXCIgJiYgby5uYW1lICE9IFwibm9uZVwiID8gKGYuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gby5jb21wb3NpdGUgfHwgXCJzb3VyY2Utb3ZlclwiLCBmLmRyYXdJbWFnZShvLnRleHR1cmUsIDAsIDAsIHAud2lkdGgsIHAuaGVpZ2h0KSwgZi5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCIsIG8uYnVtcCAmJiAoXy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCIsIF8uZHJhd0ltYWdlKG8uYnVtcCwgMCwgMCwgcC53aWR0aCwgcC5oZWlnaHQpKSkgOiBmLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIiwgZi5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCIsIGYudGV4dEFsaWduID0gXCJjZW50ZXJcIiwgZi50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCBfLnRleHRBbGlnbiA9IFwiY2VudGVyXCIsIF8udGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgZS5zaGFwZSAhPSBcImQ0XCIpIHtcbiAgICAgIGxldCBBID0ge1xuICAgICAgICBkODogeyBldmVuOiAtNy41LCBvZGQ6IC0xMjcuNSB9LFxuICAgICAgICBkMTA6IHsgYWxsOiAtNiB9LFxuICAgICAgICBkMTI6IHsgYWxsOiA1IH0sXG4gICAgICAgIGQyMDogeyBhbGw6IC03LjUgfVxuICAgICAgfVtlLnNoYXBlXTtcbiAgICAgIGlmIChBKSB7XG4gICAgICAgIGxldCBGO1xuICAgICAgICBpZiAoQS5oYXNPd25Qcm9wZXJ0eShcImFsbFwiKSA/IEYgPSBBLmFsbCA6IG4gPiAwICYmIG4gJSAyICE9IDAgPyBGID0gQS5vZGQgOiBGID0gQS5ldmVuLCBGICYmIEYgIT0gMCkge1xuICAgICAgICAgIHZhciB4ID0gcC53aWR0aCAvIDIsIE0gPSBwLmhlaWdodCAvIDI7XG4gICAgICAgICAgZi50cmFuc2xhdGUoeCwgTSksIGYucm90YXRlKEYgKiAoTWF0aC5QSSAvIDE4MCkpLCBmLnRyYW5zbGF0ZSgteCwgLU0pLCBfLnRyYW5zbGF0ZSh4LCBNKSwgXy5yb3RhdGUoRiAqIChNYXRoLlBJIC8gMTgwKSksIF8udHJhbnNsYXRlKC14LCAtTSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClcbiAgICAgICAgdSA9ICEwLCBmLmRyYXdJbWFnZShkLCAwLCAwLCBkLndpZHRoLCBkLmhlaWdodCwgMCwgMCwgcC53aWR0aCwgcC5oZWlnaHQpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBGID0gdyAvICgxICsgMiAqIHMpLCBQID0gcC5oZWlnaHQgLyAyICsgMTAsIEcgPSBwLndpZHRoIC8gMjtcbiAgICAgICAgZS5zaGFwZSA9PSBcImQxMFwiID8gKEYgPSBGICogMC43NSwgUCA9IFAgKiAxLjE1IC0gMTApIDogZS5zaGFwZSA9PSBcImQyMFwiICYmIChHID0gRyAqIDAuOTgpLCBmLmZvbnQgPSBGICsgXCJwdCBcIiArIGUuZm9udCwgXy5mb250ID0gRiArIFwicHQgXCIgKyBlLmZvbnQ7XG4gICAgICAgIGxldCB6ID0gZi5tZWFzdXJlVGV4dChcIk1cIikud2lkdGggKiAxLjQsIEwgPSBkLnNwbGl0KGBcbmApO1xuICAgICAgICBMLmxlbmd0aCA+IDEgJiYgKEYgPSBGIC8gTC5sZW5ndGgsIGYuZm9udCA9IEYgKyBcInB0IFwiICsgZS5mb250LCBfLmZvbnQgPSBGICsgXCJwdCBcIiArIGUuZm9udCwgeiA9IGYubWVhc3VyZVRleHQoXCJNXCIpLndpZHRoICogMS4yLCBQIC09IHogKiBMLmxlbmd0aCAvIDIpO1xuICAgICAgICBmb3IgKGxldCBJID0gMCwgRCA9IEwubGVuZ3RoOyBJIDwgRDsgSSsrKSB7XG4gICAgICAgICAgbGV0IHEgPSBMW0ldLnRyaW0oKTtcbiAgICAgICAgICBsICE9IFwibm9uZVwiICYmIGwgIT0gYSAmJiAoZi5zdHJva2VTdHlsZSA9IGwsIGYubGluZVdpZHRoID0gNSwgZi5zdHJva2VUZXh0KExbSV0sIEcsIFApLCBfLnN0cm9rZVN0eWxlID0gXCIjMDAwMDAwXCIsIF8ubGluZVdpZHRoID0gNSwgXy5zdHJva2VUZXh0KExbSV0sIEcsIFApLCAocSA9PSBcIjZcIiB8fCBxID09IFwiOVwiKSAmJiAoZi5zdHJva2VUZXh0KFwiICAuXCIsIEcsIFApLCBfLnN0cm9rZVRleHQoXCIgIC5cIiwgRywgUCkpKSwgZi5maWxsU3R5bGUgPSByLCBmLmZpbGxUZXh0KExbSV0sIEcsIFApLCBfLmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiLCBfLmZpbGxUZXh0KExbSV0sIEcsIFApLCAocSA9PSBcIjZcIiB8fCBxID09IFwiOVwiKSAmJiAoZi5maWxsVGV4dChcIiAgLlwiLCBHLCBQKSwgXy5maWxsVGV4dChcIiAgLlwiLCBHLCBQKSksIFAgKz0geiAqIDEuNTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeCA9IHAud2lkdGggLyAyLCBNID0gcC5oZWlnaHQgLyAyO1xuICAgICAgZi5mb250ID0gdyAvIDEyOCAqIDI0ICsgXCJwdCBcIiArIGUuZm9udCwgXy5mb250ID0gdyAvIDEyOCAqIDI0ICsgXCJwdCBcIiArIGUuZm9udDtcbiAgICAgIGZvciAobGV0IEYgPSAwOyBGIDwgZC5sZW5ndGg7IEYrKykge1xuICAgICAgICBpZiAoZFtGXSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICBsZXQgUCA9IGRbRl0ud2lkdGggLyBwLndpZHRoO1xuICAgICAgICAgIGYuZHJhd0ltYWdlKGRbRl0sIDAsIDAsIGRbRl0ud2lkdGgsIGRbRl0uaGVpZ2h0LCAxMDAgLyBQLCAyNSAvIFAsIDYwIC8gUCwgNjAgLyBQKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbCAhPSBcIm5vbmVcIiAmJiBsICE9IGEgJiYgKGYuc3Ryb2tlU3R5bGUgPSBsLCBmLmxpbmVXaWR0aCA9IDUsIGYuc3Ryb2tlVGV4dChkW0ZdLCB4LCBNIC0gdyAqIDAuMyksIF8uc3Ryb2tlU3R5bGUgPSBcIiMwMDAwMDBcIiwgXy5saW5lV2lkdGggPSA1LCBfLnN0cm9rZVRleHQoZFtGXSwgeCwgTSAtIHcgKiAwLjMpKSwgZi5maWxsU3R5bGUgPSByLCBmLmZpbGxUZXh0KGRbRl0sIHgsIE0gLSB3ICogMC4zKSwgXy5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIiwgXy5maWxsVGV4dChkW0ZdLCB4LCBNIC0gdyAqIDAuMyk7XG4gICAgICAgIGYudHJhbnNsYXRlKHgsIE0pLCBmLnJvdGF0ZShNYXRoLlBJICogMiAvIDMpLCBmLnRyYW5zbGF0ZSgteCwgLU0pLCBfLnRyYW5zbGF0ZSh4LCBNKSwgXy5yb3RhdGUoTWF0aC5QSSAqIDIgLyAzKSwgXy50cmFuc2xhdGUoLXgsIC1NKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEUgPSBuZXcgUnIocCksIFI7XG4gICAgcmV0dXJuIHUgPyBSID0gbnVsbCA6IFIgPSBuZXcgUnIodiksIGMgJiYgKHRoaXMuY2FjaGVfbWlzc2VzKyssIHRoaXMubWF0ZXJpYWxzX2NhY2hlW2ddID0geyBjb21wb3NpdGU6IEUsIGJ1bXA6IFIgfSksIHsgY29tcG9zaXRlOiBFLCBidW1wOiBSIH07XG4gIH1cbiAgYXBwbHlDb2xvclNldChlKSB7XG4gICAgdmFyIHQ7XG4gICAgdGhpcy5jb2xvcmRhdGEgPSBlLCB0aGlzLmxhYmVsX2NvbG9yID0gZS5mb3JlZ3JvdW5kLCB0aGlzLmRpY2VfY29sb3IgPSBlLmJhY2tncm91bmQsIHRoaXMubGFiZWxfb3V0bGluZSA9IGUub3V0bGluZSwgdGhpcy5kaWNlX3RleHR1cmUgPSBlLnRleHR1cmUsIHRoaXMuZGljZV9tYXRlcmlhbCA9ICgodCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudGV4dHVyZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQubWF0ZXJpYWwpIHx8IFwibm9uZVwiLCB0aGlzLmVkZ2VfY29sb3IgPSBlLmhhc093blByb3BlcnR5KFwiZWRnZVwiKSA/IGUuZWRnZSA6IGUuYmFja2dyb3VuZDtcbiAgfVxuICBzZXRNYXRlcmlhbEluZm8oZSA9IFwiXCIpIHtcbiAgICBsZXQgdCA9IHRoaXMuY29sb3JkYXRhLCBuID0gdGhpcy5kaWNlX3RleHR1cmUsIGkgPSB0aGlzLmRpY2VfbWF0ZXJpYWw7XG4gICAgaWYgKHRoaXMuZGljZV9jb2xvcl9yYW5kID0gXCJcIiwgdGhpcy5sYWJlbF9jb2xvcl9yYW5kID0gXCJcIiwgdGhpcy5sYWJlbF9vdXRsaW5lX3JhbmQgPSBcIlwiLCB0aGlzLmRpY2VfdGV4dHVyZV9yYW5kID0gXCJcIiwgdGhpcy5kaWNlX21hdGVyaWFsX3JhbmQgPSBcIlwiLCB0aGlzLmVkZ2VfY29sb3JfcmFuZCA9IFwiXCIsIEFycmF5LmlzQXJyYXkodGhpcy5kaWNlX2NvbG9yKSkge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmRpY2VfY29sb3IubGVuZ3RoKTtcbiAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5sYWJlbF9jb2xvcikgJiYgdGhpcy5sYWJlbF9jb2xvci5sZW5ndGggPT0gdGhpcy5kaWNlX2NvbG9yLmxlbmd0aCAmJiAodGhpcy5sYWJlbF9jb2xvcl9yYW5kID0gdGhpcy5sYWJlbF9jb2xvcltzXSwgQXJyYXkuaXNBcnJheSh0aGlzLmxhYmVsX291dGxpbmUpICYmIHRoaXMubGFiZWxfb3V0bGluZS5sZW5ndGggPT0gdGhpcy5sYWJlbF9jb2xvci5sZW5ndGggJiYgKHRoaXMubGFiZWxfb3V0bGluZV9yYW5kID0gdGhpcy5sYWJlbF9vdXRsaW5lW3NdKSksIEFycmF5LmlzQXJyYXkodGhpcy5kaWNlX3RleHR1cmUpICYmIHRoaXMuZGljZV90ZXh0dXJlLmxlbmd0aCA9PSB0aGlzLmRpY2VfY29sb3IubGVuZ3RoICYmICh0aGlzLmRpY2VfdGV4dHVyZV9yYW5kID0gdGhpcy5kaWNlX3RleHR1cmVbc10sIHRoaXMuZGljZV9tYXRlcmlhbF9yYW5kID0gdGhpcy5kaWNlX3RleHR1cmVfcmFuZC5tYXRlcmlhbCksIEFycmF5LmlzQXJyYXkodGhpcy5lZGdlX2NvbG9yKSAmJiB0aGlzLmVkZ2VfY29sb3IubGVuZ3RoID09IHRoaXMuZGljZV9jb2xvci5sZW5ndGggJiYgKHRoaXMuZWRnZV9jb2xvcl9yYW5kID0gdGhpcy5lZGdlX2NvbG9yW3NdKSwgdGhpcy5kaWNlX2NvbG9yX3JhbmQgPSB0aGlzLmRpY2VfY29sb3Jbc107XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmRpY2VfY29sb3JfcmFuZCA9IHRoaXMuZGljZV9jb2xvcjtcbiAgICBpZiAodGhpcy5lZGdlX2NvbG9yX3JhbmQgPT0gXCJcIilcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZWRnZV9jb2xvcikpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmVkZ2VfY29sb3IubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5lZGdlX2NvbG9yX3JhbmQgPSB0aGlzLmVkZ2VfY29sb3Jbc107XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5lZGdlX2NvbG9yX3JhbmQgPSB0aGlzLmVkZ2VfY29sb3I7XG4gICAgaWYgKHRoaXMubGFiZWxfY29sb3JfcmFuZCA9PSBcIlwiICYmIEFycmF5LmlzQXJyYXkodGhpcy5sYWJlbF9jb2xvcikpIHtcbiAgICAgIHZhciBzID0gdGhpcy5sYWJlbF9jb2xvcltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmxhYmVsX2NvbG9yLmxlbmd0aCldO1xuICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmxhYmVsX291dGxpbmUpICYmIHRoaXMubGFiZWxfb3V0bGluZS5sZW5ndGggPT0gdGhpcy5sYWJlbF9jb2xvci5sZW5ndGggJiYgKHRoaXMubGFiZWxfb3V0bGluZV9yYW5kID0gdGhpcy5sYWJlbF9vdXRsaW5lW3NdKSwgdGhpcy5sYWJlbF9jb2xvcl9yYW5kID0gdGhpcy5sYWJlbF9jb2xvcltzXTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMubGFiZWxfY29sb3JfcmFuZCA9PSBcIlwiICYmICh0aGlzLmxhYmVsX2NvbG9yX3JhbmQgPSB0aGlzLmxhYmVsX2NvbG9yKTtcbiAgICBpZiAodGhpcy5sYWJlbF9vdXRsaW5lX3JhbmQgPT0gXCJcIiAmJiBBcnJheS5pc0FycmF5KHRoaXMubGFiZWxfb3V0bGluZSkpIHtcbiAgICAgIHZhciBzID0gdGhpcy5sYWJlbF9vdXRsaW5lW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMubGFiZWxfb3V0bGluZS5sZW5ndGgpXTtcbiAgICAgIHRoaXMubGFiZWxfb3V0bGluZV9yYW5kID0gdGhpcy5sYWJlbF9vdXRsaW5lW3NdO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5sYWJlbF9vdXRsaW5lX3JhbmQgPT0gXCJcIiAmJiAodGhpcy5sYWJlbF9vdXRsaW5lX3JhbmQgPSB0aGlzLmxhYmVsX291dGxpbmUpO1xuICAgIHRoaXMuZGljZV90ZXh0dXJlX3JhbmQgPT0gXCJcIiAmJiBBcnJheS5pc0FycmF5KHRoaXMuZGljZV90ZXh0dXJlKSA/ICh0aGlzLmRpY2VfdGV4dHVyZV9yYW5kID0gdGhpcy5kaWNlX3RleHR1cmVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5kaWNlX3RleHR1cmUubGVuZ3RoKV0sIHRoaXMuZGljZV9tYXRlcmlhbF9yYW5kID0gdGhpcy5kaWNlX3RleHR1cmVfcmFuZC5tYXRlcmlhbCB8fCB0aGlzLmRpY2VfbWF0ZXJpYWwpIDogdGhpcy5kaWNlX3RleHR1cmVfcmFuZCA9PSBcIlwiICYmICh0aGlzLmRpY2VfdGV4dHVyZV9yYW5kID0gdGhpcy5kaWNlX3RleHR1cmUsIHRoaXMuZGljZV9tYXRlcmlhbF9yYW5kID0gdGhpcy5kaWNlX3RleHR1cmVfcmFuZC5tYXRlcmlhbCB8fCB0aGlzLmRpY2VfbWF0ZXJpYWwpLCB0aGlzLmRpY2VfbWF0ZXJpYWxfcmFuZCA9PSBcIlwiICYmIEFycmF5LmlzQXJyYXkodGhpcy5kaWNlX21hdGVyaWFsKSA/IHRoaXMuZGljZV9tYXRlcmlhbF9yYW5kID0gdGhpcy5kaWNlX21hdGVyaWFsW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuZGljZV9tYXRlcmlhbC5sZW5ndGgpXSA6IHRoaXMuZGljZV9tYXRlcmlhbF9yYW5kID09IFwiXCIgJiYgKHRoaXMuZGljZV9tYXRlcmlhbF9yYW5kID0gdGhpcy5kaWNlX21hdGVyaWFsKSwgdGhpcy5jb2xvcmRhdGEgJiYgdGhpcy5jb2xvcmRhdGEuaWQgIT0gdC5pZCAmJiB0aGlzLmFwcGx5Q29sb3JTZXQodCwgbiwgaSk7XG4gIH1cbiAgY2FsY190ZXh0dXJlX3NpemUoZSkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKGUpIC8gTWF0aC5sb2coMikpKTtcbiAgfVxuICBjcmVhdGVHZW9tZXRyeShlLCB0LCBuID0gITEpIHtcbiAgICBjb25zdCBpID0gbiA/IFwiY3JlYXRlX3NoYXBlXCIgOiBcImNyZWF0ZV9nZW9tXCI7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwiZDJcIjpcbiAgICAgICAgdmFyIHMgPSBuZXcga3MoMSAqIHQsIDEgKiB0LCAwLjEgKiB0LCAzMik7XG4gICAgICAgIHJldHVybiBzLmNhbm5vbl9zaGFwZSA9IG5ldyBqZCgxICogdCwgMSAqIHQsIDAuMSAqIHQsIDgpLCBzO1xuICAgICAgY2FzZSBcImQ0XCI6XG4gICAgICAgIHJldHVybiB0aGlzW2ldKHd0LmQ0LnZlcnRpY2VzLCB3dC5kNC5mYWNlcywgdCwgLTAuMSwgTWF0aC5QSSAqIDcgLyA2LCAwLjk2KTtcbiAgICAgIGNhc2UgXCJkNlwiOlxuICAgICAgICByZXR1cm4gdGhpc1tpXSh3dC5kNi52ZXJ0aWNlcywgd3QuZDYuZmFjZXMsIHQsIDAuMSwgTWF0aC5QSSAvIDQsIDAuOTYpO1xuICAgICAgY2FzZSBcImQ4XCI6XG4gICAgICAgIHJldHVybiB0aGlzW2ldKHd0LmQ4LnZlcnRpY2VzLCB3dC5kOC5mYWNlcywgdCwgMCwgLU1hdGguUEkgLyA0IC8gMiwgMC45NjUpO1xuICAgICAgY2FzZSBcImQxMFwiOlxuICAgICAgICByZXR1cm4gdGhpc1tpXSh3dC5kMTAudmVydGljZXMsIHd0LmQxMC5mYWNlcywgdCwgMC4zLCBNYXRoLlBJLCAwLjk0NSk7XG4gICAgICBjYXNlIFwiZDEyXCI6XG4gICAgICAgIHJldHVybiB0aGlzW2ldKHd0LmQxMi52ZXJ0aWNlcywgd3QuZDEyLmZhY2VzLCB0LCAwLjIsIC1NYXRoLlBJIC8gNCAvIDIsIDAuOTY4KTtcbiAgICAgIGNhc2UgXCJkMjBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXNbaV0od3QuZDIwLnZlcnRpY2VzLCB3dC5kMjAuZmFjZXMsIHQsIC0wLjIsIC1NYXRoLlBJIC8gNCAvIDIsIDAuOTU1KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBHZW9tZXRyeSBmb3IgJHtlfSBpcyBub3QgYXZhaWxhYmxlYCksIG51bGw7XG4gICAgfVxuICB9XG4gIGZpeG1hdGVyaWFscyhlLCB0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHMgPSBlLmdlb21ldHJ5Lmdyb3Vwcy5sZW5ndGg7IGkgPCBzOyArK2kpIHtcbiAgICAgIHZhciBuID0gZS5nZW9tZXRyeS5ncm91cHNbaV0ubWF0ZXJpYWxJbmRleCAtIDI7XG4gICAgICBpZiAobiA8IHQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGV0IG8gPSBuICUgdDtcbiAgICAgIGUuZ2VvbWV0cnkuZ3JvdXBzW2ldLm1hdGVyaWFsSW5kZXggPSBvICsgMjtcbiAgICB9XG4gICAgcmV0dXJuIGUuZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gITAsIGU7XG4gIH1cbiAgY3JlYXRlX3NoYXBlKGUsIHQsIG4pIHtcbiAgICBmb3IgKHZhciBpID0gbmV3IEFycmF5KGUubGVuZ3RoKSwgcyA9IDA7IHMgPCBlLmxlbmd0aDsgKytzKVxuICAgICAgaVtzXSA9IG5ldyBPKCkuZnJvbUFycmF5KGVbc10pLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAodmFyIG8gPSBuZXcgQXJyYXkoZS5sZW5ndGgpLCByID0gbmV3IEFycmF5KHQubGVuZ3RoKSwgcyA9IDA7IHMgPCBpLmxlbmd0aDsgKytzKSB7XG4gICAgICB2YXIgbCA9IGlbc107XG4gICAgICBvW3NdID0gbmV3IGIobC54ICogbiwgbC55ICogbiwgbC56ICogbik7XG4gICAgfVxuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdC5sZW5ndGg7ICsrcylcbiAgICAgIHJbc10gPSB0W3NdLnNsaWNlKDAsIHRbc10ubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIG5ldyB3bih7IHZlcnRpY2VzOiBvLCBmYWNlczogciB9KTtcbiAgfVxuICBtYWtlX2dlb20oZSwgdCwgbiwgaSwgcykge1xuICAgIGxldCBvID0gbmV3IFV0KCk7XG4gICAgZm9yIChsZXQgZyA9IDA7IGcgPCBlLmxlbmd0aDsgKytnKVxuICAgICAgZVtnXSA9IGVbZ10ubXVsdGlwbHlTY2FsYXIobik7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBjb25zdCBsID0gW10sIGEgPSBbXSwgYyA9IG5ldyBPKCksIGQgPSBuZXcgTygpO1xuICAgIGxldCB1LCBtID0gMDtcbiAgICBmb3IgKGxldCBnID0gMDsgZyA8IHQubGVuZ3RoOyArK2cpIHtcbiAgICAgIGxldCBwID0gdFtnXSwgZiA9IHAubGVuZ3RoIC0gMSwgdiA9IE1hdGguUEkgKiAyIC8gZjtcbiAgICAgIHUgPSBwW2ZdICsgMTtcbiAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgZiAtIDI7ICsrdylcbiAgICAgICAgci5wdXNoKC4uLmVbcFswXV0udG9BcnJheSgpKSwgci5wdXNoKC4uLmVbcFt3ICsgMV1dLnRvQXJyYXkoKSksIHIucHVzaCguLi5lW3BbdyArIDJdXS50b0FycmF5KCkpLCBjLnN1YlZlY3RvcnMoZVtwW3cgKyAyXV0sIGVbcFt3ICsgMV1dKSwgZC5zdWJWZWN0b3JzKGVbcFswXV0sIGVbcFt3ICsgMV1dKSwgYy5jcm9zcyhkKSwgYy5ub3JtYWxpemUoKSwgbC5wdXNoKC4uLmMudG9BcnJheSgpKSwgbC5wdXNoKC4uLmMudG9BcnJheSgpKSwgbC5wdXNoKC4uLmMudG9BcnJheSgpKSwgYS5wdXNoKChNYXRoLmNvcyhzKSArIDEgKyBpKSAvIDIgLyAoMSArIGkpLCAoTWF0aC5zaW4ocykgKyAxICsgaSkgLyAyIC8gKDEgKyBpKSksIGEucHVzaCgoTWF0aC5jb3ModiAqICh3ICsgMSkgKyBzKSArIDEgKyBpKSAvIDIgLyAoMSArIGkpLCAoTWF0aC5zaW4odiAqICh3ICsgMSkgKyBzKSArIDEgKyBpKSAvIDIgLyAoMSArIGkpKSwgYS5wdXNoKChNYXRoLmNvcyh2ICogKHcgKyAyKSArIHMpICsgMSArIGkpIC8gMiAvICgxICsgaSksIChNYXRoLnNpbih2ICogKHcgKyAyKSArIHMpICsgMSArIGkpIC8gMiAvICgxICsgaSkpO1xuICAgICAgbGV0IF8gPSAoZiAtIDIpICogMztcbiAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgXyAvIDM7IHcrKylcbiAgICAgICAgby5hZGRHcm91cChtLCAzLCB1KSwgbSArPSAzO1xuICAgIH1cbiAgICByZXR1cm4gby5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgc3QociwgMykpLCBvLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgc3QobCwgMykpLCBvLnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBzdChhLCAyKSksIG8uYm91bmRpbmdTcGhlcmUgPSBuZXcgY2kobmV3IE8oKSwgbiksIG87XG4gIH1cbiAgbWFrZV9kMTBfZ2VvbShlLCB0LCBuLCBpLCBzKSB7XG4gICAgbGV0IG8gPSBuZXcgVXQoKTtcbiAgICBmb3IgKGxldCB3ID0gMDsgdyA8IGUubGVuZ3RoOyArK3cpXG4gICAgICBlW3ddID0gZVt3XS5tdWx0aXBseVNjYWxhcihuKTtcbiAgICBsZXQgciA9IFtdO1xuICAgIGNvbnN0IGwgPSBbXSwgYSA9IFtdLCBjID0gbmV3IE8oKSwgZCA9IG5ldyBPKCk7XG4gICAgbGV0IHUsIG0gPSAwO1xuICAgIGZvciAobGV0IHcgPSAwOyB3IDwgdC5sZW5ndGg7ICsrdykge1xuICAgICAgbGV0IHggPSB0W3ddLCBNID0geC5sZW5ndGggLSAxLCBFID0gTWF0aC5QSSAqIDIgLyBNO1xuICAgICAgdSA9IHhbTV0gKyAxO1xuICAgICAgdmFyIGcgPSAwLjY1LCBwID0gMC44NSwgZiA9IDEgLSAxICogcCwgdiA9IDEgLSAwLjg5NSAvIDEuMTA1ICogcCwgXyA9IDE7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IE0gLSAyOyArK3kpXG4gICAgICAgIHIucHVzaCguLi5lW3hbMF1dLnRvQXJyYXkoKSksIHIucHVzaCguLi5lW3hbeSArIDFdXS50b0FycmF5KCkpLCByLnB1c2goLi4uZVt4W3kgKyAyXV0udG9BcnJheSgpKSwgYy5zdWJWZWN0b3JzKGVbeFt5ICsgMl1dLCBlW3hbeSArIDFdXSksIGQuc3ViVmVjdG9ycyhlW3hbMF1dLCBlW3hbeSArIDFdXSksIGMuY3Jvc3MoZCksIGMubm9ybWFsaXplKCksIGwucHVzaCguLi5jLnRvQXJyYXkoKSksIGwucHVzaCguLi5jLnRvQXJyYXkoKSksIGwucHVzaCguLi5jLnRvQXJyYXkoKSksIHRbd11bdFt3XS5sZW5ndGggLSAxXSA9PSAtMSB8fCB5ID49IDIgPyAoYS5wdXNoKChNYXRoLmNvcyhzKSArIDEgKyBpKSAvIDIgLyAoMSArIGkpLCAoTWF0aC5zaW4ocykgKyAxICsgaSkgLyAyIC8gKDEgKyBpKSksIGEucHVzaCgoTWF0aC5jb3MoRSAqICh5ICsgMSkgKyBzKSArIDEgKyBpKSAvIDIgLyAoMSArIGkpLCAoTWF0aC5zaW4oRSAqICh5ICsgMSkgKyBzKSArIDEgKyBpKSAvIDIgLyAoMSArIGkpKSwgYS5wdXNoKChNYXRoLmNvcyhFICogKHkgKyAyKSArIHMpICsgMSArIGkpIC8gMiAvICgxICsgaSksIChNYXRoLnNpbihFICogKHkgKyAyKSArIHMpICsgMSArIGkpIC8gMiAvICgxICsgaSkpKSA6IHkgPT0gMCA/IChhLnB1c2goMC41IC0gZyAvIDIsIHYpLCBhLnB1c2goMC41LCBmKSwgYS5wdXNoKDAuNSArIGcgLyAyLCB2KSkgOiB5ID09IDEgJiYgKGEucHVzaCgwLjUgLSBnIC8gMiwgdiksIGEucHVzaCgwLjUgKyBnIC8gMiwgdiksIGEucHVzaCgwLjUsIF8pKTtcbiAgICAgIGxldCBSID0gKE0gLSAyKSAqIDM7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IFIgLyAzOyB5KyspXG4gICAgICAgIG8uYWRkR3JvdXAobSwgMywgdSksIG0gKz0gMztcbiAgICB9XG4gICAgcmV0dXJuIG8uc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IHN0KHIsIDMpKSwgby5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbmV3IHN0KGwsIDMpKSwgby5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgc3QoYSwgMikpLCBvLmJvdW5kaW5nU3BoZXJlID0gbmV3IGNpKG5ldyBPKCksIG4pLCBvO1xuICB9XG4gIGNoYW1mZXJfZ2VvbShlLCB0LCBuKSB7XG4gICAgZm9yICh2YXIgaSA9IFtdLCBzID0gW10sIG8gPSBuZXcgQXJyYXkoZS5sZW5ndGgpLCByID0gMDsgciA8IGUubGVuZ3RoOyArK3IpXG4gICAgICBvW3JdID0gW107XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgKytyKSB7XG4gICAgICBmb3IgKHZhciBsID0gdFtyXSwgYSA9IGwubGVuZ3RoIC0gMSwgYyA9IG5ldyBPKCksIGQgPSBuZXcgQXJyYXkoYSksIHUgPSAwOyB1IDwgYTsgKyt1KSB7XG4gICAgICAgIHZhciBtID0gZVtsW3VdXS5jbG9uZSgpO1xuICAgICAgICBjLmFkZChtKSwgb1tsW3VdXS5wdXNoKGRbdV0gPSBpLnB1c2gobSkgLSAxKTtcbiAgICAgIH1cbiAgICAgIGMuZGl2aWRlU2NhbGFyKGEpO1xuICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBhOyArK3UpIHtcbiAgICAgICAgdmFyIG0gPSBpW2RbdV1dO1xuICAgICAgICBtLnN1YlZlY3RvcnMobSwgYykubXVsdGlwbHlTY2FsYXIobikuYWRkVmVjdG9ycyhtLCBjKTtcbiAgICAgIH1cbiAgICAgIGQucHVzaChsW2FdKSwgcy5wdXNoKGQpO1xuICAgIH1cbiAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoIC0gMTsgKytyKVxuICAgICAgZm9yICh2YXIgdSA9IHIgKyAxOyB1IDwgdC5sZW5ndGg7ICsrdSkge1xuICAgICAgICBmb3IgKHZhciBnID0gW10sIHAgPSAtMSwgZiA9IDA7IGYgPCB0W3JdLmxlbmd0aCAtIDE7ICsrZikge1xuICAgICAgICAgIHZhciB2ID0gdFt1XS5pbmRleE9mKHRbcl1bZl0pO1xuICAgICAgICAgIHYgPj0gMCAmJiB2IDwgdFt1XS5sZW5ndGggLSAxICYmIChwID49IDAgJiYgZiAhPSBwICsgMSA/IGcudW5zaGlmdChbciwgZl0sIFt1LCB2XSkgOiBnLnB1c2goW3IsIGZdLCBbdSwgdl0pLCBwID0gZik7XG4gICAgICAgIH1cbiAgICAgICAgZy5sZW5ndGggPT0gNCAmJiBzLnB1c2goW1xuICAgICAgICAgIHNbZ1swXVswXV1bZ1swXVsxXV0sXG4gICAgICAgICAgc1tnWzFdWzBdXVtnWzFdWzFdXSxcbiAgICAgICAgICBzW2dbM11bMF1dW2dbM11bMV1dLFxuICAgICAgICAgIHNbZ1syXVswXV1bZ1syXVsxXV0sXG4gICAgICAgICAgLTFcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBvLmxlbmd0aDsgKytyKSB7XG4gICAgICBmb3IgKHZhciBfID0gb1tyXSwgZCA9IFtfWzBdXSwgdyA9IF8ubGVuZ3RoIC0gMTsgdzsgKSB7XG4gICAgICAgIGZvciAodmFyIGYgPSB0Lmxlbmd0aDsgZiA8IHMubGVuZ3RoOyArK2YpIHtcbiAgICAgICAgICB2YXIgeCA9IHNbZl0uaW5kZXhPZihkW2QubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIGlmICh4ID49IDAgJiYgeCA8IDQpIHtcbiAgICAgICAgICAgIC0teCA9PSAtMSAmJiAoeCA9IDMpO1xuICAgICAgICAgICAgdmFyIE0gPSBzW2ZdW3hdO1xuICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihNKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGQucHVzaChNKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC0tdztcbiAgICAgIH1cbiAgICAgIGQucHVzaCgtMSksIHMucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmVjdG9yczogaSwgZmFjZXM6IHMgfTtcbiAgfVxuICBjcmVhdGVfZ2VvbShlLCB0LCBuLCBpLCBzLCBvKSB7XG4gICAgZm9yICh2YXIgciA9IG5ldyBBcnJheShlLmxlbmd0aCksIGwgPSAwOyBsIDwgZS5sZW5ndGg7ICsrbClcbiAgICAgIHJbbF0gPSBuZXcgTygpLmZyb21BcnJheShlW2xdKS5ub3JtYWxpemUoKTtcbiAgICB2YXIgYSA9IHRoaXMuY2hhbWZlcl9nZW9tKHIsIHQsIG8pO1xuICAgIGlmICh0Lmxlbmd0aCAhPSAxMClcbiAgICAgIHZhciBjID0gdGhpcy5tYWtlX2dlb20oYS52ZWN0b3JzLCBhLmZhY2VzLCBuLCBpLCBzKTtcbiAgICBlbHNlXG4gICAgICB2YXIgYyA9IHRoaXMubWFrZV9kMTBfZ2VvbShhLnZlY3RvcnMsIGEuZmFjZXMsIG4sIGksIHMpO1xuICAgIHJldHVybiBjLmNhbm5vbl9zaGFwZSA9IHRoaXMuY3JlYXRlX3NoYXBlKGUsIHQsIG4pLCBjLm5hbWUgPSBcImRcIiArIHQubGVuZ3RoLCBjO1xuICB9XG59O1xubGV0IEhpID0gWW47XG5ZcyhIaSwgXCJkaWNlXCIsIHt9KTtcbmNvbnN0IElzID0ge1xuICBjbG91ZHk6IHtcbiAgICBuYW1lOiBcIkNsb3VkcyAoVHJhbnNwYXJlbnQpXCIsXG4gICAgY29tcG9zaXRlOiBcImRlc3RpbmF0aW9uLWluXCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL2Nsb3VkeS53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwidGV4dHVyZXMvY2xvdWR5LmFsdC53ZWJwXCJcbiAgfSxcbiAgY2xvdWR5XzI6IHtcbiAgICBuYW1lOiBcIkNsb3Vkc1wiLFxuICAgIGNvbXBvc2l0ZTogXCJtdWx0aXBseVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9jbG91ZHkuYWx0LndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9jbG91ZHkuYWx0LndlYnBcIlxuICB9LFxuICBmaXJlOiB7XG4gICAgbmFtZTogXCJGaXJlXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL2ZpcmUud2VicFwiLFxuICAgIHNvdXJjZV9idW1wOiBcInRleHR1cmVzL2ZpcmUud2VicFwiLFxuICAgIG1hdGVyaWFsOiBcIm1ldGFsXCJcbiAgfSxcbiAgbWFyYmxlOiB7XG4gICAgbmFtZTogXCJNYXJibGVcIixcbiAgICBjb21wb3NpdGU6IFwibXVsdGlwbHlcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvbWFyYmxlLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJcIixcbiAgICBtYXRlcmlhbDogXCJnbGFzc1wiXG4gIH0sXG4gIHdhdGVyOiB7XG4gICAgbmFtZTogXCJXYXRlclwiLFxuICAgIGNvbXBvc2l0ZTogXCJkZXN0aW5hdGlvbi1pblwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy93YXRlci53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwidGV4dHVyZXMvd2F0ZXIud2VicFwiLFxuICAgIG1hdGVyaWFsOiBcImdsYXNzXCJcbiAgfSxcbiAgaWNlOiB7XG4gICAgbmFtZTogXCJJY2VcIixcbiAgICBjb21wb3NpdGU6IFwiZGVzdGluYXRpb24taW5cIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvaWNlLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9pY2Uud2VicFwiLFxuICAgIG1hdGVyaWFsOiBcImdsYXNzXCJcbiAgfSxcbiAgcGFwZXI6IHtcbiAgICBuYW1lOiBcIlBhcGVyXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL3BhcGVyLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9wYXBlci1idW1wLndlYnBcIixcbiAgICBtYXRlcmlhbDogXCJ3b29kXCJcbiAgfSxcbiAgc3BlY2tsZXM6IHtcbiAgICBuYW1lOiBcIlNwZWNrbGVzXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL3NwZWNrbGVzLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9zcGVja2xlcy53ZWJwXCIsXG4gICAgbWF0ZXJpYWw6IFwibm9uZVwiXG4gIH0sXG4gIGdsaXR0ZXI6IHtcbiAgICBuYW1lOiBcIkdsaXR0ZXJcIixcbiAgICBjb21wb3NpdGU6IFwibXVsdGlwbHlcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvZ2xpdHRlci53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwidGV4dHVyZXMvZ2xpdHRlci1idW1wLndlYnBcIixcbiAgICBtYXRlcmlhbDogXCJub25lXCJcbiAgfSxcbiAgZ2xpdHRlcl8yOiB7XG4gICAgbmFtZTogXCJHbGl0dGVyIChUcmFuc3BhcmVudClcIixcbiAgICBjb21wb3NpdGU6IFwiZGVzdGluYXRpb24taW5cIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvZ2xpdHRlci1hbHBoYS53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibm9uZVwiXG4gIH0sXG4gIHN0YXJzOiB7XG4gICAgbmFtZTogXCJTdGFyc1wiLFxuICAgIGNvbXBvc2l0ZTogXCJtdWx0aXBseVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9zdGFycy53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwidGV4dHVyZXMvc3RhcnMud2VicFwiLFxuICAgIG1hdGVyaWFsOiBcIm5vbmVcIlxuICB9LFxuICBzdGFpbmVkZ2xhc3M6IHtcbiAgICBuYW1lOiBcIlN0YWluZWQgR2xhc3NcIixcbiAgICBjb21wb3NpdGU6IFwibXVsdGlwbHlcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvc3RhaW5lZGdsYXNzLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9zdGFpbmVkZ2xhc3MtYnVtcC53ZWJwXCIsXG4gICAgbWF0ZXJpYWw6IFwiZ2xhc3NcIlxuICB9LFxuICB3b29kOiB7XG4gICAgbmFtZTogXCJXb29kXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL3dvb2Qud2VicFwiLFxuICAgIHNvdXJjZV9idW1wOiBcInRleHR1cmVzL3dvb2Qud2VicFwiLFxuICAgIG1hdGVyaWFsOiBcIndvb2RcIlxuICB9LFxuICBtZXRhbDoge1xuICAgIG5hbWU6IFwiU3RhaW5sZXNzIFN0ZWVsXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL21ldGFsLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9tZXRhbC1idW1wLndlYnBcIixcbiAgICBtYXRlcmlhbDogXCJtZXRhbFwiXG4gIH0sXG4gIHNrdWxsczoge1xuICAgIG5hbWU6IFwiU2t1bGxzXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL3NrdWxscy53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwidGV4dHVyZXMvc2t1bGxzLndlYnBcIlxuICB9LFxuICBsZW9wYXJkOiB7XG4gICAgbmFtZTogXCJMZW9wYXJkXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL2xlb3BhcmQud2VicFwiLFxuICAgIHNvdXJjZV9idW1wOiBcInRleHR1cmVzL2xlb3BhcmQud2VicFwiLFxuICAgIG1hdGVyaWFsOiBcIndvb2RcIlxuICB9LFxuICB0aWdlcjoge1xuICAgIG5hbWU6IFwiVGlnZXJcIixcbiAgICBjb21wb3NpdGU6IFwibXVsdGlwbHlcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvdGlnZXIud2VicFwiLFxuICAgIHNvdXJjZV9idW1wOiBcInRleHR1cmVzL3RpZ2VyLndlYnBcIixcbiAgICBtYXRlcmlhbDogXCJ3b29kXCJcbiAgfSxcbiAgY2hlZXRhaDoge1xuICAgIG5hbWU6IFwiQ2hlZXRhaFwiLFxuICAgIGNvbXBvc2l0ZTogXCJtdWx0aXBseVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9jaGVldGFoLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9jaGVldGFoLndlYnBcIixcbiAgICBtYXRlcmlhbDogXCJ3b29kXCJcbiAgfSxcbiAgZHJhZ29uOiB7XG4gICAgbmFtZTogXCJEcmFnb25cIixcbiAgICBjb21wb3NpdGU6IFwibXVsdGlwbHlcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvZHJhZ29uLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9kcmFnb24tYnVtcC53ZWJwXCIsXG4gICAgbWF0ZXJpYWw6IFwibm9uZVwiXG4gIH0sXG4gIGxpemFyZDoge1xuICAgIG5hbWU6IFwiTGl6YXJkXCIsXG4gICAgY29tcG9zaXRlOiBcIm11bHRpcGx5XCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL2xpemFyZC53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwidGV4dHVyZXMvbGl6YXJkLndlYnBcIixcbiAgICBtYXRlcmlhbDogXCJub25lXCJcbiAgfSxcbiAgYmlyZDoge1xuICAgIG5hbWU6IFwiQmlyZFwiLFxuICAgIGNvbXBvc2l0ZTogXCJtdWx0aXBseVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9mZWF0aGVyLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9mZWF0aGVyLWJ1bXAud2VicFwiLFxuICAgIG1hdGVyaWFsOiBcIndvb2RcIlxuICB9LFxuICBhc3RyYWw6IHtcbiAgICBuYW1lOiBcIkFzdHJhbCBTZWFcIixcbiAgICBjb21wb3NpdGU6IFwibXVsdGlwbHlcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvYXN0cmFsLndlYnBcIixcbiAgICBzb3VyY2VfYnVtcDogXCJ0ZXh0dXJlcy9zdGFycy53ZWJwXCIsXG4gICAgbWF0ZXJpYWw6IFwibm9uZVwiXG4gIH0sXG4gIGFjbGVhZjoge1xuICAgIG5hbWU6IFwiQUMgTGVhZlwiLFxuICAgIGNvbXBvc2l0ZTogXCJtdWx0aXBseVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9hY2xlYWYud2VicFwiLFxuICAgIHNvdXJjZV9idW1wOiBcInRleHR1cmVzL2FjbGVhZi53ZWJwXCIsXG4gICAgbWF0ZXJpYWw6IFwibm9uZVwiXG4gIH0sXG4gIHRoZWNhZ2U6IHtcbiAgICBuYW1lOiBcIk5pY2hvbGFzIENhZ2VcIixcbiAgICBjb21wb3NpdGU6IFwibXVsdGlwbHlcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvdGhlY2FnZS53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibWV0YWxcIlxuICB9LFxuICBpc2FiZWxsZToge1xuICAgIG5hbWU6IFwiSXNhYmVsbGVcIixcbiAgICBjb21wb3NpdGU6IFwic291cmNlLW92ZXJcIixcbiAgICBzb3VyY2U6IFwidGV4dHVyZXMvaXNhYmVsbGUud2VicFwiLFxuICAgIHNvdXJjZV9idW1wOiBcIlwiLFxuICAgIG1hdGVyaWFsOiBcIm5vbmVcIlxuICB9LFxuICBicm9uemUwMToge1xuICAgIG5hbWU6IFwiYnJvbnplMDFcIixcbiAgICBjb21wb3NpdGU6IFwiZGlmZmVyZW5jZVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9icm9uemUwMS53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibWV0YWxcIlxuICB9LFxuICBicm9uemUwMjoge1xuICAgIG5hbWU6IFwiYnJvbnplMDJcIixcbiAgICBjb21wb3NpdGU6IFwiZGlmZmVyZW5jZVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9icm9uemUwMi53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibWV0YWxcIlxuICB9LFxuICBicm9uemUwMzoge1xuICAgIG5hbWU6IFwiYnJvbnplMDNcIixcbiAgICBjb21wb3NpdGU6IFwiZGlmZmVyZW5jZVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9icm9uemUwMy53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibWV0YWxcIlxuICB9LFxuICBicm9uemUwM2E6IHtcbiAgICBuYW1lOiBcImJyb256ZTAzYVwiLFxuICAgIGNvbXBvc2l0ZTogXCJkaWZmZXJlbmNlXCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL2Jyb256ZTAzYS53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibWV0YWxcIlxuICB9LFxuICBicm9uemUwM2I6IHtcbiAgICBuYW1lOiBcImJyb256ZTAzYlwiLFxuICAgIGNvbXBvc2l0ZTogXCJkaWZmZXJlbmNlXCIsXG4gICAgc291cmNlOiBcInRleHR1cmVzL2Jyb256ZTAzYi53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibWV0YWxcIlxuICB9LFxuICBicm9uemUwNDoge1xuICAgIG5hbWU6IFwiYnJvbnplMDRcIixcbiAgICBjb21wb3NpdGU6IFwiZGlmZmVyZW5jZVwiLFxuICAgIHNvdXJjZTogXCJ0ZXh0dXJlcy9icm9uemUwNC53ZWJwXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwibWV0YWxcIlxuICB9LFxuICBub25lOiB7XG4gICAgbmFtZTogXCJub25lXCIsXG4gICAgY29tcG9zaXRlOiBcInNvdXJjZS1vdmVyXCIsXG4gICAgc291cmNlOiBcIlwiLFxuICAgIHNvdXJjZV9idW1wOiBcIlwiLFxuICAgIG1hdGVyaWFsOiBcIlwiXG4gIH0sXG4gIFwiXCI6IHtcbiAgICBuYW1lOiBcIn4gUHJlc2V0IH5cIixcbiAgICBjb21wb3NpdGU6IFwic291cmNlLW92ZXJcIixcbiAgICBzb3VyY2U6IFwiXCIsXG4gICAgc291cmNlX2J1bXA6IFwiXCIsXG4gICAgbWF0ZXJpYWw6IFwiXCJcbiAgfVxufSwgZW8gPSB7XG4gIGNvaW5fZGVmYXVsdDoge1xuICAgIG5hbWU6IFwiR29sZCBDb2luXCIsXG4gICAgZGVzY3JpcHRpb246IFwiR29sZCBEcmFnb25oZWFkIENvaW5cIixcbiAgICBjYXRlZ29yeTogXCJPdGhlclwiLFxuICAgIGZvcmVncm91bmQ6IFwiI2Y2YzkyOFwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2Y2YzkyOFwiLFxuICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgIHRleHR1cmU6IFwibWV0YWxcIlxuICB9LFxuICBjb2luX3NpbHZlcjoge1xuICAgIG5hbWU6IFwiU2lsdmVyIENvaW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJHb2xkIERyYWdvbmhlYWQgQ29pblwiLFxuICAgIGNhdGVnb3J5OiBcIk90aGVyXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjZjZjOTI4XCIsXG4gICAgYmFja2dyb3VuZDogXCIjZjZjOTI4XCIsXG4gICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgdGV4dHVyZTogXCJtZXRhbFwiXG4gIH0sXG4gIHJhZGlhbnQ6IHtcbiAgICBuYW1lOiBcIlJhZGlhbnRcIixcbiAgICBjYXRlZ29yeTogXCJEYW1hZ2UgVHlwZXNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNGOUIzMzNcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGRkZcIixcbiAgICBvdXRsaW5lOiBcIlwiLFxuICAgIHRleHR1cmU6IFwicGFwZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJSYWRpYW50XCJcbiAgfSxcbiAgZmlyZToge1xuICAgIG5hbWU6IFwiRmlyZVwiLFxuICAgIGNhdGVnb3J5OiBcIkRhbWFnZSBUeXBlc1wiLFxuICAgIGZvcmVncm91bmQ6IFwiI2Y4ZDg0ZlwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiNmOGQ4NGZcIiwgXCIjZjliMDJkXCIsIFwiI2Y0M2MwNFwiLCBcIiM5MTAyMDBcIiwgXCIjNGMxMDA5XCJdLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcImZpcmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJGaXJlXCJcbiAgfSxcbiAgaWNlOiB7XG4gICAgbmFtZTogXCJJY2VcIixcbiAgICBjYXRlZ29yeTogXCJEYW1hZ2UgVHlwZXNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiM2MEU5RkZcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjMjE0ZmEzXCIsIFwiIzNjNmFjMVwiLCBcIiMyNTNmNzBcIiwgXCIjMGI1NmUyXCIsIFwiIzA5MzE3YVwiXSxcbiAgICBvdXRsaW5lOiBcImJsYWNrXCIsXG4gICAgdGV4dHVyZTogXCJpY2VcIixcbiAgICBkZXNjcmlwdGlvbjogXCJJY2VcIlxuICB9LFxuICBwb2lzb246IHtcbiAgICBuYW1lOiBcIlBvaXNvblwiLFxuICAgIGNhdGVnb3J5OiBcIkRhbWFnZSBUeXBlc1wiLFxuICAgIGZvcmVncm91bmQ6IFwiI0Q2QThGRlwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiMzMTM4NjZcIiwgXCIjNTA0MDk5XCIsIFwiIzY2NDA5ZVwiLCBcIiM5MzRmYzNcIiwgXCIjYzk0OWZjXCJdLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcImNsb3VkeVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlBvaXNvblwiXG4gIH0sXG4gIGFjaWQ6IHtcbiAgICBuYW1lOiBcIkFjaWRcIixcbiAgICBjYXRlZ29yeTogXCJEYW1hZ2UgVHlwZXNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNBOUZGNzBcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjYTZmZjAwXCIsIFwiIzgzYjYyNVwiLCBcIiM1YWNlMDRcIiwgXCIjNjlmMDA2XCIsIFwiI2IwZjAwNlwiLCBcIiM5M2JjMjVcIl0sXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFwibWFyYmxlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQWNpZFwiXG4gIH0sXG4gIHRodW5kZXI6IHtcbiAgICBuYW1lOiBcIlRodW5kZXJcIixcbiAgICBjYXRlZ29yeTogXCJEYW1hZ2UgVHlwZXNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNGRkM1MDBcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiM3RDdEN0RcIixcbiAgICBvdXRsaW5lOiBcImJsYWNrXCIsXG4gICAgdGV4dHVyZTogXCJjbG91ZHlcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUaHVuZGVyXCJcbiAgfSxcbiAgbGlnaHRuaW5nOiB7XG4gICAgbmFtZTogXCJMaWdodG5pbmdcIixcbiAgICBjYXRlZ29yeTogXCJEYW1hZ2UgVHlwZXNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNGRkM1MDBcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjZjE3MTA1XCIsIFwiI2YzY2E0MFwiLCBcIiNlZGRlYTRcIiwgXCIjZGY5YTU3XCIsIFwiI2RlYTU0YlwiXSxcbiAgICBvdXRsaW5lOiBcIiM3RDdEN0RcIixcbiAgICB0ZXh0dXJlOiBcImljZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkxpZ2h0bmluZ1wiXG4gIH0sXG4gIGFpcjoge1xuICAgIG5hbWU6IFwiQWlyXCIsXG4gICAgY2F0ZWdvcnk6IFwiRGFtYWdlIFR5cGVzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI2QwZTVlYVwiLCBcIiNjM2RlZTVcIiwgXCIjYTRjY2Q2XCIsIFwiIzhkYWZiN1wiLCBcIiM4MGE0YWRcIl0sXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFwiY2xvdWR5XCIsXG4gICAgZGVzY3JpcHRpb246IFwiQWlyXCJcbiAgfSxcbiAgd2F0ZXI6IHtcbiAgICBuYW1lOiBcIldhdGVyXCIsXG4gICAgY2F0ZWdvcnk6IFwiRGFtYWdlIFR5cGVzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjNjBFOUZGXCIsXG4gICAgYmFja2dyb3VuZDogW1wiIzg3YjhjNFwiLCBcIiM3N2E2YjJcIiwgXCIjNmI5OGEzXCIsIFwiIzViODY5MVwiLCBcIiM0Yjc1N2ZcIl0sXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFwid2F0ZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXYXRlclwiXG4gIH0sXG4gIGVhcnRoOiB7XG4gICAgbmFtZTogXCJFYXJ0aFwiLFxuICAgIGNhdGVnb3J5OiBcIkRhbWFnZSBUeXBlc1wiLFxuICAgIGZvcmVncm91bmQ6IFwiIzZDOTk0M1wiLFxuICAgIGJhY2tncm91bmQ6IFtcIiMzNDY4MDRcIiwgXCIjMTg0MjAwXCIsIFwiIzUyN2YyMlwiLCBcIiMzYTFkMDRcIiwgXCIjNTYzNDFhXCIsIFwiIzMzMWMxN1wiLCBcIiM1YTM1MmFcIiwgXCIjMzAyMjEwXCJdLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcInNwZWNrbGVzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiRWFydGhcIlxuICB9LFxuICBmb3JjZToge1xuICAgIG5hbWU6IFwiRm9yY2VcIixcbiAgICBjYXRlZ29yeTogXCJEYW1hZ2UgVHlwZXNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIndoaXRlXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI0ZGOTdGRlwiLCBcIiNGRjY4RkZcIiwgXCIjQzY1MUM2XCJdLFxuICAgIG91dGxpbmU6IFwiIzU3MDAwMFwiLFxuICAgIHRleHR1cmU6IFwic3RhcnNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJGb3JjZVwiXG4gIH0sXG4gIHBzeWNoaWM6IHtcbiAgICBuYW1lOiBcIlBzeWNoaWNcIixcbiAgICBjYXRlZ29yeTogXCJEYW1hZ2UgVHlwZXNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNENkE4RkZcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjMzEzODY2XCIsIFwiIzUwNDA5OVwiLCBcIiM2NjQwOUVcIiwgXCIjOTM0RkMzXCIsIFwiI0M5NDlGQ1wiLCBcIiMzMTM4NjZcIl0sXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFwic3BlY2tsZXNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJQc3ljaGljXCJcbiAgfSxcbiAgbmVjcm90aWM6IHtcbiAgICBuYW1lOiBcIk5lY3JvdGljXCIsXG4gICAgY2F0ZWdvcnk6IFwiRGFtYWdlIFR5cGVzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgYmFja2dyb3VuZDogXCIjNkYwMDAwXCIsXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFwic2t1bGxzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTmVjcm90aWNcIlxuICB9LFxuICBicmVlYmFieToge1xuICAgIG5hbWU6IFwiUGFzdGVsIFN1bnNldFwiLFxuICAgIGNhdGVnb3J5OiBcIkN1c3RvbSBTZXRzXCIsXG4gICAgZm9yZWdyb3VuZDogW1wiIzVFMTc1RVwiLCBcIiM1NjRBNUVcIiwgXCIjNDU0NTVFXCIsIFwiIzNENUE1RVwiLCBcIiMxRTU5NUVcIiwgXCIjNUUzRjNEXCIsIFwiIzVFMUUyOVwiLCBcIiMyODNDNUVcIiwgXCIjMjUyOTVFXCJdLFxuICAgIGJhY2tncm91bmQ6IFtcIiNGRTg5Q0ZcIiwgXCIjREZENEYyXCIsIFwiI0MyQzJFOFwiLCBcIiNDQ0U3RkFcIiwgXCIjQTFEOUZDXCIsIFwiI0YzQzNDMlwiLCBcIiNFQjg5OTNcIiwgXCIjOEVBMUQyXCIsIFwiIzc0NzdBRFwiXSxcbiAgICBvdXRsaW5lOiBcIndoaXRlXCIsXG4gICAgdGV4dHVyZTogXCJtYXJibGVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJQYXN0ZWwgU3Vuc2V0LCBmb3IgQnJleWFubmFcIlxuICB9LFxuICBwaW5rZHJlYW1zOiB7XG4gICAgbmFtZTogXCJQaW5rIERyZWFtc1wiLFxuICAgIGNhdGVnb3J5OiBcIkN1c3RvbSBTZXRzXCIsXG4gICAgZm9yZWdyb3VuZDogXCJ3aGl0ZVwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiNmZjAwN2NcIiwgXCIjZGY3M2ZmXCIsIFwiI2Y0MDBhMVwiLCBcIiNkZjAwZmZcIiwgXCIjZmYzM2NjXCJdLFxuICAgIG91dGxpbmU6IFwiIzU3MDAwMFwiLFxuICAgIHRleHR1cmU6IFwic2t1bGxzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUGluayBEcmVhbXMsIGZvciBFdGhhblwiXG4gIH0sXG4gIGluc3BpcmVkOiB7XG4gICAgbmFtZTogXCJJbnNwaXJlZFwiLFxuICAgIGNhdGVnb3J5OiBcIkN1c3RvbSBTZXRzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjRkZEODAwXCIsXG4gICAgYmFja2dyb3VuZDogXCIjQzRDNEI2XCIsXG4gICAgb3V0bGluZTogXCIjOEU4RTg2XCIsXG4gICAgdGV4dHVyZTogXCJub25lXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSW5zcGlyZWQsIGZvciBBdXN0aW5cIlxuICB9LFxuICBibG9vZG1vb246IHtcbiAgICBuYW1lOiBcIkJsb29kIE1vb25cIixcbiAgICBjYXRlZ29yeTogXCJDdXN0b20gU2V0c1wiLFxuICAgIGZvcmVncm91bmQ6IFwiI0NEQjgwMFwiLFxuICAgIGJhY2tncm91bmQ6IFwiIzZGMDAwMFwiLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcIm1hcmJsZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb29kIE1vb24sIGZvciBKYXJlZFwiXG4gIH0sXG4gIHN0YXJ5bmlnaHQ6IHtcbiAgICBuYW1lOiBcIlN0YXJ5IE5pZ2h0XCIsXG4gICAgY2F0ZWdvcnk6IFwiQ3VzdG9tIFNldHNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiM0RjcwOEZcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjMDkxNjM2XCIsIFwiIzIzMzY2MFwiLCBcIiM0RjcwOEZcIiwgXCIjODU5N0FEXCIsIFwiI0UyRTJFMlwiXSxcbiAgICBvdXRsaW5lOiBcIndoaXRlXCIsXG4gICAgdGV4dHVyZTogXCJzcGVja2xlc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN0YXJ5IE5pZ2h0LCBmb3IgTWFpXCJcbiAgfSxcbiAgZ2xpdHRlcnBhcnR5OiB7XG4gICAgbmFtZTogXCJHbGl0dGVyIFBhcnR5XCIsXG4gICAgY2F0ZWdvcnk6IFwiQ3VzdG9tIFNldHNcIixcbiAgICBmb3JlZ3JvdW5kOiBcIndoaXRlXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI0ZGQjVGNVwiLCBcIiM3RkM5RkZcIiwgXCIjQTE3RkZGXCJdLFxuICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgIHRleHR1cmU6IFwiZ2xpdHRlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkdsaXR0ZXIgUGFydHksIGZvciBBdXN0aW5cIlxuICB9LFxuICBhc3RyYWxzZWE6IHtcbiAgICBuYW1lOiBcIkFzdHJhbCBTZWFcIixcbiAgICBjYXRlZ29yeTogXCJDdXN0b20gU2V0c1wiLFxuICAgIGZvcmVncm91bmQ6IFwiIzU2NTY1NlwiLFxuICAgIGJhY2tncm91bmQ6IFwid2hpdGVcIixcbiAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICB0ZXh0dXJlOiBcImFzdHJhbFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBBc3RyYWwgU2VhLCBmb3IgQXVzdGluXCJcbiAgfSxcbiAgYnJvbnplOiB7XG4gICAgbmFtZTogXCJUaHlsZWFuIEJyb256ZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRoeWxlYW4gQnJvbnplIGJ5IEBTcGVuY2VyVGhheWVyXCIsXG4gICAgY2F0ZWdvcnk6IFwiQ3VzdG9tIFNldHNcIixcbiAgICBmb3JlZ3JvdW5kOiBbXCIjRkY5MTU5XCIsIFwiI0ZGQjA2NlwiLCBcIiNGRkJGNTlcIiwgXCIjRkZEMDU5XCJdLFxuICAgIGJhY2tncm91bmQ6IFtcIiM3MDUyMDZcIiwgXCIjN0E0RTA2XCIsIFwiIzY0MzEwMFwiLCBcIiM3QTJEMDZcIl0sXG4gICAgb3V0bGluZTogW1wiIzNEMkQwM1wiLCBcIiM0NzJEMDRcIiwgXCIjMzAxNzAwXCIsIFwiIzQ3MUEwNFwiXSxcbiAgICBlZGdlOiBbXCIjRkY1RDBEXCIsIFwiI0ZGN0IwMFwiLCBcIiNGRkEyMERcIiwgXCIjRkZCQTBEXCJdLFxuICAgIHRleHR1cmU6IFtcImJyb256ZTAxXCIsIFwiYnJvbnplMDJcIiwgXCJicm9uemUwM1wiLCBcImJyb256ZTAzYVwiLCBcImJyb256ZTAzYlwiLCBcImJyb256ZTA0XCJdXG4gIH0sXG4gIGRyYWdvbnM6IHtcbiAgICBuYW1lOiBcIkhlcmUgYmUgRHJhZ29uc1wiLFxuICAgIGNhdGVnb3J5OiBcIkN1c3RvbSBTZXRzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjRkZGRkZGXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI0I4MDAwMFwiLCBcIiM0RDVBNUFcIiwgXCIjNUJCOEZGXCIsIFwiIzdFOTM0RVwiLCBcIiNGRkZGRkZcIiwgXCIjRjZFRDdDXCIsIFwiIzc3OTdBM1wiLCBcIiNBNzg0MzdcIiwgXCIjODYyQzFBXCIsIFwiI0ZGREY4QVwiXSxcbiAgICBvdXRsaW5lOiBcImJsYWNrXCIsXG4gICAgdGV4dHVyZTogW1wiZHJhZ29uXCIsIFwibGl6YXJkXCJdLFxuICAgIGRlc2NyaXB0aW9uOiBcIkhlcmUgYmUgRHJhZ29uc1wiXG4gIH0sXG4gIGJpcmR1cDoge1xuICAgIG5hbWU6IFwiQmlyZCBVcFwiLFxuICAgIGNhdGVnb3J5OiBcIkN1c3RvbSBTZXRzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjRkZGRkZGXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI0YxMTYwMlwiLCBcIiNGRkMwMDBcIiwgXCIjNkVDODMyXCIsIFwiIzAwOTRCQ1wiLCBcIiMwNTYwOERcIiwgXCIjRkVBQkIzXCIsIFwiI0Y3NTY4MFwiLCBcIiNGM0YwREZcIiwgXCIjQzdBNTdGXCJdLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcImJpcmRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCaXJkIFVwIVwiXG4gIH0sXG4gIHRpZ2Vya2luZzoge1xuICAgIG5hbWU6IFwiVGlnZXIgS2luZ1wiLFxuICAgIGNhdGVnb3J5OiBcIk90aGVyXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgYmFja2dyb3VuZDogXCIjRkZDQzQwXCIsXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFtcImxlb3BhcmRcIiwgXCJ0aWdlclwiLCBcImNoZWV0YWhcIl0sXG4gICAgZGVzY3JpcHRpb246IFwiTGVvcGFyZCBQcmludFwiXG4gIH0sXG4gIGNvdmlkOiB7XG4gICAgbmFtZTogXCJDT1ZpRFwiLFxuICAgIGNhdGVnb3J5OiBcIk90aGVyXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjQTlGRjcwXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI2E2ZmYwMFwiLCBcIiM4M2I2MjVcIiwgXCIjNWFjZTA0XCIsIFwiIzY5ZjAwNlwiLCBcIiNiMGYwMDZcIiwgXCIjOTNiYzI1XCJdLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcImZpcmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDb3ZpZC0xOVwiXG4gIH0sXG4gIGFjbGVhZjoge1xuICAgIG5hbWU6IFwiQW5pbWFsIENyb3NzaW5nXCIsXG4gICAgY2F0ZWdvcnk6IFwiT3RoZXJcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiMwMEZGMDBcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiMwNzU0MEFcIixcbiAgICBvdXRsaW5lOiBcImJsYWNrXCIsXG4gICAgdGV4dHVyZTogXCJhY2xlYWZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBbmltYWwgQ3Jvc3NpbmcgTGVhZlwiXG4gIH0sXG4gIGlzYWJlbGxlOiB7XG4gICAgbmFtZTogXCJJc2FiZWxsZVwiLFxuICAgIGNhdGVnb3J5OiBcIk90aGVyXCIsXG4gICAgZm9yZWdyb3VuZDogXCJ3aGl0ZVwiLFxuICAgIGJhY2tncm91bmQ6IFwiI0ZFRTVDQ1wiLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcImlzYWJlbGxlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSXNhYmVsbGVcIlxuICB9LFxuICB0aGVjYWdlOiB7XG4gICAgbmFtZTogXCJOaWNob2xhcyBDYWdlXCIsXG4gICAgY2F0ZWdvcnk6IFwiT3RoZXJcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNmZmZmZmZcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiNmZmZmZmZcIixcbiAgICBvdXRsaW5lOiBcImJsYWNrXCIsXG4gICAgdGV4dHVyZTogXCJ0aGVjYWdlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTmljaG9sYXMgQ2FnZVwiXG4gIH0sXG4gIHRlc3Q6IHtcbiAgICBuYW1lOiBcIlRlc3RcIixcbiAgICBjYXRlZ29yeTogXCJDb2xvcnNcIixcbiAgICBmb3JlZ3JvdW5kOiBbXCIjMDBGRjAwXCIsIFwiIzAwMDBGRlwiLCBcIiNGRjAwMDBcIl0sXG4gICAgYmFja2dyb3VuZDogW1wiI0ZGMDAwMFwiLCBcIiMwMEZGMDBcIiwgXCIjMDAwMEZGXCJdLFxuICAgIG91dGxpbmU6IFwiYmxhY2tcIixcbiAgICB0ZXh0dXJlOiBcIm5vbmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUZXN0XCJcbiAgfSxcbiAgcmFpbmJvdzoge1xuICAgIG5hbWU6IFwiUmFpbmJsb3dcIixcbiAgICBjYXRlZ29yeTogXCJDb2xvcnNcIixcbiAgICBmb3JlZ3JvdW5kOiBbXCIjRkY1OTU5XCIsIFwiI0ZGQTc0RlwiLCBcIiNGRkZGNTZcIiwgXCIjNTlGRjU5XCIsIFwiIzIzNzRGRlwiLCBcIiMwMEZGRkZcIiwgXCIjRkY1OUZGXCJdLFxuICAgIGJhY2tncm91bmQ6IFtcIiM5MDAwMDBcIiwgXCIjQ0UzOTAwXCIsIFwiI0JDQkMwMFwiLCBcIiMwMEI1MDBcIiwgXCIjMDAwMDhFXCIsIFwiIzAwODI4MlwiLCBcIiNBNTAwQTVcIl0sXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFwibm9uZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlJhaW5ibG93XCJcbiAgfSxcbiAgYmxhY2s6IHtcbiAgICBuYW1lOiBcIkJsYWNrXCIsXG4gICAgY2F0ZWdvcnk6IFwiQ29sb3JzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgYmFja2dyb3VuZDogXCIjMDAwMDAwXCIsXG4gICAgb3V0bGluZTogXCJibGFja1wiLFxuICAgIHRleHR1cmU6IFwibm9uZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsYWNrXCJcbiAgfSxcbiAgd2hpdGU6IHtcbiAgICBuYW1lOiBcIldoaXRlXCIsXG4gICAgY2F0ZWdvcnk6IFwiQ29sb3JzXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjMDAwMDAwXCIsXG4gICAgYmFja2dyb3VuZDogXCIjRkZGRkZGXCIsXG4gICAgb3V0bGluZTogXCIjRkZGRkZGXCIsXG4gICAgdGV4dHVyZTogXCJub25lXCIsXG4gICAgZGVzY3JpcHRpb246IFwiV2hpdGVcIlxuICB9LFxuICBzd3JwZ19hYmk6IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBSUEcgLSBBYmlsaXR5XCIsXG4gICAgY2F0ZWdvcnk6IFwiU3RhciBXYXJzXFx1MjEyMiBSUEdcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiMwMEZGMDBcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjM0Q5MjM4XCIsIFwiIzUyQjg0OFwiLCBcIiM1RUFDNTZcIiwgXCIjOUVDQjlBXCJdLFxuICAgIG91dGxpbmU6IFwiIzAwMDAwMFwiLFxuICAgIHRleHR1cmU6IFwiY2xvdWR5XzJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdGFyIFdhcnNcXHUyMTIyIFJQRyBBYmlsaXR5IERpY2VcIlxuICB9LFxuICBzd3JwZ19wcm86IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBSUEcgLSBQcm9maWNpZW5jeVwiLFxuICAgIGNhdGVnb3J5OiBcIlN0YXIgV2Fyc1xcdTIxMjIgUlBHXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjRkZGRjAwXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI0NBQkIxQ1wiLCBcIiNGOUUzM0JcIiwgXCIjRkZFOTAwXCIsIFwiI0YwRTQ5RFwiXSxcbiAgICBvdXRsaW5lOiBcIiMwMDAwMDBcIixcbiAgICB0ZXh0dXJlOiBcInBhcGVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3RhciBXYXJzXFx1MjEyMiBSUEcgUHJvZmljaWVuY3kgRGljZVwiXG4gIH0sXG4gIHN3cnBnX2RpZjoge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIFJQRyAtIERpZmZpY3VsdHlcIixcbiAgICBjYXRlZ29yeTogXCJTdGFyIFdhcnNcXHUyMTIyIFJQR1wiLFxuICAgIGZvcmVncm91bmQ6IFwiIzgwMDBGQ1wiLFxuICAgIGJhY2tncm91bmQ6IFtcIiMzOTE2NUZcIiwgXCIjNjY0Qjg0XCIsIFwiIzUwMjQ3RVwiLCBcIiM3NDVGODhcIl0sXG4gICAgb3V0bGluZTogXCIjMDAwMDAwXCIsXG4gICAgdGV4dHVyZTogXCJjbG91ZHlfMlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN0YXIgV2Fyc1xcdTIxMjIgUlBHIERpZmZpY3VsdHkgRGljZVwiXG4gIH0sXG4gIHN3cnBnX2NoYToge1xuICAgIG5hbWU6IFwiU3RhciBXYXJzIFJQRyAtIENoYWxsZW5nZVwiLFxuICAgIGNhdGVnb3J5OiBcIlN0YXIgV2Fyc1xcdTIxMjIgUlBHXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjRkYwMDAwXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI0E5MUYzMlwiLCBcIiNFQjQyNTRcIiwgXCIjRTUxODM2XCIsIFwiI0JBMzY0NVwiXSxcbiAgICBvdXRsaW5lOiBcIiMwMDAwMDBcIixcbiAgICB0ZXh0dXJlOiBcInBhcGVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3RhciBXYXJzXFx1MjEyMiBSUEcgQ2hhbGxlbmdlIERpY2VcIlxuICB9LFxuICBzd3JwZ19ib286IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBSUEcgLSBCb29zdFwiLFxuICAgIGNhdGVnb3J5OiBcIlN0YXIgV2Fyc1xcdTIxMjIgUlBHXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjMDBGRkZGXCIsXG4gICAgYmFja2dyb3VuZDogW1wiIzRCOURDNlwiLCBcIiM2ODlGQzRcIiwgXCIjODVDRkYyXCIsIFwiIzhGQzBEOFwiXSxcbiAgICBvdXRsaW5lOiBcIiMwMDAwMDBcIixcbiAgICB0ZXh0dXJlOiBcImdsaXR0ZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdGFyIFdhcnNcXHUyMTIyIFJQRyBCb29zdCBEaWNlXCJcbiAgfSxcbiAgc3dycGdfc2V0OiB7XG4gICAgbmFtZTogXCJTdGFyIFdhcnMgUlBHIC0gU2V0YmFja1wiLFxuICAgIGNhdGVnb3J5OiBcIlN0YXIgV2Fyc1xcdTIxMjIgUlBHXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjMTExMTExXCIsXG4gICAgYmFja2dyb3VuZDogW1wiIzI1MjIyM1wiLCBcIiMyNDFGMjFcIiwgXCIjMjgyODI4XCIsIFwiIzExMTExMVwiXSxcbiAgICBvdXRsaW5lOiBcIiNmZmZmZmZcIixcbiAgICB0ZXh0dXJlOiBcImdsaXR0ZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdGFyIFdhcnNcXHUyMTIyIFJQRyBTZXRiYWNrIERpY2VcIlxuICB9LFxuICBzd3JwZ19mb3I6IHtcbiAgICBuYW1lOiBcIlN0YXIgV2FycyBSUEcgLSBGb3JjZVwiLFxuICAgIGNhdGVnb3J5OiBcIlN0YXIgV2Fyc1xcdTIxMjIgUlBHXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjMDAwMDAwXCIsXG4gICAgYmFja2dyb3VuZDogW1wiI0YzRjNGM1wiLCBcIiNEM0QzRDNcIiwgXCIjQkFCQUJBXCIsIFwiI0ZGRkZGRlwiXSxcbiAgICBvdXRsaW5lOiBcIiNGRkZGRkZcIixcbiAgICB0ZXh0dXJlOiBcInN0YXJzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3RhciBXYXJzXFx1MjEyMiBSUEcgRm9yY2UgRGljZVwiXG4gIH0sXG4gIHN3YV9yZWQ6IHtcbiAgICBuYW1lOiBcIkFybWFkYSBBdHRhY2sgLSBSZWRcIixcbiAgICBjYXRlZ29yeTogXCJTdGFyIFdhcnNcXHUyMTIyIEFybWFkYVwiLFxuICAgIGZvcmVncm91bmQ6IFwiI2ZmZmZmZlwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiM0NDBEMTlcIiwgXCIjOEExNDI1XCIsIFwiI0M3MjMzNlwiLCBcIiNDMDQ1NTFcIl0sXG4gICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgdGV4dHVyZTogXCJzdGFpbmVkZ2xhc3NcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdGFyIFdhcnNcXHUyMTIyIEFybWFkYSBSZWQgQXR0YWNrIERpY2VcIlxuICB9LFxuICBzd2FfYmx1ZToge1xuICAgIG5hbWU6IFwiQXJtYWRhIEF0dGFjayAtIEJsdWVcIixcbiAgICBjYXRlZ29yeTogXCJTdGFyIFdhcnNcXHUyMTIyIEFybWFkYVwiLFxuICAgIGZvcmVncm91bmQ6IFwiI2ZmZmZmZlwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiMyMTI2NDJcIiwgXCIjMjgyODZFXCIsIFwiIzJCMzQ4Q1wiLCBcIiMzRDRCQjVcIiwgXCIjNUQ2NEFCXCJdLFxuICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgIHRleHR1cmU6IFwic3RhaW5lZGdsYXNzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3RhciBXYXJzXFx1MjEyMiBBcm1hZGEgQmx1ZSBBdHRhY2sgRGljZVwiXG4gIH0sXG4gIHN3YV9ibGFjazoge1xuICAgIG5hbWU6IFwiQXJtYWRhIEF0dGFjayAtIEJsYWNrXCIsXG4gICAgY2F0ZWdvcnk6IFwiU3RhciBXYXJzXFx1MjEyMiBBcm1hZGFcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNmZmZmZmZcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjMjUyMjIzXCIsIFwiIzI0MUYyMVwiLCBcIiMyODI4MjhcIiwgXCIjMTExMTExXCJdLFxuICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgIHRleHR1cmU6IFwic3RhaW5lZGdsYXNzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3RhciBXYXJzXFx1MjEyMiBBcm1hZGEgQmxhY2sgQXR0YWNrIERpY2VcIlxuICB9LFxuICB4d2luZ19yZWQ6IHtcbiAgICBuYW1lOiBcIlgtV2luZyBBdHRhY2sgLSBSZWRcIixcbiAgICBjYXRlZ29yeTogXCJTdGFyIFdhcnNcXHUyMTIyIFgtV2luZ1wiLFxuICAgIGZvcmVncm91bmQ6IFwiI2ZmZmZmZlwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiM0NDBEMTlcIiwgXCIjOEExNDI1XCIsIFwiI0M3MjMzNlwiLCBcIiNDMDQ1NTFcIl0sXG4gICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgdGV4dHVyZTogXCJzdGFyc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN0YXIgV2Fyc1xcdTIxMjIgWC1XaW5nIFJlZCBBdHRhY2sgRGljZVwiXG4gIH0sXG4gIHh3aW5nX2dyZWVuOiB7XG4gICAgbmFtZTogXCJYLVdpbmcgQXR0YWNrIC0gR3JlZW5cIixcbiAgICBjYXRlZ29yeTogXCJTdGFyIFdhcnNcXHUyMTIyIFgtV2luZ1wiLFxuICAgIGZvcmVncm91bmQ6IFwiI2ZmZmZmZlwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiMzRDkyMzhcIiwgXCIjNTJCODQ4XCIsIFwiIzVFQUM1NlwiLCBcIiM5RUNCOUFcIl0sXG4gICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgdGV4dHVyZTogXCJzdGFyc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN0YXIgV2Fyc1xcdTIxMjIgWC1XaW5nIEdyZWVuIEF0dGFjayBEaWNlXCJcbiAgfSxcbiAgc3dsX2F0a3JlZDoge1xuICAgIG5hbWU6IFwiTGVnaW9uIEF0dGFjayAtIFJlZFwiLFxuICAgIGNhdGVnb3J5OiBcIlN0YXIgV2Fyc1xcdTIxMjIgTGVnaW9uXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgYmFja2dyb3VuZDogW1wiIzQ0MEQxOVwiLCBcIiM4QTE0MjVcIiwgXCIjQzcyMzM2XCIsIFwiI0MwNDU1MVwiXSxcbiAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICB0ZXh0dXJlOiBcImZpcmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdGFyIFdhcnNcXHUyMTIyIExlZ2lvbiBSZWQgQXR0YWNrIERpY2VcIlxuICB9LFxuICBzd2xfYXRrYmxhY2s6IHtcbiAgICBuYW1lOiBcIkxlZ2lvbiBBdHRhY2sgLSBCbGFja1wiLFxuICAgIGNhdGVnb3J5OiBcIlN0YXIgV2Fyc1xcdTIxMjIgTGVnaW9uXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgYmFja2dyb3VuZDogW1wiIzI1MjIyM1wiLCBcIiMyNDFGMjFcIiwgXCIjMjgyODI4XCIsIFwiIzExMTExMVwiXSxcbiAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICB0ZXh0dXJlOiBcImZpcmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdGFyIFdhcnNcXHUyMTIyIExlZ2lvbiBCbGFjayBBdHRhY2sgRGljZVwiXG4gIH0sXG4gIHN3bF9hdGt3aGl0ZToge1xuICAgIG5hbWU6IFwiTGVnaW9uIEF0dGFjayAtIFdoaXRlXCIsXG4gICAgY2F0ZWdvcnk6IFwiU3RhciBXYXJzXFx1MjEyMiBMZWdpb25cIixcbiAgICBmb3JlZ3JvdW5kOiBcIiMwMDAwMDBcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjZmZmZmZmXCIsIFwiI0RGRjRGQVwiLCBcIiNCQ0JDQkNcIiwgXCIjRjFFREUyXCIsIFwiI0YyRUNFMFwiXSxcbiAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICB0ZXh0dXJlOiBcImZpcmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdGFyIFdhcnNcXHUyMTIyIExlZ2lvbiBXaGl0ZSBBdHRhY2sgRGljZVwiXG4gIH0sXG4gIHN3bF9kZWZyZWQ6IHtcbiAgICBuYW1lOiBcIkxlZ2lvbiBEZWZlbnNlIC0gUmVkXCIsXG4gICAgY2F0ZWdvcnk6IFwiU3RhciBXYXJzXFx1MjEyMiBMZWdpb25cIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNmZmZmZmZcIixcbiAgICBiYWNrZ3JvdW5kOiBbXCIjNDQwRDE5XCIsIFwiIzhBMTQyNVwiLCBcIiNDNzIzMzZcIiwgXCIjQzA0NTUxXCJdLFxuICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgIHRleHR1cmU6IFwiZmlyZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN0YXIgV2Fyc1xcdTIxMjIgTGVnaW9uIFJlZCBEZWZlbnNlIERpY2VcIlxuICB9LFxuICBzd2xfZGVmd2hpdGU6IHtcbiAgICBuYW1lOiBcIkxlZ2lvbiBEZWZlbnNlIC0gV2hpdGVcIixcbiAgICBjYXRlZ29yeTogXCJTdGFyIFdhcnNcXHUyMTIyIExlZ2lvblwiLFxuICAgIGZvcmVncm91bmQ6IFwiIzAwMDAwMFwiLFxuICAgIGJhY2tncm91bmQ6IFtcIiNmZmZmZmZcIiwgXCIjREZGNEZBXCIsIFwiI0JDQkNCQ1wiLCBcIiNGMUVERTJcIiwgXCIjRjJFQ0UwXCJdLFxuICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgIHRleHR1cmU6IFwiZmlyZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN0YXIgV2Fyc1xcdTIxMjIgTGVnaW9uIFdoaXRlIERlZmVuc2UgRGljZVwiXG4gIH1cbn07XG5jbGFzcyBNcCB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHRoaXMuY29sb3JzZXRzID0gW10sIHRoaXMuYXNzZXRQYXRoID0gZS5hc3NldFBhdGg7XG4gIH1cbiAgYXN5bmMgSW1hZ2VMb2FkZXIoZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBmb3IgKGxldCB0ID0gMCwgbiA9IGUubGVuZ3RoOyB0IDwgbjsgdCsrKVxuICAgICAgICBlW3RdID0gYXdhaXQgdGhpcy5JbWFnZUxvYWRlcihlW3RdKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4gZS5zb3VyY2UgJiYgZS5zb3VyY2UgIT0gXCJcIiAmJiAoZS50ZXh0dXJlID0gYXdhaXQgdGhpcy5sb2FkSW1hZ2UoZS5zb3VyY2UpKSwgZS5zb3VyY2VfYnVtcCAmJiBlLnNvdXJjZV9idW1wICE9IFwiXCIgJiYgKGUuYnVtcCA9IGF3YWl0IHRoaXMubG9hZEltYWdlKGUuc291cmNlX2J1bXApKSwgZTtcbiAgfVxuICBsb2FkSW1hZ2UoZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCwgbikgPT4ge1xuICAgICAgbGV0IGkgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGkub25sb2FkID0gKCkgPT4gdChpKSwgaS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCIsIGkuc3JjID0gdGhpcy5hc3NldFBhdGggKyBlLCBpLm9uZXJyb3IgPSAocykgPT4gbihzKTtcbiAgICB9KS5jYXRjaCgodCkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBsb2FkIGltYWdlIHRleHR1cmVcIik7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29sb3JTZXQoZSkge1xuICAgIGxldCB0LCBuO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiICYmICh0ID0gZSksIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgKHQgPSBlLmNvbG9yc2V0KSwgdGhpcy5jb2xvcnNldHMuaGFzT3duUHJvcGVydHkodCkpXG4gICAgICByZXR1cm4gdGhpcy5jb2xvcnNldHNbdF07XG4gICAgbGV0IGkgPSBlb1t0XTtcbiAgICByZXR1cm4gbiA9IGUudGV4dHVyZSB8fCBpLnRleHR1cmUsIGkudGV4dHVyZSA9IHRoaXMuZ2V0VGV4dHVyZShuKSwgaS50ZXh0dXJlID0gYXdhaXQgdGhpcy5JbWFnZUxvYWRlcihpLnRleHR1cmUpLCBlLm1hdGVyaWFsICYmIChpLnRleHR1cmUubWF0ZXJpYWwgPSBlLm1hdGVyaWFsKSwgdGhpcy5jb2xvcnNldHNbdF0gPSBpLCBpO1xuICB9XG4gIGFzeW5jIG1ha2VDb2xvclNldChlID0ge30pIHtcbiAgICBpZiAodGhpcy5jb2xvcnNldHMuaGFzT3duUHJvcGVydHkoZS5uYW1lKSlcbiAgICAgIHJldHVybiB0aGlzLmNvbG9yc2V0c1tlLm5hbWVdO1xuICAgIGxldCB0ID0gZW8ud2hpdGUsIG4gPSBPYmplY3QuYXNzaWduKHt9LCB0LCBlKSwgaSA9IHRoaXMuZ2V0VGV4dHVyZShuLnRleHR1cmUpO1xuICAgIHJldHVybiBuLnRleHR1cmUgPSBhd2FpdCB0aGlzLkltYWdlTG9hZGVyKGkpLCBlLm1hdGVyaWFsICYmIChuLnRleHR1cmUubWF0ZXJpYWwgPSBlLm1hdGVyaWFsKSwgbi5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwid2hpdGVcIiAmJiAobi5uYW1lID0gYCR7RGF0ZS5ub3coKX1gKSwgdGhpcy5jb2xvcnNldHNbbi5uYW1lXSA9IG4sIG47XG4gIH1cbiAgZ2V0VGV4dHVyZShlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGxldCB0ID0gW107XG4gICAgICBmb3IgKGxldCBuID0gMCwgaSA9IGUubGVuZ3RoOyBuIDwgaTsgbisrKVxuICAgICAgICB0LnB1c2godGhpcy5nZXRUZXh0dXJlKGVbbl0pKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICByZXR1cm4gSXMuaGFzT3duUHJvcGVydHkoZSkgPyBJc1tlXSA6IElzLm5vbmU7XG4gIH1cbn1cbmNvbnN0IFNwID0ge1xuICBkZWZhdWx0OiB7XG4gICAgbmFtZTogXCJTb2xpZCBDb2xvclwiLFxuICAgIGF1dGhvcjogXCJNYWpvclZpY3RvcnlcIixcbiAgICBzaG93Q29sb3JQaWNrZXI6ICEwLFxuICAgIHN1cmZhY2U6IFwid29vZF90cmF5XCIsXG4gICAgY29sb3JzOiB7IGZnOiBcIiM5Nzk0ZmZcIiwgYmc6IFwiIzBiMWEzZVwiIH0sXG4gICAgY3ViZU1hcDogW1wiZW52bWFwLmpwZ1wiLCBcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCIsIFwiZW52bWFwLmpwZ1wiLCBcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCJdXG4gIH0sXG4gIFwiYmx1ZS1mZWx0XCI6IHtcbiAgICBuYW1lOiBcIkJsdWUgRmVsdFwiLFxuICAgIGF1dGhvcjogXCJNYWpvclZpY3RvcnlcIixcbiAgICBzaG93Q29sb3JQaWNrZXI6ICEwLFxuICAgIHN1cmZhY2U6IFwiZmVsdFwiLFxuICAgIGNvbG9yczogeyBmZzogXCIjOTc5NGZmXCIsIGJnOiBcIiMwYjFhM2VcIiB9LFxuICAgIGN1YmVNYXA6IFtcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCIsIFwiZW52bWFwLmpwZ1wiLCBcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCIsIFwiZW52bWFwLmpwZ1wiXVxuICB9LFxuICBcInJlZC1mZWx0XCI6IHtcbiAgICBuYW1lOiBcIlJlZCBGZWx0XCIsXG4gICAgYXV0aG9yOiBcIk1ham9yVmljdG9yeVwiLFxuICAgIHNob3dDb2xvclBpY2tlcjogITAsXG4gICAgc3VyZmFjZTogXCJmZWx0XCIsXG4gICAgY29sb3JzOiB7IGZnOiBcIiNmZjk0OTRcIiwgYmc6IFwiIzRkMWUxZVwiIH0sXG4gICAgY3ViZU1hcDogW1wiZW52bWFwLmpwZ1wiLCBcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCIsIFwiZW52bWFwLmpwZ1wiLCBcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCJdXG4gIH0sXG4gIFwiZ3JlZW4tZmVsdFwiOiB7XG4gICAgbmFtZTogXCJHcmVlbiBGZWx0XCIsXG4gICAgYXV0aG9yOiBcIk1ham9yVmljdG9yeVwiLFxuICAgIHNob3dDb2xvclBpY2tlcjogITAsXG4gICAgc3VyZmFjZTogXCJmZWx0XCIsXG4gICAgY29sb3JzOiB7IGZnOiBcIiM5N2ZmOTRcIiwgYmc6IFwiIzI0NGQxZVwiIH0sXG4gICAgY3ViZU1hcDogW1wiZW52bWFwLmpwZ1wiLCBcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCIsIFwiZW52bWFwLmpwZ1wiLCBcImVudm1hcC5qcGdcIiwgXCJlbnZtYXAuanBnXCJdXG4gIH0sXG4gIHRhdmVybnRhYmxlOiB7XG4gICAgbmFtZTogXCJPbGQgVGF2ZXJuIFRhYmxlXCIsXG4gICAgYXV0aG9yOiBcIk1ham9yVmljdG9yeVwiLFxuICAgIHNob3dDb2xvclBpY2tlcjogITAsXG4gICAgc3VyZmFjZTogXCJ3b29kX3RhYmxlXCIsXG4gICAgY29sb3JzOiB7IGZnOiBcIiM5Nzk0ZmZcIiwgYmc6IFwiIzBiMWEzZVwiIH0sXG4gICAgY3ViZU1hcDogW1wicHgucG5nXCIsIFwibngucG5nXCIsIFwicHkucG5nXCIsIFwibnkucG5nXCIsIFwicHoucG5nXCIsIFwibnoucG5nXCJdXG4gIH0sXG4gIG1haG9nYW55OiB7XG4gICAgbmFtZTogXCIoTWFoLUhvZy1BbnkpXCIsXG4gICAgYXV0aG9yOiBcIk1ham9yVmljdG9yeVwiLFxuICAgIHNob3dDb2xvclBpY2tlcjogITAsXG4gICAgc3VyZmFjZTogXCJ3b29kX3RhYmxlXCIsXG4gICAgY29sb3JzOiB7IGZnOiBcIiM5Nzk0ZmZcIiwgYmc6IFwiIzBiMWEzZVwiIH0sXG4gICAgY3ViZU1hcDogW1wicHgucG5nXCIsIFwibngucG5nXCIsIFwicHkucG5nXCIsIFwibnkucG5nXCIsIFwicHoucG5nXCIsIFwibnoucG5nXCJdXG4gIH0sXG4gIHN0YWlubGVzczoge1xuICAgIG5hbWU6IFwiU3RhaW5sZXNzIFN0ZWVsXCIsXG4gICAgYXV0aG9yOiBcIk1ham9yVmljdG9yeVwiLFxuICAgIHNob3dDb2xvclBpY2tlcjogITAsXG4gICAgc3VyZmFjZTogXCJtZXRhbFwiLFxuICAgIGNvbG9yczogeyBmZzogXCIjOTc5NGZmXCIsIGJnOiBcIiMwYjFhM2VcIiB9LFxuICAgIGN1YmVNYXA6IFtcInB4LnBuZ1wiLCBcIm54LnBuZ1wiLCBcInB5LnBuZ1wiLCBcIm55LnBuZ1wiLCBcInB6LnBuZ1wiLCBcIm56LnBuZ1wiXVxuICB9LFxuICBjeWJlcnB1bms6IHtcbiAgICBuYW1lOiBcIk5lby1OZXctRnV0dXJlLUNpdHlcIixcbiAgICBhdXRob3I6IFwiTWFqb3JWaWN0b3J5XCIsXG4gICAgc2hvd0NvbG9yUGlja2VyOiAhMCxcbiAgICBzdXJmYWNlOiBcIm1ldGFsXCIsXG4gICAgY29sb3JzOiB7IGZnOiBcIiMzNDk0QTZcIiwgYmc6IFwiIzQ0MEIyOFwiIH0sXG4gICAgY3ViZU1hcDogW1wicHgucG5nXCIsIFwibngucG5nXCIsIFwicHkucG5nXCIsIFwibnkucG5nXCIsIFwicHoucG5nXCIsIFwibnoucG5nXCJdXG4gIH0sXG4gIGNhZ2V0b3duOiB7XG4gICAgbmFtZTogXCJDYWdlIFRvd25cIixcbiAgICBhdXRob3I6IFwiTWFqb3JWaWN0b3J5XCIsXG4gICAgc2hvd0NvbG9yUGlja2VyOiAhMCxcbiAgICBzdXJmYWNlOiBcIndvb2RfdGFibGVcIixcbiAgICBjb2xvcnM6IHsgZmc6IFwiI0Q3QTg2NlwiLCBiZzogXCIjMjgyODExXCIgfSxcbiAgICBjdWJlTWFwOiBbXCJweC5wbmdcIiwgXCJueC5wbmdcIiwgXCJweS5wbmdcIiwgXCJueS5wbmdcIiwgXCJwei5wbmdcIiwgXCJuei5wbmdcIl1cbiAgfVxufSwgRXAgPSAoaCkgPT4ge1xuICBsZXQgZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGxldCB0ID0gdGhpcywgbiA9IGFyZ3VtZW50cztcbiAgICBlICYmIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShlKSwgZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICBoLmFwcGx5KHQsIG4pO1xuICAgIH0pO1xuICB9O1xufSwgVHAgPSB7XG4gIGFzc2V0UGF0aDogXCIuL1wiLFxuICBmcmFtZXJhdGU6IDEgLyA2MCxcbiAgc291bmRzOiAhMSxcbiAgdm9sdW1lOiAxMDAsXG4gIGNvbG9yX3Nwb3RsaWdodDogMTU3MjA0MDUsXG4gIHNoYWRvd3M6ICEwLFxuICB0aGVtZV9zdXJmYWNlOiBcImdyZWVuLWZlbHRcIixcbiAgc291bmRfZGllTWF0ZXJpYWw6IFwicGxhc3RpY1wiLFxuICB0aGVtZV9jdXN0b21Db2xvcnNldDogbnVsbCxcbiAgdGhlbWVfY29sb3JzZXQ6IFwid2hpdGVcIixcbiAgdGhlbWVfdGV4dHVyZTogXCJcIixcbiAgdGhlbWVfbWF0ZXJpYWw6IFwiZ2xhc3NcIixcbiAgZ3Jhdml0eV9tdWx0aXBsaWVyOiA0MDAsXG4gIGxpZ2h0X2ludGVuc2l0eTogMC43LFxuICBiYXNlU2NhbGU6IDEwMCxcbiAgc3RyZW5ndGg6IDEsXG4gIGl0ZXJhdGlvbkxpbWl0OiAxZTMsXG4gIG9uUm9sbENvbXBsZXRlOiAoKSA9PiB7XG4gIH0sXG4gIG9uUmVyb2xsQ29tcGxldGU6ICgpID0+IHtcbiAgfSxcbiAgb25BZGREaWNlQ29tcGxldGU6ICgpID0+IHtcbiAgfSxcbiAgb25SZW1vdmVEaWNlQ29tcGxldGU6ICgpID0+IHtcbiAgfVxufTtcbmNsYXNzIENwIHtcbiAgY29uc3RydWN0b3IoZSwgdCA9IHt9KSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSksIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBDZSh0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCwgdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0KSwgdGhpcy5hZGFwdGl2ZV90aW1lc3RlcCA9ICExLCB0aGlzLmxhc3RfdGltZSA9IDAsIHRoaXMucnVubmluZyA9ICExLCB0aGlzLnJvbGxpbmcgPSAhMSwgdGhpcy50aHJlYWRpZCwgdGhpcy5kaXNwbGF5ID0ge1xuICAgICAgY3VycmVudFdpZHRoOiBudWxsLFxuICAgICAgY3VycmVudEhlaWdodDogbnVsbCxcbiAgICAgIGNvbnRhaW5lcldpZHRoOiBudWxsLFxuICAgICAgY29udGFpbmVySGVpZ2h0OiBudWxsLFxuICAgICAgYXNwZWN0OiBudWxsLFxuICAgICAgc2NhbGU6IG51bGxcbiAgICB9LCB0aGlzLmNhbWVyYUhlaWdodCA9IHtcbiAgICAgIG1heDogbnVsbCxcbiAgICAgIGNsb3NlOiBudWxsLFxuICAgICAgbWVkaXVtOiBudWxsLFxuICAgICAgZmFyOiBudWxsXG4gICAgfSwgdGhpcy5zY2VuZSA9IG5ldyBOdSgpLCB0aGlzLndvcmxkID0gbmV3IGRwKCksIHRoaXMuZGljZV9ib2R5X21hdGVyaWFsID0gbmV3IFNuKCksIHRoaXMuc291bmRzX3RhYmxlID0ge30sIHRoaXMuc291bmRzX2RpY2UgPSBbXSwgdGhpcy5sYXN0U291bmRUeXBlID0gXCJcIiwgdGhpcy5sYXN0U291bmRTdGVwID0gMCwgdGhpcy5sYXN0U291bmQgPSAwLCB0aGlzLml0ZXJhdGlvbiwgdGhpcy5yZW5kZXJlciwgdGhpcy5iYXJyaWVyLCB0aGlzLmNhbWVyYSwgdGhpcy5saWdodCwgdGhpcy5saWdodF9hbWIsIHRoaXMuZGVzaywgdGhpcy5ib3hfYm9keSA9IHt9LCB0aGlzLmJvZGllcyA9IFtdLCB0aGlzLm1lc2hlcyA9IFtdLCB0aGlzLmRpY2VMaXN0ID0gW10sIHRoaXMubm90YXRpb25WZWN0b3JzID0gbnVsbCwgdGhpcy5kaWVJbmRleCA9IDAsIHRoaXMuc291bmREZWxheSA9IDEwLCB0aGlzLmFuaW1zdGF0ZSA9IFwiXCIsIHRoaXMuc2VsZWN0b3IgPSB7XG4gICAgICBhbmltYXRlOiAhMCxcbiAgICAgIHJvdGF0ZTogITAsXG4gICAgICBpbnRlcnNlY3RlZDogbnVsbCxcbiAgICAgIGRpY2U6IFtdXG4gICAgfSwgT2JqZWN0LmFzc2lnbih0aGlzLCBUcCwgdCksIHRoaXMuRGljZUNvbG9ycyA9IG5ldyBNcCh7IGFzc2V0UGF0aDogdGhpcy5hc3NldFBhdGggfSksIHRoaXMuRGljZUZhY3RvcnkgPSBuZXcgSGkoe1xuICAgICAgYmFzZVNjYWxlOiB0aGlzLmJhc2VTY2FsZVxuICAgIH0pLCB0aGlzLkRpY2VGYWN0b3J5LnNldEJ1bXBNYXBwaW5nKCEwKSwgdGhpcy5zdXJmYWNlID0gU3BbdGhpcy50aGVtZV9zdXJmYWNlXS5zdXJmYWNlO1xuICB9XG4gIGVuYWJsZVNoYWRvd3MoKSB7XG4gICAgdGhpcy5zaGFkb3dzID0gITAsIHRoaXMucmVuZGVyZXIgJiYgKHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0aGlzLnNoYWRvd3MpLCB0aGlzLmxpZ2h0ICYmICh0aGlzLmxpZ2h0LmNhc3RTaGFkb3cgPSB0aGlzLnNoYWRvd3MpLCB0aGlzLmRlc2sgJiYgKHRoaXMuZGVzay5yZWNlaXZlU2hhZG93ID0gdGhpcy5zaGFkb3dzKTtcbiAgfVxuICBkaXNhYmxlU2hhZG93cygpIHtcbiAgICB0aGlzLnNoYWRvd3MgPSAhMSwgdGhpcy5yZW5kZXJlciAmJiAodGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHRoaXMuc2hhZG93cyksIHRoaXMubGlnaHQgJiYgKHRoaXMubGlnaHQuY2FzdFNoYWRvdyA9IHRoaXMuc2hhZG93cyksIHRoaXMuZGVzayAmJiAodGhpcy5kZXNrLnJlY2VpdmVTaGFkb3cgPSB0aGlzLnNoYWRvd3MpO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyB4byh7IGFudGlhbGlhczogITAsIGFscGhhOiAhMCB9KSwgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KSwgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHRoaXMuc2hhZG93cywgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IDIsIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigwLCAwKSwgdGhpcy5zZXREaW1lbnNpb25zKHRoaXMuZGltZW5zaW9ucyksIHRoaXMud29ybGQuZ3Jhdml0eS5zZXQoMCwgMCwgLTkuOCAqIHRoaXMuZ3Jhdml0eV9tdWx0aXBsaWVyKSwgdGhpcy53b3JsZC5icm9hZHBoYXNlID0gbmV3IHdvKCksIHRoaXMud29ybGQuc29sdmVyLml0ZXJhdGlvbnMgPSAxNCwgdGhpcy53b3JsZC5hbGxvd1NsZWVwID0gITAsIHRoaXMubWFrZVdvcmxkQm94KCksIHRoaXMucmVzaXplV29ybGQoKSwgYXdhaXQgdGhpcy5sb2FkVGhlbWUoe1xuICAgICAgY29sb3JzZXQ6IHRoaXMudGhlbWVfY29sb3JzZXQsXG4gICAgICB0ZXh0dXJlOiB0aGlzLnRoZW1lX3RleHR1cmUsXG4gICAgICBtYXRlcmlhbDogdGhpcy50aGVtZV9tYXRlcmlhbFxuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9hZCB0aGVtZVwiKTtcbiAgICB9KSwgdGhpcy5zb3VuZHMgJiYgYXdhaXQgdGhpcy5sb2FkU291bmRzKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsb2FkIHNvdW5kc1wiKTtcbiAgICB9KSwgdGhpcy5pbml0aWFsaXplZCA9ICEwLCB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cbiAgbWFrZVdvcmxkQm94KCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuYm94X2JvZHkpLmxlbmd0aCAmJiAodGhpcy53b3JsZC5yZW1vdmVCb2R5KHRoaXMuYm94X2JvZHkuZGVzayksIHRoaXMud29ybGQucmVtb3ZlQm9keSh0aGlzLmJveF9ib2R5LnRvcFdhbGwpLCB0aGlzLndvcmxkLnJlbW92ZUJvZHkodGhpcy5ib3hfYm9keS5ib3R0b21XYWxsKSwgdGhpcy53b3JsZC5yZW1vdmVCb2R5KHRoaXMuYm94X2JvZHkubGVmdFdhbGwpLCB0aGlzLndvcmxkLnJlbW92ZUJvZHkodGhpcy5ib3hfYm9keS5yaWdodFdhbGwpKTtcbiAgICBjb25zdCBlID0gbmV3IFNuKCksIHQgPSBuZXcgU24oKTtcbiAgICB0aGlzLndvcmxkLmFkZENvbnRhY3RNYXRlcmlhbChuZXcgTW4oZSwgdGhpcy5kaWNlX2JvZHlfbWF0ZXJpYWwsIHsgbWFzczogMCwgZnJpY3Rpb246IDAuNiwgcmVzdGl0dXRpb246IDAuNSB9KSksIHRoaXMud29ybGQuYWRkQ29udGFjdE1hdGVyaWFsKG5ldyBNbih0LCB0aGlzLmRpY2VfYm9keV9tYXRlcmlhbCwgeyBtYXNzOiAwLCBmcmljdGlvbjogMC42LCByZXN0aXR1dGlvbjogMSB9KSksIHRoaXMud29ybGQuYWRkQ29udGFjdE1hdGVyaWFsKG5ldyBNbih0aGlzLmRpY2VfYm9keV9tYXRlcmlhbCwgdGhpcy5kaWNlX2JvZHlfbWF0ZXJpYWwsIHsgbWFzczogMCwgZnJpY3Rpb246IDAuNiwgcmVzdGl0dXRpb246IDAuNSB9KSksIHRoaXMuYm94X2JvZHkuZGVzayA9IG5ldyBpZSh7IGFsbG93U2xlZXA6ICExLCBtYXNzOiAwLCBzaGFwZTogbmV3IHNpKCksIG1hdGVyaWFsOiBlIH0pLCB0aGlzLndvcmxkLmFkZEJvZHkodGhpcy5ib3hfYm9keS5kZXNrKSwgdGhpcy5ib3hfYm9keS50b3BXYWxsID0gbmV3IGllKHsgYWxsb3dTbGVlcDogITEsIG1hc3M6IDAsIHNoYXBlOiBuZXcgc2koKSwgbWF0ZXJpYWw6IHQgfSksIHRoaXMuYm94X2JvZHkudG9wV2FsbC5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUobmV3IGIoMSwgMCwgMCksIE1hdGguUEkgLyAyKSwgdGhpcy5ib3hfYm9keS50b3BXYWxsLnBvc2l0aW9uLnNldCgwLCB0aGlzLmRpc3BsYXkuY29udGFpbmVySGVpZ2h0ICogMC45MywgMCksIHRoaXMud29ybGQuYWRkQm9keSh0aGlzLmJveF9ib2R5LnRvcFdhbGwpLCB0aGlzLmJveF9ib2R5LmJvdHRvbVdhbGwgPSBuZXcgaWUoeyBhbGxvd1NsZWVwOiAhMSwgbWFzczogMCwgc2hhcGU6IG5ldyBzaSgpLCBtYXRlcmlhbDogdCB9KSwgdGhpcy5ib3hfYm9keS5ib3R0b21XYWxsLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShuZXcgYigxLCAwLCAwKSwgLU1hdGguUEkgLyAyKSwgdGhpcy5ib3hfYm9keS5ib3R0b21XYWxsLnBvc2l0aW9uLnNldCgwLCAtdGhpcy5kaXNwbGF5LmNvbnRhaW5lckhlaWdodCAqIDAuOTMsIDApLCB0aGlzLndvcmxkLmFkZEJvZHkodGhpcy5ib3hfYm9keS5ib3R0b21XYWxsKSwgdGhpcy5ib3hfYm9keS5sZWZ0V2FsbCA9IG5ldyBpZSh7IGFsbG93U2xlZXA6ICExLCBtYXNzOiAwLCBzaGFwZTogbmV3IHNpKCksIG1hdGVyaWFsOiB0IH0pLCB0aGlzLmJveF9ib2R5LmxlZnRXYWxsLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShuZXcgYigwLCAxLCAwKSwgLU1hdGguUEkgLyAyKSwgdGhpcy5ib3hfYm9keS5sZWZ0V2FsbC5wb3NpdGlvbi5zZXQodGhpcy5kaXNwbGF5LmNvbnRhaW5lcldpZHRoICogMC45MywgMCwgMCksIHRoaXMud29ybGQuYWRkQm9keSh0aGlzLmJveF9ib2R5LmxlZnRXYWxsKSwgdGhpcy5ib3hfYm9keS5yaWdodFdhbGwgPSBuZXcgaWUoeyBhbGxvd1NsZWVwOiAhMSwgbWFzczogMCwgc2hhcGU6IG5ldyBzaSgpLCBtYXRlcmlhbDogdCB9KSwgdGhpcy5ib3hfYm9keS5yaWdodFdhbGwucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBiKDAsIDEsIDApLCBNYXRoLlBJIC8gMiksIHRoaXMuYm94X2JvZHkucmlnaHRXYWxsLnBvc2l0aW9uLnNldCgtdGhpcy5kaXNwbGF5LmNvbnRhaW5lcldpZHRoICogMC45MywgMCwgMCksIHRoaXMud29ybGQuYWRkQm9keSh0aGlzLmJveF9ib2R5LnJpZ2h0V2FsbCk7XG4gIH1cbiAgYXN5bmMgbG9hZFRoZW1lKGUpIHtcbiAgICBsZXQgdDtcbiAgICB0aGlzLnRoZW1lX2N1c3RvbUNvbG9yc2V0ID8gdCA9IGF3YWl0IHRoaXMuRGljZUNvbG9ycy5tYWtlQ29sb3JTZXQodGhpcy50aGVtZV9jdXN0b21Db2xvcnNldCkgOiB0ID0gYXdhaXQgdGhpcy5EaWNlQ29sb3JzLmdldENvbG9yU2V0KGUpLCB0aGlzLkRpY2VGYWN0b3J5LmFwcGx5Q29sb3JTZXQodCksIHRoaXMuY29sb3JEYXRhID0gdDtcbiAgfVxuICBhc3luYyBsb2FkU291bmRzKCkge1xuICAgIGxldCBlID0ge1xuICAgICAgZmVsdDogNyxcbiAgICAgIHdvb2RfdGFibGU6IDcsXG4gICAgICB3b29kX3RyYXk6IDcsXG4gICAgICBtZXRhbDogOVxuICAgIH0sIHQgPSB7XG4gICAgICBjb2luOiA2LFxuICAgICAgbWV0YWw6IDEyLFxuICAgICAgcGxhc3RpYzogMTUsXG4gICAgICB3b29kOiAxMlxuICAgIH07XG4gICAgY29uc3QgbiA9IHRoaXMuY29sb3JEYXRhLnRleHR1cmUubWF0ZXJpYWwubWF0Y2goL3dvb2R8bWV0YWwvZyk7XG4gICAgaWYgKHRoaXMuc291bmRfZGllTWF0ZXJpYWwgPSBuID8gdGhpcy5jb2xvckRhdGEudGV4dHVyZS5tYXRlcmlhbCA6IFwicGxhc3RpY1wiLCAhdGhpcy5zb3VuZHNfdGFibGUuaGFzT3duUHJvcGVydHkodGhpcy5zdXJmYWNlKSkge1xuICAgICAgdGhpcy5zb3VuZHNfdGFibGVbdGhpcy5zdXJmYWNlXSA9IFtdO1xuICAgICAgbGV0IGkgPSBlW3RoaXMuc3VyZmFjZV07XG4gICAgICBmb3IgKGxldCBzID0gMTsgcyA8PSBpOyArK3MpIHtcbiAgICAgICAgY29uc3QgbyA9IGF3YWl0IHRoaXMubG9hZEF1ZGlvKHRoaXMuYXNzZXRQYXRoICsgXCJzb3VuZHMvc3VyZmFjZXMvc3VyZmFjZV9cIiArIHRoaXMuc3VyZmFjZSArIHMgKyBcIi5tcDNcIik7XG4gICAgICAgIHRoaXMuc291bmRzX3RhYmxlW3RoaXMuc3VyZmFjZV0ucHVzaChvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnNvdW5kc19kaWNlLmhhc093blByb3BlcnR5KFwiY29pblwiKSkge1xuICAgICAgdGhpcy5zb3VuZHNfZGljZS5jb2luID0gW107XG4gICAgICBsZXQgaSA9IHQuY29pbjtcbiAgICAgIGZvciAobGV0IHMgPSAxOyBzIDw9IGk7ICsrcykge1xuICAgICAgICBjb25zdCBvID0gYXdhaXQgdGhpcy5sb2FkQXVkaW8odGhpcy5hc3NldFBhdGggKyBcInNvdW5kcy9kaWNlaGl0L2RpY2VoaXRfY29pblwiICsgcyArIFwiLm1wM1wiKTtcbiAgICAgICAgdGhpcy5zb3VuZHNfZGljZS5jb2luLnB1c2gobyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5zb3VuZHNfZGljZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLnNvdW5kX2RpZU1hdGVyaWFsKSkge1xuICAgICAgdGhpcy5zb3VuZHNfZGljZVt0aGlzLnNvdW5kX2RpZU1hdGVyaWFsXSA9IFtdO1xuICAgICAgbGV0IGkgPSB0W3RoaXMuc291bmRfZGllTWF0ZXJpYWxdO1xuICAgICAgZm9yIChsZXQgcyA9IDE7IHMgPD0gaTsgKytzKSB7XG4gICAgICAgIGNvbnN0IG8gPSBhd2FpdCB0aGlzLmxvYWRBdWRpbyh0aGlzLmFzc2V0UGF0aCArIFwic291bmRzL2RpY2VoaXQvZGljZWhpdF9cIiArIHRoaXMuc291bmRfZGllTWF0ZXJpYWwgKyBzICsgXCIubXAzXCIpO1xuICAgICAgICB0aGlzLnNvdW5kc19kaWNlW3RoaXMuc291bmRfZGllTWF0ZXJpYWxdLnB1c2gobyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWRBdWRpbyhlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0LCBuKSA9PiB7XG4gICAgICBsZXQgaSA9IG5ldyBBdWRpbygpO1xuICAgICAgaS5vbmNhbnBsYXl0aHJvdWdoID0gKCkgPT4gdChpKSwgaS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCIsIGkuc3JjID0gZSwgaS5vbmVycm9yID0gKHMpID0+IG4ocyk7XG4gICAgfSkuY2F0Y2goKHQpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gbG9hZCBhdWRpb1wiKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVDb25maWcoZSA9IHt9KSB7XG4gICAgT2JqZWN0LmFwcGx5KHRoaXMsIGUpLCB0aGlzLnRoZW1lX2N1c3RvbUNvbG9yc2V0ID0gZS50aGVtZV9jdXN0b21Db2xvcnNldCA/IGUudGhlbWVfY3VzdG9tQ29sb3JzZXQgOiBudWxsLCBlLnRoZW1lX2NvbG9yc2V0ICYmICh0aGlzLnRoZW1lX2NvbG9yc2V0ID0gZS50aGVtZV9jb2xvcnNldCksIGUudGhlbWVfdGV4dHVyZSAmJiAodGhpcy50aGVtZV90ZXh0dXJlID0gZS50aGVtZV90ZXh0dXJlKSwgZS50aGVtZV9tYXRlcmlhbCAmJiAodGhpcy50aGVtZV9tYXRlcmlhbCA9IGUudGhlbWVfbWF0ZXJpYWwpLCAoZS50aGVtZV9jb2xvcnNldCB8fCBlLnRoZW1lX3RleHR1cmUgfHwgZS50aGVtZV9tYXRlcmlhbCB8fCBlLnRoZW1lX2N1c3RvbUNvbG9yc2V0KSAmJiBhd2FpdCB0aGlzLmxvYWRUaGVtZSh7XG4gICAgICBjb2xvcnNldDogdGhpcy50aGVtZV9jb2xvcnNldCxcbiAgICAgIHRleHR1cmU6IHRoaXMudGhlbWVfdGV4dHVyZSxcbiAgICAgIG1hdGVyaWFsOiB0aGlzLnRoZW1lX21hdGVyaWFsXG4gICAgfSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucyhlKSB7XG4gICAgc3dpdGNoICh0aGlzLmRpc3BsYXkuY3VycmVudFdpZHRoID0gdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGggLyAyLCB0aGlzLmRpc3BsYXkuY3VycmVudEhlaWdodCA9IHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDIsIGUgPyAodGhpcy5kaXNwbGF5LmNvbnRhaW5lcldpZHRoID0gZS54LCB0aGlzLmRpc3BsYXkuY29udGFpbmVySGVpZ2h0ID0gZS55KSA6ICh0aGlzLmRpc3BsYXkuY29udGFpbmVyV2lkdGggPSB0aGlzLmRpc3BsYXkuY3VycmVudFdpZHRoLCB0aGlzLmRpc3BsYXkuY29udGFpbmVySGVpZ2h0ID0gdGhpcy5kaXNwbGF5LmN1cnJlbnRIZWlnaHQpLCB0aGlzLmRpc3BsYXkuYXNwZWN0ID0gTWF0aC5taW4odGhpcy5kaXNwbGF5LmN1cnJlbnRXaWR0aCAvIHRoaXMuZGlzcGxheS5jb250YWluZXJXaWR0aCwgdGhpcy5kaXNwbGF5LmN1cnJlbnRIZWlnaHQgLyB0aGlzLmRpc3BsYXkuY29udGFpbmVySGVpZ2h0KSwgdGhpcy5kaXNwbGF5LnNjYWxlID0gTWF0aC5zcXJ0KHRoaXMuZGlzcGxheS5jb250YWluZXJXaWR0aCAqIHRoaXMuZGlzcGxheS5jb250YWluZXJXaWR0aCArIHRoaXMuZGlzcGxheS5jb250YWluZXJIZWlnaHQgKiB0aGlzLmRpc3BsYXkuY29udGFpbmVySGVpZ2h0KSAvIDEzLCB0aGlzLm1ha2VXb3JsZEJveCgpLCB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy5kaXNwbGF5LmN1cnJlbnRXaWR0aCAqIDIsIHRoaXMuZGlzcGxheS5jdXJyZW50SGVpZ2h0ICogMiksIHRoaXMuY2FtZXJhSGVpZ2h0Lm1heCA9IHRoaXMuZGlzcGxheS5jdXJyZW50SGVpZ2h0IC8gdGhpcy5kaXNwbGF5LmFzcGVjdCAvIE1hdGgudGFuKDEwICogTWF0aC5QSSAvIDE4MCksIHRoaXMuY2FtZXJhSGVpZ2h0Lm1lZGl1bSA9IHRoaXMuY2FtZXJhSGVpZ2h0Lm1heCAvIDEuNSwgdGhpcy5jYW1lcmFIZWlnaHQuZmFyID0gdGhpcy5jYW1lcmFIZWlnaHQubWF4LCB0aGlzLmNhbWVyYUhlaWdodC5jbG9zZSA9IHRoaXMuY2FtZXJhSGVpZ2h0Lm1heCAvIDIsIHRoaXMuY2FtZXJhICYmIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMuY2FtZXJhKSwgdGhpcy5jYW1lcmEgPSBuZXcgZ3QoMjAsIHRoaXMuZGlzcGxheS5jdXJyZW50V2lkdGggLyB0aGlzLmRpc3BsYXkuY3VycmVudEhlaWdodCwgMSwgdGhpcy5jYW1lcmFIZWlnaHQubWF4ICogMS4zKSwgdGhpcy5hbmltc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJzZWxlY3RvclwiOlxuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gdGhpcy5zZWxlY3Rvci5kaWNlLmxlbmd0aCA+IDkgPyB0aGlzLmNhbWVyYUhlaWdodC5mYXIgOiB0aGlzLnNlbGVjdG9yLmRpY2UubGVuZ3RoIDwgNiA/IHRoaXMuY2FtZXJhSGVpZ2h0LmNsb3NlIDogdGhpcy5jYW1lcmFIZWlnaHQubWVkaXVtO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgY2FzZSBcImFmdGVydGhyb3dcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSB0aGlzLmNhbWVyYUhlaWdodC5mYXI7XG4gICAgfVxuICAgIHRoaXMuY2FtZXJhLmxvb2tBdChuZXcgTygwLCAwLCAwKSk7XG4gICAgY29uc3QgdCA9IE1hdGgubWF4KHRoaXMuZGlzcGxheS5jb250YWluZXJXaWR0aCwgdGhpcy5kaXNwbGF5LmNvbnRhaW5lckhlaWdodCk7XG4gICAgdGhpcy5saWdodCAmJiB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLmxpZ2h0KSwgdGhpcy5saWdodF9hbWIgJiYgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5saWdodF9hbWIpLCB0aGlzLmxpZ2h0ID0gbmV3IEh1KHRoaXMuY29sb3Jfc3BvdGxpZ2h0LCB0aGlzLmxpZ2h0X2ludGVuc2l0eSksIHRoaXMubGlnaHQucG9zaXRpb24uc2V0KC10IC8gMiwgdCAvIDIsIHQgKiAzKSwgdGhpcy5saWdodC50YXJnZXQucG9zaXRpb24uc2V0KDAsIDAsIDApLCB0aGlzLmxpZ2h0LmRpc3RhbmNlID0gdCAqIDUsIHRoaXMubGlnaHQuYW5nbGUgPSBNYXRoLlBJIC8gNCwgdGhpcy5saWdodC5jYXN0U2hhZG93ID0gdGhpcy5zaGFkb3dzLCB0aGlzLmxpZ2h0LnNoYWRvdy5jYW1lcmEubmVhciA9IHQgLyAxMCwgdGhpcy5saWdodC5zaGFkb3cuY2FtZXJhLmZhciA9IHQgKiA1LCB0aGlzLmxpZ2h0LnNoYWRvdy5jYW1lcmEuZm92ID0gNTAsIHRoaXMubGlnaHQuc2hhZG93LmJpYXMgPSAxZS0zLCB0aGlzLmxpZ2h0LnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNCwgdGhpcy5saWdodC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSAxMDI0LCB0aGlzLnNjZW5lLmFkZCh0aGlzLmxpZ2h0KSwgdGhpcy5saWdodF9hbWIgPSBuZXcga3UoMTY3NzcxNDcsIDY3NzY2ODksIHRoaXMubGlnaHRfaW50ZW5zaXR5KSwgdGhpcy5zY2VuZS5hZGQodGhpcy5saWdodF9hbWIpLCB0aGlzLmRlc2sgJiYgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5kZXNrKTtcbiAgICBsZXQgbiA9IG5ldyBPdSgpO1xuICAgIG4ub3BhY2l0eSA9IDAuNSwgdGhpcy5kZXNrID0gbmV3IE50KG5ldyBqaSh0aGlzLmRpc3BsYXkuY29udGFpbmVyV2lkdGggKiA2LCB0aGlzLmRpc3BsYXkuY29udGFpbmVySGVpZ2h0ICogNiwgMSwgMSksIG4pLCB0aGlzLmRlc2sucmVjZWl2ZVNoYWRvdyA9IHRoaXMuc2hhZG93cywgdGhpcy5zY2VuZS5hZGQodGhpcy5kZXNrKSwgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG4gIHJlc2l6ZVdvcmxkKCkge1xuICAgIGNvbnN0IHQgPSBFcCgoKSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy5yZW5kZXJlci5kb21FbGVtZW50LCBpID0gdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsIHMgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsIG8gPSBuLndpZHRoICE9PSBpIHx8IG4uaGVpZ2h0ICE9PSBzO1xuICAgICAgcmV0dXJuIG8gJiYgdGhpcy5zZXREaW1lbnNpb25zKG5ldyBDZSh0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCwgdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0KSksIG87XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdCk7XG4gIH1cbiAgdmVjdG9yUmFuZCh7IHg6IGUsIHk6IHQgfSkge1xuICAgIGxldCBuID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgLyA1IC0gTWF0aC5QSSAvIDUgLyAyLCBpID0ge1xuICAgICAgeDogZSAqIE1hdGguY29zKG4pIC0gdCAqIE1hdGguc2luKG4pLFxuICAgICAgeTogZSAqIE1hdGguc2luKG4pICsgdCAqIE1hdGguY29zKG4pXG4gICAgfTtcbiAgICByZXR1cm4gaS54ID09IDAgJiYgKGkueCA9IDAuMDEpLCBpLnkgPT0gMCAmJiAoaS55ID0gMC4wMSksIGk7XG4gIH1cbiAgZ2V0Tm90YXRpb25WZWN0b3JzKGUsIHQsIG4sIGkpIHtcbiAgICBsZXQgcyA9IG5ldyBRcihlKTtcbiAgICBmb3IgKGxldCBvIGluIHMuc2V0KSB7XG4gICAgICBjb25zdCByID0gdGhpcy5EaWNlRmFjdG9yeS5nZXQocy5zZXRbb10udHlwZSk7XG4gICAgICBsZXQgbCA9IHMuc2V0W29dLm51bSwgYSA9IHMuc2V0W29dLm9wLCBjID0gcy5zZXRbb10uc2lkLCBkID0gcy5zZXRbb10uZ2lkLCB1ID0gcy5zZXRbb10uZ2x2bCwgbSA9IHMuc2V0W29dLmZ1bmMsIGcgPSBzLnNldFtvXS5hcmdzO1xuICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBsOyBwKyspIHtcbiAgICAgICAgbGV0IGYgPSB0aGlzLnZlY3RvclJhbmQodCk7XG4gICAgICAgIGYueCAvPSBpLCBmLnkgLz0gaTtcbiAgICAgICAgbGV0IHYgPSB7XG4gICAgICAgICAgeDogdGhpcy5kaXNwbGF5LmNvbnRhaW5lcldpZHRoICogKGYueCA+IDAgPyAtMSA6IDEpICogMC45LFxuICAgICAgICAgIHk6IHRoaXMuZGlzcGxheS5jb250YWluZXJIZWlnaHQgKiAoZi55ID4gMCA/IC0xIDogMSkgKiAwLjksXG4gICAgICAgICAgejogTWF0aC5yYW5kb20oKSAqIDIwMCArIDIwMFxuICAgICAgICB9LCBfID0gTWF0aC5hYnMoZi54IC8gZi55KTtcbiAgICAgICAgXyA+IDEgPyB2LnkgLz0gXyA6IHYueCAqPSBfO1xuICAgICAgICBsZXQgdyA9IHRoaXMudmVjdG9yUmFuZCh0KTtcbiAgICAgICAgdy54IC89IGksIHcueSAvPSBpO1xuICAgICAgICBsZXQgeCwgTSwgRTtcbiAgICAgICAgci5zaGFwZSAhPSBcImQyXCIgPyAoeCA9IHtcbiAgICAgICAgICB4OiB3LnggKiBuLFxuICAgICAgICAgIHk6IHcueSAqIG4sXG4gICAgICAgICAgejogLTEwXG4gICAgICAgIH0sIE0gPSB7XG4gICAgICAgICAgeDogLShNYXRoLnJhbmRvbSgpICogZi55ICogNSArIHIuaW5lcnRpYSAqIGYueSksXG4gICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIGYueCAqIDUgKyByLmluZXJ0aWEgKiBmLngsXG4gICAgICAgICAgejogMFxuICAgICAgICB9LCBFID0ge1xuICAgICAgICAgIHg6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgeTogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICB6OiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgIGE6IE1hdGgucmFuZG9tKClcbiAgICAgICAgfSkgOiAoeCA9IHtcbiAgICAgICAgICB4OiB3LnggKiBuIC8gMTAsXG4gICAgICAgICAgeTogdy55ICogbiAvIDEwLFxuICAgICAgICAgIHo6IDNlM1xuICAgICAgICB9LCBNID0ge1xuICAgICAgICAgIHg6IDEyICogci5pbmVydGlhLFxuICAgICAgICAgIHk6IDEgKiByLmluZXJ0aWEsXG4gICAgICAgICAgejogMFxuICAgICAgICB9LCBFID0ge1xuICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgeTogMSxcbiAgICAgICAgICB6OiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgIGE6IE1hdGgucmFuZG9tKClcbiAgICAgICAgfSksIHMudmVjdG9ycy5wdXNoKHtcbiAgICAgICAgICBpbmRleDogdGhpcy5kaWVJbmRleCsrLFxuICAgICAgICAgIHR5cGU6IHIudHlwZSxcbiAgICAgICAgICBvcDogYSxcbiAgICAgICAgICBzaWQ6IGMsXG4gICAgICAgICAgZ2lkOiBkLFxuICAgICAgICAgIGdsdmw6IHUsXG4gICAgICAgICAgZnVuYzogbSxcbiAgICAgICAgICBhcmdzOiBnLFxuICAgICAgICAgIHBvczogdixcbiAgICAgICAgICB2ZWxvY2l0eTogeCxcbiAgICAgICAgICBhbmdsZTogTSxcbiAgICAgICAgICBheGlzOiBFXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuICBzd2FwRGljZUZhY2UoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLkRpY2VGYWN0b3J5LmdldChlLm5vdGF0aW9uLnR5cGUpO1xuICAgIGlmIChlLnJlc3VsdFJlYXNvbiA9IFwiZm9yY2VkXCIsIG4uc2hhcGUgPT0gXCJkNFwiKSB7XG4gICAgICB0aGlzLnN3YXBEaWNlRmFjZV9ENChlLCB0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbi52YWx1ZXM7XG4gICAgbGV0IGkgPSBwYXJzZUludChlLmdldExhc3RWYWx1ZSgpLnZhbHVlKTtcbiAgICB0ID0gcGFyc2VJbnQodCksIGUubm90YXRpb24udHlwZSA9PSBcImQxMFwiICYmIGkgPT0gMCAmJiAoaSA9IDEwKSwgZS5ub3RhdGlvbi50eXBlID09IFwiZDEwMFwiICYmIGkgPT0gMCAmJiAoaSA9IDEwMCksIGUubm90YXRpb24udHlwZSA9PSBcImQxMDBcIiAmJiBpID4gMCAmJiBpIDwgMTAgJiYgKGkgKj0gMTApLCBlLm5vdGF0aW9uLnR5cGUgPT0gXCJkMTBcIiAmJiB0ID09IDAgJiYgKHQgPSAxMCksIGUubm90YXRpb24udHlwZSA9PSBcImQxMDBcIiAmJiB0ID09IDAgJiYgKHQgPSAxMDApLCBlLm5vdGF0aW9uLnR5cGUgPT0gXCJkMTAwXCIgJiYgdCA+IDAgJiYgdCA8IDEwICYmICh0ICo9IDEwKTtcbiAgICBsZXQgcyA9IG4udmFsdWVzLmluZGV4T2YoaSksIG8gPSBuLnZhbHVlcy5pbmRleE9mKHQpO1xuICAgIGlmIChzIDwgMCB8fCBvIDwgMCB8fCBzID09IG8pXG4gICAgICByZXR1cm47XG4gICAgbGV0IHIgPSBlLmdlb21ldHJ5LmNsb25lKCksIGwgPSBbXSwgYSA9IFtdLCBjID0gMjtcbiAgICBuLnNoYXBlID09IFwiZDEwXCIgJiYgKGMgPSAxKTtcbiAgICBsZXQgZCwgdSA9IG8gKyBjO1xuICAgIG4uc2hhcGUgIT0gXCJkMlwiID8gKGQgPSBzICsgYywgdSA9IG8gKyBjKSA6IChkID0gcyArIDEsIHUgPSBvICsgMSk7XG4gICAgZm9yICh2YXIgbSA9IDAsIGcgPSByLmdyb3Vwcy5sZW5ndGg7IG0gPCBnOyArK20pIHtcbiAgICAgIGNvbnN0IGYgPSByLmdyb3Vwc1ttXS5tYXRlcmlhbEluZGV4O1xuICAgICAgaWYgKGYgPT0gZCkge1xuICAgICAgICBsLnB1c2gobSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGYgPT0gdSkge1xuICAgICAgICBhLnB1c2gobSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIShsLmxlbmd0aCA8PSAwIHx8IGEubGVuZ3RoIDw9IDApKSB7XG4gICAgICBmb3IgKGxldCBwID0gMCwgZiA9IGEubGVuZ3RoOyBwIDwgZjsgcCsrKVxuICAgICAgICByLmdyb3Vwc1thW3BdXS5tYXRlcmlhbEluZGV4ID0gZDtcbiAgICAgIGZvciAobGV0IHAgPSAwLCBmID0gbC5sZW5ndGg7IHAgPCBmOyBwKyspXG4gICAgICAgIHIuZ3JvdXBzW2xbcF1dLm1hdGVyaWFsSW5kZXggPSB1O1xuICAgICAgZS5nZW9tZXRyeSA9IHIsIGUucmVzdWx0ID0gW107XG4gICAgfVxuICB9XG4gIHN3YXBEaWNlRmFjZV9ENChlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuRGljZUZhY3RvcnkuZ2V0KGUubm90YXRpb24udHlwZSk7XG4gICAgbGV0IGkgPSBwYXJzZUludChlLmdldExhc3RWYWx1ZSgpLnZhbHVlKTtcbiAgICBpZiAodCA9IHBhcnNlSW50KHQpLCAhKGkgPj0gMSAmJiBpIDw9IDQpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBzID0gdCAtIGksIG8gPSBlLmdlb21ldHJ5LmNsb25lKCk7XG4gICAgZm9yIChsZXQgciA9IDAsIGwgPSBvLmdyb3Vwcy5sZW5ndGg7IHIgPCBsOyArK3IpIHtcbiAgICAgIGNvbnN0IGEgPSBvLmdyb3Vwc1tyXTtcbiAgICAgIGxldCBjID0gYS5tYXRlcmlhbEluZGV4O1xuICAgICAgaWYgKGMgIT0gMCkge1xuICAgICAgICBmb3IgKGMgKz0gcyAtIDE7IGMgPiA0OyApXG4gICAgICAgICAgYyAtPSA0O1xuICAgICAgICBmb3IgKDsgYyA8IDE7IClcbiAgICAgICAgICBjICs9IDQ7XG4gICAgICAgIGEubWF0ZXJpYWxJbmRleCA9IGMgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICBzICE9IDAgJiYgKHMgPCAwICYmIChzICs9IDQpLCBlLm1hdGVyaWFsID0gdGhpcy5EaWNlRmFjdG9yeS5jcmVhdGVNYXRlcmlhbHMobiwgMCwgMCwgITEsIHMpKSwgZS5nZW9tZXRyeSA9IG87XG4gIH1cbiAgc3Bhd25EaWNlKGUsIHQgPSAhMSkge1xuICAgIGNvbnN0IHsgcG9zOiBuLCBheGlzOiBpLCBhbmdsZTogcywgdmVsb2NpdHk6IG8gfSA9IGU7XG4gICAgbGV0IHI7XG4gICAgaWYgKHQpXG4gICAgICByID0gdCwgci5zdG9wcGVkID0gMCwgdGhpcy53b3JsZC5yZW1vdmVCb2R5KHIuYm9keSk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAociA9IHRoaXMuRGljZUZhY3RvcnkuY3JlYXRlKGUudHlwZSwgdGhpcy5jb2xvckRhdGEpLCAhcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgci5ub3RhdGlvbiA9IGUsIHIucmVzdWx0ID0gW10sIHIuc3RvcHBlZCA9IDAsIHIuY2FzdFNoYWRvdyA9IHRoaXMuc2hhZG93cywgdGhpcy5zY2VuZS5hZGQociksIHRoaXMuZGljZUxpc3QucHVzaChyKTtcbiAgICB9XG4gICAgci5ib2R5ID0gbmV3IGllKHsgYWxsb3dTbGVlcDogITAsIHNsZWVwU3BlZWRMaW1pdDogNzUsIHNsZWVwVGltZUxpbWl0OiAwLjksIG1hc3M6IHIubWFzcywgc2hhcGU6IHIuZ2VvbWV0cnkuY2Fubm9uX3NoYXBlLCBtYXRlcmlhbDogdGhpcy5kaWNlX2JvZHlfbWF0ZXJpYWwgfSksIHIuYm9keS50eXBlID0gaWUuRFlOQU1JQywgci5ib2R5LnBvc2l0aW9uLnNldChuLngsIG4ueSwgbi56KSwgci5ib2R5LnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShuZXcgYihpLngsIGkueSwgaS56KSwgaS5hICogTWF0aC5QSSAqIDIpLCByLmJvZHkuYW5ndWxhclZlbG9jaXR5LnNldChzLngsIHMueSwgcy56KSwgci5ib2R5LnZlbG9jaXR5LnNldChvLngsIG8ueSwgby56KSwgci5ib2R5LmxpbmVhckRhbXBpbmcgPSAwLjEsIHIuYm9keS5hbmd1bGFyRGFtcGluZyA9IDAuMSwgci5ib2R5LmRpY2VTaGFwZSA9IHIuc2hhcGUsIHIuYm9keS5zbGVlcFN0YXRlID0gMCwgci5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjb2xsaWRlXCIsIHRoaXMuZXZlbnRDb2xsaWRlLmJpbmQodGhpcykpLCB0aGlzLndvcmxkLmFkZEJvZHkoci5ib2R5KTtcbiAgfVxuICBldmVudENvbGxpZGUoeyBib2R5OiBlLCB0YXJnZXQ6IHQgfSkge1xuICAgIGlmICh0aGlzLmFuaW1zdGF0ZSA9PSBcInNpbXVsYXRlXCIgfHwgIXRoaXMuc291bmRzIHx8ICFlIHx8IHRoaXMudm9sdW1lIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IG4gPSBEYXRlLm5vdygpLCBpID0gZS5tYXNzID4gMCA/IFwiZGljZVwiIDogXCJ0YWJsZVwiO1xuICAgIGlmICghKCh0aGlzLmxhc3RTb3VuZFN0ZXAgPT0gZS53b3JsZC5zdGVwbnVtYmVyIHx8IHRoaXMubGFzdFNvdW5kID4gbikgJiYgaSAhPSBcImRpY2VcIikgJiYgISgodGhpcy5sYXN0U291bmRTdGVwID09IGUud29ybGQuc3RlcG51bWJlciB8fCB0aGlzLmxhc3RTb3VuZCA+IG4pICYmIGkgPT0gXCJkaWNlXCIgJiYgdGhpcy5sYXN0U291bmRUeXBlID09IFwiZGljZVwiKSkge1xuICAgICAgaWYgKGUubWFzcyA+IDApIHtcbiAgICAgICAgbGV0IHMgPSBlLnZlbG9jaXR5Lmxlbmd0aCgpO1xuICAgICAgICBpZiAocyA8IDI1MClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBvO1xuICAgICAgICBlLmRpY2VTaGFwZSA9PT0gXCJkMlwiID8gbyA9IHRoaXMuc291bmRzX2RpY2UuY29pbltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNvdW5kc19kaWNlLmNvaW4ubGVuZ3RoKV0gOiBvID0gdGhpcy5zb3VuZHNfZGljZVt0aGlzLnNvdW5kX2RpZU1hdGVyaWFsXVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNvdW5kc19kaWNlW3RoaXMuc291bmRfZGllTWF0ZXJpYWxdLmxlbmd0aCldLCBvICYmIChvLnZvbHVtZSA9IE1hdGgubWluKHMgLyA4ZTMsIHRoaXMudm9sdW1lIC8gMTAwKSwgby5wbGF5KCkuY2F0Y2goKHIpID0+IHtcbiAgICAgICAgfSkpLCB0aGlzLmxhc3RTb3VuZFR5cGUgPSBcImRpY2VcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzID0gdC52ZWxvY2l0eS5sZW5ndGgoKTtcbiAgICAgICAgaWYgKHMgPCAyNTApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbyA9IHRoaXMuc3VyZmFjZSwgciA9IHRoaXMuc291bmRzX3RhYmxlW29dLCBsID0gcltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByLmxlbmd0aCldO1xuICAgICAgICBsICYmIChsLnZvbHVtZSA9IE1hdGgubWluKHMgLyA4ZTMsIHRoaXMudm9sdW1lIC8gMTAwKSwgbC5wbGF5KCkuY2F0Y2goKGEpID0+IHtcbiAgICAgICAgfSkpLCB0aGlzLmxhc3RTb3VuZFR5cGUgPSBcInRhYmxlXCI7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RTb3VuZFN0ZXAgPSBlLndvcmxkLnN0ZXBudW1iZXIsIHRoaXMubGFzdFNvdW5kID0gbiArIHRoaXMuc291bmREZWxheTtcbiAgICB9XG4gIH1cbiAgY2hlY2tGb3JSZXRocm93KGUpIHtcbiAgICBsZXQgdCA9IGUubm90YXRpb24uZnVuYyA/IGUubm90YXRpb24uZnVuYy50b0xvd2VyQ2FzZSgpIDogXCJcIiwgbiwgaSA9ICExO1xuICAgIGlmICh0ICE9IFwiXCIgJiYgbiAmJiBuLm1ldGhvZCkge1xuICAgICAgdCA9IGUubm90YXRpb24uZnVuYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgbGV0IHMgPSBlLm5vdGF0aW9uLmFyZ3MgfHwgXCJcIjtcbiAgICAgIGkgPSBuLm1ldGhvZChlLCBzKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgdGhyb3dGaW5pc2hlZCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5pdGVyYXRpb24gPiB0aGlzLml0ZXJhdGlvbkxpbWl0O1xuICAgIGZvciAobGV0IHQgPSAwLCBuID0gdGhpcy5kaWNlTGlzdC5sZW5ndGg7IHQgPCBuOyArK3QpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmRpY2VMaXN0W3RdLCBzID0gaWUuU0xFRVBJTkc7XG4gICAgICBpZiAoaS5ib2R5LnNsZWVwU3RhdGUgPCBzICYmICFlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoaS5ib2R5LnNsZWVwU3RhdGUgPT0gcyB8fCBlKSB7XG4gICAgICAgIGlmIChpLmJvZHkudHlwZSA9PT0gaWUuS0lORU1BVElDKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbyA9ICExO1xuICAgICAgICBpZiAoaS5yZXN1bHQubGVuZ3RoID09IDAgPyAoaS5zdG9yZVJvbGxlZFZhbHVlKGkucmVzdWx0UmVhc29uKSwgbyA9IHRoaXMuY2hlY2tGb3JSZXRocm93KGkpKSA6IGkucmVzdWx0Lmxlbmd0aCA+IDAgJiYgaS5yZXJvbGxpbmcgJiYgKGkucmVyb2xsaW5nID0gITEsIGkuc3RvcmVSb2xsZWRWYWx1ZShcInJlcm9sbFwiKSwgbyA9IHRoaXMuY2hlY2tGb3JSZXRocm93KGkpKSwgbylcbiAgICAgICAgICByZXR1cm4gaS5yZXJvbGxzICs9IDEsIGkucmVyb2xsaW5nID0gITAsIGkuYm9keS53YWtlVXAoKSwgaS5ib2R5LnR5cGUgPSBpZS5EWU5BTUlDLCBpLmJvZHkuYW5ndWxhclZlbG9jaXR5ID0gbmV3IGIoMjUsIDI1LCAyNSksIGkuYm9keS52ZWxvY2l0eSA9IG5ldyBiKDAsIDAsIDNlMyksICExO1xuICAgICAgICBpLnJlcm9sbGluZyA9ICExLCBpLmJvZHkudHlwZSA9IGllLktJTkVNQVRJQztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHNpbXVsYXRlVGhyb3coKSB7XG4gICAgZm9yICh0aGlzLmFuaW1zdGF0ZSA9IFwic2ltdWxhdGVcIiwgdGhpcy5pdGVyYXRpb24gPSAwLCB0aGlzLnJvbGxpbmcgPSAhMDsgIXRoaXMudGhyb3dGaW5pc2hlZCghMCk7IClcbiAgICAgICsrdGhpcy5pdGVyYXRpb24sIHRoaXMud29ybGQuc3RlcCh0aGlzLmZyYW1lcmF0ZSk7XG4gIH1cbiAgYW5pbWF0ZVRocm93KGUsIHQpIHtcbiAgICB0aGlzLmFuaW1zdGF0ZSA9IFwidGhyb3dcIjtcbiAgICBsZXQgbiA9IERhdGUubm93KCk7XG4gICAgdGhpcy5sYXN0X3RpbWUgPSB0aGlzLmxhc3RfdGltZSB8fCBuIC0gdGhpcy5mcmFtZXJhdGUgKiAxZTM7XG4gICAgbGV0IGkgPSAobiAtIHRoaXMubGFzdF90aW1lKSAvIDFlMztcbiAgICArK3RoaXMuaXRlcmF0aW9uO1xuICAgIGxldCBzID0gTWF0aC5mbG9vcihpIC8gdGhpcy5mcmFtZXJhdGUpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgczsgbysrKVxuICAgICAgdGhpcy53b3JsZC5zdGVwKHRoaXMuZnJhbWVyYXRlKSwgKyt0aGlzLnN0ZXBzO1xuICAgIGZvciAobGV0IG8gaW4gdGhpcy5zY2VuZS5jaGlsZHJlbikge1xuICAgICAgbGV0IHIgPSB0aGlzLnNjZW5lLmNoaWxkcmVuW29dO1xuICAgICAgci5ib2R5ICE9IG51bGwgJiYgKHIucG9zaXRpb24uY29weShyLmJvZHkucG9zaXRpb24pLCByLnF1YXRlcm5pb24uY29weShyLmJvZHkucXVhdGVybmlvbikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpLCB0aGlzLmxhc3RfdGltZSA9IHRoaXMubGFzdF90aW1lICsgcyAqIHRoaXMuZnJhbWVyYXRlICogMWUzLCB0aGlzLnJ1bm5pbmcgPT0gZSAmJiB0aGlzLnRocm93RmluaXNoZWQoKSkge1xuICAgICAgdGhpcy5ydW5uaW5nID0gITEsIHRoaXMucm9sbGluZyA9ICExLCB0ICYmIHQuY2FsbCh0aGlzLCB0aGlzLm5vdGF0aW9uVmVjdG9ycyksIHRoaXMucnVubmluZyA9IERhdGUubm93KCksIHRoaXMuYW5pbWF0ZUFmdGVyVGhyb3codGhpcy5ydW5uaW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ydW5uaW5nID09IGUgJiYgKChvLCByLCBsLCBhLCBjKSA9PiB7XG4gICAgICAhbCAmJiBpIDwgdGhpcy5mcmFtZXJhdGUgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBvLmNhbGwodGhpcywgciwgYSwgYyk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgKHRoaXMuZnJhbWVyYXRlIC0gaSkgKiAxZTMpIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgby5jYWxsKHRoaXMsIHIsIGEsIGMpO1xuICAgICAgfSk7XG4gICAgfSkuYmluZCh0aGlzKSh0aGlzLmFuaW1hdGVUaHJvdywgZSwgdGhpcy5hZGFwdGl2ZV90aW1lc3RlcCwgdCk7XG4gIH1cbiAgYW5pbWF0ZUFmdGVyVGhyb3coZSkge1xuICAgIHRoaXMuYW5pbXN0YXRlID0gXCJhZnRlcnRocm93XCI7XG4gICAgbGV0IHQgPSBEYXRlLm5vdygpLCBuID0gKHQgLSB0aGlzLmxhc3RfdGltZSkgLyAxZTM7XG4gICAgbiA+IDMgJiYgKG4gPSB0aGlzLmZyYW1lcmF0ZSksIHRoaXMucnVubmluZyA9ICExLCB0aGlzLmxhc3RfdGltZSA9IHQsIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKSwgdGhpcy5ydW5uaW5nID09IGUgJiYgKChpLCBzLCBvKSA9PiB7XG4gICAgICAhbyAmJiBuIDwgdGhpcy5mcmFtZXJhdGUgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpLmNhbGwodGhpcywgcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgKHRoaXMuZnJhbWVyYXRlIC0gbikgKiAxZTMpIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgaS5jYWxsKHRoaXMsIHMpO1xuICAgICAgfSk7XG4gICAgfSkuYmluZCh0aGlzKSh0aGlzLmFuaW1hdGVBZnRlclRocm93LCBlLCB0aGlzLmFkYXB0aXZlX3RpbWVzdGVwKTtcbiAgfVxuICBzdGFydENsaWNrVGhyb3coZSkge1xuICAgIHRoaXMucm9sbGluZyAmJiAodGhpcy5jbGVhckRpY2UoKSwgdGhpcy5yb2xsaW5nID0gITEpO1xuICAgIGxldCB0ID0geyB4OiAoTWF0aC5yYW5kb20oKSAqIDIgLSAwLjUpICogdGhpcy5kaXNwbGF5LmN1cnJlbnRXaWR0aCwgeTogLShNYXRoLnJhbmRvbSgpICogMiAtIDAuNSkgKiB0aGlzLmRpc3BsYXkuY3VycmVudEhlaWdodCB9LCBuID0gTWF0aC5zcXJ0KHQueCAqIHQueCArIHQueSAqIHQueSkgKyAxMDAsIGkgPSAoTWF0aC5yYW5kb20oKSArIDMpICogbiAqIHRoaXMuc3RyZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm90YXRpb25WZWN0b3JzKGUsIHQsIGksIG4pO1xuICB9XG4gIGNsZWFyRGljZSgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSAhMTtcbiAgICBsZXQgZTtcbiAgICBmb3IgKDsgZSA9IHRoaXMuZGljZUxpc3QucG9wKCk7IClcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKGUpLCBlLmJvZHkgJiYgdGhpcy53b3JsZC5yZW1vdmVCb2R5KGUuYm9keSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICB9LCAxMDApO1xuICB9XG4gIGdldERpY2VSZXN1bHRzKGUpIHtcbiAgICBpZiAoZSAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy5kaWNlTGlzdFtlXS5zaGFwZSxcbiAgICAgICAgc2lkZXM6IHBhcnNlSW50KHRoaXMuZGljZUxpc3RbZV0uc2hhcGUuc3Vic3RyaW5nKDEpKSxcbiAgICAgICAgaWQ6IGUsXG4gICAgICAgIC4uLnRoaXMuZGljZUxpc3RbZV0ucmVzdWx0LmF0KC0xKVxuICAgICAgfTtcbiAgICBsZXQgdCA9IDA7XG4gICAgY29uc3QgbiA9IHRoaXMubm90YXRpb25WZWN0b3JzLmNvbnN0YW50ID8gcGFyc2VJbnQoYCR7dGhpcy5ub3RhdGlvblZlY3RvcnMub3B9JHt0aGlzLm5vdGF0aW9uVmVjdG9ycy5jb25zdGFudH1gKSA6IDA7XG4gICAgbGV0IGkgPSBuO1xuICAgIHJldHVybiB7XG4gICAgICBub3RhdGlvbjogdGhpcy5ub3RhdGlvblZlY3RvcnMubm90YXRpb24sXG4gICAgICBzZXRzOiB0aGlzLm5vdGF0aW9uVmVjdG9ycy5zZXQubWFwKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSB0ICsgby5udW0gLSAxO1xuICAgICAgICBsZXQgbCA9IDA7XG4gICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZCA9IHQ7IGQgPD0gcjsgZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGljZUxpc3RbdF0ucmVzdWx0LmF0KC0xKS5yZWFzb24gPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogby50eXBlLFxuICAgICAgICAgICAgc2lkZXM6IHBhcnNlSW50KG8udHlwZS5zdWJzdHJpbmcoMSkpLFxuICAgICAgICAgICAgaWQ6IHQsXG4gICAgICAgICAgICAuLi50aGlzLmRpY2VMaXN0W3RdLnJlc3VsdC5hdCgtMSlcbiAgICAgICAgICB9KSwgbCArPSB0aGlzLmRpY2VMaXN0W3RdLnJlc3VsdC5hdCgtMSkudmFsdWUsIHQrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjID0ge1xuICAgICAgICAgIG51bTogby5udW0sXG4gICAgICAgICAgdHlwZTogby50eXBlLFxuICAgICAgICAgIHNpZGVzOiBwYXJzZUludChvLnR5cGUuc3Vic3RyaW5nKDEpKSxcbiAgICAgICAgICByb2xsczogYSxcbiAgICAgICAgICB0b3RhbDogbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaSArPSBsLCBjO1xuICAgICAgfSksXG4gICAgICBtb2RpZmllcjogbixcbiAgICAgIHRvdGFsOiBpXG4gICAgfTtcbiAgfVxuICBhc3luYyByb2xsKGUpIHtcbiAgICBpZiAodGhpcy5ub3RhdGlvblZlY3RvcnMgPSB0aGlzLnN0YXJ0Q2xpY2tUaHJvdyhlKSwgdGhpcy5ub3RhdGlvblZlY3RvcnMpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHQsIG4pID0+IHtcbiAgICAgICAgdGhpcy5yb2xsRGljZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0RGljZVJlc3VsdHMoKTtcbiAgICAgICAgICB0aGlzLm9uUm9sbENvbXBsZXRlKGkpO1xuICAgICAgICAgIGNvbnN0IHMgPSBuZXcgQ3VzdG9tRXZlbnQoXCJyb2xsQ29tcGxldGVcIiwgeyBkZXRhaWw6IGkgfSk7XG4gICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChzKSwgdChpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuICBhc3luYyByZXJvbGwoZSkge1xuICAgIHJldHVybiB0aGlzLnJvbGxpbmcgPSAhMCwgdGhpcy5ydW5uaW5nID0gRGF0ZS5ub3coKSwgdGhpcy5pdGVyYXRpb24gPSAwLCBuZXcgUHJvbWlzZSgodCwgbikgPT4ge1xuICAgICAgZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmRpY2VMaXN0W2ldO1xuICAgICAgICBzLnJlcm9sbHMgKz0gMSwgcy5yZXJvbGxpbmcgPSAhMCwgcy5ib2R5Lndha2VVcCgpLCBzLmJvZHkudHlwZSA9IGllLkRZTkFNSUMsIHMuYm9keS5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgYigyNSwgMjUsIDI1KSwgcy5ib2R5LnZlbG9jaXR5ID0gbmV3IGIoMCwgMCwgM2UzKTtcbiAgICAgIH0pLCB0aGlzLmFuaW1hdGVUaHJvdyh0aGlzLnJ1bm5pbmcsICgpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGUubWFwKChvKSA9PiB0aGlzLmdldERpY2VSZXN1bHRzKG8pKTtcbiAgICAgICAgdGhpcy5vblJlcm9sbENvbXBsZXRlKGkpO1xuICAgICAgICBjb25zdCBzID0gbmV3IEN1c3RvbUV2ZW50KFwicmVyb2xsQ29tcGxldGVcIiwgeyBkZXRhaWw6IGkgfSk7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQocyksIHQoaSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhZGQoZSkge1xuICAgIGxldCB0ID0gdGhpcy5kaWNlTGlzdC5sZW5ndGg7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuIHRoaXMucm9sbChlKTtcbiAgICBsZXQgbiA9IHRoaXMuc3RhcnRDbGlja1Rocm93KGUpLCBpID0gW107XG4gICAgZm9yIChsZXQgcyA9IDAsIG8gPSBuLnZlY3RvcnMubGVuZ3RoOyBzIDwgbzsgKytzKVxuICAgICAgdGhpcy5zcGF3bkRpY2Uobi52ZWN0b3JzW3NdKTtcbiAgICB0aGlzLnNpbXVsYXRlVGhyb3coKSwgdGhpcy5zdGVwcyA9IDAsIHRoaXMuaXRlcmF0aW9uID0gMDtcbiAgICBmb3IgKGxldCBzID0gMCwgbyA9IG4udmVjdG9ycy5sZW5ndGg7IHMgPCBvOyArK3MpIHtcbiAgICAgIGNvbnN0IHIgPSB0ICsgcztcbiAgICAgICF0aGlzLmRpY2VMaXN0W3JdIHx8ICh0aGlzLnNwYXduRGljZShuLnZlY3RvcnNbc10sIHRoaXMuZGljZUxpc3Rbcl0pLCBpLnB1c2gocikpO1xuICAgIH1cbiAgICBpZiAobi5yZXN1bHQgJiYgbi5yZXN1bHQubGVuZ3RoID4gMClcbiAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgbi5yZXN1bHQubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgY29uc3QgbyA9IHQgKyBzO1xuICAgICAgICBsZXQgciA9IHRoaXMuZGljZUxpc3Rbb107XG4gICAgICAgICFyIHx8IHIuZ2V0TGFzdFZhbHVlKCkudmFsdWUgIT0gbi5yZXN1bHRbc10gJiYgdGhpcy5zd2FwRGljZUZhY2Uociwgbi5yZXN1bHRbc10pO1xuICAgICAgfVxuICAgIHJldHVybiB0aGlzLm5vdGF0aW9uVmVjdG9ycyA9IFFyLm1lcmdlTm90YXRpb24odGhpcy5ub3RhdGlvblZlY3RvcnMsIG4pLCBuZXcgUHJvbWlzZSgocywgbykgPT4ge1xuICAgICAgY29uc3QgciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbCA9IGkubWFwKChjKSA9PiB0aGlzLmdldERpY2VSZXN1bHRzKGMpKTtcbiAgICAgICAgdGhpcy5vbkFkZERpY2VDb21wbGV0ZShsKTtcbiAgICAgICAgY29uc3QgYSA9IG5ldyBDdXN0b21FdmVudChcImFkZERpY2VDb21wbGV0ZVwiLCB7IGRldGFpbDogbCB9KTtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChhKSwgcyhsKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnJvbGxpbmcgPSAhMCwgdGhpcy5ydW5uaW5nID0gRGF0ZS5ub3coKSwgdGhpcy5sYXN0X3RpbWUgPSAwLCB0aGlzLmFuaW1hdGVUaHJvdyh0aGlzLnJ1bm5pbmcsIHIpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJlbW92ZShlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0LCBuKSA9PiB7XG4gICAgICBjb25zdCBpID0gW107XG4gICAgICBlLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZGljZUxpc3Rbb107XG4gICAgICAgIHIuYm9keSAmJiB0aGlzLndvcmxkLnJlbW92ZUJvZHkoci5ib2R5KSwgdGhpcy5zY2VuZS5yZW1vdmUociksIHIuc3RvcmVSb2xsZWRWYWx1ZShcInJlbW92ZVwiKSwgaS5wdXNoKHRoaXMuZ2V0RGljZVJlc3VsdHMobykpO1xuICAgICAgfSksIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKSwgdGhpcy5vblJlbW92ZURpY2VDb21wbGV0ZShpKTtcbiAgICAgIGNvbnN0IHMgPSBuZXcgQ3VzdG9tRXZlbnQoXCJyZW1vdmVEaWNlQ29tcGxldGVcIiwgeyBkZXRhaWw6IGkgfSk7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KHMpLCB0KGkpO1xuICAgIH0pO1xuICB9XG4gIHJvbGxEaWNlKGUpIHtcbiAgICBpZiAodGhpcy5ub3RhdGlvblZlY3RvcnMuZXJyb3IpIHtcbiAgICAgIGUuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jbGVhckRpY2UoKTtcbiAgICBmb3IgKGxldCB0ID0gMCwgbiA9IHRoaXMubm90YXRpb25WZWN0b3JzLnZlY3RvcnMubGVuZ3RoOyB0IDwgbjsgKyt0KVxuICAgICAgdGhpcy5zcGF3bkRpY2UodGhpcy5ub3RhdGlvblZlY3RvcnMudmVjdG9yc1t0XSk7XG4gICAgdGhpcy5zaW11bGF0ZVRocm93KCksIHRoaXMuc3RlcHMgPSAwLCB0aGlzLml0ZXJhdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgdCA9IDAsIG4gPSB0aGlzLmRpY2VMaXN0Lmxlbmd0aDsgdCA8IG47ICsrdClcbiAgICAgICF0aGlzLmRpY2VMaXN0W3RdIHx8IHRoaXMuc3Bhd25EaWNlKHRoaXMubm90YXRpb25WZWN0b3JzLnZlY3RvcnNbdF0sIHRoaXMuZGljZUxpc3RbdF0pO1xuICAgIGlmICh0aGlzLm5vdGF0aW9uVmVjdG9ycy5yZXN1bHQgJiYgdGhpcy5ub3RhdGlvblZlY3RvcnMucmVzdWx0Lmxlbmd0aCA+IDApXG4gICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMubm90YXRpb25WZWN0b3JzLnJlc3VsdC5sZW5ndGg7IHQrKykge1xuICAgICAgICBsZXQgbiA9IHRoaXMuZGljZUxpc3RbdF07XG4gICAgICAgICFuIHx8IG4uZ2V0TGFzdFZhbHVlKCkudmFsdWUgIT0gdGhpcy5ub3RhdGlvblZlY3RvcnMucmVzdWx0W3RdICYmIHRoaXMuc3dhcERpY2VGYWNlKG4sIHRoaXMubm90YXRpb25WZWN0b3JzLnJlc3VsdFt0XSk7XG4gICAgICB9XG4gICAgdGhpcy5yb2xsaW5nID0gITAsIHRoaXMucnVubmluZyA9IERhdGUubm93KCksIHRoaXMubGFzdF90aW1lID0gMCwgdGhpcy5hbmltYXRlVGhyb3codGhpcy5ydW5uaW5nLCBlKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQ3AgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCB7IHJvbGxEaWNlIH0gZnJvbSBcIi4uL2RpY2Vib3hcIjtcbmV4cG9ydCB2YXIgQXR0aXR1ZGU7XG4oZnVuY3Rpb24gKEF0dGl0dWRlKSB7XG4gICAgQXR0aXR1ZGVbQXR0aXR1ZGVbXCJIb3N0aWxlXCJdID0gLTFdID0gXCJIb3N0aWxlXCI7XG4gICAgQXR0aXR1ZGVbQXR0aXR1ZGVbXCJOZXV0cmFsXCJdID0gMF0gPSBcIk5ldXRyYWxcIjtcbiAgICBBdHRpdHVkZVtBdHRpdHVkZVtcIkZyaWVuZGx5XCJdID0gMV0gPSBcIkZyaWVuZGx5XCI7XG59KShBdHRpdHVkZSB8fCAoQXR0aXR1ZGUgPSB7fSkpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5pdGlhdGl2ZUNyZWF0dXJlIHtcbiAgICBhc3luYyByb2xsSW5pdGlhdGl2ZSgpIHtcbiAgICAgICAgLy8gV2UgdXNlIGRldGVybWluaXN0aWMgZGljZSByb2xsaW5nIHRvIGd1YXJhbnRlZSBhIHJlc3VsdCBldmVuIGlmIGludGVycnVwdGVkXG4gICAgICAgIGxldCByb2xsID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApICsgMTtcbiAgICAgICAgYXdhaXQgcm9sbERpY2UoXCIxZDIwQFwiICsgcm9sbCk7XG4gICAgICAgIHRoaXMuaW5pdGlhdGl2ZSA9IHJvbGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXR0aXR1ZGUgPSBBdHRpdHVkZS5OZXV0cmFsKSB7XG4gICAgICAgIHRoaXMuaWQgPSAwO1xuICAgICAgICB0aGlzLmF0dGl0dWRlID0gQXR0aXR1ZGUuTmV1dHJhbDtcbiAgICAgICAgdGhpcy5pbml0aWF0aXZlID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHRoaXMuaW5pdEJvbnVzID0gMDtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5oaXRfcG9pbnRzID0gTmFOO1xuICAgICAgICB0aGlzLmFybW9yX2NsYXNzID0gTmFOO1xuICAgICAgICB0aGlzLmRtZ1R5cGVNb2QgPSBbXTtcbiAgICAgICAgdGhpcy5yb3dFbGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1R1cm4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub3RlcyA9IFwiXCI7XG4gICAgICAgIHRoaXMuc3RhdEJsb2NrVXJsID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRpdHVkZSA9IGF0dGl0dWRlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IHJvbGxEaWNlIH0gZnJvbSBcIi4uL2RpY2Vib3hcIjtcbmltcG9ydCBJbml0aWF0aXZlVGFibGVIYW5kbGVyIGZyb20gXCIuL0luaXRpYXRpdmVUYWJsZUhhbmRsZXJcIjtcbmNsYXNzIEluaXRpYXRpdmVPcmRlciB7XG4gICAgc3RhdGljIGFkZENyZWF0dXJlKGNyZWF0dXJlKSB7XG4gICAgICAgIHRoaXMucnVubmluZ0lkKys7XG4gICAgICAgIGNyZWF0dXJlLmlkID0gdGhpcy5ydW5uaW5nSWQ7XG4gICAgICAgIEluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzLnB1c2goY3JlYXR1cmUpO1xuICAgICAgICBJbml0aWF0aXZlVGFibGVIYW5kbGVyLnVwZGF0ZVRhYmxlKCk7XG4gICAgICAgIHJldHVybiBjcmVhdHVyZS5pZDtcbiAgICB9XG4gICAgc3RhdGljIGdldENyZWF0dXJlKGlkKSB7XG4gICAgICAgIHJldHVybiBJbml0aWF0aXZlT3JkZXIuaW5pdGlhdGl2ZUNyZWF0dXJlcy5maW5kKHggPT4geC5pZCA9PT0gaWQpO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlQ3JlYXR1cmUoaWQsIGRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coSW5pdGlhdGl2ZU9yZGVyLmluaXRpYXRpdmVDcmVhdHVyZXMpO1xuICAgICAgICBsZXQgaW5kZXggPSBJbml0aWF0aXZlT3JkZXIuaW5pdGlhdGl2ZUNyZWF0dXJlcy5maW5kSW5kZXgoeCA9PiB4LmlkID09PSBpZCk7XG4gICAgICAgIGRhdGEuaWQgPSBJbml0aWF0aXZlT3JkZXIuaW5pdGlhdGl2ZUNyZWF0dXJlc1tpbmRleF0uaWQ7XG4gICAgICAgIEluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzW2luZGV4XSA9IGRhdGE7XG4gICAgICAgIEluaXRpYXRpdmVUYWJsZUhhbmRsZXIudXBkYXRlVGFibGUoKTtcbiAgICB9XG4gICAgc3RhdGljIHJlbW92ZUNyZWF0dXJlKGlkKSB7XG4gICAgICAgIEluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzLmZpbHRlcih4ID0+IHguaWQgIT09IGlkKTtcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci51cGRhdGVUYWJsZSgpO1xuICAgICAgICByZXR1cm4gSW5pdGlhdGl2ZU9yZGVyLmluaXRpYXRpdmVDcmVhdHVyZXMubGVuZ3RoO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QWxsQ3JlYXR1cmVzKCkge1xuICAgICAgICByZXR1cm4gSW5pdGlhdGl2ZU9yZGVyLmluaXRpYXRpdmVDcmVhdHVyZXM7XG4gICAgfVxuICAgIHN0YXRpYyBzb3J0Q3JlYXR1cmVzKCkge1xuICAgICAgICBJbml0aWF0aXZlT3JkZXIuaW5pdGlhdGl2ZUNyZWF0dXJlcyA9IEluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIC8vIFByZWZlcmVuY2UgZm9yIGhpZ2hlciB0b3RhbCBpbml0aWF0aXZlXG4gICAgICAgICAgICBsZXQgc29ydCA9IChiLmluaXRpYXRpdmUgKyBiLmluaXRCb251cykgLSAoYS5pbml0aWF0aXZlICsgYS5pbml0Qm9udXMpO1xuICAgICAgICAgICAgLy8gU2Vjb25kYXJ5IHByZWZlcmVuY2UgZm9yIGZyaWVuZGx5IGNyZWF0dXJlc1xuICAgICAgICAgICAgaWYgKHNvcnQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHNvcnQgPT0gYi5hdHRpdHVkZSAtIGEuYXR0aXR1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydDtcbiAgICAgICAgfSk7XG4gICAgICAgIEluaXRpYXRpdmVUYWJsZUhhbmRsZXIudXBkYXRlVGFibGUoKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHJvbGxJbml0aWF0aXZlKGNyZWF0dXJlSWQpIHtcbiAgICAgICAgY29uc3QgY3JlYXR1cmUgPSB0aGlzLmdldENyZWF0dXJlKGNyZWF0dXJlSWQpO1xuICAgICAgICBpZiAoIWNyZWF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhd2FpdCBjcmVhdHVyZS5yb2xsSW5pdGlhdGl2ZSgpO1xuICAgICAgICBJbml0aWF0aXZlVGFibGVIYW5kbGVyLnVwZGF0ZVRhYmxlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyByb2xsSW5pdGlhdGl2ZUZvckFsbCgpIHtcbiAgICAgICAgbGV0IHJvbGxzID0gW107XG4gICAgICAgIGZvciAobGV0IGNyZWF0dXJlIG9mIEluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzKSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgZGV0ZXJtaW5pc3RpYyBkaWNlIHJvbGxpbmcgdG8gZ3VhcmFudGVlIGEgcmVzdWx0IGV2ZW4gaWYgaW50ZXJydXB0ZWRcbiAgICAgICAgICAgIHJvbGxzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApICsgMSk7XG4gICAgICAgICAgICBjcmVhdHVyZS5pbml0aWF0aXZlID0gcm9sbHNbcm9sbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcm9sbERpY2Uocm9sbHMubGVuZ3RoICsgXCJkMjBAXCIgKyByb2xscy5qb2luKCkpO1xuICAgICAgICBJbml0aWF0aXZlVGFibGVIYW5kbGVyLnVwZGF0ZVRhYmxlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyByb2xsSW5pdGlhdGl2ZUZvckF0dGl0dWRlKGF0dGl0dWRlcykge1xuICAgICAgICBsZXQgcm9sbHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY3JlYXR1cmUgb2YgSW5pdGlhdGl2ZU9yZGVyLmluaXRpYXRpdmVDcmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGlmIChhdHRpdHVkZXMuaW5jbHVkZXMoY3JlYXR1cmUuYXR0aXR1ZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGRldGVybWluaXN0aWMgZGljZSByb2xsaW5nIHRvIGd1YXJhbnRlZSBhIHJlc3VsdCBldmVuIGlmIGludGVycnVwdGVkXG4gICAgICAgICAgICAgICAgcm9sbHMucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCkgKyAxKTtcbiAgICAgICAgICAgICAgICBjcmVhdHVyZS5pbml0aWF0aXZlID0gcm9sbHNbcm9sbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcm9sbERpY2Uocm9sbHMubGVuZ3RoICsgXCJkMjBAXCIgKyByb2xscy5qb2luKCkpO1xuICAgICAgICBJbml0aWF0aXZlVGFibGVIYW5kbGVyLnVwZGF0ZVRhYmxlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjbGVhcigpIHtcbiAgICAgICAgSW5pdGlhdGl2ZU9yZGVyLmluaXRpYXRpdmVDcmVhdHVyZXMgPSBbXTtcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci51cGRhdGVUYWJsZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlQ3VycmVudFR1cm4oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKEluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzLmxlbmd0aCA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZ2l2ZVR1cm4gPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgY3JlYXR1cmUgb2YgSW5pdGlhdGl2ZU9yZGVyLmluaXRpYXRpdmVDcmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGlmIChnaXZlVHVybikge1xuICAgICAgICAgICAgICAgIChfYSA9IGNyZWF0dXJlLnJvd0VsZW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QuYWRkKFwiY3VycmVudC10dXJuXCIpO1xuICAgICAgICAgICAgICAgIGNyZWF0dXJlLmlzVHVybiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVhdHVyZS5pc1R1cm4pIHtcbiAgICAgICAgICAgICAgICBnaXZlVHVybiA9IHRydWU7XG4gICAgICAgICAgICAgICAgKF9iID0gY3JlYXR1cmUucm93RWxlbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsYXNzTGlzdC5yZW1vdmUoXCJjdXJyZW50LXR1cm5cIik7XG4gICAgICAgICAgICAgICAgY3JlYXR1cmUuaXNUdXJuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoX2MgPSBjcmVhdHVyZS5yb3dFbGVtKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2xhc3NMaXN0LnJlbW92ZShcImN1cnJlbnQtdHVyblwiKTtcbiAgICAgICAgICAgICAgICBjcmVhdHVyZS5pc1R1cm4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdpdmVUdXJuKSB7XG4gICAgICAgICAgICAoX2QgPSBJbml0aWF0aXZlT3JkZXIuaW5pdGlhdGl2ZUNyZWF0dXJlc1swXS5yb3dFbGVtKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2xhc3NMaXN0LmFkZChcImN1cnJlbnQtdHVyblwiKTtcbiAgICAgICAgICAgIEluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzWzBdLmlzVHVybiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci51cGRhdGVUYWJsZSgpO1xuICAgIH1cbn1cbkluaXRpYXRpdmVPcmRlci5pbml0aWF0aXZlQ3JlYXR1cmVzID0gW107XG5Jbml0aWF0aXZlT3JkZXIucnVubmluZ0lkID0gMDtcbmV4cG9ydCBkZWZhdWx0IEluaXRpYXRpdmVPcmRlcjtcbiIsImltcG9ydCBJbml0aWF0aXZlQ3JlYXR1cmUsIHsgQXR0aXR1ZGUgfSBmcm9tIFwiLi9Jbml0aWF0aXZlQ3JlYXR1cmVcIjtcbmltcG9ydCBJbml0aWF0aXZlT3JkZXIgZnJvbSBcIi4vSW5pdGlhdGl2ZU9yZGVyXCI7XG5pbXBvcnQgTW9uc3RlckRyb3Bkb3duIGZyb20gXCIuL01vbnN0ZXJEcm9wZG93blwiO1xuY2xhc3MgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlciB7XG4gICAgc3RhdGljIGNyZWF0ZVRhYmxlKCkge1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIHRhYmxlIHdpdGggdGhlIGNvcnJlY3QgSURcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50YWJsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0YWJsZSNpbml0aWF0aXZlLXRhYmxlXCIpO1xuICAgICAgICBpZiAoSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50YWJsZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IFwiVW5hYmxlIHRvIGZpbmQgaW5pdGlhdGl2ZSB0YWJsZSFcIjtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZWNlc3NhcnkgY2hpbGQgZWxlbWVudHMgZm9yIGl0XG4gICAgICAgIEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY2FwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYXB0aW9uXCIpO1xuICAgICAgICBJbml0aWF0aXZlVGFibGVIYW5kbGVyLmNhcHRpb24udGV4dENvbnRlbnQgPSBcIkluaXRpYXRpdmUgT3JkZXJcIjtcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50aGVhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aGVhZFwiKTtcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50Ym9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiKTtcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5oZWFkUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0YWJsZSBoZWFkIHdpdGggYWxsIHRoZSBoZWFkZXJzXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY29sdW1ucykge1xuICAgICAgICAgICAgbGV0IHRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRoXCIpO1xuICAgICAgICAgICAgdGguY2xhc3NMaXN0LmFkZChjb2x1bW4uaWQgKyBcIi1oZWFkXCIpO1xuICAgICAgICAgICAgdGguc2NvcGUgPSBcImNvbFwiO1xuICAgICAgICAgICAgdGgudGV4dENvbnRlbnQgPSBjb2x1bW4uaGVhZGVyO1xuICAgICAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5oZWFkUm93LmFwcGVuZENoaWxkKHRoKTtcbiAgICAgICAgfVxuICAgICAgICBJbml0aWF0aXZlVGFibGVIYW5kbGVyLnRoZWFkLmFwcGVuZENoaWxkKEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuaGVhZFJvdyk7XG4gICAgICAgIC8vIEFwcGVuZCB0aGUgY2FwdGlvbiwgaGVhZCwgYW5kIGJvZHkgdG8gdGhlIHRhYmxlXG4gICAgICAgIEluaXRpYXRpdmVUYWJsZUhhbmRsZXIudGFibGUuYXBwZW5kKEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY2FwdGlvbiwgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50aGVhZCwgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50Ym9keSk7XG4gICAgICAgIEluaXRpYXRpdmVPcmRlci5hZGRDcmVhdHVyZShuZXcgSW5pdGlhdGl2ZUNyZWF0dXJlKCkpO1xuICAgICAgICBJbml0aWF0aXZlVGFibGVIYW5kbGVyLnVwZGF0ZVRhYmxlKCk7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGVUYWJsZSgpIHtcbiAgICAgICAgaWYgKCFJbml0aWF0aXZlVGFibGVIYW5kbGVyLnRib2R5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDbGVhciB0aGUgdGFibGVcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50Ym9keS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAvLyBGb3IgZWFjaCBjcmVhdHVyZVxuICAgICAgICBmb3IgKGNvbnN0IGNyZWF0dXJlIG9mIEluaXRpYXRpdmVPcmRlci5nZXRBbGxDcmVhdHVyZXMoKSB8fCBbXSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHJvdyBpbiB0aGUgdGJvZHlcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIudGJvZHkuaW5zZXJ0Um93KCk7XG4gICAgICAgICAgICAvLyBBZGQgY3JlYXR1cmUgaWQgdG8gdGhlIHJvdyBmb3IgZWFzaWVyIGFjY2Vzc1xuICAgICAgICAgICAgcm93LmRhdGFzZXQuY3JlYXR1cmVJZCA9IGNyZWF0dXJlLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBBZGQgYSBjbGFzcyBmb3Igc3R5bGluZyBiYXNlZCBvbiB0aGUgYXR0aXR1ZGVcbiAgICAgICAgICAgIGlmIChjcmVhdHVyZS5hdHRpdHVkZSA9PSBBdHRpdHVkZS5GcmllbmRseSlcbiAgICAgICAgICAgICAgICByb3cuY2xhc3NMaXN0LmFkZChcImF0dGl0dWRlLWZyaWVuZGx5XCIpO1xuICAgICAgICAgICAgaWYgKGNyZWF0dXJlLmF0dGl0dWRlID09IEF0dGl0dWRlLk5ldXRyYWwpXG4gICAgICAgICAgICAgICAgcm93LmNsYXNzTGlzdC5hZGQoXCJhdHRpdHVkZS1uZXV0cmFsXCIpO1xuICAgICAgICAgICAgaWYgKGNyZWF0dXJlLmF0dGl0dWRlID09IEF0dGl0dWRlLkhvc3RpbGUpXG4gICAgICAgICAgICAgICAgcm93LmNsYXNzTGlzdC5hZGQoXCJhdHRpdHVkZS1ob3N0aWxlXCIpO1xuICAgICAgICAgICAgLy8gQWRkIGEgY2xhc3MgZm9yIHRoZSBvbmUgd2l0aCB0aGUgY3VycmVudCB0dXJuIGlmIGl0IGlzIHRoZWlyIHR1cm5cbiAgICAgICAgICAgIHJvdy5jbGFzc0xpc3QudG9nZ2xlKFwiY3VycmVudC10dXJuXCIsIGNyZWF0dXJlLmlzVHVybik7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBpdCB3aXRoIGNlbGxzIGZvciBlYWNoIGNvbHVtblxuICAgICAgICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNvbHVtbi5jcmVhdGUoY3JlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZChjb2x1bW4uaWQgKyBcIi1jZWxsXCIpO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlQW5kQXBwZW5kSW5wdXQoY2VsbCkge1xuICAgICAgICAvLyBXZSB1c2UgYSBjb250ZW50ZWRpdGFibGUgZGl2IHNpbmNlIGl0IGlzIG11Y2ggZWFzaWVyIHRvIHN0eWxlXG4gICAgICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlucHV0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwiZWRpdGFibGVcIik7XG4gICAgICAgIGNlbGwuYXBwZW5kKGlucHV0KTtcbiAgICAgICAgLy8gQWRkIGEgbGlzdGVuZXIgdG8gZm9jdXMgdGhlIGlucHV0IHdoZW4gY2xpY2tpbmcgd2l0aGluIHRoZSBjZWxsXG4gICAgICAgIGNlbGwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVJbml0aWF0aXZlQ2VsbChjcmVhdHVyZSkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGNlbGxcbiAgICAgICAgbGV0IGNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgIC8vIENyZWF0ZSBhIGJ1dHRvbiBmb3Igcm9sbGluZyBpbml0aWF0aXZlIGFuZCBhcHBlbmQgaXQgdG8gdGhlIGNlbGxcbiAgICAgICAgbGV0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIGJ0bi5jbGFzc0xpc3QuYWRkKFwiY3JlYXR1cmUtaW5pdC1idG5cIik7XG4gICAgICAgIGJ0bi50aXRsZSA9IFwiUm9sbCBJbml0aWF0aXZlXCI7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gSW5pdGlhdGl2ZU9yZGVyLnJvbGxJbml0aWF0aXZlKGNyZWF0dXJlLmlkKSk7XG4gICAgICAgIC8vIEFkZCBhbiBpbWFnZSB0byB0aGUgYnV0dG9uXG4gICAgICAgIGxldCBidG5JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBidG5JbWcuc3JjID0gXCIuL2ltZy9kMjAuc3ZnXCI7XG4gICAgICAgIGJ0bi5hcHBlbmQoYnRuSW1nKTtcbiAgICAgICAgY2VsbC5hcHBlbmQoYnRuKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGlucHV0IGZvciBlZGl0aW5nIGFuZCBhcHBlbmQgaXQgdG8gdGhlIGNlbGxcbiAgICAgICAgbGV0IGlucHV0ID0gSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5jcmVhdGVBbmRBcHBlbmRJbnB1dChjZWxsKTtcbiAgICAgICAgLy8gRXZlbnQgbGlzdGVuZXIgdG8gdXBkYXRlIGluaXRpYXRpdmUgYmFzZWQgb24gaW5wdXQgdmFsdWVcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYyA9IEluaXRpYXRpdmVPcmRlci5nZXRDcmVhdHVyZShjcmVhdHVyZS5pZCk7XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYy5pbml0aWF0aXZlID0gK2UudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgSW5pdGlhdGl2ZU9yZGVyLnVwZGF0ZUNyZWF0dXJlKGNyZWF0dXJlLmlkLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGNyZWF0dXJlLmluaXRpYXRpdmUpO1xuICAgICAgICAvLyBJZiB0aGUgY3JlYXR1cmUgaGFzIGFuIGluaXRpYXRpdmUgYXNzaWduZWQgdG8gaXRcbiAgICAgICAgaWYgKGNyZWF0dXJlLmluaXRpYXRpdmUgPiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZSB0byB0aGF0IGluaXRpYXRpdmVcbiAgICAgICAgICAgIGlucHV0LnRleHRDb250ZW50ID0gY3JlYXR1cmUuaW5pdGlhdGl2ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIHN0cmluZyB0byB0aGUgZGF0YXNldCBmb3IgdXNlIGluIENTUywgdXNlZCB0byBzaG93IHRoZSBpbml0aWF0aXZlIGJvbnVzXG4gICAgICAgIGNlbGwuZGF0YXNldC5pbml0aWF0aXZlQm9udXNTdHJpbmcgPSBcIiAoK1wiICsgY3JlYXR1cmUuaW5pdEJvbnVzLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVOYW1lQ2VsbChjcmVhdHVyZSkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGNlbGxcbiAgICAgICAgbGV0IGNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnB1dCBmb3IgZWRpdGluZyBhbmQgYXBwZW5kIGl0IHRvIHRoZSBjZWxsXG4gICAgICAgIGxldCBpbnB1dCA9IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY3JlYXRlQW5kQXBwZW5kSW5wdXQoY2VsbCk7XG4gICAgICAgIC8vIEV2ZW50IGxpc3RlbmVyIHRvIHVwZGF0ZSBuYW1lIGJhc2VkIG9uIGlucHV0IHZhbHVlXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGMgPSBJbml0aWF0aXZlT3JkZXIuZ2V0Q3JlYXR1cmUoY3JlYXR1cmUuaWQpO1xuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGMubmFtZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgSW5pdGlhdGl2ZU9yZGVyLnVwZGF0ZUNyZWF0dXJlKGNyZWF0dXJlLmlkLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBpbnB1dCB0byBzZWFyY2ggbW9uc3RlcnNcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIE1vbnN0ZXJEcm9wZG93bi5zZWFyY2hEcm9wZG93bkVkaXQpO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgTW9uc3RlckRyb3Bkb3duLnNlYXJjaERyb3Bkb3duUmVtb3ZlKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBNb25zdGVyRHJvcGRvd24uc2VhcmNoRHJvcGRvd25SZW1vdmUpO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgTW9uc3RlckRyb3Bkb3duLnNlYXJjaFBpY2tGaXJzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTW9uc3RlckRyb3Bkb3duLnNlYXJjaERyb3Bkb3duRWRpdChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC50ZXh0Q29udGVudCA9IGNyZWF0dXJlLm5hbWU7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgc3RhdGJsb2NrIFVSTCwgYWRkIGl0XG4gICAgICAgIGlmIChjcmVhdHVyZS5zdGF0QmxvY2tVcmwpIHtcbiAgICAgICAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSBjcmVhdHVyZS5zdGF0QmxvY2tVcmw7XG4gICAgICAgICAgICBsaW5rLmNsYXNzTGlzdC5hZGQoXCJtb25zdGVyLWxpbmtcIik7XG4gICAgICAgICAgICBsaW5rLnRhcmdldCA9IFwiX2JsYW5rXCI7XG4gICAgICAgICAgICBjZWxsLnByZXBlbmQobGluayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVIUENlbGwoY3JlYXR1cmUpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBjZWxsXG4gICAgICAgIGxldCBjZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgICAvLyBDcmVhdGUgYW4gaW5wdXQgZm9yIGVkaXRpbmcgYW5kIGFwcGVuZCBpdCB0byB0aGUgY2VsbFxuICAgICAgICBsZXQgaW5wdXQgPSBJbml0aWF0aXZlVGFibGVIYW5kbGVyLmNyZWF0ZUFuZEFwcGVuZElucHV0KGNlbGwpO1xuICAgICAgICAvLyBFdmVudCBsaXN0ZW5lciB0byB1cGRhdGUgSFAgYmFzZWQgb24gaW5wdXQgdmFsdWVcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYyA9IEluaXRpYXRpdmVPcmRlci5nZXRDcmVhdHVyZShjcmVhdHVyZS5pZCk7XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYy5oaXRfcG9pbnRzID0gK2UudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgSW5pdGlhdGl2ZU9yZGVyLnVwZGF0ZUNyZWF0dXJlKGNyZWF0dXJlLmlkLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZSBjcmVhdHVyZSBoYXMgYW4gSFAgYXNzaWduZWQgdG8gaXRcbiAgICAgICAgaWYgKCFpc05hTihjcmVhdHVyZS5oaXRfcG9pbnRzKSkge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZSB0byB0aGF0IEhQXG4gICAgICAgICAgICBpbnB1dC50ZXh0Q29udGVudCA9IGNyZWF0dXJlLmhpdF9wb2ludHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUFDQ2VsbChjcmVhdHVyZSkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGNlbGxcbiAgICAgICAgbGV0IGNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnB1dCBmb3IgZWRpdGluZyBhbmQgYXBwZW5kIGl0IHRvIHRoZSBjZWxsXG4gICAgICAgIGxldCBpbnB1dCA9IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY3JlYXRlQW5kQXBwZW5kSW5wdXQoY2VsbCk7XG4gICAgICAgIC8vIEV2ZW50IGxpc3RlbmVyIHRvIHVwZGF0ZSBBQyBiYXNlZCBvbiBpbnB1dCB2YWx1ZVxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBjID0gSW5pdGlhdGl2ZU9yZGVyLmdldENyZWF0dXJlKGNyZWF0dXJlLmlkKTtcbiAgICAgICAgICAgIGlmICghYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjLmFybW9yX2NsYXNzID0gK2UudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgSW5pdGlhdGl2ZU9yZGVyLnVwZGF0ZUNyZWF0dXJlKGNyZWF0dXJlLmlkLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZSBjcmVhdHVyZSBoYXMgYW4gQUMgYXNzaWduZWQgdG8gaXRcbiAgICAgICAgaWYgKCFpc05hTihjcmVhdHVyZS5hcm1vcl9jbGFzcykpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgdmFsdWUgdG8gdGhhdCBBQ1xuICAgICAgICAgICAgaW5wdXQudGV4dENvbnRlbnQgPSBjcmVhdHVyZS5hcm1vcl9jbGFzcy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlTm90ZXNDZWxsKGNyZWF0dXJlKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgY2VsbFxuICAgICAgICBsZXQgY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGlucHV0IGZvciBlZGl0aW5nIGFuZCBhcHBlbmQgaXQgdG8gdGhlIGNlbGxcbiAgICAgICAgbGV0IGlucHV0ID0gSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5jcmVhdGVBbmRBcHBlbmRJbnB1dChjZWxsKTtcbiAgICAgICAgLy8gRXZlbnQgbGlzdGVuZXIgdG8gdXBkYXRlIG5vdGVzIGJhc2VkIG9uIGlucHV0IHZhbHVlXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGMgPSBJbml0aWF0aXZlT3JkZXIuZ2V0Q3JlYXR1cmUoY3JlYXR1cmUuaWQpO1xuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGMubm90ZXMgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIEluaXRpYXRpdmVPcmRlci51cGRhdGVDcmVhdHVyZShjcmVhdHVyZS5pZCwgYyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC50ZXh0Q29udGVudCA9IGNyZWF0dXJlLm5vdGVzO1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZURhbWFnZVR5cGVNb2RpZmllckNlbGwoY3JlYXR1cmUpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBjZWxsXG4gICAgICAgIGxldCBjZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgICBmb3IgKGxldCBtb2Qgb2YgY3JlYXR1cmUuZG1nVHlwZU1vZCkge1xuICAgICAgICAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBpbWcuY2xhc3NMaXN0LmFkZChcImRtZ3R5cGVtb2RcIik7XG4gICAgICAgICAgICBpbWcuY2xhc3NMaXN0LmFkZChtb2QudHlwZSk7XG4gICAgICAgICAgICBpbWcuY2xhc3NMaXN0LmFkZChtb2QubWFnaWNhbCk7XG4gICAgICAgICAgICBpbWcuY2xhc3NMaXN0LmFkZChtb2QubW9kaWZpZXIpO1xuICAgICAgICAgICAgaW1nLmNsYXNzTGlzdC5hZGQobW9kLmFkYW1hbnRpbmUpO1xuICAgICAgICAgICAgaW1nLmNsYXNzTGlzdC5hZGQobW9kLnNpbHZlcmVkKTtcbiAgICAgICAgICAgIGltZy50aXRsZSA9IG1vZC5kZXNjO1xuICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbn1cbkluaXRpYXRpdmVUYWJsZUhhbmRsZXIudGFibGUgPSBudWxsO1xuSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5jYXB0aW9uID0gbnVsbDtcbkluaXRpYXRpdmVUYWJsZUhhbmRsZXIudGhlYWQgPSBudWxsO1xuSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci50Ym9keSA9IG51bGw7XG5Jbml0aWF0aXZlVGFibGVIYW5kbGVyLmhlYWRSb3cgPSBudWxsO1xuSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5jb2x1bW5zID0gW1xuICAgIHtcbiAgICAgICAgaGVhZGVyOiBcIkluaXRpYXRpdmVcIiwgaWQ6IFwiaW5pdGlhdGl2ZVwiLFxuICAgICAgICBjcmVhdGU6IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY3JlYXRlSW5pdGlhdGl2ZUNlbGxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaGVhZGVyOiBcIk5hbWVcIiwgaWQ6IFwibmFtZVwiLFxuICAgICAgICBjcmVhdGU6IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY3JlYXRlTmFtZUNlbGxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaGVhZGVyOiBcIkhQXCIsIGlkOiBcImhpdC1wb2ludHNcIixcbiAgICAgICAgY3JlYXRlOiBJbml0aWF0aXZlVGFibGVIYW5kbGVyLmNyZWF0ZUhQQ2VsbFxuICAgIH0sXG4gICAge1xuICAgICAgICBoZWFkZXI6IFwiQUNcIiwgaWQ6IFwiYXJtb3ItY2xhc3NcIixcbiAgICAgICAgY3JlYXRlOiBJbml0aWF0aXZlVGFibGVIYW5kbGVyLmNyZWF0ZUFDQ2VsbFxuICAgIH0sXG4gICAge1xuICAgICAgICBoZWFkZXI6IFwiTm90ZXNcIiwgaWQ6IFwibm90ZXNcIixcbiAgICAgICAgY3JlYXRlOiBJbml0aWF0aXZlVGFibGVIYW5kbGVyLmNyZWF0ZU5vdGVzQ2VsbFxuICAgIH0sXG4gICAge1xuICAgICAgICBoZWFkZXI6IFwiRGFtYWdlIFR5cGUgTW9kaWZpZXJzXCIsIGlkOiBcImRhbWFnZS10eXBlLW1vZGlmaWVyc1wiLFxuICAgICAgICBjcmVhdGU6IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIuY3JlYXRlRGFtYWdlVHlwZU1vZGlmaWVyQ2VsbFxuICAgIH0sXG5dO1xuZXhwb3J0IGRlZmF1bHQgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlcjtcbiIsImltcG9ydCB7IEFQSV9VUkwsIERBTUFHRV9UWVBFUyB9IGZyb20gXCIuLi9nbG9iYWxzXCI7XG5pbXBvcnQgSW5pdGlhdGl2ZU9yZGVyIGZyb20gXCIuL0luaXRpYXRpdmVPcmRlclwiO1xuaW1wb3J0IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIgZnJvbSBcIi4vSW5pdGlhdGl2ZVRhYmxlSGFuZGxlclwiO1xuaW1wb3J0IE1vbnN0ZXJMaXN0IGZyb20gXCIuL01vbnN0ZXJMaXN0XCI7XG5jb25zdCBNT05TVEVSX0RST1BET1dOX0lEID0gXCJtb25zdGVyLWRyb3Bkb3duXCI7XG5jbGFzcyBNb25zdGVyRHJvcGRvd24ge1xuICAgIHN0YXRpYyBhc3luYyBmZXRjaE1vbnN0ZXJzKCkge1xuICAgICAgICBNb25zdGVyRHJvcGRvd24ubW9uc3RlcnMgPSBhd2FpdCBNb25zdGVyTGlzdC5mZXRjaCgpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VhcmNoUGlja0ZpcnN0KCkge1xuICAgICAgICBpZiAoTW9uc3RlckRyb3Bkb3duLmRyb3Bkb3duICYmIE1vbnN0ZXJEcm9wZG93bi5kcm9wZG93bi5jaGlsZHJlblswXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBNb25zdGVyRHJvcGRvd24uZHJvcGRvd24uY2hpbGRyZW5bMF0uY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2VhcmNoRHJvcGRvd25FZGl0KGV2ZW50KSB7XG4gICAgICAgIC8vIFR5cGVzY3JpcHQgdHlwZSBjaGVja2luZ1xuICAgICAgICBpZiAoTW9uc3RlckRyb3Bkb3duLm1vbnN0ZXJzID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCB8fCAhKGlucHV0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjZWxsID0gaW5wdXQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKGNlbGwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgdGhhdCBpcyByZXF1ZXN0aW5nIHRoZSBzZWFyY2hcbiAgICAgICAgbGV0IHNlYXJjaCA9IGlucHV0LnRleHRDb250ZW50IHx8IFwiXCI7XG4gICAgICAgIC8vIEZpbHRlciB0aGUgTW9uc3RlckRyb3Bkb3duLm1vbnN0ZXJzIHRvIG9ubHkgdGhlIG9uZXMgdGhhdCBjb250YWluIHRoZSBzZWFyY2hcbiAgICAgICAgbGV0IHJlc3VsdCA9IE1vbnN0ZXJEcm9wZG93bi5tb25zdGVycy5zZWFyY2hNb25zdGVycyhzZWFyY2gpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCBNb25zdGVyRHJvcGRvd24uZHJvcGRvd25cbiAgICAgICAgTW9uc3RlckRyb3Bkb3duLnNlYXJjaERyb3Bkb3duUmVtb3ZlKCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBNb25zdGVyRHJvcGRvd24uZHJvcGRvd25cbiAgICAgICAgTW9uc3RlckRyb3Bkb3duLmRyb3Bkb3duID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICBNb25zdGVyRHJvcGRvd24uZHJvcGRvd24uaWQgPSBNT05TVEVSX0RST1BET1dOX0lEO1xuICAgICAgICAvLyBQb3B1bGF0ZSBpdCB3aXRoIG5ldyBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBtb25zdGVyIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgY29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICAgICAgICBsaS50ZXh0Q29udGVudCA9IG1vbnN0ZXIubmFtZTtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSB1cmwgaW4gdGhlIGRhdGFzZXQgZm9yIHVzZSB3aGVuIHdlIGNsaWNrIGl0XG4gICAgICAgICAgICBsaS5kYXRhc2V0Lm1vbnN0ZXJVcmwgPSBtb25zdGVyLnVybDtcbiAgICAgICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgTW9uc3RlckRyb3Bkb3duLmNsaWNrU2VhcmNoSXRlbSk7XG4gICAgICAgICAgICBNb25zdGVyRHJvcGRvd24uZHJvcGRvd24uYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGVuZCB0aGUgTW9uc3RlckRyb3Bkb3duLmRyb3Bkb3duIHRvIHRoZSBjZWxsIHRoZSBpbnB1dCBpcyBpbiBmb3IgcG9zaXRpb25pbmdcbiAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChNb25zdGVyRHJvcGRvd24uZHJvcGRvd24pO1xuICAgIH1cbiAgICBzdGF0aWMgc2VhcmNoRHJvcGRvd25SZW1vdmUoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChNb25zdGVyRHJvcGRvd24uZHJvcGRvd24pXG4gICAgICAgICAgICAoX2EgPSBNb25zdGVyRHJvcGRvd24uZHJvcGRvd24ucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKE1vbnN0ZXJEcm9wZG93bi5kcm9wZG93bik7XG4gICAgICAgIGxldCBvbGREcm9wZG93biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE1PTlNURVJfRFJPUERPV05fSUQpO1xuICAgICAgICBpZiAob2xkRHJvcGRvd24pXG4gICAgICAgICAgICAoX2IgPSBvbGREcm9wZG93bi5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlQ2hpbGQob2xkRHJvcGRvd24pO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY2xpY2tTZWFyY2hJdGVtKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIFR5cGVzY3JpcHQgdHlwZSBjaGVja2luZ1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IG51bGwgfHwgIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MTElFbGVtZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2VsbCB3aGVyZSB0aGlzIE1vbnN0ZXJEcm9wZG93bi5kcm9wZG93biBpcyBhdHRhY2hlZFxuICAgICAgICBsZXQgY2VsbCA9IChfYSA9IGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKGNlbGwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFNb25zdGVyRHJvcGRvd24uZHJvcGRvd24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgTW9uc3RlckRyb3Bkb3duLmRyb3Bkb3duXG4gICAgICAgIE1vbnN0ZXJEcm9wZG93bi5zZWFyY2hEcm9wZG93blJlbW92ZSgpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgZnVsbCBkZXRhaWxzIG9mIHRoZSBtb25zdGVyIGZyb20gdGhlIEFQSSBiYXNlZCBvbiB0aGUgVVJMIGluIHRoZSBkYXRhc2V0XG4gICAgICAgIGxldCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goQVBJX1VSTCArIGV2ZW50LnRhcmdldC5kYXRhc2V0Lm1vbnN0ZXJVcmwpO1xuICAgICAgICBsZXQgbW9uc3RlciA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGNyZWF0dXJlIHRvIGVkaXRcbiAgICAgICAgY29uc3Qgcm93ID0gY2VsbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAoIXJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY3JlYXR1cmVJZCA9ICsoKF9iID0gcm93LmRhdGFzZXQuY3JlYXR1cmVJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTmFOKTtcbiAgICAgICAgaWYgKGlzTmFOKGNyZWF0dXJlSWQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBFZGl0IHRoZSBjcmVhdHVyZSBiYXNlZCBvbiB0aGUgZGF0YSBmcm9tIHRoZSBBUElcbiAgICAgICAgbGV0IGNyZWF0dXJlID0gSW5pdGlhdGl2ZU9yZGVyLmdldENyZWF0dXJlKGNyZWF0dXJlSWQpO1xuICAgICAgICBpZiAoIWNyZWF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjcmVhdHVyZS5hcm1vcl9jbGFzcyA9IG1vbnN0ZXIuYXJtb3JfY2xhc3NbMF0udmFsdWU7XG4gICAgICAgIGNyZWF0dXJlLmluaXRCb251cyA9IE1hdGguZmxvb3IoKG1vbnN0ZXIuZGV4dGVyaXR5IC0gMTApIC8gMik7XG4gICAgICAgIGNyZWF0dXJlLmhpdF9wb2ludHMgPSBtb25zdGVyLmhpdF9wb2ludHM7XG4gICAgICAgIGNyZWF0dXJlLm5hbWUgPSBtb25zdGVyLm5hbWU7XG4gICAgICAgIGNyZWF0dXJlLmRtZ1R5cGVNb2QgPSBbXTtcbiAgICAgICAgY3JlYXR1cmUubm90ZXMgPSBtb25zdGVyLnNpemUgKyBcIiBcIiArIG1vbnN0ZXIudHlwZSArIFwiLCBcIiArIG1vbnN0ZXIuYWxpZ25tZW50O1xuICAgICAgICBjcmVhdHVyZS5zdGF0QmxvY2tVcmwgPSBgaHR0cHM6Ly93d3cuYWlkZWRkLm9yZy9kbmQvbW9uc3RyZXMucGhwP3ZvPSR7bW9uc3Rlci5pbmRleH1gO1xuICAgICAgICBsZXQgcmVzID0gbW9uc3Rlci5kYW1hZ2VfcmVzaXN0YW5jZXMubWFwKHJlc2lzdGFuY2UgPT4gKHsgdHlwZTogXCJyZXNpc3RhbmNlXCIsIGRhdGE6IHJlc2lzdGFuY2UgfSkpO1xuICAgICAgICBsZXQgdnVsID0gbW9uc3Rlci5kYW1hZ2VfdnVsbmVyYWJpbGl0aWVzLm1hcCh2dWxuZXJhYmlsaXR5ID0+ICh7IHR5cGU6IFwidnVsbmVyYWJpbGl0eVwiLCBkYXRhOiB2dWxuZXJhYmlsaXR5IH0pKTtcbiAgICAgICAgbGV0IGltbSA9IG1vbnN0ZXIuZGFtYWdlX2ltbXVuaXRpZXMubWFwKGltbXVuaXR5ID0+ICh7IHR5cGU6IFwiaW1tdW5pdHlcIiwgZGF0YTogaW1tdW5pdHkgfSkpO1xuICAgICAgICBsZXQgbW9kaWZpZXJzID0gWy4uLnZ1bCwgLi4ucmVzLCAuLi5pbW1dO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIG1vZGlmaWVyc1xuICAgICAgICBmb3IgKGxldCBtb2Qgb2YgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhIHBoeXNpY2FsIGRhbWFnZSByZXNpc3RhbmNlLCBicmVhayBpdCBkb3duIGludG8gaXRzIHBhcnRzXG4gICAgICAgICAgICBpZiAobW9kLmRhdGEuc3RhcnRzV2l0aChcImJsdWRnZW9uaW5nLCBwaWVyY2luZywgYW5kIHNsYXNoaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IG1vZC5kYXRhLnN1YnN0cihtb2QuZGF0YS5pbmRleE9mKFwic2xhc2hpbmdcIikgKyA4KTtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMucHVzaCh7IHR5cGU6IG1vZC50eXBlLCBkYXRhOiBcImJsdWRnZW9uaW5nXCIgKyBzdWZmaXggfSk7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goeyB0eXBlOiBtb2QudHlwZSwgZGF0YTogXCJwaWVyY2luZ1wiICsgc3VmZml4IH0pO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKHsgdHlwZTogbW9kLnR5cGUsIGRhdGE6IFwic2xhc2hpbmdcIiArIHN1ZmZpeCB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyZWF0dXJlLmRtZ1R5cGVNb2QucHVzaChNb25zdGVyRHJvcGRvd24uaGFuZGxlTW9kaWZpZXIobW9kKSk7XG4gICAgICAgIH1cbiAgICAgICAgSW5pdGlhdGl2ZU9yZGVyLnVwZGF0ZUNyZWF0dXJlKGNyZWF0dXJlSWQsIGNyZWF0dXJlKTtcbiAgICAgICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci51cGRhdGVUYWJsZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFuZGxlTW9kaWZpZXIobW9kKSB7XG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBtb2QudHlwZSArIFwiIHRvIFwiICsgbW9kLmRhdGE7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kaWZpZXIgb25seSBhcHBsaWVzIG1hZ2ljYWwsIG5vbm1hZ2ljYWwsIG9yIGJvdGhcbiAgICAgICAgY29uc3QgbWFnaWNhbCA9IG1vZC5kYXRhLmluZGV4T2YoXCIgbWFnaWNhbFwiKSA+PSAwO1xuICAgICAgICBjb25zdCBub25tYWdpY2FsID0gbW9kLmRhdGEuaW5kZXhPZihcIm5vbm1hZ2ljYWxcIikgPj0gMDtcbiAgICAgICAgY29uc3QgYm90aE0gPSBtYWdpY2FsID09IG5vbm1hZ2ljYWw7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kaWZpZXIgb25seSBhcHBsaWVzIHNpbHZlcmVkLCBub25zaWx2ZXIsIG9yIGJvdGhcbiAgICAgICAgY29uc3Qgc2lsdmVyZWQgPSBtb2QuZGF0YS5pbmRleE9mKFwiIHNpbHZlcmVkXCIpID49IDA7XG4gICAgICAgIGNvbnN0IG5vbnNpbHZlcmVkID0gbW9kLmRhdGEuaW5kZXhPZihcIm5vbnNpbHZlclwiKSA+PSAwO1xuICAgICAgICBjb25zdCBib3RoUyA9IHNpbHZlcmVkID09IG5vbnNpbHZlcmVkO1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGlmaWVyIG9ubHkgYXBwbGllcyBhbWFudGluZSwgbm9uYWRhbWFudGluZSwgb3IgYm90aFxuICAgICAgICBjb25zdCBhZGFtYW50aW5lID0gbW9kLmRhdGEuaW5kZXhPZihcImFyZSBhZGFtYW50aW5lXCIpID49IDA7XG4gICAgICAgIGNvbnN0IG5vbmFkYW1hbnRpbmUgPSBtb2QuZGF0YS5pbmRleE9mKFwiYXJlbid0IGFkYW1hbnRpbmVcIikgPj0gMDtcbiAgICAgICAgY29uc3QgYm90aEEgPSBhZGFtYW50aW5lID09IG5vbmFkYW1hbnRpbmU7XG4gICAgICAgIGlmICghYm90aE0gfHwgIWJvdGhTKSB7XG4gICAgICAgICAgICBtb2QuZGF0YSA9IG1vZC5kYXRhLnJlcGxhY2UoXCJmcm9tIG1hZ2ljYWwvc2lsdmVyZWQgd2VhcG9uc1wiLCBcIlwiKTtcbiAgICAgICAgICAgIG1vZC5kYXRhID0gbW9kLmRhdGEucmVwbGFjZShcImZyb20gbm9ubWFnaWNhbC9ub25zaWx2ZXIgd2VhcG9uc1wiLCBcIlwiKTtcbiAgICAgICAgICAgIG1vZC5kYXRhID0gbW9kLmRhdGEucmVwbGFjZShcImZyb20gbWFnaWNhbCB3ZWFwb25zXCIsIFwiXCIpO1xuICAgICAgICAgICAgbW9kLmRhdGEgPSBtb2QuZGF0YS5yZXBsYWNlKFwiZnJvbSBub25tYWdpY2FsIHdlYXBvbnNcIiwgXCJcIik7XG4gICAgICAgICAgICBtb2QuZGF0YSA9IG1vZC5kYXRhLnJlcGxhY2UoXCJmcm9tIHNpbHZlcmVkIHdlYXBvbnNcIiwgXCJcIik7XG4gICAgICAgICAgICBtb2QuZGF0YSA9IG1vZC5kYXRhLnJlcGxhY2UoXCJmcm9tIG5vbnNpbHZlciB3ZWFwb25zXCIsIFwiXCIpO1xuICAgICAgICAgICAgbW9kLmRhdGEgPSBtb2QuZGF0YS5yZXBsYWNlKFwidGhhdCBhcmVuJ3QgYWRhbWFudGluZVwiLCBcIlwiKTtcbiAgICAgICAgICAgIG1vZC5kYXRhID0gbW9kLmRhdGEucmVwbGFjZShcInRoYXQgYXJlIGFkYW1hbnRpbmVcIiwgXCJcIik7XG4gICAgICAgICAgICBtb2QuZGF0YSA9IG1vZC5kYXRhLnJlcGxhY2UoXCIgIFwiLCBcIiBcIik7XG4gICAgICAgICAgICBtb2QuZGF0YSA9IG1vZC5kYXRhLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIURBTUFHRV9UWVBFUy5pbmNsdWRlcyhtb2QuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5yZWNvZ25pc2VkIGRhbWFnZSB0eXBlOiBcIiArIG1vZC5kYXRhKTtcbiAgICAgICAgICAgIG1vZC5kYXRhID0gXCJvdGhlclwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbW9kaWZpZXJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IG1vZC5kYXRhLFxuICAgICAgICAgICAgbWFnaWNhbDogYm90aE0gPyBcImJvdGgtbWFnaWNhbFwiIDogbWFnaWNhbCA/IFwibWFnaWNhbFwiIDogXCJub25tYWdpY2FsXCIsXG4gICAgICAgICAgICBzaWx2ZXJlZDogYm90aFMgPyBcImJvdGgtc2lsdmVyXCIgOiBzaWx2ZXJlZCA/IFwic2lsdmVyZWRcIiA6IFwibm9uc2lsdmVyZWRcIixcbiAgICAgICAgICAgIGFkYW1hbnRpbmU6IGJvdGhBID8gXCJib3RoLWFkYW1hbnRpbmVcIiA6IGFkYW1hbnRpbmUgPyBcImFkYW1hbnRpbmVcIiA6IFwibm9uYWRhbWFudGluZVwiLFxuICAgICAgICAgICAgbW9kaWZpZXI6IG1vZC50eXBlLFxuICAgICAgICAgICAgZGVzYzogdG9vbHRpcFxuICAgICAgICB9O1xuICAgIH1cbn1cbk1vbnN0ZXJEcm9wZG93bi5kcm9wZG93biA9IG51bGw7XG5Nb25zdGVyRHJvcGRvd24ubW9uc3RlcnMgPSBudWxsO1xuZXhwb3J0IGRlZmF1bHQgTW9uc3RlckRyb3Bkb3duO1xuIiwiaW1wb3J0IHsgQVBJX1VSTCB9IGZyb20gXCIuLi9nbG9iYWxzXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb25zdGVyTGlzdCB7XG4gICAgY29uc3RydWN0b3IobW9uc3RlcnMpIHtcbiAgICAgICAgdGhpcy5tb25zdGVycyA9IFtdO1xuICAgICAgICB0aGlzLm1vbnN0ZXJzID0gbW9uc3RlcnM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmZXRjaCgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChBUElfVVJMICsgXCIvYXBpL21vbnN0ZXJzXCIpO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gbmV3IE1vbnN0ZXJMaXN0KGpzb24ucmVzdWx0cyk7XG4gICAgfVxuICAgIGdldE1vbnN0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb25zdGVycztcbiAgICB9XG4gICAgc2VhcmNoTW9uc3RlcnMoc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaCA9IHNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBGaWx0ZXIgdGhlIG1vbnN0ZXJzIHRvIG9ubHkgdGhlIG9uZXMgdGhhdCBjb250YWluIHRoZSBzZWFyY2hcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubW9uc3RlcnMuZmlsdGVyKG1vbnN0ZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnN0ZXIubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTb3J0IHRoZSBtb25zdGVycyBiYXNlZCBvbiB3aGljaCBjb250YWlucyB0aGUgc2VhcmNoIGZpcnN0XG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKSAtIGIubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IERpY2VCb3ggZnJvbSBcIkAzZC1kaWNlL2RpY2UtYm94LXRocmVlanNcIjtcbmxldCBkaWNlYm94ID0gbnVsbDtcbmxldCBkaWNlQ2xlYXJUaW1lb3V0ID0gTmFOO1xuYXN5bmMgZnVuY3Rpb24gaW5pdERpY2VCb3goKSB7XG4gICAgZGljZWJveCA9IG5ldyBEaWNlQm94KFwiI2RpY2Vib3hcIiwge1xuICAgICAgICBzb3VuZHM6IHRydWVcbiAgICB9KTtcbiAgICBhd2FpdCBkaWNlYm94LmluaXRpYWxpemUoKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByb2xsRGljZShkaWNlKSB7XG4gICAgY29uc29sZS5sb2coZGljZSk7XG4gICAgaWYgKGRpY2Vib3ggPT09IG51bGwpXG4gICAgICAgIGF3YWl0IGluaXREaWNlQm94KCk7XG4gICAgbGV0IGJveEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2RpY2Vib3hcIik7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCk7XG4gICAgICAgIGJveEVsZW0uc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICBhd2FpdCBkaWNlYm94LnJvbGwoZGljZSk7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZGljZUNsZWFyVGltZW91dCk7XG4gICAgICAgIGRpY2VDbGVhclRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBib3hFbGVtLnN0eWxlLm9wYWNpdHkgPSBcIjBcIiwgMTAwMCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbn1cbiIsImV4cG9ydCBjb25zdCBBUElfVVJMID0gXCJodHRwczovL3d3dy5kbmQ1ZWFwaS5jb1wiO1xuZXhwb3J0IGNvbnN0IERBTUFHRV9UWVBFUyA9IFtcbiAgICBcImFjaWRcIixcbiAgICBcImJsdWRnZW9uaW5nXCIsXG4gICAgXCJjb2xkXCIsXG4gICAgXCJmaXJlXCIsXG4gICAgXCJmb3JjZVwiLFxuICAgIFwibGlnaHRuaW5nXCIsXG4gICAgXCJuZWNyb3RpY1wiLFxuICAgIFwicGllcmNpbmdcIixcbiAgICBcInBvaXNvblwiLFxuICAgIFwicHN5Y2hpY1wiLFxuICAgIFwicmFkaWFudFwiLFxuICAgIFwic2xhc2hpbmdcIixcbiAgICBcInRodW5kZXJcIlxuXTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IEluaXRpYXRpdmVPcmRlciBmcm9tIFwiLi9jbGFzc2VzL0luaXRpYXRpdmVPcmRlclwiO1xuaW1wb3J0IEluaXRpYXRpdmVUYWJsZUhhbmRsZXIgZnJvbSBcIi4vY2xhc3Nlcy9Jbml0aWF0aXZlVGFibGVIYW5kbGVyXCI7XG5pbXBvcnQgTW9uc3RlckRyb3Bkb3duIGZyb20gXCIuL2NsYXNzZXMvTW9uc3RlckRyb3Bkb3duXCI7XG5pbXBvcnQgSW5pdGlhdGl2ZUNyZWF0dXJlLCB7IEF0dGl0dWRlIH0gZnJvbSBcIi4vY2xhc3Nlcy9Jbml0aWF0aXZlQ3JlYXR1cmVcIjtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIE1vbnN0ZXJEcm9wZG93bi5mZXRjaE1vbnN0ZXJzKCk7XG4gICAgSW5pdGlhdGl2ZVRhYmxlSGFuZGxlci5jcmVhdGVUYWJsZSgpO1xuICAgIChfYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY2xlYXItYnRuXCIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IEluaXRpYXRpdmVPcmRlci5jbGVhcigpKTtcbiAgICAoX2IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnJvbGwtYWxsLWJ0blwiKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiBJbml0aWF0aXZlT3JkZXIucm9sbEluaXRpYXRpdmVGb3JBbGwoKSk7XG4gICAgKF9jID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5yb2xsLW5vbmZyaWVuZGx5LWJ0blwiKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIEluaXRpYXRpdmVPcmRlci5yb2xsSW5pdGlhdGl2ZUZvckF0dGl0dWRlKFtBdHRpdHVkZS5Ib3N0aWxlLCBBdHRpdHVkZS5OZXV0cmFsXSk7XG4gICAgfSk7XG4gICAgKF9kID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zb3J0LWJ0blwiKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiBJbml0aWF0aXZlT3JkZXIuc29ydENyZWF0dXJlcygpKTtcbiAgICAoX2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm5leHQtYnRuXCIpKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEluaXRpYXRpdmVPcmRlci51cGRhdGVDdXJyZW50VHVybik7XG4gICAgKF9mID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5wbHVzLWJ0bi5mcmllbmRseVwiKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiBJbml0aWF0aXZlT3JkZXIuYWRkQ3JlYXR1cmUobmV3IEluaXRpYXRpdmVDcmVhdHVyZShBdHRpdHVkZS5GcmllbmRseSkpKTtcbiAgICAoX2cgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnBsdXMtYnRuLm5ldXRyYWxcIikpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gSW5pdGlhdGl2ZU9yZGVyLmFkZENyZWF0dXJlKG5ldyBJbml0aWF0aXZlQ3JlYXR1cmUoQXR0aXR1ZGUuTmV1dHJhbCkpKTtcbiAgICAoX2ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnBsdXMtYnRuLmhvc3RpbGVcIikpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gSW5pdGlhdGl2ZU9yZGVyLmFkZENyZWF0dXJlKG5ldyBJbml0aWF0aXZlQ3JlYXR1cmUoQXR0aXR1ZGUuSG9zdGlsZSkpKTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9